[
  {
    "function_name": "fat_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "271-288",
    "snippet": "static struct dentry *fat_get_parent(struct dentry *child_dir)\n{\n\tstruct super_block *sb = child_dir->d_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent_inode = NULL;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (!fat_get_dotdot_entry(child_dir->d_inode, &bh, &de)) {\n\t\tint parent_logstart = fat_get_start(sbi, de);\n\t\tparent_inode = fat_dget(sb, parent_logstart);\n\t\tif (!parent_inode && sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\t\tparent_inode = fat_rebuild_parent(sb, parent_logstart);\n\t}\n\tbrelse(bh);\n\n\treturn d_obtain_alias(parent_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "parent_inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_rebuild_parent",
          "args": [
            "sb",
            "parent_logstart"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "fat_rebuild_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "222-263",
          "snippet": "static\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\n{\n\tint search_clus, clus_to_match;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent = NULL;\n\tstruct inode *dummy_grand_parent = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\n\tstruct buffer_head *parent_bh = sb_bread(sb, blknr);\n\tif (!parent_bh) {\n\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\"unable to read cluster of parent directory\");\n\t\treturn NULL;\n\t}\n\n\tde = (struct msdos_dir_entry *) parent_bh->b_data;\n\tclus_to_match = fat_get_start(sbi, &de[0]);\n\tsearch_clus = fat_get_start(sbi, &de[1]);\n\n\tdummy_grand_parent = fat_dget(sb, search_clus);\n\tif (!dummy_grand_parent) {\n\t\tdummy_grand_parent = new_inode(sb);\n\t\tif (!dummy_grand_parent) {\n\t\t\tbrelse(parent_bh);\n\t\t\treturn parent;\n\t\t}\n\n\t\tdummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\t\tfat_fill_inode(dummy_grand_parent, &de[1]);\n\t\tMSDOS_I(dummy_grand_parent)->i_pos = -1;\n\t}\n\n\tif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\n\t\tparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\n\tbrelse(parent_bh);\n\tiput(dummy_grand_parent);\n\n\treturn parent;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\n{\n\tint search_clus, clus_to_match;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent = NULL;\n\tstruct inode *dummy_grand_parent = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\n\tstruct buffer_head *parent_bh = sb_bread(sb, blknr);\n\tif (!parent_bh) {\n\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\"unable to read cluster of parent directory\");\n\t\treturn NULL;\n\t}\n\n\tde = (struct msdos_dir_entry *) parent_bh->b_data;\n\tclus_to_match = fat_get_start(sbi, &de[0]);\n\tsearch_clus = fat_get_start(sbi, &de[1]);\n\n\tdummy_grand_parent = fat_dget(sb, search_clus);\n\tif (!dummy_grand_parent) {\n\t\tdummy_grand_parent = new_inode(sb);\n\t\tif (!dummy_grand_parent) {\n\t\t\tbrelse(parent_bh);\n\t\t\treturn parent;\n\t\t}\n\n\t\tdummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\t\tfat_fill_inode(dummy_grand_parent, &de[1]);\n\t\tMSDOS_I(dummy_grand_parent)->i_pos = -1;\n\t}\n\n\tif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\n\t\tparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\n\tbrelse(parent_bh);\n\tiput(dummy_grand_parent);\n\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dget",
          "args": [
            "sb",
            "parent_logstart"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "32-51",
          "snippet": "static struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_start",
          "args": [
            "sbi",
            "de"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "258-265",
          "snippet": "static inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_dotdot_entry",
          "args": [
            "child_dir->d_inode",
            "&bh",
            "&de"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_dotdot_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "891-902",
          "snippet": "int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct dentry *fat_get_parent(struct dentry *child_dir)\n{\n\tstruct super_block *sb = child_dir->d_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent_inode = NULL;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (!fat_get_dotdot_entry(child_dir->d_inode, &bh, &de)) {\n\t\tint parent_logstart = fat_get_start(sbi, de);\n\t\tparent_inode = fat_dget(sb, parent_logstart);\n\t\tif (!parent_inode && sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\t\tparent_inode = fat_rebuild_parent(sb, parent_logstart);\n\t}\n\tbrelse(bh);\n\n\treturn d_obtain_alias(parent_inode);\n}"
  },
  {
    "function_name": "fat_rebuild_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "222-263",
    "snippet": "static\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\n{\n\tint search_clus, clus_to_match;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent = NULL;\n\tstruct inode *dummy_grand_parent = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\n\tstruct buffer_head *parent_bh = sb_bread(sb, blknr);\n\tif (!parent_bh) {\n\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\"unable to read cluster of parent directory\");\n\t\treturn NULL;\n\t}\n\n\tde = (struct msdos_dir_entry *) parent_bh->b_data;\n\tclus_to_match = fat_get_start(sbi, &de[0]);\n\tsearch_clus = fat_get_start(sbi, &de[1]);\n\n\tdummy_grand_parent = fat_dget(sb, search_clus);\n\tif (!dummy_grand_parent) {\n\t\tdummy_grand_parent = new_inode(sb);\n\t\tif (!dummy_grand_parent) {\n\t\t\tbrelse(parent_bh);\n\t\t\treturn parent;\n\t\t}\n\n\t\tdummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\t\tfat_fill_inode(dummy_grand_parent, &de[1]);\n\t\tMSDOS_I(dummy_grand_parent)->i_pos = -1;\n\t}\n\n\tif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\n\t\tparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\n\tbrelse(parent_bh);\n\tiput(dummy_grand_parent);\n\n\treturn parent;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dummy_grand_parent"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "parent_bh"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_scan_logstart",
          "args": [
            "dummy_grand_parent",
            "clus_to_match",
            "&sinfo"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "dummy_grand_parent"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fill_inode",
          "args": [
            "dummy_grand_parent",
            "&de[1]"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "fat_fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "462-519",
          "snippet": "int fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct address_space_operations fat_aops = {\n\t.readpage\t= fat_readpage,\n\t.readpages\t= fat_readpages,\n\t.writepage\t= fat_writepage,\n\t.writepages\t= fat_writepages,\n\t.write_begin\t= fat_write_begin,\n\t.write_end\t= fat_write_end,\n\t.direct_IO\t= fat_direct_IO,\n\t.bmap\t\t= _fat_bmap\n};\n\nint fat_fill_inode(struct inode *inode, struct msdos_dir_entry *de)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint error;\n\n\tMSDOS_I(inode)->i_pos = 0;\n\tinode->i_uid = sbi->options.fs_uid;\n\tinode->i_gid = sbi->options.fs_gid;\n\tinode->i_version++;\n\tinode->i_generation = get_seconds();\n\n\tif ((de->attr & ATTR_DIR) && !IS_FREE(de->name)) {\n\t\tinode->i_generation &= ~1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr, S_IRWXUGO);\n\t\tinode->i_op = sbi->dir_ops;\n\t\tinode->i_fop = &fat_dir_operations;\n\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\terror = fat_calc_dir_size(inode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\n\t\tset_nlink(inode, fat_subdirs(inode));\n\t} else { /* not a directory */\n\t\tinode->i_generation |= 1;\n\t\tinode->i_mode = fat_make_mode(sbi, de->attr,\n\t\t\t((sbi->options.showexec && !is_exec(de->name + 8))\n\t\t\t ? S_IRUGO|S_IWUGO : S_IRWXUGO));\n\t\tMSDOS_I(inode)->i_start = fat_get_start(sbi, de);\n\n\t\tMSDOS_I(inode)->i_logstart = MSDOS_I(inode)->i_start;\n\t\tinode->i_size = le32_to_cpu(de->size);\n\t\tinode->i_op = &fat_file_inode_operations;\n\t\tinode->i_fop = &fat_file_operations;\n\t\tinode->i_mapping->a_ops = &fat_aops;\n\t\tMSDOS_I(inode)->mmu_private = inode->i_size;\n\t}\n\tif (de->attr & ATTR_SYS) {\n\t\tif (sbi->options.sys_immutable)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t}\n\tfat_save_attrs(inode, de->attr);\n\n\tinode->i_blocks = ((inode->i_size + (sbi->cluster_size - 1))\n\t\t\t   & ~((loff_t)sbi->cluster_size - 1)) >> 9;\n\n\tfat_time_fat2unix(sbi, &inode->i_mtime, de->time, de->date, 0);\n\tif (sbi->options.isvfat) {\n\t\tfat_time_fat2unix(sbi, &inode->i_ctime, de->ctime,\n\t\t\t\t  de->cdate, de->ctime_cs);\n\t\tfat_time_fat2unix(sbi, &inode->i_atime, 0, de->adate, 0);\n\t} else\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "MSDOS_ROOT_INO"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dget",
          "args": [
            "sb",
            "search_clus"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "32-51",
          "snippet": "static struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_start",
          "args": [
            "sbi",
            "&de[1]"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "258-265",
          "snippet": "static inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int fat_get_start(const struct msdos_sb_info *sbi,\n\t\t\t\tconst struct msdos_dir_entry *de)\n{\n\tint cluster = le16_to_cpu(de->start);\n\tif (sbi->fat_bits == 32)\n\t\tcluster |= (le16_to_cpu(de->starthi) << 16);\n\treturn cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"unable to read cluster of parent directory\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blknr"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_clus_to_blknr",
          "args": [
            "sbi",
            "parent_logstart"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clus_to_blknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "219-223",
          "snippet": "static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\n{\n\tint search_clus, clus_to_match;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent = NULL;\n\tstruct inode *dummy_grand_parent = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\n\tstruct buffer_head *parent_bh = sb_bread(sb, blknr);\n\tif (!parent_bh) {\n\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\"unable to read cluster of parent directory\");\n\t\treturn NULL;\n\t}\n\n\tde = (struct msdos_dir_entry *) parent_bh->b_data;\n\tclus_to_match = fat_get_start(sbi, &de[0]);\n\tsearch_clus = fat_get_start(sbi, &de[1]);\n\n\tdummy_grand_parent = fat_dget(sb, search_clus);\n\tif (!dummy_grand_parent) {\n\t\tdummy_grand_parent = new_inode(sb);\n\t\tif (!dummy_grand_parent) {\n\t\t\tbrelse(parent_bh);\n\t\t\treturn parent;\n\t\t}\n\n\t\tdummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\t\tfat_fill_inode(dummy_grand_parent, &de[1]);\n\t\tMSDOS_I(dummy_grand_parent)->i_pos = -1;\n\t}\n\n\tif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\n\t\tparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\n\tbrelse(parent_bh);\n\tiput(dummy_grand_parent);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "fat_fh_to_parent_nostale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "196-216",
    "snippet": "static struct dentry *fat_fh_to_parent_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITH_PARENT:\n\t\ti_pos = fid->parent_i_pos_hi;\n\t\ti_pos = (i_pos << 32) | (fid->parent_i_pos_low);\n\t\tinode = __fat_nfs_get_inode(sb, 0, fid->parent_i_gen, i_pos);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [
      "#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fat_nfs_get_inode",
          "args": [
            "sb",
            "0",
            "fid->parent_i_gen",
            "i_pos"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "65-99",
          "snippet": "static struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\n#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))\n\nstatic struct dentry *fat_fh_to_parent_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITH_PARENT:\n\t\ti_pos = fid->parent_i_pos_hi;\n\t\ti_pos = (i_pos << 32) | (fid->parent_i_pos_low);\n\t\tinode = __fat_nfs_get_inode(sb, 0, fid->parent_i_gen, i_pos);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "fat_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "189-194",
    "snippet": "static struct dentry *fat_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "fat_nfs_get_inode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct dentry *fat_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}"
  },
  {
    "function_name": "fat_fh_to_dentry_nostale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "158-183",
    "snippet": "static struct dentry *fat_fh_to_dentry_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITHOUT_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITHOUT_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase FILEID_FAT_WITH_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\ti_pos = fid->i_pos_hi;\n\ti_pos = (i_pos << 32) | (fid->i_pos_low);\n\tinode = __fat_nfs_get_inode(sb, 0, fid->i_gen, i_pos);\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [
      "#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))",
      "#define FAT_FID_SIZE_WITHOUT_PARENT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fat_nfs_get_inode",
          "args": [
            "sb",
            "0",
            "fid->i_gen",
            "i_pos"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "65-99",
          "snippet": "static struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\n#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))\n#define FAT_FID_SIZE_WITHOUT_PARENT 3\n\nstatic struct dentry *fat_fh_to_dentry_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITHOUT_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITHOUT_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase FILEID_FAT_WITH_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\ti_pos = fid->i_pos_hi;\n\ti_pos = (i_pos << 32) | (fid->i_pos_low);\n\tinode = __fat_nfs_get_inode(sb, 0, fid->i_gen, i_pos);\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "fat_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "151-156",
    "snippet": "static struct dentry *fat_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "fat_nfs_get_inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct dentry *fat_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}"
  },
  {
    "function_name": "fat_encode_fh_nostale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "108-145",
    "snippet": "static int\nfat_encode_fh_nostale(struct inode *inode, __u32 *fh, int *lenp,\n\t\t      struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct fat_fid *fid = (struct fat_fid *) fh;\n\tloff_t i_pos;\n\tint type = FILEID_FAT_WITHOUT_PARENT;\n\n\tif (parent) {\n\t\tif (len < FAT_FID_SIZE_WITH_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t} else {\n\t\tif (len < FAT_FID_SIZE_WITHOUT_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t}\n\n\ti_pos = fat_i_pos_read(sbi, inode);\n\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\tfid->i_gen = inode->i_generation;\n\tfid->i_pos_low = i_pos & 0xFFFFFFFF;\n\tfid->i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\tif (parent) {\n\t\ti_pos = fat_i_pos_read(sbi, parent);\n\t\tfid->parent_i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\t\tfid->parent_i_pos_low = i_pos & 0xFFFFFFFF;\n\t\tfid->parent_i_gen = parent->i_generation;\n\t\ttype = FILEID_FAT_WITH_PARENT;\n\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t}\n\n\treturn type;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [
      "#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))",
      "#define FAT_FID_SIZE_WITHOUT_PARENT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_i_pos_read",
          "args": [
            "sbi",
            "parent"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "fat_i_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "232-244",
          "snippet": "static inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\n#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))\n#define FAT_FID_SIZE_WITHOUT_PARENT 3\n\nstatic int\nfat_encode_fh_nostale(struct inode *inode, __u32 *fh, int *lenp,\n\t\t      struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct fat_fid *fid = (struct fat_fid *) fh;\n\tloff_t i_pos;\n\tint type = FILEID_FAT_WITHOUT_PARENT;\n\n\tif (parent) {\n\t\tif (len < FAT_FID_SIZE_WITH_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t} else {\n\t\tif (len < FAT_FID_SIZE_WITHOUT_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t}\n\n\ti_pos = fat_i_pos_read(sbi, inode);\n\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\tfid->i_gen = inode->i_generation;\n\tfid->i_pos_low = i_pos & 0xFFFFFFFF;\n\tfid->i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\tif (parent) {\n\t\ti_pos = fat_i_pos_read(sbi, parent);\n\t\tfid->parent_i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\t\tfid->parent_i_pos_low = i_pos & 0xFFFFFFFF;\n\t\tfid->parent_i_gen = parent->i_generation;\n\t\ttype = FILEID_FAT_WITH_PARENT;\n\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t}\n\n\treturn type;\n}"
  },
  {
    "function_name": "fat_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "101-106",
    "snippet": "static struct inode *fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation)\n{\n\n\treturn __fat_nfs_get_inode(sb, ino, generation, 0);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fat_nfs_get_inode",
          "args": [
            "sb",
            "ino",
            "generation",
            "0"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "65-99",
          "snippet": "static struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation)\n{\n\n\treturn __fat_nfs_get_inode(sb, ino, generation, 0);\n}"
  },
  {
    "function_name": "__fat_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "65-99",
    "snippet": "static struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "&de[offset]",
            "i_pos"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FREE",
          "args": [
            "de[offset].name"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"unable to read block(%llu) for building NFS inode\"",
            "(llu)blocknr"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_get_blknr_offset",
          "args": [
            "MSDOS_SB(sb)",
            "i_pos",
            "&blocknr",
            "&offset"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_blknr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "225-230",
          "snippet": "static inline void fat_get_blknr_offset(struct msdos_sb_info *sbi,\n\t\t\t\tloff_t i_pos, sector_t *blknr, int *offset)\n{\n\t*blknr = i_pos >> sbi->dir_per_block_bits;\n\t*offset = i_pos & (sbi->dir_per_block - 1);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_get_blknr_offset(struct msdos_sb_info *sbi,\n\t\t\t\tloff_t i_pos, sector_t *blknr, int *offset)\n{\n\t*blknr = i_pos >> sbi->dir_per_block_bits;\n\t*offset = i_pos & (sbi->dir_per_block - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ilookup",
          "args": [
            "sb",
            "ino",
            "i_pos"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ilookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
          "lines": "53-63",
          "snippet": "static struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\n{\n\tif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\treturn fat_iget(sb, i_pos);\n\n\telse {\n\t\tif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\n\t\t\treturn NULL;\n\t\treturn ilookup(sb, ino);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\n{\n\tif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\treturn fat_iget(sb, i_pos);\n\n\telse {\n\t\tif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\n\t\t\treturn NULL;\n\t\treturn ilookup(sb, ino);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t\"unable to read block(%llu) for building NFS inode\",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "fat_ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "53-63",
    "snippet": "static struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\n{\n\tif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\treturn fat_iget(sb, i_pos);\n\n\telse {\n\t\tif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\n\t\t\treturn NULL;\n\t\treturn ilookup(sb, ino);\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilookup",
          "args": [
            "sb",
            "ino"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1258-1270",
          "snippet": "struct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_iget",
          "args": [
            "sb",
            "i_pos"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "fat_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "414-432",
          "snippet": "struct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_iget(struct super_block *sb, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head = sbi->inode_hashtable + fat_hash(i_pos);\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&sbi->inode_hash_lock);\n\thlist_for_each_entry(i, head, i_fat_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_pos != i_pos)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->inode_hash_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\n{\n\tif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\treturn fat_iget(sb, i_pos);\n\n\telse {\n\t\tif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\n\t\t\treturn NULL;\n\t\treturn ilookup(sb, ino);\n\t}\n}"
  },
  {
    "function_name": "fat_dget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/nfs.c",
    "lines": "32-51",
    "snippet": "static struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&i->vfs_inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i->vfs_inode.i_sb != sb"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "i",
            "head",
            "i_dir_hash"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_hash_lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_hash",
          "args": [
            "i_logstart"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "386-389",
          "snippet": "static inline unsigned long fat_dir_hash(int logstart)\n{\n\treturn hash_32(logstart, FAT_HASH_BITS);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define FAT_HASH_BITS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\n#define FAT_HASH_BITS\t8\n\nstatic inline unsigned long fat_dir_hash(int logstart)\n{\n\treturn hash_32(logstart, FAT_HASH_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/exportfs.h>\n\nstatic struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}"
  }
]