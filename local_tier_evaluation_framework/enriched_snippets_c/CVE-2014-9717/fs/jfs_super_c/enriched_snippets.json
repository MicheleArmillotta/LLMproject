[
  {
    "function_name": "exit_jfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "985-1009",
    "snippet": "static void __exit exit_jfs_fs(void)\n{\n\tint i;\n\n\tjfs_info(\"exit_jfs_fs called\");\n\n\ttxExit();\n\tmetapage_exit();\n\n\tkthread_stop(jfsIOthread);\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsSyncThread);\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tunregister_filesystem(&jfs_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(jfs_inode_cachep);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jfs_inode_cachep;",
      "static struct file_system_type jfs_fs_type;",
      "static int commit_threads;",
      "static struct task_struct *jfsCommitThread[MAX_COMMIT_THREADS];",
      "struct task_struct *jfsIOthread;",
      "struct task_struct *jfsSyncThread;",
      "static struct file_system_type jfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"jfs\",\n\t.mount\t\t= jfs_do_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jfs_inode_cachep"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&jfs_fs_type"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_proc_clean",
          "args": [],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_proc_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_debug.c",
          "lines": "98-107",
          "snippet": "void jfs_proc_clean(void)\n{\n\tint i;\n\n\tif (base) {\n\t\tfor (i = 0; i < NPROCENT; i++)\n\t\t\tremove_proc_entry(Entries[i].name, base);\n\t\tremove_proc_entry(\"fs/jfs\", NULL);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NPROCENT\tARRAY_SIZE(Entries)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <asm/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\n#define NPROCENT\tARRAY_SIZE(Entries)\n\nvoid jfs_proc_clean(void)\n{\n\tint i;\n\n\tif (base) {\n\t\tfor (i = 0; i < NPROCENT; i++)\n\t\t\tremove_proc_entry(Entries[i].name, base);\n\t\tremove_proc_entry(\"fs/jfs\", NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsSyncThread"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsCommitThread[i]"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsIOthread"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_exit",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "234-238",
          "snippet": "void metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *metapage_cache;",
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\nvoid metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txExit",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "txExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "340-346",
          "snippet": "void txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tblock *TxBlock;",
            "struct tlock *TxLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tblock *TxBlock;\nstruct tlock *TxLock;\n\nvoid txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"exit_jfs_fs called\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *jfs_inode_cachep;\nstatic struct file_system_type jfs_fs_type;\nstatic int commit_threads;\nstatic struct task_struct *jfsCommitThread[MAX_COMMIT_THREADS];\nstruct task_struct *jfsIOthread;\nstruct task_struct *jfsSyncThread;\nstatic struct file_system_type jfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"jfs\",\n\t.mount\t\t= jfs_do_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_jfs_fs(void)\n{\n\tint i;\n\n\tjfs_info(\"exit_jfs_fs called\");\n\n\ttxExit();\n\tmetapage_exit();\n\n\tkthread_stop(jfsIOthread);\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsSyncThread);\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tunregister_filesystem(&jfs_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(jfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_jfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "897-983",
    "snippet": "static int __init init_jfs_fs(void)\n{\n\tint i;\n\tint rc;\n\n\tjfs_inode_cachep =\n\t    kmem_cache_create(\"jfs_ip\", sizeof(struct jfs_inode_info), 0,\n\t\t\t    SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t    init_once);\n\tif (jfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Metapage initialization\n\t */\n\trc = metapage_init();\n\tif (rc) {\n\t\tjfs_err(\"metapage_init failed w/rc = %d\", rc);\n\t\tgoto free_slab;\n\t}\n\n\t/*\n\t * Transaction Manager initialization\n\t */\n\trc = txInit();\n\tif (rc) {\n\t\tjfs_err(\"txInit failed w/rc = %d\", rc);\n\t\tgoto free_metapage;\n\t}\n\n\t/*\n\t * I/O completion thread (endio)\n\t */\n\tjfsIOthread = kthread_run(jfsIOWait, NULL, \"jfsIO\");\n\tif (IS_ERR(jfsIOthread)) {\n\t\trc = PTR_ERR(jfsIOthread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto end_txmngr;\n\t}\n\n\tif (commit_threads < 1)\n\t\tcommit_threads = num_online_cpus();\n\tif (commit_threads > MAX_COMMIT_THREADS)\n\t\tcommit_threads = MAX_COMMIT_THREADS;\n\n\tfor (i = 0; i < commit_threads; i++) {\n\t\tjfsCommitThread[i] = kthread_run(jfs_lazycommit, NULL,\n\t\t\t\t\t\t \"jfsCommit\");\n\t\tif (IS_ERR(jfsCommitThread[i])) {\n\t\t\trc = PTR_ERR(jfsCommitThread[i]);\n\t\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\t\tcommit_threads = i;\n\t\t\tgoto kill_committask;\n\t\t}\n\t}\n\n\tjfsSyncThread = kthread_run(jfs_sync, NULL, \"jfsSync\");\n\tif (IS_ERR(jfsSyncThread)) {\n\t\trc = PTR_ERR(jfsSyncThread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto kill_committask;\n\t}\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_init();\n#endif\n\n\trc = register_filesystem(&jfs_fs_type);\n\tif (!rc)\n\t\treturn 0;\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tkthread_stop(jfsSyncThread);\nkill_committask:\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsIOthread);\nend_txmngr:\n\ttxExit();\nfree_metapage:\n\tmetapage_exit();\nfree_slab:\n\tkmem_cache_destroy(jfs_inode_cachep);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_COMMIT_THREADS 64"
    ],
    "globals_used": [
      "static struct kmem_cache *jfs_inode_cachep;",
      "static struct file_system_type jfs_fs_type;",
      "static int commit_threads;",
      "static struct task_struct *jfsCommitThread[MAX_COMMIT_THREADS];",
      "struct task_struct *jfsIOthread;",
      "struct task_struct *jfsSyncThread;",
      "static struct file_system_type jfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"jfs\",\n\t.mount\t\t= jfs_do_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jfs_inode_cachep"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_exit",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "234-238",
          "snippet": "void metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *metapage_cache;",
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\nvoid metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txExit",
          "args": [],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "txExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "340-346",
          "snippet": "void txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tblock *TxBlock;",
            "struct tlock *TxLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tblock *TxBlock;\nstruct tlock *TxLock;\n\nvoid txExit(void)\n{\n\tvfree(TxLock);\n\tTxLock = NULL;\n\tvfree(TxBlock);\n\tTxBlock = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsIOthread"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsCommitThread[i]"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "jfsSyncThread"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_proc_clean",
          "args": [],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_proc_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_debug.c",
          "lines": "98-107",
          "snippet": "void jfs_proc_clean(void)\n{\n\tint i;\n\n\tif (base) {\n\t\tfor (i = 0; i < NPROCENT; i++)\n\t\t\tremove_proc_entry(Entries[i].name, base);\n\t\tremove_proc_entry(\"fs/jfs\", NULL);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NPROCENT\tARRAY_SIZE(Entries)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <asm/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\n#define NPROCENT\tARRAY_SIZE(Entries)\n\nvoid jfs_proc_clean(void)\n{\n\tint i;\n\n\tif (base) {\n\t\tfor (i = 0; i < NPROCENT; i++)\n\t\t\tremove_proc_entry(Entries[i].name, base);\n\t\tremove_proc_entry(\"fs/jfs\", NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&jfs_fs_type"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_proc_init",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_proc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_debug.c",
          "lines": "87-96",
          "snippet": "void jfs_proc_init(void)\n{\n\tint i;\n\n\tif (!(base = proc_mkdir(\"fs/jfs\", NULL)))\n\t\treturn;\n\n\tfor (i = 0; i < NPROCENT; i++)\n\t\tproc_create(Entries[i].name, 0, base, Entries[i].proc_fops);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NPROCENT\tARRAY_SIZE(Entries)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <asm/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\n#define NPROCENT\tARRAY_SIZE(Entries)\n\nvoid jfs_proc_init(void)\n{\n\tint i;\n\n\tif (!(base = proc_mkdir(\"fs/jfs\", NULL)))\n\t\treturn;\n\n\tfor (i = 0; i < NPROCENT; i++)\n\t\tproc_create(Entries[i].name, 0, base, Entries[i].proc_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"init_jfs_fs: fork failed w/rc = %d\"",
            "rc"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "jfsSyncThread"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "jfsSyncThread"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "jfs_sync",
            "NULL",
            "\"jfsSync\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "jfsCommitThread[i]"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "jfsCommitThread[i]"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "jfs_lazycommit",
            "NULL",
            "\"jfsCommit\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "jfsIOthread"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "jfsIOthread"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "jfsIOWait",
            "NULL",
            "\"jfsIO\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txInit",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "txInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "238-333",
          "snippet": "int txInit(void)\n{\n\tint k, size;\n\tstruct sysinfo si;\n\n\t/* Set defaults for nTxLock and nTxBlock if unset */\n\n\tif (nTxLock == -1) {\n\t\tif (nTxBlock == -1) {\n\t\t\t/* Base default on memory size */\n\t\t\tsi_meminfo(&si);\n\t\t\tif (si.totalram > (256 * 1024)) /* 1 GB */\n\t\t\t\tnTxLock = 64 * 1024;\n\t\t\telse\n\t\t\t\tnTxLock = si.totalram >> 2;\n\t\t} else if (nTxBlock > (8 * 1024))\n\t\t\tnTxLock = 64 * 1024;\n\t\telse\n\t\t\tnTxLock = nTxBlock << 3;\n\t}\n\tif (nTxBlock == -1)\n\t\tnTxBlock = nTxLock >> 3;\n\n\t/* Verify tunable parameters */\n\tif (nTxBlock < 16)\n\t\tnTxBlock = 16;\t/* No one should set it this low */\n\tif (nTxBlock > 65536)\n\t\tnTxBlock = 65536;\n\tif (nTxLock < 256)\n\t\tnTxLock = 256;\t/* No one should set it this low */\n\tif (nTxLock > 65536)\n\t\tnTxLock = 65536;\n\n\tprintk(KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\",\n\t       nTxBlock, nTxLock);\n\t/*\n\t * initialize transaction block (tblock) table\n\t *\n\t * transaction id (tid) = tblock index\n\t * tid = 0 is reserved.\n\t */\n\tTxLockLWM = (nTxLock * 4) / 10;\n\tTxLockHWM = (nTxLock * 7) / 10;\n\tTxLockVHWM = (nTxLock * 8) / 10;\n\n\tsize = sizeof(struct tblock) * nTxBlock;\n\tTxBlock = vmalloc(size);\n\tif (TxBlock == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (k = 1; k < nTxBlock - 1; k++) {\n\t\tTxBlock[k].next = k + 1;\n\t\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\t\tinit_waitqueue_head(&TxBlock[k].waitor);\n\t}\n\tTxBlock[k].next = 0;\n\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\tinit_waitqueue_head(&TxBlock[k].waitor);\n\n\tTxAnchor.freetid = 1;\n\tinit_waitqueue_head(&TxAnchor.freewait);\n\n\tstattx.maxtid = 1;\t/* statistics */\n\n\t/*\n\t * initialize transaction lock (tlock) table\n\t *\n\t * transaction lock id = tlock index\n\t * tlock id = 0 is reserved.\n\t */\n\tsize = sizeof(struct tlock) * nTxLock;\n\tTxLock = vmalloc(size);\n\tif (TxLock == NULL) {\n\t\tvfree(TxBlock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialize tlock table */\n\tfor (k = 1; k < nTxLock - 1; k++)\n\t\tTxLock[k].next = k + 1;\n\tTxLock[k].next = 0;\n\tinit_waitqueue_head(&TxAnchor.freelockwait);\n\tinit_waitqueue_head(&TxAnchor.lowlockwait);\n\n\tTxAnchor.freelock = 1;\n\tTxAnchor.tlocksInUse = 0;\n\tINIT_LIST_HEAD(&TxAnchor.anon_list);\n\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\n\tLAZY_LOCK_INIT();\n\tINIT_LIST_HEAD(&TxAnchor.unlock_queue);\n\n\tstattx.maxlid = 1;\t/* statistics */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int nTxBlock = -1;",
            "static int nTxLock = -1;",
            "struct tblock *TxBlock;",
            "static int TxLockLWM;",
            "static int TxLockHWM;",
            "static int TxLockVHWM;",
            "struct tlock *TxLock;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int nTxBlock = -1;\nstatic int nTxLock = -1;\nstruct tblock *TxBlock;\nstatic int TxLockLWM;\nstatic int TxLockHWM;\nstatic int TxLockVHWM;\nstruct tlock *TxLock;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\n\nint txInit(void)\n{\n\tint k, size;\n\tstruct sysinfo si;\n\n\t/* Set defaults for nTxLock and nTxBlock if unset */\n\n\tif (nTxLock == -1) {\n\t\tif (nTxBlock == -1) {\n\t\t\t/* Base default on memory size */\n\t\t\tsi_meminfo(&si);\n\t\t\tif (si.totalram > (256 * 1024)) /* 1 GB */\n\t\t\t\tnTxLock = 64 * 1024;\n\t\t\telse\n\t\t\t\tnTxLock = si.totalram >> 2;\n\t\t} else if (nTxBlock > (8 * 1024))\n\t\t\tnTxLock = 64 * 1024;\n\t\telse\n\t\t\tnTxLock = nTxBlock << 3;\n\t}\n\tif (nTxBlock == -1)\n\t\tnTxBlock = nTxLock >> 3;\n\n\t/* Verify tunable parameters */\n\tif (nTxBlock < 16)\n\t\tnTxBlock = 16;\t/* No one should set it this low */\n\tif (nTxBlock > 65536)\n\t\tnTxBlock = 65536;\n\tif (nTxLock < 256)\n\t\tnTxLock = 256;\t/* No one should set it this low */\n\tif (nTxLock > 65536)\n\t\tnTxLock = 65536;\n\n\tprintk(KERN_INFO \"JFS: nTxBlock = %d, nTxLock = %d\\n\",\n\t       nTxBlock, nTxLock);\n\t/*\n\t * initialize transaction block (tblock) table\n\t *\n\t * transaction id (tid) = tblock index\n\t * tid = 0 is reserved.\n\t */\n\tTxLockLWM = (nTxLock * 4) / 10;\n\tTxLockHWM = (nTxLock * 7) / 10;\n\tTxLockVHWM = (nTxLock * 8) / 10;\n\n\tsize = sizeof(struct tblock) * nTxBlock;\n\tTxBlock = vmalloc(size);\n\tif (TxBlock == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (k = 1; k < nTxBlock - 1; k++) {\n\t\tTxBlock[k].next = k + 1;\n\t\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\t\tinit_waitqueue_head(&TxBlock[k].waitor);\n\t}\n\tTxBlock[k].next = 0;\n\tinit_waitqueue_head(&TxBlock[k].gcwait);\n\tinit_waitqueue_head(&TxBlock[k].waitor);\n\n\tTxAnchor.freetid = 1;\n\tinit_waitqueue_head(&TxAnchor.freewait);\n\n\tstattx.maxtid = 1;\t/* statistics */\n\n\t/*\n\t * initialize transaction lock (tlock) table\n\t *\n\t * transaction lock id = tlock index\n\t * tlock id = 0 is reserved.\n\t */\n\tsize = sizeof(struct tlock) * nTxLock;\n\tTxLock = vmalloc(size);\n\tif (TxLock == NULL) {\n\t\tvfree(TxBlock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialize tlock table */\n\tfor (k = 1; k < nTxLock - 1; k++)\n\t\tTxLock[k].next = k + 1;\n\tTxLock[k].next = 0;\n\tinit_waitqueue_head(&TxAnchor.freelockwait);\n\tinit_waitqueue_head(&TxAnchor.lowlockwait);\n\n\tTxAnchor.freelock = 1;\n\tTxAnchor.tlocksInUse = 0;\n\tINIT_LIST_HEAD(&TxAnchor.anon_list);\n\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\n\tLAZY_LOCK_INIT();\n\tINIT_LIST_HEAD(&TxAnchor.unlock_queue);\n\n\tstattx.maxlid = 1;\t/* statistics */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapage_init",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "213-232",
          "snippet": "int __init metapage_init(void)\n{\n\t/*\n\t * Allocate the metapage structures\n\t */\n\tmetapage_cache = kmem_cache_create(\"jfs_mp\", sizeof(struct metapage),\n\t\t\t\t\t   0, 0, init_once);\n\tif (metapage_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\n\t\t\t\t\t\t    metapage_cache);\n\n\tif (metapage_mempool == NULL) {\n\t\tkmem_cache_destroy(metapage_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define METAPOOL_MIN_PAGES 32"
          ],
          "globals_used": [
            "static struct kmem_cache *metapage_cache;",
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define METAPOOL_MIN_PAGES 32\n\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\nint __init metapage_init(void)\n{\n\t/*\n\t * Allocate the metapage structures\n\t */\n\tmetapage_cache = kmem_cache_create(\"jfs_mp\", sizeof(struct metapage),\n\t\t\t\t\t   0, 0, init_once);\n\tif (metapage_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\n\t\t\t\t\t\t    metapage_cache);\n\n\tif (metapage_mempool == NULL) {\n\t\tkmem_cache_destroy(metapage_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"jfs_ip\"",
            "sizeof(struct jfs_inode_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "init_once"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_COMMIT_THREADS 64\n\nstatic struct kmem_cache *jfs_inode_cachep;\nstatic struct file_system_type jfs_fs_type;\nstatic int commit_threads;\nstatic struct task_struct *jfsCommitThread[MAX_COMMIT_THREADS];\nstruct task_struct *jfsIOthread;\nstruct task_struct *jfsSyncThread;\nstatic struct file_system_type jfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"jfs\",\n\t.mount\t\t= jfs_do_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_jfs_fs(void)\n{\n\tint i;\n\tint rc;\n\n\tjfs_inode_cachep =\n\t    kmem_cache_create(\"jfs_ip\", sizeof(struct jfs_inode_info), 0,\n\t\t\t    SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t    init_once);\n\tif (jfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Metapage initialization\n\t */\n\trc = metapage_init();\n\tif (rc) {\n\t\tjfs_err(\"metapage_init failed w/rc = %d\", rc);\n\t\tgoto free_slab;\n\t}\n\n\t/*\n\t * Transaction Manager initialization\n\t */\n\trc = txInit();\n\tif (rc) {\n\t\tjfs_err(\"txInit failed w/rc = %d\", rc);\n\t\tgoto free_metapage;\n\t}\n\n\t/*\n\t * I/O completion thread (endio)\n\t */\n\tjfsIOthread = kthread_run(jfsIOWait, NULL, \"jfsIO\");\n\tif (IS_ERR(jfsIOthread)) {\n\t\trc = PTR_ERR(jfsIOthread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto end_txmngr;\n\t}\n\n\tif (commit_threads < 1)\n\t\tcommit_threads = num_online_cpus();\n\tif (commit_threads > MAX_COMMIT_THREADS)\n\t\tcommit_threads = MAX_COMMIT_THREADS;\n\n\tfor (i = 0; i < commit_threads; i++) {\n\t\tjfsCommitThread[i] = kthread_run(jfs_lazycommit, NULL,\n\t\t\t\t\t\t \"jfsCommit\");\n\t\tif (IS_ERR(jfsCommitThread[i])) {\n\t\t\trc = PTR_ERR(jfsCommitThread[i]);\n\t\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\t\tcommit_threads = i;\n\t\t\tgoto kill_committask;\n\t\t}\n\t}\n\n\tjfsSyncThread = kthread_run(jfs_sync, NULL, \"jfsSync\");\n\tif (IS_ERR(jfsSyncThread)) {\n\t\trc = PTR_ERR(jfsSyncThread);\n\t\tjfs_err(\"init_jfs_fs: fork failed w/rc = %d\", rc);\n\t\tgoto kill_committask;\n\t}\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_init();\n#endif\n\n\trc = register_filesystem(&jfs_fs_type);\n\tif (!rc)\n\t\treturn 0;\n\n#ifdef PROC_FS_JFS\n\tjfs_proc_clean();\n#endif\n\tkthread_stop(jfsSyncThread);\nkill_committask:\n\tfor (i = 0; i < commit_threads; i++)\n\t\tkthread_stop(jfsCommitThread[i]);\n\tkthread_stop(jfsIOthread);\nend_txmngr:\n\ttxExit();\nfree_metapage:\n\tmetapage_exit();\nfree_slab:\n\tkmem_cache_destroy(jfs_inode_cachep);\n\treturn rc;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "883-895",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct jfs_inode_info *jfs_ip = (struct jfs_inode_info *) foo;\n\n\tmemset(jfs_ip, 0, sizeof(struct jfs_inode_info));\n\tINIT_LIST_HEAD(&jfs_ip->anon_inode_list);\n\tinit_rwsem(&jfs_ip->rdwrlock);\n\tmutex_init(&jfs_ip->commit_mutex);\n\tinit_rwsem(&jfs_ip->xattr_sem);\n\tspin_lock_init(&jfs_ip->ag_lock);\n\tjfs_ip->active_ag = -1;\n\tinode_init_once(&jfs_ip->vfs_inode);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&jfs_ip->vfs_inode"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&jfs_ip->ag_lock"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&jfs_ip->xattr_sem"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&jfs_ip->commit_mutex"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&jfs_ip->rdwrlock"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jfs_ip->anon_inode_list"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "jfs_ip",
            "0",
            "sizeof(struct jfs_inode_info)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct jfs_inode_info *jfs_ip = (struct jfs_inode_info *) foo;\n\n\tmemset(jfs_ip, 0, sizeof(struct jfs_inode_info));\n\tINIT_LIST_HEAD(&jfs_ip->anon_inode_list);\n\tinit_rwsem(&jfs_ip->rdwrlock);\n\tmutex_init(&jfs_ip->commit_mutex);\n\tinit_rwsem(&jfs_ip->xattr_sem);\n\tspin_lock_init(&jfs_ip->ag_lock);\n\tjfs_ip->active_ag = -1;\n\tinode_init_once(&jfs_ip->vfs_inode);\n}"
  },
  {
    "function_name": "jfs_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "842-845",
    "snippet": "static struct dquot **jfs_get_dquots(struct inode *inode)\n{\n\treturn JFS_IP(inode)->i_dquot;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct dquot **jfs_get_dquots(struct inode *inode)\n{\n\treturn JFS_IP(inode)->i_dquot;\n}"
  },
  {
    "function_name": "jfs_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "786-840",
    "snippet": "static ssize_t jfs_quota_write(struct super_block *sb, int type,\n\t\t\t       const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\tmutex_lock(&inode->i_mutex);\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = 1 << inode->i_blkbits;\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn err;\n\t}\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tmutex_unlock(&inode->i_mutex);\n\treturn len - towrite;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "off+len-towrite"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data+offset",
            "data",
            "tocopy"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "1"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "196-280",
          "snippet": "int jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic ssize_t jfs_quota_write(struct super_block *sb, int type,\n\t\t\t       const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\tmutex_lock(&inode->i_mutex);\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = 1 << inode->i_blkbits;\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn err;\n\t}\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tmutex_unlock(&inode->i_mutex);\n\treturn len - towrite;\n}"
  },
  {
    "function_name": "jfs_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "741-783",
    "snippet": "static ssize_t jfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t      size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = 1 << inode->i_blkbits;\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data+offset",
            "tocopy"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "tocopy"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&tmp_bh"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "0"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "196-280",
          "snippet": "int jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic ssize_t jfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t      size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = 1 << inode->i_blkbits;\n\t\terr = jfs_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "jfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "703-733",
    "snippet": "static int jfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(root->d_sb);\n\n\tif (uid_valid(sbi->uid))\n\t\tseq_printf(seq, \",uid=%d\", from_kuid(&init_user_ns, sbi->uid));\n\tif (gid_valid(sbi->gid))\n\t\tseq_printf(seq, \",gid=%d\", from_kgid(&init_user_ns, sbi->gid));\n\tif (sbi->umask != -1)\n\t\tseq_printf(seq, \",umask=%03o\", sbi->umask);\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\tseq_puts(seq, \",nointegrity\");\n\tif (sbi->flag & JFS_DISCARD)\n\t\tseq_printf(seq, \",discard=%u\", sbi->minblks_trim);\n\tif (sbi->nls_tab)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->nls_tab->charset);\n\tif (sbi->flag & JFS_ERR_CONTINUE)\n\t\tseq_printf(seq, \",errors=continue\");\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tseq_printf(seq, \",errors=panic\");\n\n#ifdef CONFIG_QUOTA\n\tif (sbi->flag & JFS_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->flag & JFS_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",grpquota\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",errors=panic\""
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "sbi->gid"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "sbi->gid"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "sbi->uid"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "sbi->uid"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "root->d_sb"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(root->d_sb);\n\n\tif (uid_valid(sbi->uid))\n\t\tseq_printf(seq, \",uid=%d\", from_kuid(&init_user_ns, sbi->uid));\n\tif (gid_valid(sbi->gid))\n\t\tseq_printf(seq, \",gid=%d\", from_kgid(&init_user_ns, sbi->gid));\n\tif (sbi->umask != -1)\n\t\tseq_printf(seq, \",umask=%03o\", sbi->umask);\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\tseq_puts(seq, \",nointegrity\");\n\tif (sbi->flag & JFS_DISCARD)\n\t\tseq_printf(seq, \",discard=%u\", sbi->minblks_trim);\n\tif (sbi->nls_tab)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->nls_tab->charset);\n\tif (sbi->flag & JFS_ERR_CONTINUE)\n\t\tseq_printf(seq, \",errors=continue\");\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tseq_printf(seq, \",errors=panic\");\n\n#ifdef CONFIG_QUOTA\n\tif (sbi->flag & JFS_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->flag & JFS_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "685-701",
    "snippet": "static int jfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\t/* log == NULL indicates read-only mount */\n\tif (log) {\n\t\t/*\n\t\t * Write quota structures to quota file, sync_blockdev() will\n\t\t * write them to disk later\n\t\t */\n\t\tdquot_writeback_dquots(sb, -1);\n\t\tjfs_flush_journal(log, wait);\n\t\tjfs_syncpt(log, 0);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_syncpt",
          "args": [
            "log",
            "0"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_syncpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1059-1064",
          "snippet": "void jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static int lmLogSync(struct jfs_log * log, int hard_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nvoid jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "wait"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_writeback_dquots",
          "args": [
            "sb",
            "-1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_writeback_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "605-652",
          "snippet": "int dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\t/* log == NULL indicates read-only mount */\n\tif (log) {\n\t\t/*\n\t\t * Write quota structures to quota file, sync_blockdev() will\n\t\t * write them to disk later\n\t\t */\n\t\tdquot_writeback_dquots(sb, -1);\n\t\tjfs_flush_journal(log, wait);\n\t\tjfs_syncpt(log, 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_do_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "679-683",
    "snippet": "static struct dentry *jfs_do_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, jfs_fill_super);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "jfs_fill_super"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct dentry *jfs_do_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, jfs_fill_super);\n}"
  },
  {
    "function_name": "jfs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "658-677",
    "snippet": "static int jfs_unfreeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\trc = updateSuper(sb, FM_MOUNT);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"updateSuper failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trc = lmLogInit(log);\n\t\tif (rc)\n\t\t\tjfs_error(sb, \"lmLogInit failed\\n\");\nout:\n\t\ttxResume(sb);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txResume",
          "args": [
            "sb"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "txResume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2916-2922",
          "snippet": "void txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nvoid txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"lmLogInit failed\\n\""
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogInit",
          "args": [
            "log"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1262-1443",
          "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_MOUNT"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_unfreeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\trc = updateSuper(sb, FM_MOUNT);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"updateSuper failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trc = lmLogInit(log);\n\t\tif (rc)\n\t\t\tjfs_error(sb, \"lmLogInit failed\\n\");\nout:\n\t\ttxResume(sb);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "628-656",
    "snippet": "static int jfs_freeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\ttxQuiesce(sb);\n\t\trc = lmLogShutdown(log);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"lmLogShutdown failed\\n\");\n\n\t\t\t/* let operations fail rather than hang */\n\t\t\ttxResume(sb);\n\n\t\t\treturn rc;\n\t\t}\n\t\trc = updateSuper(sb, FM_CLEAN);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_freeze: updateSuper failed\\n\");\n\t\t\t/*\n\t\t\t * Don't fail here. Everything succeeded except\n\t\t\t * marking the superblock clean, so there's really\n\t\t\t * no harm in leaving it frozen for now.\n\t\t\t */\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_freeze: updateSuper failed\\n\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_CLEAN"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txResume",
          "args": [
            "sb"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "txResume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2916-2922",
          "snippet": "void txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nvoid txResume(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\n\tclear_bit(log_QUIESCE, &log->flag);\n\tTXN_WAKEUP(&log->syncwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"lmLogShutdown failed\\n\""
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogShutdown",
          "args": [
            "log"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1654-1713",
          "snippet": "int lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txQuiesce",
          "args": [
            "sb"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "txQuiesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2859-2909",
          "snippet": "void txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\n\nvoid txQuiesce(struct super_block *sb)\n{\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\ttid_t tid;\n\n\tset_bit(log_QUIESCE, &log->flag);\n\n\tTXN_LOCK();\nrestart:\n\twhile (!list_empty(&TxAnchor.anon_list)) {\n\t\tjfs_ip = list_entry(TxAnchor.anon_list.next,\n\t\t\t\t    struct jfs_inode_info,\n\t\t\t\t    anon_inode_list);\n\t\tip = &jfs_ip->vfs_inode;\n\n\t\t/*\n\t\t * inode will be removed from anonymous list\n\t\t * when it is committed\n\t\t */\n\t\tTXN_UNLOCK();\n\t\ttid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\n\t\tmutex_lock(&jfs_ip->commit_mutex);\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&jfs_ip->commit_mutex);\n\t\t/*\n\t\t * Just to be safe.  I don't know how\n\t\t * long we can run without blocking\n\t\t */\n\t\tcond_resched();\n\t\tTXN_LOCK();\n\t}\n\n\t/*\n\t * If jfs_sync is running in parallel, there could be some inodes\n\t * on anon_list2.  Let's check.\n\t */\n\tif (!list_empty(&TxAnchor.anon_list2)) {\n\t\tlist_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);\n\t\tINIT_LIST_HEAD(&TxAnchor.anon_list2);\n\t\tgoto restart;\n\t}\n\tTXN_UNLOCK();\n\n\t/*\n\t * We may need to kick off the group commit\n\t */\n\tjfs_flush_journal(log, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_freeze(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tint rc = 0;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\ttxQuiesce(sb);\n\t\trc = lmLogShutdown(log);\n\t\tif (rc) {\n\t\t\tjfs_error(sb, \"lmLogShutdown failed\\n\");\n\n\t\t\t/* let operations fail rather than hang */\n\t\t\ttxResume(sb);\n\n\t\t\treturn rc;\n\t\t}\n\t\trc = updateSuper(sb, FM_CLEAN);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_freeze: updateSuper failed\\n\");\n\t\t\t/*\n\t\t\t * Don't fail here. Everything succeeded except\n\t\t\t * marking the superblock clean, so there's really\n\t\t\t * no harm in leaving it frozen for now.\n\t\t\t */\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "489-626",
    "snippet": "static int jfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct jfs_sb_info *sbi;\n\tstruct inode *inode;\n\tint rc;\n\ts64 newLVSize = 0;\n\tint flag, ret = -EINVAL;\n\n\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);\n\n\tif (!new_valid_dev(sb->s_bdev->bd_dev))\n\t\treturn -EOVERFLOW;\n\n\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsb->s_max_links = JFS_LINK_MAX;\n\tsbi->sb = sb;\n\tsbi->uid = INVALID_UID;\n\tsbi->gid = INVALID_GID;\n\tsbi->umask = -1;\n\n\t/* initialize the mount flag and determine the default error handler */\n\tflag = JFS_ERR_REMOUNT_RO;\n\n\tif (!parse_options((char *) data, sb, &newLVSize, &flag))\n\t\tgoto out_kfree;\n\tsbi->flag = flag;\n\n#ifdef CONFIG_JFS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tif (newLVSize) {\n\t\tpr_err(\"resize option for remount only\\n\");\n\t\tgoto out_kfree;\n\t}\n\n\t/*\n\t * Initialize blocksize to 4K.\n\t */\n\tsb_set_blocksize(sb, PSIZE);\n\n\t/*\n\t * Set method vectors.\n\t */\n\tsb->s_op = &jfs_super_operations;\n\tsb->s_export_op = &jfs_export_operations;\n\tsb->s_xattr = jfs_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * Initialize direct-mapping inode/address-space\n\t */\n\tinode = new_inode(sb);\n\tif (inode == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unload;\n\t}\n\tinode->i_ino = 0;\n\tinode->i_size = sb->s_bdev->bd_inode->i_size;\n\tinode->i_mapping->a_ops = &jfs_metapage_aops;\n\thlist_add_fake(&inode->i_hash);\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\n\tsbi->direct_inode = inode;\n\n\trc = jfs_mount(sb);\n\tif (rc) {\n\t\tif (!silent)\n\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);\n\t\tgoto out_mount_failed;\n\t}\n\tif (sb->s_flags & MS_RDONLY)\n\t\tsbi->log = NULL;\n\telse {\n\t\trc = jfs_mount_rw(sb, 0);\n\t\tif (rc) {\n\t\t\tif (!silent) {\n\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",\n\t\t\t\t\trc);\n\t\t\t}\n\t\t\tgoto out_no_rw;\n\t\t}\n\t}\n\n\tsb->s_magic = JFS_SUPER_MAGIC;\n\n\tif (sbi->mntflag & JFS_OS2)\n\t\tsb->s_d_op = &jfs_ci_dentry_operations;\n\n\tinode = jfs_iget(sb, ROOT_I);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_no_rw;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto out_no_root;\n\n\t/* logical blocks are represented by 40 bits in pxd_t, etc. */\n\tsb->s_maxbytes = ((u64) sb->s_blocksize) << 40;\n#if BITS_PER_LONG == 32\n\t/*\n\t * Page cache is indexed by long.\n\t * I would use MAX_LFS_FILESIZE, but it's only half as big\n\t */\n\tsb->s_maxbytes = min(((u64) PAGE_CACHE_SIZE << 32) - 1,\n\t\t\t     (u64)sb->s_maxbytes);\n#endif\n\tsb->s_time_gran = 1;\n\treturn 0;\n\nout_no_root:\n\tjfs_err(\"jfs_read_super: get root dentry failed\");\n\nout_no_rw:\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\nout_mount_failed:\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tmake_bad_inode(sbi->direct_inode);\n\tiput(sbi->direct_inode);\n\tsbi->direct_inode = NULL;\nout_unload:\n\tunload_nls(sbi->nls_tab);\nout_kfree:\n\tkfree(sbi);\n\treturn ret;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations jfs_super_operations;",
      "static const struct export_operations jfs_export_operations;",
      "static const struct super_operations jfs_super_operations = {\n\t.alloc_inode\t= jfs_alloc_inode,\n\t.destroy_inode\t= jfs_destroy_inode,\n\t.dirty_inode\t= jfs_dirty_inode,\n\t.write_inode\t= jfs_write_inode,\n\t.evict_inode\t= jfs_evict_inode,\n\t.put_super\t= jfs_put_super,\n\t.sync_fs\t= jfs_sync_fs,\n\t.freeze_fs\t= jfs_freeze,\n\t.unfreeze_fs\t= jfs_unfreeze,\n\t.statfs\t\t= jfs_statfs,\n\t.remount_fs\t= jfs_remount,\n\t.show_options\t= jfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= jfs_quota_read,\n\t.quota_write\t= jfs_quota_write,\n\t.get_dquots\t= jfs_get_dquots,\n#endif\n};",
      "static const struct export_operations jfs_export_operations = {\n\t.fh_to_dentry\t= jfs_fh_to_dentry,\n\t.fh_to_parent\t= jfs_fh_to_parent,\n\t.get_parent\t= jfs_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->nls_tab"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->direct_inode"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "sbi->direct_inode"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "sbi->direct_inode->i_mapping",
            "0"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->direct_inode->i_mapping"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_umount failed with return code %d\"",
            "rc"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_umount",
          "args": [
            "sb"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_umount_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_umount.c",
          "lines": "136-168",
          "snippet": "int jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/fs.h>\n\nint jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_read_super: get root dentry failed\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "((u64) PAGE_CACHE_SIZE << 32) - 1",
            "(u64)sb->s_maxbytes"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_iget",
          "args": [
            "sb",
            "ROOT_I"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "36-78",
          "snippet": "struct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nconst struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_mount_rw",
          "args": [
            "sb",
            "0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_mount_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "239-289",
          "snippet": "int jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_mount",
          "args": [
            "sb"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "81-231",
          "snippet": "int jfs_mount(struct super_block *sb)\n{\n\tint rc = 0;\t\t/* Return code */\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipaimap = NULL;\n\tstruct inode *ipaimap2 = NULL;\n\tstruct inode *ipimap = NULL;\n\tstruct inode *ipbmap = NULL;\n\n\t/*\n\t * read/validate superblock\n\t * (initialize mount inode from the superblock)\n\t */\n\tif ((rc = chkSuper(sb))) {\n\t\tgoto errout20;\n\t}\n\n\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\n\tif (ipaimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\trc = -EIO;\n\t\tgoto errout20;\n\t}\n\tsbi->ipaimap = ipaimap;\n\n\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);\n\n\t/*\n\t * initialize aggregate inode allocation map\n\t */\n\tif ((rc = diMount(ipaimap))) {\n\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);\n\t\tgoto errout21;\n\t}\n\n\t/*\n\t * open aggregate block allocation map\n\t */\n\tipbmap = diReadSpecial(sb, BMAP_I, 0);\n\tif (ipbmap == NULL) {\n\t\trc = -EIO;\n\t\tgoto errout22;\n\t}\n\n\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);\n\n\tsbi->ipbmap = ipbmap;\n\n\t/*\n\t * initialize aggregate block allocation map\n\t */\n\tif ((rc = dbMount(ipbmap))) {\n\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);\n\t\tgoto errout22;\n\t}\n\n\t/*\n\t * open the secondary aggregate inode allocation map\n\t *\n\t * This is a duplicate of the aggregate inode allocation map.\n\t *\n\t * hand craft a vfs in the same fashion as we did to read ipaimap.\n\t * By adding INOSPEREXT (32) to the inode number, we are telling\n\t * diReadSpecial that we are reading from the secondary aggregate\n\t * inode table.  This also creates a unique entry in the inode hash\n\t * table.\n\t */\n\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\n\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\n\t\tif (!ipaimap2) {\n\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\t\trc = -EIO;\n\t\t\tgoto errout35;\n\t\t}\n\t\tsbi->ipaimap2 = ipaimap2;\n\n\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);\n\n\t\t/*\n\t\t * initialize secondary aggregate inode allocation map\n\t\t */\n\t\tif ((rc = diMount(ipaimap2))) {\n\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto errout35;\n\t\t}\n\t} else\n\t\t/* Secondary aggregate inode table is not valid */\n\t\tsbi->ipaimap2 = NULL;\n\n\t/*\n\t *\tmount (the only/single) fileset\n\t */\n\t/*\n\t * open fileset inode allocation map (aka fileset inode)\n\t */\n\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\n\tif (ipimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");\n\t\t/* open fileset secondary inode allocation map */\n\t\trc = -EIO;\n\t\tgoto errout40;\n\t}\n\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);\n\n\t/* map further access of per fileset inodes by the fileset inode */\n\tsbi->ipimap = ipimap;\n\n\t/* initialize fileset inode allocation map */\n\tif ((rc = diMount(ipimap))) {\n\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);\n\t\tgoto errout41;\n\t}\n\n\tgoto out;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout41:\t\t/* close fileset inode allocation map inode */\n\tdiFreeSpecial(ipimap);\n\n      errout40:\t\t/* fileset closed */\n\n\t/* close secondary aggregate inode allocation map */\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 1);\n\t\tdiFreeSpecial(ipaimap2);\n\t}\n\n      errout35:\n\n\t/* close aggregate block allocation map */\n\tdbUnmount(ipbmap, 1);\n\tdiFreeSpecial(ipbmap);\n\n      errout22:\t\t/* close aggregate inode allocation map */\n\n\tdiUnmount(ipaimap, 1);\n\n      errout21:\t\t/* close aggregate inodes */\n\tdiFreeSpecial(ipaimap);\n      errout20:\t\t/* aggregate closed */\n\n      out:\n\n\tif (rc)\n\t\tjfs_err(\"Mount JFS Failure: %d\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint jfs_mount(struct super_block *sb)\n{\n\tint rc = 0;\t\t/* Return code */\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipaimap = NULL;\n\tstruct inode *ipaimap2 = NULL;\n\tstruct inode *ipimap = NULL;\n\tstruct inode *ipbmap = NULL;\n\n\t/*\n\t * read/validate superblock\n\t * (initialize mount inode from the superblock)\n\t */\n\tif ((rc = chkSuper(sb))) {\n\t\tgoto errout20;\n\t}\n\n\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\n\tif (ipaimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\trc = -EIO;\n\t\tgoto errout20;\n\t}\n\tsbi->ipaimap = ipaimap;\n\n\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);\n\n\t/*\n\t * initialize aggregate inode allocation map\n\t */\n\tif ((rc = diMount(ipaimap))) {\n\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);\n\t\tgoto errout21;\n\t}\n\n\t/*\n\t * open aggregate block allocation map\n\t */\n\tipbmap = diReadSpecial(sb, BMAP_I, 0);\n\tif (ipbmap == NULL) {\n\t\trc = -EIO;\n\t\tgoto errout22;\n\t}\n\n\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);\n\n\tsbi->ipbmap = ipbmap;\n\n\t/*\n\t * initialize aggregate block allocation map\n\t */\n\tif ((rc = dbMount(ipbmap))) {\n\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);\n\t\tgoto errout22;\n\t}\n\n\t/*\n\t * open the secondary aggregate inode allocation map\n\t *\n\t * This is a duplicate of the aggregate inode allocation map.\n\t *\n\t * hand craft a vfs in the same fashion as we did to read ipaimap.\n\t * By adding INOSPEREXT (32) to the inode number, we are telling\n\t * diReadSpecial that we are reading from the secondary aggregate\n\t * inode table.  This also creates a unique entry in the inode hash\n\t * table.\n\t */\n\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\n\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\n\t\tif (!ipaimap2) {\n\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\t\trc = -EIO;\n\t\t\tgoto errout35;\n\t\t}\n\t\tsbi->ipaimap2 = ipaimap2;\n\n\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);\n\n\t\t/*\n\t\t * initialize secondary aggregate inode allocation map\n\t\t */\n\t\tif ((rc = diMount(ipaimap2))) {\n\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto errout35;\n\t\t}\n\t} else\n\t\t/* Secondary aggregate inode table is not valid */\n\t\tsbi->ipaimap2 = NULL;\n\n\t/*\n\t *\tmount (the only/single) fileset\n\t */\n\t/*\n\t * open fileset inode allocation map (aka fileset inode)\n\t */\n\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\n\tif (ipimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");\n\t\t/* open fileset secondary inode allocation map */\n\t\trc = -EIO;\n\t\tgoto errout40;\n\t}\n\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);\n\n\t/* map further access of per fileset inodes by the fileset inode */\n\tsbi->ipimap = ipimap;\n\n\t/* initialize fileset inode allocation map */\n\tif ((rc = diMount(ipimap))) {\n\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);\n\t\tgoto errout41;\n\t}\n\n\tgoto out;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout41:\t\t/* close fileset inode allocation map inode */\n\tdiFreeSpecial(ipimap);\n\n      errout40:\t\t/* fileset closed */\n\n\t/* close secondary aggregate inode allocation map */\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 1);\n\t\tdiFreeSpecial(ipaimap2);\n\t}\n\n      errout35:\n\n\t/* close aggregate block allocation map */\n\tdbUnmount(ipbmap, 1);\n\tdiFreeSpecial(ipbmap);\n\n      errout22:\t\t/* close aggregate inode allocation map */\n\n\tdiUnmount(ipaimap, 1);\n\n      errout21:\t\t/* close aggregate inodes */\n\tdiFreeSpecial(ipaimap);\n      errout20:\t\t/* aggregate closed */\n\n      out:\n\n\tif (rc)\n\t\tjfs_err(\"Mount JFS Failure: %d\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_NOFS"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_fake",
          "args": [
            "&inode->i_hash"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "PSIZE"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"resize option for remount only\\n\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "sb",
            "&newLVSize",
            "&flag"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "232-427",
          "snippet": "static int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct jfs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"In jfs_read_super: s_flags=0x%lx\"",
            "sb->s_flags"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const struct super_operations jfs_super_operations;\nstatic const struct export_operations jfs_export_operations;\nstatic const struct super_operations jfs_super_operations = {\n\t.alloc_inode\t= jfs_alloc_inode,\n\t.destroy_inode\t= jfs_destroy_inode,\n\t.dirty_inode\t= jfs_dirty_inode,\n\t.write_inode\t= jfs_write_inode,\n\t.evict_inode\t= jfs_evict_inode,\n\t.put_super\t= jfs_put_super,\n\t.sync_fs\t= jfs_sync_fs,\n\t.freeze_fs\t= jfs_freeze,\n\t.unfreeze_fs\t= jfs_unfreeze,\n\t.statfs\t\t= jfs_statfs,\n\t.remount_fs\t= jfs_remount,\n\t.show_options\t= jfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= jfs_quota_read,\n\t.quota_write\t= jfs_quota_write,\n\t.get_dquots\t= jfs_get_dquots,\n#endif\n};\nstatic const struct export_operations jfs_export_operations = {\n\t.fh_to_dentry\t= jfs_fh_to_dentry,\n\t.fh_to_parent\t= jfs_fh_to_parent,\n\t.get_parent\t= jfs_get_parent,\n};\n\nstatic int jfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct jfs_sb_info *sbi;\n\tstruct inode *inode;\n\tint rc;\n\ts64 newLVSize = 0;\n\tint flag, ret = -EINVAL;\n\n\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);\n\n\tif (!new_valid_dev(sb->s_bdev->bd_dev))\n\t\treturn -EOVERFLOW;\n\n\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsb->s_max_links = JFS_LINK_MAX;\n\tsbi->sb = sb;\n\tsbi->uid = INVALID_UID;\n\tsbi->gid = INVALID_GID;\n\tsbi->umask = -1;\n\n\t/* initialize the mount flag and determine the default error handler */\n\tflag = JFS_ERR_REMOUNT_RO;\n\n\tif (!parse_options((char *) data, sb, &newLVSize, &flag))\n\t\tgoto out_kfree;\n\tsbi->flag = flag;\n\n#ifdef CONFIG_JFS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tif (newLVSize) {\n\t\tpr_err(\"resize option for remount only\\n\");\n\t\tgoto out_kfree;\n\t}\n\n\t/*\n\t * Initialize blocksize to 4K.\n\t */\n\tsb_set_blocksize(sb, PSIZE);\n\n\t/*\n\t * Set method vectors.\n\t */\n\tsb->s_op = &jfs_super_operations;\n\tsb->s_export_op = &jfs_export_operations;\n\tsb->s_xattr = jfs_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * Initialize direct-mapping inode/address-space\n\t */\n\tinode = new_inode(sb);\n\tif (inode == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unload;\n\t}\n\tinode->i_ino = 0;\n\tinode->i_size = sb->s_bdev->bd_inode->i_size;\n\tinode->i_mapping->a_ops = &jfs_metapage_aops;\n\thlist_add_fake(&inode->i_hash);\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\n\tsbi->direct_inode = inode;\n\n\trc = jfs_mount(sb);\n\tif (rc) {\n\t\tif (!silent)\n\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);\n\t\tgoto out_mount_failed;\n\t}\n\tif (sb->s_flags & MS_RDONLY)\n\t\tsbi->log = NULL;\n\telse {\n\t\trc = jfs_mount_rw(sb, 0);\n\t\tif (rc) {\n\t\t\tif (!silent) {\n\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",\n\t\t\t\t\trc);\n\t\t\t}\n\t\t\tgoto out_no_rw;\n\t\t}\n\t}\n\n\tsb->s_magic = JFS_SUPER_MAGIC;\n\n\tif (sbi->mntflag & JFS_OS2)\n\t\tsb->s_d_op = &jfs_ci_dentry_operations;\n\n\tinode = jfs_iget(sb, ROOT_I);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_no_rw;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\tgoto out_no_root;\n\n\t/* logical blocks are represented by 40 bits in pxd_t, etc. */\n\tsb->s_maxbytes = ((u64) sb->s_blocksize) << 40;\n#if BITS_PER_LONG == 32\n\t/*\n\t * Page cache is indexed by long.\n\t * I would use MAX_LFS_FILESIZE, but it's only half as big\n\t */\n\tsb->s_maxbytes = min(((u64) PAGE_CACHE_SIZE << 32) - 1,\n\t\t\t     (u64)sb->s_maxbytes);\n#endif\n\tsb->s_time_gran = 1;\n\treturn 0;\n\nout_no_root:\n\tjfs_err(\"jfs_read_super: get root dentry failed\");\n\nout_no_rw:\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\nout_mount_failed:\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tmake_bad_inode(sbi->direct_inode);\n\tiput(sbi->direct_inode);\n\tsbi->direct_inode = NULL;\nout_unload:\n\tunload_nls(sbi->nls_tab);\nout_kfree:\n\tkfree(sbi);\n\treturn ret;\n}"
  },
  {
    "function_name": "jfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "429-487",
    "snippet": "static int jfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\ts64 newLVSize = 0;\n\tint rc = 0;\n\tint flag = JFS_SBI(sb)->flag;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tif (!parse_options(data, sb, &newLVSize, &flag))\n\t\treturn -EINVAL;\n\n\tif (newLVSize) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tpr_err(\"JFS: resize requires volume to be mounted read-write\\n\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\trc = jfs_extendfs(sb, newLVSize, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\t/*\n\t\t * Invalidate any previously read metadata.  fsck may have\n\t\t * changed the on-disk data since we mounted r/o\n\t\t */\n\t\ttruncate_inode_pages(JFS_SBI(sb)->direct_inode->i_mapping, 0);\n\n\t\tJFS_SBI(sb)->flag = flag;\n\t\tret = jfs_mount_rw(sb, 1);\n\n\t\t/* mark the fs r/w for quota activity */\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\tdquot_resume(sb, -1);\n\t\treturn ret;\n\t}\n\tif ((!(sb->s_flags & MS_RDONLY)) && (*flags & MS_RDONLY)) {\n\t\trc = dquot_suspend(sb, -1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = jfs_umount_rw(sb);\n\t\tJFS_SBI(sb)->flag = flag;\n\t\treturn rc;\n\t}\n\tif ((JFS_SBI(sb)->flag & JFS_NOINTEGRITY) != (flag & JFS_NOINTEGRITY))\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\trc = jfs_umount_rw(sb);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tJFS_SBI(sb)->flag = flag;\n\t\t\tret = jfs_mount_rw(sb, 1);\n\t\t\treturn ret;\n\t\t}\n\tJFS_SBI(sb)->flag = flag;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_mount_rw",
          "args": [
            "sb",
            "1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_mount_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "239-289",
          "snippet": "int jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_umount_rw",
          "args": [
            "sb"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_umount_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_umount.c",
          "lines": "136-168",
          "snippet": "int jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/fs.h>\n\nint jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "sb",
            "-1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "sb",
            "-1"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "JFS_SBI(sb)->direct_inode->i_mapping",
            "0"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_extendfs",
          "args": [
            "sb",
            "newLVSize",
            "0"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_extendfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/resize.c",
          "lines": "62-543",
          "snippet": "int jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipbmap2;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct jfs_log *log = sbi->log;\n\tstruct bmap *bmp = sbi->bmap;\n\ts64 newLogAddress, newFSCKAddress;\n\tint newFSCKSize;\n\ts64 newMapSize = 0, mapSize;\n\ts64 XAddress, XSize, nblocks, xoff, xaddr, t64;\n\ts64 oldLVSize;\n\ts64 newFSSize;\n\ts64 VolumeSize;\n\tint newNpages = 0, nPages, newPage, xlen, t32;\n\tint tid;\n\tint log_formatted = 0;\n\tstruct inode *iplist[1];\n\tstruct jfs_superblock *j_sb, *j_sb2;\n\ts64 old_agsize;\n\tint agsizechanged = 0;\n\tstruct buffer_head *bh, *bh2;\n\n\t/* If the volume hasn't grown, get out now */\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\toldLVSize = addressPXD(&sbi->logpxd) + lengthPXD(&sbi->logpxd);\n\telse\n\t\toldLVSize = addressPXD(&sbi->fsckpxd) +\n\t\t    lengthPXD(&sbi->fsckpxd);\n\n\tif (oldLVSize >= newLVSize) {\n\t\tprintk(KERN_WARNING\n\t\t       \"jfs_extendfs: volume hasn't grown, returning\\n\");\n\t\tgoto out;\n\t}\n\n\tVolumeSize = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (VolumeSize) {\n\t\tif (newLVSize > VolumeSize) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* check the device */\n\t\tbh = sb_bread(sb, newLVSize - 1);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbforget(bh);\n\t}\n\n\t/* Can't extend write-protected drive */\n\n\tif (isReadOnly(ipbmap)) {\n\t\tprintk(KERN_WARNING \"jfs_extendfs: read-only file system\\n\");\n\t\trc = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\treconfigure LV spaces\n\t *\t---------------------\n\t *\n\t * validate new size, or, if not specified, determine new size\n\t */\n\n\t/*\n\t * reconfigure inline log space:\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG)) {\n\t\tif (newLogSize == 0) {\n\t\t\t/*\n\t\t\t * no size specified: default to 1/256 of aggregate\n\t\t\t * size; rounded up to a megabyte boundary;\n\t\t\t */\n\t\t\tnewLogSize = newLVSize >> 8;\n\t\t\tt32 = (1 << (20 - sbi->l2bsize)) - 1;\n\t\t\tnewLogSize = (newLogSize + t32) & ~t32;\n\t\t\tnewLogSize =\n\t\t\t    min(newLogSize, MEGABYTE32 >> sbi->l2bsize);\n\t\t} else {\n\t\t\t/*\n\t\t\t * convert the newLogSize to fs blocks.\n\t\t\t *\n\t\t\t * Since this is given in megabytes, it will always be\n\t\t\t * an even number of pages.\n\t\t\t */\n\t\t\tnewLogSize = (newLogSize * MEGABYTE) >> sbi->l2bsize;\n\t\t}\n\n\t} else\n\t\tnewLogSize = 0;\n\n\tnewLogAddress = newLVSize - newLogSize;\n\n\t/*\n\t * reconfigure fsck work space:\n\t *\n\t * configure it to the end of the logical volume regardless of\n\t * whether file system extends to the end of the aggregate;\n\t * Need enough 4k pages to cover:\n\t *  - 1 bit per block in aggregate rounded up to BPERDMAP boundary\n\t *  - 1 extra page to handle control page and intermediate level pages\n\t *  - 50 extra pages for the chkdsk service log\n\t */\n\tt64 = ((newLVSize - newLogSize + BPERDMAP - 1) >> L2BPERDMAP)\n\t    << L2BPERDMAP;\n\tt32 = DIV_ROUND_UP(t64, BITSPERPAGE) + 1 + 50;\n\tnewFSCKSize = t32 << sbi->l2nbperpage;\n\tnewFSCKAddress = newLogAddress - newFSCKSize;\n\n\t/*\n\t * compute new file system space;\n\t */\n\tnewFSSize = newLVSize - newLogSize - newFSCKSize;\n\n\t/* file system cannot be shrunk */\n\tif (newFSSize < bmp->db_mapsize) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we're expanding enough that the inline log does not overlap\n\t * the old one, we can format the new log before we quiesce the\n\t * filesystem.\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG) && (newLogAddress > oldLVSize)) {\n\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\tgoto out;\n\t\tlog_formatted = 1;\n\t}\n\t/*\n\t *\tquiesce file system\n\t *\n\t * (prepare to move the inline log and to prevent map update)\n\t *\n\t * block any new transactions and wait for completion of\n\t * all wip transactions and flush modified pages s.t.\n\t * on-disk file system is in consistent state and\n\t * log is not required for recovery.\n\t */\n\ttxQuiesce(sb);\n\n\t/* Reset size of direct inode */\n\tsbi->direct_inode->i_size =  sb->s_bdev->bd_inode->i_size;\n\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\t/*\n\t\t * deactivate old inline log\n\t\t */\n\t\tlmLogShutdown(log);\n\n\t\t/*\n\t\t * mark on-disk super block for fs in transition;\n\t\t *\n\t\t * update on-disk superblock for the new space configuration\n\t\t * of inline log space and fsck work space descriptors:\n\t\t * N.B. FS descriptor is NOT updated;\n\t\t *\n\t\t * crash recovery:\n\t\t * logredo(): if FM_EXTENDFS, return to fsck() for cleanup;\n\t\t * fsck(): if FM_EXTENDFS, reformat inline log and fsck\n\t\t * workspace from superblock inline log descriptor and fsck\n\t\t * workspace descriptor;\n\t\t */\n\n\t\t/* read in superblock */\n\t\tif ((rc = readSuper(sb, &bh)))\n\t\t\tgoto error_out;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t\t/* mark extendfs() in progress */\n\t\tj_sb->s_state |= cpu_to_le32(FM_EXTENDFS);\n\t\tj_sb->s_xsize = cpu_to_le64(newFSSize);\n\t\tPXDaddress(&j_sb->s_xfsckpxd, newFSCKAddress);\n\t\tPXDlength(&j_sb->s_xfsckpxd, newFSCKSize);\n\t\tPXDaddress(&j_sb->s_xlogpxd, newLogAddress);\n\t\tPXDlength(&j_sb->s_xlogpxd, newLogSize);\n\n\t\t/* synchronously update superblock */\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\n\t\t/*\n\t\t * format new inline log synchronously;\n\t\t *\n\t\t * crash recovery: if log move in progress,\n\t\t * reformat log and exit success;\n\t\t */\n\t\tif (!log_formatted)\n\t\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\t\tgoto error_out;\n\n\t\t/*\n\t\t * activate new log\n\t\t */\n\t\tlog->base = newLogAddress;\n\t\tlog->size = newLogSize >> (L2LOGPSIZE - sb->s_blocksize_bits);\n\t\tif ((rc = lmLogInit(log)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\textend block allocation map\n\t *\t---------------------------\n\t *\n\t * extendfs() for new extension, retry after crash recovery;\n\t *\n\t * note: both logredo() and fsck() rebuild map from\n\t * the bitmap and configuration parameter from superblock\n\t * (disregarding all other control information in the map);\n\t *\n\t * superblock:\n\t *  s_size: aggregate size in physical blocks;\n\t */\n\t/*\n\t *\tcompute the new block allocation map configuration\n\t *\n\t * map dinode:\n\t *  di_size: map file size in byte;\n\t *  di_nblocks: number of blocks allocated for map file;\n\t *  di_mapsize: number of blocks in aggregate (covered by map);\n\t * map control page:\n\t *  db_mapsize: number of blocks in aggregate (covered by map);\n\t */\n\tnewMapSize = newFSSize;\n\t/* number of data pages of new bmap file:\n\t * roundup new size to full dmap page boundary and\n\t * add 1 extra dmap page for next extendfs()\n\t */\n\tt64 = (newMapSize - 1) + BPERDMAP;\n\tnewNpages = BLKTODMAPN(t64) + 1;\n\n\t/*\n\t *\textend map from current map (WITHOUT growing mapfile)\n\t *\n\t * map new extension with unmapped part of the last partial\n\t * dmap page, if applicable, and extra page(s) allocated\n\t * at end of bmap by mkfs() or previous extendfs();\n\t */\n      extendBmap:\n\t/* compute number of blocks requested to extend */\n\tmapSize = bmp->db_mapsize;\n\tXAddress = mapSize;\t/* eXtension Address */\n\tXSize = newMapSize - mapSize;\t/* eXtension Size */\n\told_agsize = bmp->db_agsize;\t/* We need to know if this changes */\n\n\t/* compute number of blocks that can be extended by current mapfile */\n\tt64 = dbMapFileSizeToMapSize(ipbmap);\n\tif (mapSize > t64) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: mapSize (0x%Lx) > t64 (0x%Lx)\\n\",\n\t\t       (long long) mapSize, (long long) t64);\n\t\trc = -EIO;\n\t\tgoto error_out;\n\t}\n\tnblocks = min(t64 - mapSize, XSize);\n\n\t/*\n\t * update map pages for new extension:\n\t *\n\t * update/init dmap and bubble up the control hierarchy\n\t * incrementally fold up dmaps into upper levels;\n\t * update bmap control page;\n\t */\n\tif ((rc = dbExtendFS(ipbmap, XAddress, nblocks)))\n\t\tgoto error_out;\n\n\tagsizechanged |= (bmp->db_agsize != old_agsize);\n\n\t/*\n\t * the map now has extended to cover additional nblocks:\n\t * dn_mapsize = oldMapsize + nblocks;\n\t */\n\t/* ipbmap->i_mapsize += nblocks; */\n\tXSize -= nblocks;\n\n\t/*\n\t *\tgrow map file to cover remaining extension\n\t *\tand/or one extra dmap page for next extendfs();\n\t *\n\t * allocate new map pages and its backing blocks, and\n\t * update map file xtree\n\t */\n\t/* compute number of data pages of current bmap file */\n\tnPages = ipbmap->i_size >> L2PSIZE;\n\n\t/* need to grow map file ? */\n\tif (nPages == newNpages)\n\t\tgoto finalizeBmap;\n\n\t/*\n\t * grow bmap file for the new map pages required:\n\t *\n\t * allocate growth at the start of newly extended region;\n\t * bmap file only grows sequentially, i.e., both data pages\n\t * and possibly xtree index pages may grow in append mode,\n\t * s.t. logredo() can reconstruct pre-extension state\n\t * by washing away bmap file of pages outside s_size boundary;\n\t */\n\t/*\n\t * journal map file growth as if a regular file growth:\n\t * (note: bmap is created with di_mode = IFJOURNAL|IFREG);\n\t *\n\t * journaling of bmap file growth is not required since\n\t * logredo() do/can not use log records of bmap file growth\n\t * but it provides careful write semantics, pmap update, etc.;\n\t */\n\t/* synchronous write of data pages: bmap data pages are\n\t * cached in meta-data cache, and not written out\n\t * by txCommit();\n\t */\n\tfilemap_fdatawait(ipbmap->i_mapping);\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\tdiWriteSpecial(ipbmap, 0);\n\n\tnewPage = nPages;\t/* first new page number */\n\txoff = newPage << sbi->l2nbperpage;\n\txlen = (newNpages - nPages) << sbi->l2nbperpage;\n\txlen = min(xlen, (int) nblocks) & ~(sbi->nbperpage - 1);\n\txaddr = XAddress;\n\n\ttid = txBegin(sb, COMMIT_FORCE);\n\n\tif ((rc = xtAppend(tid, ipbmap, 0, xoff, nblocks, &xlen, &xaddr, 0))) {\n\t\ttxEnd(tid);\n\t\tgoto error_out;\n\t}\n\t/* update bmap file size */\n\tipbmap->i_size += xlen << sbi->l2bsize;\n\tinode_add_bytes(ipbmap, xlen << sbi->l2bsize);\n\n\tiplist[0] = ipbmap;\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\n\tif (rc)\n\t\tgoto error_out;\n\n\t/*\n\t * map file has been grown now to cover extension to further out;\n\t * di_size = new map file size;\n\t *\n\t * if huge extension, the previous extension based on previous\n\t * map file size may not have been sufficient to cover whole extension\n\t * (it could have been used up for new map pages),\n\t * but the newly grown map file now covers lot bigger new free space\n\t * available for further extension of map;\n\t */\n\t/* any more blocks to extend ? */\n\tif (XSize)\n\t\tgoto extendBmap;\n\n      finalizeBmap:\n\t/* finalize bmap */\n\tdbFinalizeBmap(ipbmap);\n\n\t/*\n\t *\tupdate inode allocation map\n\t *\t---------------------------\n\t *\n\t * move iag lists from old to new iag;\n\t * agstart field is not updated for logredo() to reconstruct\n\t * iag lists if system crash occurs.\n\t * (computation of ag number from agstart based on agsize\n\t * will correctly identify the new ag);\n\t */\n\t/* if new AG size the same as old AG size, done! */\n\tif (agsizechanged) {\n\t\tif ((rc = diExtendFS(ipimap, ipbmap)))\n\t\t\tgoto error_out;\n\n\t\t/* finalize imap */\n\t\tif ((rc = diSync(ipimap)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\tfinalize\n\t *\t--------\n\t *\n\t * extension is committed when on-disk super block is\n\t * updated with new descriptors: logredo will recover\n\t * crash before it to pre-extension state;\n\t */\n\n\t/* sync log to skip log replay of bmap file growth transaction; */\n\t/* lmLogSync(log, 1); */\n\n\t/*\n\t * synchronous write bmap global control page;\n\t * for crash before completion of write\n\t * logredo() will recover to pre-extendfs state;\n\t * for crash after completion of write,\n\t * logredo() will recover post-extendfs state;\n\t */\n\tif ((rc = dbSync(ipbmap)))\n\t\tgoto error_out;\n\n\t/*\n\t * copy primary bmap inode to secondary bmap inode\n\t */\n\n\tipbmap2 = diReadSpecial(sb, BMAP_I, 1);\n\tif (ipbmap2 == NULL) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: diReadSpecial(bmap) failed\\n\");\n\t\tgoto error_out;\n\t}\n\tmemcpy(&JFS_IP(ipbmap2)->i_xtroot, &JFS_IP(ipbmap)->i_xtroot, 288);\n\tipbmap2->i_size = ipbmap->i_size;\n\tipbmap2->i_blocks = ipbmap->i_blocks;\n\n\tdiWriteSpecial(ipbmap2, 1);\n\tdiFreeSpecial(ipbmap2);\n\n\t/*\n\t *\tupdate superblock\n\t */\n\tif ((rc = readSuper(sb, &bh)))\n\t\tgoto error_out;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/* mark extendfs() completion */\n\tj_sb->s_state &= cpu_to_le32(~FM_EXTENDFS);\n\tj_sb->s_size = cpu_to_le64(bmp->db_mapsize <<\n\t\t\t\t   le16_to_cpu(j_sb->s_l2bfactor));\n\tj_sb->s_agsize = cpu_to_le32(bmp->db_agsize);\n\n\t/* update inline log space descriptor */\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\tPXDaddress(&(j_sb->s_logpxd), newLogAddress);\n\t\tPXDlength(&(j_sb->s_logpxd), newLogSize);\n\t}\n\n\t/* record log's mount serial number */\n\tj_sb->s_logserial = cpu_to_le32(log->serial);\n\n\t/* update fsck work space descriptor */\n\tPXDaddress(&(j_sb->s_fsckpxd), newFSCKAddress);\n\tPXDlength(&(j_sb->s_fsckpxd), newFSCKSize);\n\tj_sb->s_fscklog = 1;\n\t/* sb->s_fsckloglen remains the same */\n\n\t/* Update secondary superblock */\n\tbh2 = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (bh2) {\n\t\tj_sb2 = (struct jfs_superblock *)bh2->b_data;\n\t\tmemcpy(j_sb2, j_sb, sizeof (struct jfs_superblock));\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh2);\n\t\tbrelse(bh2);\n\t}\n\n\t/* write primary superblock */\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\tgoto resume;\n\n      error_out:\n\tjfs_error(sb, \"\\n\");\n\n      resume:\n\t/*\n\t *\tresume file system transactions\n\t */\n\ttxResume(sb);\n\n      out:\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MEGABYTE32\t(MEGABYTE << 5)",
            "#define MEGABYTE\t(1 << L2MEGABYTE)",
            "#define BITSPERPAGE\t(PSIZE << 3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\n#define MEGABYTE32\t(MEGABYTE << 5)\n#define MEGABYTE\t(1 << L2MEGABYTE)\n#define BITSPERPAGE\t(PSIZE << 3)\n\nint jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipbmap2;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct jfs_log *log = sbi->log;\n\tstruct bmap *bmp = sbi->bmap;\n\ts64 newLogAddress, newFSCKAddress;\n\tint newFSCKSize;\n\ts64 newMapSize = 0, mapSize;\n\ts64 XAddress, XSize, nblocks, xoff, xaddr, t64;\n\ts64 oldLVSize;\n\ts64 newFSSize;\n\ts64 VolumeSize;\n\tint newNpages = 0, nPages, newPage, xlen, t32;\n\tint tid;\n\tint log_formatted = 0;\n\tstruct inode *iplist[1];\n\tstruct jfs_superblock *j_sb, *j_sb2;\n\ts64 old_agsize;\n\tint agsizechanged = 0;\n\tstruct buffer_head *bh, *bh2;\n\n\t/* If the volume hasn't grown, get out now */\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\toldLVSize = addressPXD(&sbi->logpxd) + lengthPXD(&sbi->logpxd);\n\telse\n\t\toldLVSize = addressPXD(&sbi->fsckpxd) +\n\t\t    lengthPXD(&sbi->fsckpxd);\n\n\tif (oldLVSize >= newLVSize) {\n\t\tprintk(KERN_WARNING\n\t\t       \"jfs_extendfs: volume hasn't grown, returning\\n\");\n\t\tgoto out;\n\t}\n\n\tVolumeSize = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (VolumeSize) {\n\t\tif (newLVSize > VolumeSize) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* check the device */\n\t\tbh = sb_bread(sb, newLVSize - 1);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_WARNING \"jfs_extendfs: invalid size\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbforget(bh);\n\t}\n\n\t/* Can't extend write-protected drive */\n\n\tif (isReadOnly(ipbmap)) {\n\t\tprintk(KERN_WARNING \"jfs_extendfs: read-only file system\\n\");\n\t\trc = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\treconfigure LV spaces\n\t *\t---------------------\n\t *\n\t * validate new size, or, if not specified, determine new size\n\t */\n\n\t/*\n\t * reconfigure inline log space:\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG)) {\n\t\tif (newLogSize == 0) {\n\t\t\t/*\n\t\t\t * no size specified: default to 1/256 of aggregate\n\t\t\t * size; rounded up to a megabyte boundary;\n\t\t\t */\n\t\t\tnewLogSize = newLVSize >> 8;\n\t\t\tt32 = (1 << (20 - sbi->l2bsize)) - 1;\n\t\t\tnewLogSize = (newLogSize + t32) & ~t32;\n\t\t\tnewLogSize =\n\t\t\t    min(newLogSize, MEGABYTE32 >> sbi->l2bsize);\n\t\t} else {\n\t\t\t/*\n\t\t\t * convert the newLogSize to fs blocks.\n\t\t\t *\n\t\t\t * Since this is given in megabytes, it will always be\n\t\t\t * an even number of pages.\n\t\t\t */\n\t\t\tnewLogSize = (newLogSize * MEGABYTE) >> sbi->l2bsize;\n\t\t}\n\n\t} else\n\t\tnewLogSize = 0;\n\n\tnewLogAddress = newLVSize - newLogSize;\n\n\t/*\n\t * reconfigure fsck work space:\n\t *\n\t * configure it to the end of the logical volume regardless of\n\t * whether file system extends to the end of the aggregate;\n\t * Need enough 4k pages to cover:\n\t *  - 1 bit per block in aggregate rounded up to BPERDMAP boundary\n\t *  - 1 extra page to handle control page and intermediate level pages\n\t *  - 50 extra pages for the chkdsk service log\n\t */\n\tt64 = ((newLVSize - newLogSize + BPERDMAP - 1) >> L2BPERDMAP)\n\t    << L2BPERDMAP;\n\tt32 = DIV_ROUND_UP(t64, BITSPERPAGE) + 1 + 50;\n\tnewFSCKSize = t32 << sbi->l2nbperpage;\n\tnewFSCKAddress = newLogAddress - newFSCKSize;\n\n\t/*\n\t * compute new file system space;\n\t */\n\tnewFSSize = newLVSize - newLogSize - newFSCKSize;\n\n\t/* file system cannot be shrunk */\n\tif (newFSSize < bmp->db_mapsize) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we're expanding enough that the inline log does not overlap\n\t * the old one, we can format the new log before we quiesce the\n\t * filesystem.\n\t */\n\tif ((sbi->mntflag & JFS_INLINELOG) && (newLogAddress > oldLVSize)) {\n\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\tgoto out;\n\t\tlog_formatted = 1;\n\t}\n\t/*\n\t *\tquiesce file system\n\t *\n\t * (prepare to move the inline log and to prevent map update)\n\t *\n\t * block any new transactions and wait for completion of\n\t * all wip transactions and flush modified pages s.t.\n\t * on-disk file system is in consistent state and\n\t * log is not required for recovery.\n\t */\n\ttxQuiesce(sb);\n\n\t/* Reset size of direct inode */\n\tsbi->direct_inode->i_size =  sb->s_bdev->bd_inode->i_size;\n\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\t/*\n\t\t * deactivate old inline log\n\t\t */\n\t\tlmLogShutdown(log);\n\n\t\t/*\n\t\t * mark on-disk super block for fs in transition;\n\t\t *\n\t\t * update on-disk superblock for the new space configuration\n\t\t * of inline log space and fsck work space descriptors:\n\t\t * N.B. FS descriptor is NOT updated;\n\t\t *\n\t\t * crash recovery:\n\t\t * logredo(): if FM_EXTENDFS, return to fsck() for cleanup;\n\t\t * fsck(): if FM_EXTENDFS, reformat inline log and fsck\n\t\t * workspace from superblock inline log descriptor and fsck\n\t\t * workspace descriptor;\n\t\t */\n\n\t\t/* read in superblock */\n\t\tif ((rc = readSuper(sb, &bh)))\n\t\t\tgoto error_out;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t\t/* mark extendfs() in progress */\n\t\tj_sb->s_state |= cpu_to_le32(FM_EXTENDFS);\n\t\tj_sb->s_xsize = cpu_to_le64(newFSSize);\n\t\tPXDaddress(&j_sb->s_xfsckpxd, newFSCKAddress);\n\t\tPXDlength(&j_sb->s_xfsckpxd, newFSCKSize);\n\t\tPXDaddress(&j_sb->s_xlogpxd, newLogAddress);\n\t\tPXDlength(&j_sb->s_xlogpxd, newLogSize);\n\n\t\t/* synchronously update superblock */\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\n\t\t/*\n\t\t * format new inline log synchronously;\n\t\t *\n\t\t * crash recovery: if log move in progress,\n\t\t * reformat log and exit success;\n\t\t */\n\t\tif (!log_formatted)\n\t\t\tif ((rc = lmLogFormat(log, newLogAddress, newLogSize)))\n\t\t\t\tgoto error_out;\n\n\t\t/*\n\t\t * activate new log\n\t\t */\n\t\tlog->base = newLogAddress;\n\t\tlog->size = newLogSize >> (L2LOGPSIZE - sb->s_blocksize_bits);\n\t\tif ((rc = lmLogInit(log)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\textend block allocation map\n\t *\t---------------------------\n\t *\n\t * extendfs() for new extension, retry after crash recovery;\n\t *\n\t * note: both logredo() and fsck() rebuild map from\n\t * the bitmap and configuration parameter from superblock\n\t * (disregarding all other control information in the map);\n\t *\n\t * superblock:\n\t *  s_size: aggregate size in physical blocks;\n\t */\n\t/*\n\t *\tcompute the new block allocation map configuration\n\t *\n\t * map dinode:\n\t *  di_size: map file size in byte;\n\t *  di_nblocks: number of blocks allocated for map file;\n\t *  di_mapsize: number of blocks in aggregate (covered by map);\n\t * map control page:\n\t *  db_mapsize: number of blocks in aggregate (covered by map);\n\t */\n\tnewMapSize = newFSSize;\n\t/* number of data pages of new bmap file:\n\t * roundup new size to full dmap page boundary and\n\t * add 1 extra dmap page for next extendfs()\n\t */\n\tt64 = (newMapSize - 1) + BPERDMAP;\n\tnewNpages = BLKTODMAPN(t64) + 1;\n\n\t/*\n\t *\textend map from current map (WITHOUT growing mapfile)\n\t *\n\t * map new extension with unmapped part of the last partial\n\t * dmap page, if applicable, and extra page(s) allocated\n\t * at end of bmap by mkfs() or previous extendfs();\n\t */\n      extendBmap:\n\t/* compute number of blocks requested to extend */\n\tmapSize = bmp->db_mapsize;\n\tXAddress = mapSize;\t/* eXtension Address */\n\tXSize = newMapSize - mapSize;\t/* eXtension Size */\n\told_agsize = bmp->db_agsize;\t/* We need to know if this changes */\n\n\t/* compute number of blocks that can be extended by current mapfile */\n\tt64 = dbMapFileSizeToMapSize(ipbmap);\n\tif (mapSize > t64) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: mapSize (0x%Lx) > t64 (0x%Lx)\\n\",\n\t\t       (long long) mapSize, (long long) t64);\n\t\trc = -EIO;\n\t\tgoto error_out;\n\t}\n\tnblocks = min(t64 - mapSize, XSize);\n\n\t/*\n\t * update map pages for new extension:\n\t *\n\t * update/init dmap and bubble up the control hierarchy\n\t * incrementally fold up dmaps into upper levels;\n\t * update bmap control page;\n\t */\n\tif ((rc = dbExtendFS(ipbmap, XAddress, nblocks)))\n\t\tgoto error_out;\n\n\tagsizechanged |= (bmp->db_agsize != old_agsize);\n\n\t/*\n\t * the map now has extended to cover additional nblocks:\n\t * dn_mapsize = oldMapsize + nblocks;\n\t */\n\t/* ipbmap->i_mapsize += nblocks; */\n\tXSize -= nblocks;\n\n\t/*\n\t *\tgrow map file to cover remaining extension\n\t *\tand/or one extra dmap page for next extendfs();\n\t *\n\t * allocate new map pages and its backing blocks, and\n\t * update map file xtree\n\t */\n\t/* compute number of data pages of current bmap file */\n\tnPages = ipbmap->i_size >> L2PSIZE;\n\n\t/* need to grow map file ? */\n\tif (nPages == newNpages)\n\t\tgoto finalizeBmap;\n\n\t/*\n\t * grow bmap file for the new map pages required:\n\t *\n\t * allocate growth at the start of newly extended region;\n\t * bmap file only grows sequentially, i.e., both data pages\n\t * and possibly xtree index pages may grow in append mode,\n\t * s.t. logredo() can reconstruct pre-extension state\n\t * by washing away bmap file of pages outside s_size boundary;\n\t */\n\t/*\n\t * journal map file growth as if a regular file growth:\n\t * (note: bmap is created with di_mode = IFJOURNAL|IFREG);\n\t *\n\t * journaling of bmap file growth is not required since\n\t * logredo() do/can not use log records of bmap file growth\n\t * but it provides careful write semantics, pmap update, etc.;\n\t */\n\t/* synchronous write of data pages: bmap data pages are\n\t * cached in meta-data cache, and not written out\n\t * by txCommit();\n\t */\n\tfilemap_fdatawait(ipbmap->i_mapping);\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\tdiWriteSpecial(ipbmap, 0);\n\n\tnewPage = nPages;\t/* first new page number */\n\txoff = newPage << sbi->l2nbperpage;\n\txlen = (newNpages - nPages) << sbi->l2nbperpage;\n\txlen = min(xlen, (int) nblocks) & ~(sbi->nbperpage - 1);\n\txaddr = XAddress;\n\n\ttid = txBegin(sb, COMMIT_FORCE);\n\n\tif ((rc = xtAppend(tid, ipbmap, 0, xoff, nblocks, &xlen, &xaddr, 0))) {\n\t\ttxEnd(tid);\n\t\tgoto error_out;\n\t}\n\t/* update bmap file size */\n\tipbmap->i_size += xlen << sbi->l2bsize;\n\tinode_add_bytes(ipbmap, xlen << sbi->l2bsize);\n\n\tiplist[0] = ipbmap;\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\n\tif (rc)\n\t\tgoto error_out;\n\n\t/*\n\t * map file has been grown now to cover extension to further out;\n\t * di_size = new map file size;\n\t *\n\t * if huge extension, the previous extension based on previous\n\t * map file size may not have been sufficient to cover whole extension\n\t * (it could have been used up for new map pages),\n\t * but the newly grown map file now covers lot bigger new free space\n\t * available for further extension of map;\n\t */\n\t/* any more blocks to extend ? */\n\tif (XSize)\n\t\tgoto extendBmap;\n\n      finalizeBmap:\n\t/* finalize bmap */\n\tdbFinalizeBmap(ipbmap);\n\n\t/*\n\t *\tupdate inode allocation map\n\t *\t---------------------------\n\t *\n\t * move iag lists from old to new iag;\n\t * agstart field is not updated for logredo() to reconstruct\n\t * iag lists if system crash occurs.\n\t * (computation of ag number from agstart based on agsize\n\t * will correctly identify the new ag);\n\t */\n\t/* if new AG size the same as old AG size, done! */\n\tif (agsizechanged) {\n\t\tif ((rc = diExtendFS(ipimap, ipbmap)))\n\t\t\tgoto error_out;\n\n\t\t/* finalize imap */\n\t\tif ((rc = diSync(ipimap)))\n\t\t\tgoto error_out;\n\t}\n\n\t/*\n\t *\tfinalize\n\t *\t--------\n\t *\n\t * extension is committed when on-disk super block is\n\t * updated with new descriptors: logredo will recover\n\t * crash before it to pre-extension state;\n\t */\n\n\t/* sync log to skip log replay of bmap file growth transaction; */\n\t/* lmLogSync(log, 1); */\n\n\t/*\n\t * synchronous write bmap global control page;\n\t * for crash before completion of write\n\t * logredo() will recover to pre-extendfs state;\n\t * for crash after completion of write,\n\t * logredo() will recover post-extendfs state;\n\t */\n\tif ((rc = dbSync(ipbmap)))\n\t\tgoto error_out;\n\n\t/*\n\t * copy primary bmap inode to secondary bmap inode\n\t */\n\n\tipbmap2 = diReadSpecial(sb, BMAP_I, 1);\n\tif (ipbmap2 == NULL) {\n\t\tprintk(KERN_ERR \"jfs_extendfs: diReadSpecial(bmap) failed\\n\");\n\t\tgoto error_out;\n\t}\n\tmemcpy(&JFS_IP(ipbmap2)->i_xtroot, &JFS_IP(ipbmap)->i_xtroot, 288);\n\tipbmap2->i_size = ipbmap->i_size;\n\tipbmap2->i_blocks = ipbmap->i_blocks;\n\n\tdiWriteSpecial(ipbmap2, 1);\n\tdiFreeSpecial(ipbmap2);\n\n\t/*\n\t *\tupdate superblock\n\t */\n\tif ((rc = readSuper(sb, &bh)))\n\t\tgoto error_out;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/* mark extendfs() completion */\n\tj_sb->s_state &= cpu_to_le32(~FM_EXTENDFS);\n\tj_sb->s_size = cpu_to_le64(bmp->db_mapsize <<\n\t\t\t\t   le16_to_cpu(j_sb->s_l2bfactor));\n\tj_sb->s_agsize = cpu_to_le32(bmp->db_agsize);\n\n\t/* update inline log space descriptor */\n\tif (sbi->mntflag & JFS_INLINELOG) {\n\t\tPXDaddress(&(j_sb->s_logpxd), newLogAddress);\n\t\tPXDlength(&(j_sb->s_logpxd), newLogSize);\n\t}\n\n\t/* record log's mount serial number */\n\tj_sb->s_logserial = cpu_to_le32(log->serial);\n\n\t/* update fsck work space descriptor */\n\tPXDaddress(&(j_sb->s_fsckpxd), newFSCKAddress);\n\tPXDlength(&(j_sb->s_fsckpxd), newFSCKSize);\n\tj_sb->s_fscklog = 1;\n\t/* sb->s_fsckloglen remains the same */\n\n\t/* Update secondary superblock */\n\tbh2 = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (bh2) {\n\t\tj_sb2 = (struct jfs_superblock *)bh2->b_data;\n\t\tmemcpy(j_sb2, j_sb, sizeof (struct jfs_superblock));\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh2);\n\t\tbrelse(bh2);\n\t}\n\n\t/* write primary superblock */\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\tgoto resume;\n\n      error_out:\n\tjfs_error(sb, \"\\n\");\n\n      resume:\n\t/*\n\t *\tresume file system transactions\n\t */\n\ttxResume(sb);\n\n      out:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: resize requires volume to be mounted read-write\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb",
            "&newLVSize",
            "&flag"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "232-427",
          "snippet": "static int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\ts64 newLVSize = 0;\n\tint rc = 0;\n\tint flag = JFS_SBI(sb)->flag;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tif (!parse_options(data, sb, &newLVSize, &flag))\n\t\treturn -EINVAL;\n\n\tif (newLVSize) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tpr_err(\"JFS: resize requires volume to be mounted read-write\\n\");\n\t\t\treturn -EROFS;\n\t\t}\n\t\trc = jfs_extendfs(sb, newLVSize, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\t/*\n\t\t * Invalidate any previously read metadata.  fsck may have\n\t\t * changed the on-disk data since we mounted r/o\n\t\t */\n\t\ttruncate_inode_pages(JFS_SBI(sb)->direct_inode->i_mapping, 0);\n\n\t\tJFS_SBI(sb)->flag = flag;\n\t\tret = jfs_mount_rw(sb, 1);\n\n\t\t/* mark the fs r/w for quota activity */\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\tdquot_resume(sb, -1);\n\t\treturn ret;\n\t}\n\tif ((!(sb->s_flags & MS_RDONLY)) && (*flags & MS_RDONLY)) {\n\t\trc = dquot_suspend(sb, -1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = jfs_umount_rw(sb);\n\t\tJFS_SBI(sb)->flag = flag;\n\t\treturn rc;\n\t}\n\tif ((JFS_SBI(sb)->flag & JFS_NOINTEGRITY) != (flag & JFS_NOINTEGRITY))\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\trc = jfs_umount_rw(sb);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tJFS_SBI(sb)->flag = flag;\n\t\t\tret = jfs_mount_rw(sb, 1);\n\t\t\treturn ret;\n\t\t}\n\tJFS_SBI(sb)->flag = flag;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "232-427",
    "snippet": "static int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "nls_map"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\"",
            "p"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: discard option not supported on device\\n\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "minblks_trim",
            "0",
            "&sbi->minblks_trim"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: discard option not supported on device\\n\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: Invalid value of umask\\n\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "umask",
            "8",
            "&sbi->umask"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "sbi->gid"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "val"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "gid",
            "0",
            "&val"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "sbi->uid"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "val"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "uid",
            "0",
            "&val"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: quota operations not supported\\n\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: %s is an invalid error handler\\n\"",
            "errors"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "errors",
            "\"panic\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: Cannot determine volume size\\n\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "resize",
            "0",
            "newLVSize"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"JFS: charset not found\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_integrity, \"integrity\"},\n\t{Opt_nointegrity, \"nointegrity\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_resize, \"resize=%u\"},\n\t{Opt_resize_nosize, \"resize\"},\n\t{Opt_errors, \"errors=%s\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%u\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_discard_minblk, \"discard=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, s64 *newLVSize,\n\t\t\t int *flag)\n{\n\tvoid *nls_map = (void *)-1;\t/* -1: no change;  NULL: none */\n\tchar *p;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\t*newLVSize = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_integrity:\n\t\t\t*flag &= ~JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_nointegrity:\n\t\t\t*flag |= JFS_NOINTEGRITY;\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\t/* Silently ignore the quota options */\n\t\t\t/* Don't do anything ;-) */\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (nls_map && nls_map != (void *) -1)\n\t\t\t\tunload_nls(nls_map);\n\t\t\tif (!strcmp(args[0].from, \"none\"))\n\t\t\t\tnls_map = NULL;\n\t\t\telse {\n\t\t\t\tnls_map = load_nls(args[0].from);\n\t\t\t\tif (!nls_map) {\n\t\t\t\t\tpr_err(\"JFS: charset not found\\n\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t{\n\t\t\tchar *resize = args[0].from;\n\t\t\tint rc = kstrtoll(resize, 0, newLVSize);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_resize_nosize:\n\t\t{\n\t\t\t*newLVSize = sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tif (*newLVSize == 0)\n\t\t\t\tpr_err(\"JFS: Cannot determine volume size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_errors:\n\t\t{\n\t\t\tchar *errors = args[0].from;\n\t\t\tif (!errors || !*errors)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!strcmp(errors, \"continue\")) {\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_CONTINUE;\n\t\t\t} else if (!strcmp(errors, \"remount-ro\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_PANIC;\n\t\t\t\t*flag |= JFS_ERR_REMOUNT_RO;\n\t\t\t} else if (!strcmp(errors, \"panic\")) {\n\t\t\t\t*flag &= ~JFS_ERR_CONTINUE;\n\t\t\t\t*flag &= ~JFS_ERR_REMOUNT_RO;\n\t\t\t\t*flag |= JFS_ERR_PANIC;\n\t\t\t} else {\n\t\t\t\tpr_err(\"JFS: %s is an invalid error handler\\n\",\n\t\t\t\t       errors);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\t*flag |= JFS_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\t*flag |= JFS_GRPQUOTA;\n\t\t\tbreak;\n#else\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\tcase Opt_quota:\n\t\t\tpr_err(\"JFS: quota operations not supported\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uid:\n\t\t{\n\t\t\tchar *uid = args[0].from;\n\t\t\tuid_t val;\n\t\t\tint rc = kstrtouint(uid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->uid = make_kuid(current_user_ns(), val);\n\t\t\tif (!uid_valid(sbi->uid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_gid:\n\t\t{\n\t\t\tchar *gid = args[0].from;\n\t\t\tgid_t val;\n\t\t\tint rc = kstrtouint(gid, 0, &val);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tsbi->gid = make_kgid(current_user_ns(), val);\n\t\t\tif (!gid_valid(sbi->gid))\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_umask:\n\t\t{\n\t\t\tchar *umask = args[0].from;\n\t\t\tint rc = kstrtouint(umask, 8, &sbi->umask);\n\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t\tif (sbi->umask & ~0777) {\n\t\t\t\tpr_err(\"JFS: Invalid value of umask\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_discard:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\t/* if set to 1, even copying files will cause\n\t\t\t * trimming :O\n\t\t\t * -> user has more control over the online trimming\n\t\t\t */\n\t\t\tsbi->minblks_trim = 64;\n\t\t\tif (blk_queue_discard(q))\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\telse\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Opt_nodiscard:\n\t\t\t*flag &= ~JFS_DISCARD;\n\t\t\tbreak;\n\n\t\tcase Opt_discard_minblk:\n\t\t{\n\t\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\t\tchar *minblks_trim = args[0].from;\n\t\t\tint rc;\n\t\t\tif (blk_queue_discard(q)) {\n\t\t\t\t*flag |= JFS_DISCARD;\n\t\t\t\trc = kstrtouint(minblks_trim, 0,\n\t\t\t\t\t\t&sbi->minblks_trim);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else\n\t\t\t\tpr_err(\"JFS: discard option not supported on device\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"jfs: Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t       p);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (nls_map != (void *) -1) {\n\t\t/* Discard old (if remount) */\n\t\tunload_nls(sbi->nls_tab);\n\t\tsbi->nls_tab = nls_map;\n\t}\n\treturn 1;\n\ncleanup:\n\tif (nls_map && nls_map != (void *) -1)\n\t\tunload_nls(nls_map);\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "184-203",
    "snippet": "static void jfs_put_super(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\tjfs_info(\"In jfs_put_super\");\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\n\n\tunload_nls(sbi->nls_tab);\n\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tiput(sbi->direct_inode);\n\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->direct_inode"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "sbi->direct_inode->i_mapping",
            "0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->nls_tab"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_umount failed with return code %d\"",
            "rc"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_umount",
          "args": [
            "sb"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_umount_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_umount.c",
          "lines": "136-168",
          "snippet": "int jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/fs.h>\n\nint jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "sb",
            "-1",
            "DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"In jfs_put_super\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void jfs_put_super(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\tjfs_info(\"In jfs_put_super\");\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\trc = jfs_umount(sb);\n\tif (rc)\n\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);\n\n\tunload_nls(sbi->nls_tab);\n\n\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);\n\tiput(sbi->direct_inode);\n\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "jfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "149-182",
    "snippet": "static int jfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(dentry->d_sb);\n\ts64 maxinodes;\n\tstruct inomap *imap = JFS_IP(sbi->ipimap)->i_imap;\n\n\tjfs_info(\"In jfs_statfs\");\n\tbuf->f_type = JFS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->bsize;\n\tbuf->f_blocks = sbi->bmap->db_mapsize;\n\tbuf->f_bfree = sbi->bmap->db_nfree;\n\tbuf->f_bavail = sbi->bmap->db_nfree;\n\t/*\n\t * If we really return the number of allocated & free inodes, some\n\t * applications will fail because they won't see enough free inodes.\n\t * We'll try to calculate some guess as to how many inodes we can\n\t * really allocate\n\t *\n\t * buf->f_files = atomic_read(&imap->im_numinos);\n\t * buf->f_ffree = atomic_read(&imap->im_numfree);\n\t */\n\tmaxinodes = min((s64) atomic_read(&imap->im_numinos) +\n\t\t\t((sbi->bmap->db_nfree >> imap->im_l2nbperiext)\n\t\t\t << L2INOSPEREXT), (s64) 0xffffffffLL);\n\tbuf->f_files = maxinodes;\n\tbuf->f_ffree = maxinodes - (atomic_read(&imap->im_numinos) -\n\t\t\t\t    atomic_read(&imap->im_numfree));\n\tbuf->f_fsid.val[0] = (u32)crc32_le(0, sbi->uuid, sizeof(sbi->uuid)/2);\n\tbuf->f_fsid.val[1] = (u32)crc32_le(0, sbi->uuid + sizeof(sbi->uuid)/2,\n\t\t\t\t\tsizeof(sbi->uuid)/2);\n\n\tbuf->f_namelen = JFS_NAME_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "sbi->uuid + sizeof(sbi->uuid)/2",
            "sizeof(sbi->uuid)/2"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "sbi->uuid",
            "sizeof(sbi->uuid)/2"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numfree"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numinos"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(s64) atomic_read(&imap->im_numinos) +\n\t\t\t((sbi->bmap->db_nfree >> imap->im_l2nbperiext)\n\t\t\t << L2INOSPEREXT)",
            "(s64) 0xffffffffLL"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numinos"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"In jfs_statfs\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "sbi->ipimap"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "dentry->d_sb"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(dentry->d_sb);\n\ts64 maxinodes;\n\tstruct inomap *imap = JFS_IP(sbi->ipimap)->i_imap;\n\n\tjfs_info(\"In jfs_statfs\");\n\tbuf->f_type = JFS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->bsize;\n\tbuf->f_blocks = sbi->bmap->db_mapsize;\n\tbuf->f_bfree = sbi->bmap->db_nfree;\n\tbuf->f_bavail = sbi->bmap->db_nfree;\n\t/*\n\t * If we really return the number of allocated & free inodes, some\n\t * applications will fail because they won't see enough free inodes.\n\t * We'll try to calculate some guess as to how many inodes we can\n\t * really allocate\n\t *\n\t * buf->f_files = atomic_read(&imap->im_numinos);\n\t * buf->f_ffree = atomic_read(&imap->im_numfree);\n\t */\n\tmaxinodes = min((s64) atomic_read(&imap->im_numinos) +\n\t\t\t((sbi->bmap->db_nfree >> imap->im_l2nbperiext)\n\t\t\t << L2INOSPEREXT), (s64) 0xffffffffLL);\n\tbuf->f_files = maxinodes;\n\tbuf->f_ffree = maxinodes - (atomic_read(&imap->im_numinos) -\n\t\t\t\t    atomic_read(&imap->im_numfree));\n\tbuf->f_fsid.val[0] = (u32)crc32_le(0, sbi->uuid, sizeof(sbi->uuid)/2);\n\tbuf->f_fsid.val[1] = (u32)crc32_le(0, sbi->uuid + sizeof(sbi->uuid)/2,\n\t\t\t\t\tsizeof(sbi->uuid)/2);\n\n\tbuf->f_namelen = JFS_NAME_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "133-147",
    "snippet": "static void jfs_destroy_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n\tcall_rcu(&inode->i_rcu, jfs_i_callback);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "jfs_i_callback"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ji->ag_lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bmap->db_active[ji->active_ag]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "inode->i_sb"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ji->ag_lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&ji->anon_inode_list)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ji->anon_inode_list"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void jfs_destroy_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n\tcall_rcu(&inode->i_rcu, jfs_i_callback);\n}"
  },
  {
    "function_name": "jfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "126-131",
    "snippet": "static void jfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tkmem_cache_free(jfs_inode_cachep, ji);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jfs_inode_cachep",
            "ji"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *jfs_inode_cachep;\n\nstatic void jfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tkmem_cache_free(jfs_inode_cachep, ji);\n}"
  },
  {
    "function_name": "jfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "113-124",
    "snippet": "static struct inode *jfs_alloc_inode(struct super_block *sb)\n{\n\tstruct jfs_inode_info *jfs_inode;\n\n\tjfs_inode = kmem_cache_alloc(jfs_inode_cachep, GFP_NOFS);\n\tif (!jfs_inode)\n\t\treturn NULL;\n#ifdef CONFIG_QUOTA\n\tmemset(&jfs_inode->i_dquot, 0, sizeof(jfs_inode->i_dquot));\n#endif\n\treturn &jfs_inode->vfs_inode;\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&jfs_inode->i_dquot",
            "0",
            "sizeof(jfs_inode->i_dquot)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "jfs_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *jfs_inode_cachep;\n\nstatic struct inode *jfs_alloc_inode(struct super_block *sb)\n{\n\tstruct jfs_inode_info *jfs_inode;\n\n\tjfs_inode = kmem_cache_alloc(jfs_inode_cachep, GFP_NOFS);\n\tif (!jfs_inode)\n\t\treturn NULL;\n#ifdef CONFIG_QUOTA\n\tmemset(&jfs_inode->i_dquot, 0, sizeof(jfs_inode->i_dquot));\n#endif\n\treturn &jfs_inode->vfs_inode;\n}"
  },
  {
    "function_name": "jfs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "95-111",
    "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_handle_error",
          "args": [
            "sb"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "74-93",
          "snippet": "static void jfs_handle_error(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tupdateSuper(sb, FM_DIRTY);\n\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tpanic(\"JFS (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\telse if (sbi->flag & JFS_ERR_REMOUNT_RO) {\n\t\tjfs_err(\"ERROR: (device %s): remounting filesystem as read-only\\n\",\n\t\t\tsb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/* nothing is done for continue beyond marking the superblock dirty */\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void jfs_handle_error(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tupdateSuper(sb, FM_DIRTY);\n\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tpanic(\"JFS (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\telse if (sbi->flag & JFS_ERR_REMOUNT_RO) {\n\t\tjfs_err(\"ERROR: (device %s): remounting filesystem as read-only\\n\",\n\t\t\tsb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/* nothing is done for continue beyond marking the superblock dirty */\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ERROR: (device %s): %pf: %pV\\n\"",
            "sb->s_id",
            "__builtin_return_address(0)",
            "&vaf"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
  },
  {
    "function_name": "jfs_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
    "lines": "74-93",
    "snippet": "static void jfs_handle_error(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tupdateSuper(sb, FM_DIRTY);\n\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tpanic(\"JFS (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\telse if (sbi->flag & JFS_ERR_REMOUNT_RO) {\n\t\tjfs_err(\"ERROR: (device %s): remounting filesystem as read-only\\n\",\n\t\t\tsb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/* nothing is done for continue beyond marking the superblock dirty */\n}",
    "includes": [
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/seq_file.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/crc32.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/kthread.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/mount.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/completion.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"ERROR: (device %s): remounting filesystem as read-only\\n\"",
            "sb->s_id"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"JFS (device %s): panic forced after error\\n\"",
            "sb->s_id"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_DIRTY"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void jfs_handle_error(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tupdateSuper(sb, FM_DIRTY);\n\n\tif (sbi->flag & JFS_ERR_PANIC)\n\t\tpanic(\"JFS (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\telse if (sbi->flag & JFS_ERR_REMOUNT_RO) {\n\t\tjfs_err(\"ERROR: (device %s): remounting filesystem as read-only\\n\",\n\t\t\tsb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/* nothing is done for continue beyond marking the superblock dirty */\n}"
  }
]