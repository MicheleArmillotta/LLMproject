[
  {
    "function_name": "sign_verify_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "110-124",
    "snippet": "int sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sign_buff",
            "hash",
            "8"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nwsign",
          "args": [
            "server->sign_last",
            "data",
            "hash"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nwsign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "54-91",
          "snippet": "static void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 12",
            "packet",
            "52"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data + 12 + size",
            "0",
            "52 - size"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 12",
            "packet",
            "size"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "server->sign_root",
            "8"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nint sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}"
  },
  {
    "function_name": "__sign_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "95-108",
    "snippet": "void __sign_packet(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, void *sign_buff) {\n\tunsigned char data[64];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, server->sign_last);\n\tmemcpy(sign_buff, server->sign_last, 8);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sign_buff",
            "server->sign_last",
            "8"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nwsign",
          "args": [
            "server->sign_last",
            "data",
            "server->sign_last"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nwsign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "54-91",
          "snippet": "static void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 12",
            "packet",
            "52"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data + 12 + size",
            "0",
            "52 - size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 12",
            "packet",
            "size"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "server->sign_root",
            "8"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nvoid __sign_packet(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, void *sign_buff) {\n\tunsigned char data[64];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, server->sign_last);\n\tmemcpy(sign_buff, server->sign_last, 8);\n}"
  },
  {
    "function_name": "nwsign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "54-91",
    "snippet": "static void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PUT_LE32",
          "args": [
            "outdata+12",
            "(w3+GET_LE32(r_data1+12)) & 0xffffffff"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+12"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_LE32",
          "args": [
            "outdata+8",
            "(w2+GET_LE32(r_data1+8)) & 0xffffffff"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+8"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_LE32",
          "args": [
            "outdata+4",
            "(w1+GET_LE32(r_data1+4)) & 0xffffffff"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+4"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_LE32",
          "args": [
            "outdata",
            "(w0+GET_LE32(r_data1)) & 0xffffffff"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12]",
            "15"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4]",
            "11"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8]",
            "9"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0]",
            "3"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12]",
            "13"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8]",
            "9"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4]",
            "5"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0]",
            "3"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3]",
            "19"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2]",
            "11"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1]",
            "7"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0]",
            "3"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+12"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+8"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1+4"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_LE32",
          "args": [
            "r_data2+(i<<2)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic void nwsign(char *r_data1, char *r_data2, char *outdata) {\n int i;\n unsigned int w0,w1,w2,w3;\n static int rbit[4]={0, 2, 1, 3};\n#ifdef __i386__\n unsigned int *data2=(unsigned int *)r_data2;\n#else\n unsigned int data2[16];\n for (i=0;i<16;i++)\n  data2[i]=GET_LE32(r_data2+(i<<2));\n#endif \n w0=GET_LE32(r_data1);\n w1=GET_LE32(r_data1+4);\n w2=GET_LE32(r_data1+8);\n w3=GET_LE32(r_data1+12);\n for (i=0;i<16;i+=4) {\n  w0=rol32(w0 + ((w1 & w2) | ((~w1) & w3)) + data2[i+0],3);\n  w3=rol32(w3 + ((w0 & w1) | ((~w0) & w2)) + data2[i+1],7);\n  w2=rol32(w2 + ((w3 & w0) | ((~w3) & w1)) + data2[i+2],11);\n  w1=rol32(w1 + ((w2 & w3) | ((~w2) & w0)) + data2[i+3],19);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + (((w2 | w3) & w1) | (w2 & w3)) + 0x5a827999 + data2[i+0],3);\n  w3=rol32(w3 + (((w1 | w2) & w0) | (w1 & w2)) + 0x5a827999 + data2[i+4],5);\n  w2=rol32(w2 + (((w0 | w1) & w3) | (w0 & w1)) + 0x5a827999 + data2[i+8],9);\n  w1=rol32(w1 + (((w3 | w0) & w2) | (w3 & w0)) + 0x5a827999 + data2[i+12],13);\n }\n for (i=0;i<4;i++) {\n  w0=rol32(w0 + ((w1 ^ w2) ^ w3) + 0x6ed9eba1 + data2[rbit[i]+0],3);\n  w3=rol32(w3 + ((w0 ^ w1) ^ w2) + 0x6ed9eba1 + data2[rbit[i]+8],9);\n  w2=rol32(w2 + ((w3 ^ w0) ^ w1) + 0x6ed9eba1 + data2[rbit[i]+4],11);\n  w1=rol32(w1 + ((w2 ^ w3) ^ w0) + 0x6ed9eba1 + data2[rbit[i]+12],15);\n }\n PUT_LE32(outdata,(w0+GET_LE32(r_data1)) & 0xffffffff);\n PUT_LE32(outdata+4,(w1+GET_LE32(r_data1+4)) & 0xffffffff);\n PUT_LE32(outdata+8,(w2+GET_LE32(r_data1+8)) & 0xffffffff);\n PUT_LE32(outdata+12,(w3+GET_LE32(r_data1+12)) & 0xffffffff);\n}"
  },
  {
    "function_name": "DSET_LH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "43-48",
    "snippet": "static inline void\nDSET_LH(__u8 * buf, int pos, __u32 val)\n{\n\tWSET_LH(buf, pos, val & 0xffff);\n\tWSET_LH(buf, pos + 2, val >> 16);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSET_LH",
          "args": [
            "buf",
            "pos + 2",
            "val >> 16"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "WSET_LH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "37-42",
          "snippet": "static inline void\nWSET_LH(__u8 * buf, int pos, __u16 val)\n{\n\tBSET(buf, pos, val & 0xff);\n\tBSET(buf, pos + 1, val >> 8);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline void\nWSET_LH(__u8 * buf, int pos, __u16 val)\n{\n\tBSET(buf, pos, val & 0xff);\n\tBSET(buf, pos + 1, val >> 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline void\nDSET_LH(__u8 * buf, int pos, __u32 val)\n{\n\tWSET_LH(buf, pos, val & 0xffff);\n\tWSET_LH(buf, pos + 2, val >> 16);\n}"
  },
  {
    "function_name": "WSET_LH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "37-42",
    "snippet": "static inline void\nWSET_LH(__u8 * buf, int pos, __u16 val)\n{\n\tBSET(buf, pos, val & 0xff);\n\tBSET(buf, pos + 1, val >> 8);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BSET",
          "args": [
            "buf",
            "pos + 1",
            "val >> 8"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BSET",
          "args": [
            "buf",
            "pos",
            "val & 0xff"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline void\nWSET_LH(__u8 * buf, int pos, __u16 val)\n{\n\tBSET(buf, pos, val & 0xff);\n\tBSET(buf, pos + 1, val >> 8);\n}"
  },
  {
    "function_name": "DVAL_LH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "32-36",
    "snippet": "static inline __u32\nDVAL_LH(const __u8 * buf, int pos)\n{\n\treturn WVAL_LH(buf, pos) | WVAL_LH(buf, pos + 2) << 16;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WVAL_LH",
          "args": [
            "buf",
            "pos + 2"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "WVAL_LH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "27-31",
          "snippet": "static inline __u16\nWVAL_LH(const __u8 * buf, int pos)\n{\n\treturn PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline __u16\nWVAL_LH(const __u8 * buf, int pos)\n{\n\treturn PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline __u32\nDVAL_LH(const __u8 * buf, int pos)\n{\n\treturn WVAL_LH(buf, pos) | WVAL_LH(buf, pos + 2) << 16;\n}"
  },
  {
    "function_name": "WVAL_LH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
    "lines": "27-31",
    "snippet": "static inline __u16\nWVAL_LH(const __u8 * buf, int pos)\n{\n\treturn PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/ncp.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PVAL",
          "args": [
            "buf",
            "pos + 1"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PVAL",
          "args": [
            "buf",
            "pos"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nstatic inline __u16\nWVAL_LH(const __u8 * buf, int pos)\n{\n\treturn PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;\n}"
  }
]