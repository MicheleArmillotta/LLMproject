[
  {
    "function_name": "xfs_next_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
    "lines": "88-118",
    "snippet": "int xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}",
    "includes": [
      "#include \"xfs_bit.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "tmp"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "561-593",
          "snippet": "__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\n__uint64_t\nxfs_max_file_offset(\n\tunsigned int\t\tblockshift)\n{\n\tunsigned int\t\tpagefactor = 1;\n\tunsigned int\t\tbitshift = BITS_PER_LONG - 1;\n\n\t/* Figure out maximum filesize, on Linux this can depend on\n\t * the filesystem blocksize (on 32 bit platforms).\n\t * __block_write_begin does this in an [unsigned] long...\n\t *      page->index << (PAGE_CACHE_SHIFT - bbits)\n\t * So, for page sized blocks (4K on 32 bit platforms),\n\t * this wraps at around 8Tb (hence MAX_LFS_FILESIZE which is\n\t *      (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)\n\t * but for smaller blocksizes it is less (bbits = log2 bsize).\n\t * Note1: get_block_t takes a long (implicit cast from above)\n\t * Note2: The Large Block Device (LBD and HAVE_SECTOR_T) patch\n\t * can optionally convert the [unsigned] long from above into\n\t * an [unsigned] long long.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tASSERT(sizeof(sector_t) == 8);\n\tpagefactor = PAGE_CACHE_SIZE;\n\tbitshift = BITS_PER_LONG;\n# else\n\tpagefactor = PAGE_CACHE_SIZE >> (PAGE_CACHE_SHIFT - blockshift);\n# endif\n#endif\n\n\treturn (((__uint64_t)pagefactor) << bitshift) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint xfs_next_bit(uint *map, uint size, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = start_bit & ~(NBWORD - 1);\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tif (start_bit >= size)\n\t\treturn -1;\n\tsize -= result;\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to zero first offset bits prior to start */\n\t\ttmp &= (~0U << start_bit);\n\t\tif (tmp != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != 0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn -1;\nfound:\n\treturn result + ffs(tmp) - 1;\n}"
  },
  {
    "function_name": "xfs_contig_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
    "lines": "48-78",
    "snippet": "int\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}",
    "includes": [
      "#include \"xfs_bit.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "tmp"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_bit < size"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_contig_bits(uint *map, uint\tsize, uint start_bit)\n{\n\tuint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);\n\tuint result = 0;\n\tuint tmp;\n\n\tsize <<= BIT_TO_WORD_SHIFT;\n\n\tASSERT(start_bit < size);\n\tsize -= start_bit & ~(NBWORD - 1);\n\tstart_bit &= (NBWORD - 1);\n\tif (start_bit) {\n\t\ttmp = *p++;\n\t\t/* set to one first offset bits prior to start */\n\t\ttmp |= (~0U >> (NBWORD-start_bit));\n\t\tif (tmp != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\twhile (size) {\n\t\tif ((tmp = *p++) != ~0U)\n\t\t\tgoto found;\n\t\tresult += NBWORD;\n\t\tsize -= NBWORD;\n\t}\n\treturn result - start_bit;\nfound:\n\treturn result + ffz(tmp) - start_bit;\n}"
  },
  {
    "function_name": "xfs_bitmap_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bit.c",
    "lines": "31-42",
    "snippet": "int\nxfs_bitmap_empty(uint *map, uint size)\n{\n\tuint i;\n\tuint ret = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tret |= map[i];\n\t}\n\n\treturn (ret == 0);\n}",
    "includes": [
      "#include \"xfs_bit.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_bit.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_bitmap_empty(uint *map, uint size)\n{\n\tuint i;\n\tuint ret = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tret |= map[i];\n\t}\n\n\treturn (ret == 0);\n}"
  }
]