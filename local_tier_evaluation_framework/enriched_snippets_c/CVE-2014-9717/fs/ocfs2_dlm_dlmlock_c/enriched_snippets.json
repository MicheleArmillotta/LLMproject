[
  {
    "function_name": "dlmlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "558-760",
    "snippet": "enum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_drop_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_drop_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "672-686",
          "snippet": "void dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_recovery",
          "args": [
            "dlm"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "412-422",
          "snippet": "void dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_node_death",
          "args": [
            "dlm",
            "res->owner",
            "DLM_NODE_DEATH_WAIT_MAX"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_node_death",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "362-377",
          "snippet": "void dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmlock_remote",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "dlmlock_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "215-291",
          "snippet": "static enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tenum dlm_status status = DLM_DENIED;\n\tint lockres_changed = 1;\n\n\tmlog(0, \"type=%d, lockres %.*s, flags = 0x%x\\n\",\n\t     lock->ml.type, res->lockname.len,\n\t     res->lockname.name, flags);\n\n\t/*\n\t * Wait if resource is getting recovered, remastered, etc.\n\t * If the resource was remastered and new owner is self, then exit.\n\t */\n\tspin_lock(&res->spinlock);\n\t__dlm_wait_on_lockres(res);\n\tif (res->owner == dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn DLM_RECOVERING;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\t/* add lock to local (secondary) queue */\n\tdlm_lock_get(lock);\n\tlist_add_tail(&lock->list, &res->blocked);\n\tlock->lock_pending = 1;\n\tspin_unlock(&res->spinlock);\n\n\t/* spec seems to say that you will get DLM_NORMAL when the lock\n\t * has been queued, meaning we need to wait for a reply here. */\n\tstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->lock_pending = 0;\n\tif (status != DLM_NORMAL) {\n\t\tif (status == DLM_RECOVERING &&\n\t\t    dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\t/* recovery lock was mastered by dead node.\n\t\t\t * we need to have calc_usage shoot down this\n\t\t\t * lockres and completely remaster it. */\n\t\t\tmlog(0, \"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\",\n\t\t\t     dlm->name, res->owner);\n\t\t} else if (status != DLM_NOTQUEUED) {\n\t\t\t/*\n\t\t\t * DO NOT call calc_usage, as this would unhash\n\t\t\t * the remote lockres before we ever get to use\n\t\t\t * it.  treat as if we never made any change to\n\t\t\t * the lockres.\n\t\t\t */\n\t\t\tlockres_changed = 0;\n\t\t\tdlm_error(status);\n\t\t}\n\t\tdlm_revert_pending_lock(res, lock);\n\t\tdlm_lock_put(lock);\n\t} else if (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\tres->lockname.len)) {\n\t\t/* special case for the $RECOVERY lock.\n\t\t * there will never be an AST delivered to put\n\t\t * this lock on the proper secondary queue\n\t\t * (granted), so do it manually. */\n\t\tmlog(0, \"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\",\n\t\t     dlm->name, dlm->node_num, res->owner);\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (lockres_changed)\n\t\tdlm_lockres_calc_usage(dlm, res);\n\n\twake_up(&res->wq);\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tenum dlm_status status = DLM_DENIED;\n\tint lockres_changed = 1;\n\n\tmlog(0, \"type=%d, lockres %.*s, flags = 0x%x\\n\",\n\t     lock->ml.type, res->lockname.len,\n\t     res->lockname.name, flags);\n\n\t/*\n\t * Wait if resource is getting recovered, remastered, etc.\n\t * If the resource was remastered and new owner is self, then exit.\n\t */\n\tspin_lock(&res->spinlock);\n\t__dlm_wait_on_lockres(res);\n\tif (res->owner == dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn DLM_RECOVERING;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\t/* add lock to local (secondary) queue */\n\tdlm_lock_get(lock);\n\tlist_add_tail(&lock->list, &res->blocked);\n\tlock->lock_pending = 1;\n\tspin_unlock(&res->spinlock);\n\n\t/* spec seems to say that you will get DLM_NORMAL when the lock\n\t * has been queued, meaning we need to wait for a reply here. */\n\tstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->lock_pending = 0;\n\tif (status != DLM_NORMAL) {\n\t\tif (status == DLM_RECOVERING &&\n\t\t    dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\t/* recovery lock was mastered by dead node.\n\t\t\t * we need to have calc_usage shoot down this\n\t\t\t * lockres and completely remaster it. */\n\t\t\tmlog(0, \"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\",\n\t\t\t     dlm->name, res->owner);\n\t\t} else if (status != DLM_NOTQUEUED) {\n\t\t\t/*\n\t\t\t * DO NOT call calc_usage, as this would unhash\n\t\t\t * the remote lockres before we ever get to use\n\t\t\t * it.  treat as if we never made any change to\n\t\t\t * the lockres.\n\t\t\t */\n\t\t\tlockres_changed = 0;\n\t\t\tdlm_error(status);\n\t\t}\n\t\tdlm_revert_pending_lock(res, lock);\n\t\tdlm_lock_put(lock);\n\t} else if (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\tres->lockname.len)) {\n\t\t/* special case for the $RECOVERY lock.\n\t\t * there will never be an AST delivered to put\n\t\t * this lock on the proper secondary queue\n\t\t * (granted), so do it manually. */\n\t\tmlog(0, \"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\",\n\t\t     dlm->name, dlm->node_num, res->owner);\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (lockres_changed)\n\t\tdlm_lockres_calc_usage(dlm, res);\n\n\twake_up(&res->wq);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmlock_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "dlmlock_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "119-197",
          "snippet": "static enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"LKM_VALBLK passed by caller\\n\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_attach_lockres",
          "args": [
            "lock",
            "res"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_attach_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "374-379",
          "snippet": "void dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"creating lock: lock=%p res=%p\\n\"",
            "lock",
            "res"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_resource",
          "args": [
            "dlm",
            "name",
            "namelen",
            "flags"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "733-1005",
          "snippet": "struct dlm_lock_resource * dlm_get_lock_resource(struct dlm_ctxt *dlm,\n\t\t\t\t\t  const char *lockid,\n\t\t\t\t\t  int namelen,\n\t\t\t\t\t  int flags)\n{\n\tstruct dlm_lock_resource *tmpres=NULL, *res=NULL;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *alloc_mle = NULL;\n\tint blocked = 0;\n\tint ret, nodenum;\n\tstruct dlm_node_iter iter;\n\tunsigned int hash;\n\tint tries = 0;\n\tint bit, wait_on_recovery = 0;\n\n\tBUG_ON(!lockid);\n\n\thash = dlm_lockid_hash(lockid, namelen);\n\n\tmlog(0, \"get lockres %s (len %d)\\n\", lockid, namelen);\n\nlookup:\n\tspin_lock(&dlm->spinlock);\n\ttmpres = __dlm_lookup_lockres_full(dlm, lockid, namelen, hash);\n\tif (tmpres) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_lock(&tmpres->spinlock);\n\t\t/* Wait on the thread that is mastering the resource */\n\t\tif (tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t__dlm_wait_on_lockres(tmpres);\n\t\t\tBUG_ON(tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Wait on the resource purge to complete before continuing */\n\t\tif (tmpres->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tBUG_ON(tmpres->owner == dlm->node_num);\n\t\t\t__dlm_wait_on_lockres_flags(tmpres,\n\t\t\t\t\t\t    DLM_LOCK_RES_DROPPING_REF);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Grab inflight ref to pin the resource */\n\t\tdlm_lockres_grab_inflight_ref(dlm, tmpres);\n\n\t\tspin_unlock(&tmpres->spinlock);\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t\tres = tmpres;\n\t\tgoto leave;\n\t}\n\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(0, \"allocating a new resource\\n\");\n\t\t/* nothing found and we need to allocate one. */\n\t\talloc_mle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\tif (!alloc_mle)\n\t\t\tgoto leave;\n\t\tres = dlm_new_lockres(dlm, lockid, namelen);\n\t\tif (!res)\n\t\t\tgoto leave;\n\t\tgoto lookup;\n\t}\n\n\tmlog(0, \"no lockres found, allocated our own: %p\\n\", res);\n\n\tif (flags & LKM_LOCAL) {\n\t\t/* caller knows it's safe to assume it's not mastered elsewhere\n\t\t * DONE!  return right away */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tdlm_lockres_grab_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* lockres still marked IN_PROGRESS */\n\t\tgoto wake_waiters;\n\t}\n\n\t/* check master list to see if another node has started mastering it */\n\tspin_lock(&dlm->master_lock);\n\n\t/* if we found a block, wait for lock to be mastered by another node */\n\tblocked = dlm_find_mle(dlm, &mle, (char *)lockid, namelen);\n\tif (blocked) {\n\t\tint mig;\n\t\tif (mle->type == DLM_MLE_MASTER) {\n\t\t\tmlog(ML_ERROR, \"master entry for nonexistent lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmig = (mle->type == DLM_MLE_MIGRATION);\n\t\t/* if there is a migration in progress, let the migration\n\t\t * finish before continuing.  we can wait for the absence\n\t\t * of the MIGRATION mle: either the migrate finished or\n\t\t * one of the nodes died and the mle was cleaned up.\n\t\t * if there is a BLOCK here, but it already has a master\n\t\t * set, we are too late.  the master does not have a ref\n\t\t * for us in the refmap.  detach the mle and drop it.\n\t\t * either way, go back to the top and start over. */\n\t\tif (mig || mle->master != O2NM_MAX_NODES) {\n\t\t\tBUG_ON(mig && mle->master == dlm->node_num);\n\t\t\t/* we arrived too late.  the master does not\n\t\t\t * have a ref for us. retry. */\n\t\t\tmlog(0, \"%s:%.*s: late on %s\\n\",\n\t\t\t     dlm->name, namelen, lockid,\n\t\t\t     mig ?  \"MIGRATION\" : \"BLOCK\");\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* master is known, detach */\n\t\t\tif (!mig)\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t\tmle = NULL;\n\t\t\t/* this is lame, but we can't wait on either\n\t\t\t * the mle or lockres waitqueue here */\n\t\t\tif (mig)\n\t\t\t\tmsleep(100);\n\t\t\tgoto lookup;\n\t\t}\n\t} else {\n\t\t/* go ahead and try to master lock on this node */\n\t\tmle = alloc_mle;\n\t\t/* make sure this does not get freed below */\n\t\talloc_mle = NULL;\n\t\tdlm_init_mle(mle, DLM_MLE_MASTER, dlm, res, NULL, 0);\n\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\n\t\t/* still holding the dlm spinlock, check the recovery map\n\t\t * to see if there are any nodes that still need to be\n\t\t * considered.  these will not appear in the mle nodemap\n\t\t * but they might own this lockres.  wait on them. */\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t}\n\t}\n\n\t/* at this point there is either a DLM_MLE_BLOCK or a\n\t * DLM_MLE_MASTER on the master list, so it's safe to add the\n\t * lockres to the hashtable.  anyone who finds the lock will\n\t * still have to wait on the IN_PROGRESS. */\n\n\t/* finally add the lockres to its hash bucket */\n\t__dlm_insert_lockres(dlm, res);\n\n\t/* since this lockres is new it doesn't not require the spinlock */\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n\n\t/* get an extra ref on the mle in case this is a BLOCK\n\t * if so, the creator of the BLOCK may try to put the last\n\t * ref at this time in the assert master handler, so we\n\t * need an extra one to keep from a bad ptr deref. */\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\nredo_request:\n\twhile (wait_on_recovery) {\n\t\t/* any cluster changes that occurred after dropping the\n\t\t * dlm spinlock would be detectable be a change on the mle,\n\t\t * so we only need to clear out the recovery map once. */\n\t\tif (dlm_is_recovery_lock(lockid, namelen)) {\n\t\t\tmlog(0, \"%s: Recovery map is not empty, but must \"\n\t\t\t     \"master $RECOVERY lock now\\n\", dlm->name);\n\t\t\tif (!dlm_pre_master_reco_lockres(dlm, res))\n\t\t\t\twait_on_recovery = 0;\n\t\t\telse {\n\t\t\t\tmlog(0, \"%s: waiting 500ms for heartbeat state \"\n\t\t\t\t    \"change\\n\", dlm->name);\n\t\t\t\tmsleep(500);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_kick_recovery_thread(dlm);\n\t\tmsleep(1000);\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tspin_lock(&dlm->spinlock);\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t} else\n\t\t\twait_on_recovery = 0;\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tif (wait_on_recovery)\n\t\t\tdlm_wait_for_node_recovery(dlm, bit, 10000);\n\t}\n\n\t/* must wait for lock to be mastered elsewhere */\n\tif (blocked)\n\t\tgoto wait;\n\n\tret = -EINVAL;\n\tdlm_node_iter_init(mle->vote_map, &iter);\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = dlm_do_master_request(res, mle, nodenum);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tif (mle->master != O2NM_MAX_NODES) {\n\t\t\t/* found a master ! */\n\t\t\tif (mle->master <= nodenum)\n\t\t\t\tbreak;\n\t\t\t/* if our master request has not reached the master\n\t\t\t * yet, keep going until it does.  this is how the\n\t\t\t * master will know that asserts are needed back to\n\t\t\t * the lower nodes. */\n\t\t\tmlog(0, \"%s: res %.*s, Requests only up to %u but \"\n\t\t\t     \"master is %u, keep going\\n\", dlm->name, namelen,\n\t\t\t     lockid, nodenum, mle->master);\n\t\t}\n\t}\n\nwait:\n\t/* keep going until the response map includes all nodes */\n\tret = dlm_wait_for_lock_mastery(dlm, res, mle, &blocked);\n\tif (ret < 0) {\n\t\twait_on_recovery = 1;\n\t\tmlog(0, \"%s: res %.*s, Node map changed, redo the master \"\n\t\t     \"request now, blocked=%d\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name, blocked);\n\t\tif (++tries > 20) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Spinning on \"\n\t\t\t     \"dlm_wait_for_lock_mastery, blocked = %d\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, blocked);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_print_one_mle(mle);\n\t\t\ttries = 0;\n\t\t}\n\t\tgoto redo_request;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Mastered by %u\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name, res->owner);\n\t/* make sure we never continue without this */\n\tBUG_ON(res->owner == O2NM_MAX_NODES);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle(mle);\n\t/* put the extra ref */\n\tdlm_put_mle_inuse(mle);\n\nwake_waiters:\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\nleave:\n\t/* need to free the unused mle */\n\tif (alloc_mle)\n\t\tkmem_cache_free(dlm_mle_cache, alloc_mle);\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static struct kmem_cache *dlm_mle_cache;",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
            "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstruct dlm_lock_resource * dlm_get_lock_resource(struct dlm_ctxt *dlm,\n\t\t\t\t\t  const char *lockid,\n\t\t\t\t\t  int namelen,\n\t\t\t\t\t  int flags)\n{\n\tstruct dlm_lock_resource *tmpres=NULL, *res=NULL;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *alloc_mle = NULL;\n\tint blocked = 0;\n\tint ret, nodenum;\n\tstruct dlm_node_iter iter;\n\tunsigned int hash;\n\tint tries = 0;\n\tint bit, wait_on_recovery = 0;\n\n\tBUG_ON(!lockid);\n\n\thash = dlm_lockid_hash(lockid, namelen);\n\n\tmlog(0, \"get lockres %s (len %d)\\n\", lockid, namelen);\n\nlookup:\n\tspin_lock(&dlm->spinlock);\n\ttmpres = __dlm_lookup_lockres_full(dlm, lockid, namelen, hash);\n\tif (tmpres) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_lock(&tmpres->spinlock);\n\t\t/* Wait on the thread that is mastering the resource */\n\t\tif (tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t__dlm_wait_on_lockres(tmpres);\n\t\t\tBUG_ON(tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Wait on the resource purge to complete before continuing */\n\t\tif (tmpres->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tBUG_ON(tmpres->owner == dlm->node_num);\n\t\t\t__dlm_wait_on_lockres_flags(tmpres,\n\t\t\t\t\t\t    DLM_LOCK_RES_DROPPING_REF);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Grab inflight ref to pin the resource */\n\t\tdlm_lockres_grab_inflight_ref(dlm, tmpres);\n\n\t\tspin_unlock(&tmpres->spinlock);\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t\tres = tmpres;\n\t\tgoto leave;\n\t}\n\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(0, \"allocating a new resource\\n\");\n\t\t/* nothing found and we need to allocate one. */\n\t\talloc_mle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\tif (!alloc_mle)\n\t\t\tgoto leave;\n\t\tres = dlm_new_lockres(dlm, lockid, namelen);\n\t\tif (!res)\n\t\t\tgoto leave;\n\t\tgoto lookup;\n\t}\n\n\tmlog(0, \"no lockres found, allocated our own: %p\\n\", res);\n\n\tif (flags & LKM_LOCAL) {\n\t\t/* caller knows it's safe to assume it's not mastered elsewhere\n\t\t * DONE!  return right away */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tdlm_lockres_grab_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* lockres still marked IN_PROGRESS */\n\t\tgoto wake_waiters;\n\t}\n\n\t/* check master list to see if another node has started mastering it */\n\tspin_lock(&dlm->master_lock);\n\n\t/* if we found a block, wait for lock to be mastered by another node */\n\tblocked = dlm_find_mle(dlm, &mle, (char *)lockid, namelen);\n\tif (blocked) {\n\t\tint mig;\n\t\tif (mle->type == DLM_MLE_MASTER) {\n\t\t\tmlog(ML_ERROR, \"master entry for nonexistent lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmig = (mle->type == DLM_MLE_MIGRATION);\n\t\t/* if there is a migration in progress, let the migration\n\t\t * finish before continuing.  we can wait for the absence\n\t\t * of the MIGRATION mle: either the migrate finished or\n\t\t * one of the nodes died and the mle was cleaned up.\n\t\t * if there is a BLOCK here, but it already has a master\n\t\t * set, we are too late.  the master does not have a ref\n\t\t * for us in the refmap.  detach the mle and drop it.\n\t\t * either way, go back to the top and start over. */\n\t\tif (mig || mle->master != O2NM_MAX_NODES) {\n\t\t\tBUG_ON(mig && mle->master == dlm->node_num);\n\t\t\t/* we arrived too late.  the master does not\n\t\t\t * have a ref for us. retry. */\n\t\t\tmlog(0, \"%s:%.*s: late on %s\\n\",\n\t\t\t     dlm->name, namelen, lockid,\n\t\t\t     mig ?  \"MIGRATION\" : \"BLOCK\");\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* master is known, detach */\n\t\t\tif (!mig)\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t\tmle = NULL;\n\t\t\t/* this is lame, but we can't wait on either\n\t\t\t * the mle or lockres waitqueue here */\n\t\t\tif (mig)\n\t\t\t\tmsleep(100);\n\t\t\tgoto lookup;\n\t\t}\n\t} else {\n\t\t/* go ahead and try to master lock on this node */\n\t\tmle = alloc_mle;\n\t\t/* make sure this does not get freed below */\n\t\talloc_mle = NULL;\n\t\tdlm_init_mle(mle, DLM_MLE_MASTER, dlm, res, NULL, 0);\n\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\n\t\t/* still holding the dlm spinlock, check the recovery map\n\t\t * to see if there are any nodes that still need to be\n\t\t * considered.  these will not appear in the mle nodemap\n\t\t * but they might own this lockres.  wait on them. */\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t}\n\t}\n\n\t/* at this point there is either a DLM_MLE_BLOCK or a\n\t * DLM_MLE_MASTER on the master list, so it's safe to add the\n\t * lockres to the hashtable.  anyone who finds the lock will\n\t * still have to wait on the IN_PROGRESS. */\n\n\t/* finally add the lockres to its hash bucket */\n\t__dlm_insert_lockres(dlm, res);\n\n\t/* since this lockres is new it doesn't not require the spinlock */\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n\n\t/* get an extra ref on the mle in case this is a BLOCK\n\t * if so, the creator of the BLOCK may try to put the last\n\t * ref at this time in the assert master handler, so we\n\t * need an extra one to keep from a bad ptr deref. */\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\nredo_request:\n\twhile (wait_on_recovery) {\n\t\t/* any cluster changes that occurred after dropping the\n\t\t * dlm spinlock would be detectable be a change on the mle,\n\t\t * so we only need to clear out the recovery map once. */\n\t\tif (dlm_is_recovery_lock(lockid, namelen)) {\n\t\t\tmlog(0, \"%s: Recovery map is not empty, but must \"\n\t\t\t     \"master $RECOVERY lock now\\n\", dlm->name);\n\t\t\tif (!dlm_pre_master_reco_lockres(dlm, res))\n\t\t\t\twait_on_recovery = 0;\n\t\t\telse {\n\t\t\t\tmlog(0, \"%s: waiting 500ms for heartbeat state \"\n\t\t\t\t    \"change\\n\", dlm->name);\n\t\t\t\tmsleep(500);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_kick_recovery_thread(dlm);\n\t\tmsleep(1000);\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tspin_lock(&dlm->spinlock);\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t} else\n\t\t\twait_on_recovery = 0;\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tif (wait_on_recovery)\n\t\t\tdlm_wait_for_node_recovery(dlm, bit, 10000);\n\t}\n\n\t/* must wait for lock to be mastered elsewhere */\n\tif (blocked)\n\t\tgoto wait;\n\n\tret = -EINVAL;\n\tdlm_node_iter_init(mle->vote_map, &iter);\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = dlm_do_master_request(res, mle, nodenum);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tif (mle->master != O2NM_MAX_NODES) {\n\t\t\t/* found a master ! */\n\t\t\tif (mle->master <= nodenum)\n\t\t\t\tbreak;\n\t\t\t/* if our master request has not reached the master\n\t\t\t * yet, keep going until it does.  this is how the\n\t\t\t * master will know that asserts are needed back to\n\t\t\t * the lower nodes. */\n\t\t\tmlog(0, \"%s: res %.*s, Requests only up to %u but \"\n\t\t\t     \"master is %u, keep going\\n\", dlm->name, namelen,\n\t\t\t     lockid, nodenum, mle->master);\n\t\t}\n\t}\n\nwait:\n\t/* keep going until the response map includes all nodes */\n\tret = dlm_wait_for_lock_mastery(dlm, res, mle, &blocked);\n\tif (ret < 0) {\n\t\twait_on_recovery = 1;\n\t\tmlog(0, \"%s: res %.*s, Node map changed, redo the master \"\n\t\t     \"request now, blocked=%d\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name, blocked);\n\t\tif (++tries > 20) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Spinning on \"\n\t\t\t     \"dlm_wait_for_lock_mastery, blocked = %d\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, blocked);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_print_one_mle(mle);\n\t\t\ttries = 0;\n\t\t}\n\t\tgoto redo_request;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Mastered by %u\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name, res->owner);\n\t/* make sure we never continue without this */\n\tBUG_ON(res->owner == O2NM_MAX_NODES);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle(mle);\n\t/* put the extra ref */\n\tdlm_put_mle_inuse(mle);\n\nwake_waiters:\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\nleave:\n\t/* need to free the unused mle */\n\tif (alloc_mle)\n\t\tkmem_cache_free(dlm_mle_cache, alloc_mle);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lock",
          "args": [
            "mode",
            "dlm->node_num",
            "tmpcookie",
            "lksb"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "423-449",
          "snippet": "struct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_next_cookie",
          "args": [
            "dlm->node_num",
            "&tmpcookie"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_next_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "542-556",
          "snippet": "static inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\n{\n\tu64 tmpnode = node_num;\n\n\t/* shift single byte of node num into top 8 bits */\n\ttmpnode <<= 56;\n\n\tspin_lock(&dlm_cookie_lock);\n\t*cookie = (dlm_next_cookie | tmpnode);\n\tif (++dlm_next_cookie & 0xff00000000000000ull) {\n\t\tmlog(0, \"This node's cookie will now wrap!\\n\");\n\t\tdlm_next_cookie = 1;\n\t}\n\tspin_unlock(&dlm_cookie_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(dlm_cookie_lock);",
            "static u64 dlm_next_cookie = 1;",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(dlm_cookie_lock);\nstatic u64 dlm_next_cookie = 1;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\n\nstatic inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\n{\n\tu64 tmpnode = node_num;\n\n\t/* shift single byte of node num into top 8 bits */\n\ttmpnode <<= 56;\n\n\tspin_lock(&dlm_cookie_lock);\n\t*cookie = (dlm_next_cookie | tmpnode);\n\tif (++dlm_next_cookie & 0xff00000000000000ull) {\n\t\tmlog(0, \"This node's cookie will now wrap!\\n\");\n\t\tdlm_next_cookie = 1;\n\t}\n\tspin_unlock(&dlm_cookie_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmconvert_remote",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags",
            "mode"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "dlmconvert_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "260-333",
          "snippet": "enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tenum dlm_status status;\n\n\tmlog(0, \"type=%d, convert_type=%d, busy=%d\\n\", lock->ml.type,\n\t     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\");\n\t\t/* __dlm_print_one_lock_resource(res); */\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto bail;\n\t}\n\t/* will exit this call with spinlock held */\n\t__dlm_wait_on_lockres(res);\n\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t__dlm_print_one_lock_resource(res);\n\t\tmlog(ML_ERROR, \"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.convert_type);\n\t\tstatus = DLM_DENIED;\n\t\tgoto bail;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t/* move lock to local convert queue */\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\tlock->convert_pending = 1;\n\tlock->ml.convert_type = type;\n\n\tif (flags & LKM_VALBLK) {\n\t\tif (lock->ml.type == LKM_EXMODE) {\n\t\t\tflags |= LKM_PUT_LVB;\n\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t} else {\n\t\t\tif (lock->ml.convert_type == LKM_NLMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* no locks held here.\n\t * need to wait for a reply as to whether it got queued or not. */\n\tstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->convert_pending = 0;\n\t/* if it failed, move it back to granted queue */\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tdlm_revert_pending_convert(res, lock);\n\t}\nbail:\n\tspin_unlock(&res->spinlock);\n\n\t/* TODO: should this be a wake_one? */\n\t/* wake up any IN_PROGRESS waiters */\n\twake_up(&res->wq);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nenum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tenum dlm_status status;\n\n\tmlog(0, \"type=%d, convert_type=%d, busy=%d\\n\", lock->ml.type,\n\t     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\");\n\t\t/* __dlm_print_one_lock_resource(res); */\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto bail;\n\t}\n\t/* will exit this call with spinlock held */\n\t__dlm_wait_on_lockres(res);\n\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t__dlm_print_one_lock_resource(res);\n\t\tmlog(ML_ERROR, \"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.convert_type);\n\t\tstatus = DLM_DENIED;\n\t\tgoto bail;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t/* move lock to local convert queue */\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\tlock->convert_pending = 1;\n\tlock->ml.convert_type = type;\n\n\tif (flags & LKM_VALBLK) {\n\t\tif (lock->ml.type == LKM_EXMODE) {\n\t\t\tflags |= LKM_PUT_LVB;\n\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t} else {\n\t\t\tif (lock->ml.convert_type == LKM_NLMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* no locks held here.\n\t * need to wait for a reply as to whether it got queued or not. */\n\tstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->convert_pending = 0;\n\t/* if it failed, move it back to granted queue */\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tdlm_revert_pending_convert(res, lock);\n\t}\nbail:\n\tspin_unlock(&res->spinlock);\n\n\t/* TODO: should this be a wake_one? */\n\t/* wake up any IN_PROGRESS waiters */\n\twake_up(&res->wq);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmconvert_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags",
            "mode"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "dlmconvert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "76-108",
          "snippet": "enum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status;\n\n\tspin_lock(&res->spinlock);\n\t/* we are not in a network handler, this is fine */\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\tstatus = __dlmconvert_master(dlm, res, lock, flags, type,\n\t\t\t\t     &call_ast, &kick_thread);\n\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\tif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\n\t\tdlm_error(status);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);",
            "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nenum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status;\n\n\tspin_lock(&res->spinlock);\n\t/* we are not in a network handler, this is fine */\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\tstatus = __dlmconvert_master(dlm, res, lock, flags, type,\n\t\t\t\t     &call_ast, &kick_thread);\n\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\tif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\n\t\tdlm_error(status);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\"",
            "lock->lksb",
            "lock->ast",
            "lock->bast",
            "lock->astdata"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\"",
            "lksb",
            "ast",
            "bast",
            "data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "name",
            "namelen"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nenum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_get_next_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "542-556",
    "snippet": "static inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\n{\n\tu64 tmpnode = node_num;\n\n\t/* shift single byte of node num into top 8 bits */\n\ttmpnode <<= 56;\n\n\tspin_lock(&dlm_cookie_lock);\n\t*cookie = (dlm_next_cookie | tmpnode);\n\tif (++dlm_next_cookie & 0xff00000000000000ull) {\n\t\tmlog(0, \"This node's cookie will now wrap!\\n\");\n\t\tdlm_next_cookie = 1;\n\t}\n\tspin_unlock(&dlm_cookie_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(dlm_cookie_lock);",
      "static u64 dlm_next_cookie = 1;",
      "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_cookie_lock"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"This node's cookie will now wrap!\\n\""
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_cookie_lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(dlm_cookie_lock);\nstatic u64 dlm_next_cookie = 1;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\n\nstatic inline void dlm_get_next_cookie(u8 node_num, u64 *cookie)\n{\n\tu64 tmpnode = node_num;\n\n\t/* shift single byte of node num into top 8 bits */\n\ttmpnode <<= 56;\n\n\tspin_lock(&dlm_cookie_lock);\n\t*cookie = (dlm_next_cookie | tmpnode);\n\tif (++dlm_next_cookie & 0xff00000000000000ull) {\n\t\tmlog(0, \"This node's cookie will now wrap!\\n\");\n\t\tdlm_next_cookie = 1;\n\t}\n\tspin_unlock(&dlm_cookie_lock);\n}"
  },
  {
    "function_name": "dlm_create_lock_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "458-538",
    "snippet": "int dlm_create_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_create_lock *create = (struct dlm_create_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tenum dlm_status status = DLM_NORMAL;\n\tchar *name;\n\tunsigned int namelen;\n\n\tBUG_ON(!dlm);\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_REJECTED;\n\n\tname = create->name;\n\tnamelen = create->namelen;\n\tstatus = DLM_REJECTED;\n\tif (!dlm_domain_fully_joined(dlm)) {\n\t\tmlog(ML_ERROR, \"Domain %s not fully joined, but node %u is \"\n\t\t     \"sending a create_lock message for lock %.*s!\\n\",\n\t\t     dlm->name, create->node_idx, namelen, name);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_IVBUFLEN;\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_SYSERR;\n\tnewlock = dlm_new_lock(create->requested_type,\n\t\t\t       create->node_idx,\n\t\t\t       be64_to_cpu(create->cookie), NULL);\n\tif (!newlock) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tlksb = newlock->lksb;\n\n\tif (be32_to_cpu(create->flags) & LKM_GET_LVB) {\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t\tmlog(0, \"set DLM_LKSB_GET_LVB flag\\n\");\n\t}\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, name, namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tspin_unlock(&res->spinlock);\n\n\tif (status != DLM_NORMAL) {\n\t\tmlog(0, \"lockres recovering/migrating/in-progress\\n\");\n\t\tgoto leave;\n\t}\n\n\tdlm_lock_attach_lockres(newlock, res);\n\n\tstatus = dlmlock_master(dlm, res, newlock, be32_to_cpu(create->flags));\nleave:\n\tif (status != DLM_NORMAL)\n\t\tif (newlock)\n\t\t\tdlm_lock_put(newlock);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "newlock"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmlock_master",
          "args": [
            "dlm",
            "res",
            "newlock",
            "be32_to_cpu(create->flags)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dlmlock_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "119-197",
          "snippet": "static enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "create->flags"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_attach_lockres",
          "args": [
            "newlock",
            "res"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_attach_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "374-379",
          "snippet": "void dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lockres recovering/migrating/in-progress\\n\""
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_state_to_status",
          "args": [
            "res"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_state_to_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "796-811",
          "snippet": "static inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "namelen"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "create->flags"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_new_lock",
          "args": [
            "create->requested_type",
            "create->node_idx",
            "be64_to_cpu(create->cookie)",
            "NULL"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "423-449",
          "snippet": "struct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "create->cookie"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Domain %s not fully joined, but node %u is \"\n\t\t     \"sending a create_lock message for lock %.*s!\\n\"",
            "dlm->name",
            "create->node_idx",
            "namelen",
            "name"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nint dlm_create_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_create_lock *create = (struct dlm_create_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tenum dlm_status status = DLM_NORMAL;\n\tchar *name;\n\tunsigned int namelen;\n\n\tBUG_ON(!dlm);\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_REJECTED;\n\n\tname = create->name;\n\tnamelen = create->namelen;\n\tstatus = DLM_REJECTED;\n\tif (!dlm_domain_fully_joined(dlm)) {\n\t\tmlog(ML_ERROR, \"Domain %s not fully joined, but node %u is \"\n\t\t     \"sending a create_lock message for lock %.*s!\\n\",\n\t\t     dlm->name, create->node_idx, namelen, name);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_IVBUFLEN;\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = DLM_SYSERR;\n\tnewlock = dlm_new_lock(create->requested_type,\n\t\t\t       create->node_idx,\n\t\t\t       be64_to_cpu(create->cookie), NULL);\n\tif (!newlock) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tlksb = newlock->lksb;\n\n\tif (be32_to_cpu(create->flags) & LKM_GET_LVB) {\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t\tmlog(0, \"set DLM_LKSB_GET_LVB flag\\n\");\n\t}\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, name, namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tspin_unlock(&res->spinlock);\n\n\tif (status != DLM_NORMAL) {\n\t\tmlog(0, \"lockres recovering/migrating/in-progress\\n\");\n\t\tgoto leave;\n\t}\n\n\tdlm_lock_attach_lockres(newlock, res);\n\n\tstatus = dlmlock_master(dlm, res, newlock, be32_to_cpu(create->flags));\nleave:\n\tif (status != DLM_NORMAL)\n\t\tif (newlock)\n\t\t\tdlm_lock_put(newlock);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_new_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "423-449",
    "snippet": "struct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lock_cache;",
      "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_init_lock",
          "args": [
            "lock",
            "type",
            "node",
            "cookie"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "394-421",
          "snippet": "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie)\n{\n\tINIT_LIST_HEAD(&newlock->list);\n\tINIT_LIST_HEAD(&newlock->ast_list);\n\tINIT_LIST_HEAD(&newlock->bast_list);\n\tspin_lock_init(&newlock->spinlock);\n\tnewlock->ml.type = type;\n\tnewlock->ml.convert_type = LKM_IVMODE;\n\tnewlock->ml.highest_blocked = LKM_IVMODE;\n\tnewlock->ml.node = node;\n\tnewlock->ml.pad1 = 0;\n\tnewlock->ml.list = 0;\n\tnewlock->ml.flags = 0;\n\tnewlock->ast = NULL;\n\tnewlock->bast = NULL;\n\tnewlock->astdata = NULL;\n\tnewlock->ml.cookie = cpu_to_be64(cookie);\n\tnewlock->ast_pending = 0;\n\tnewlock->bast_pending = 0;\n\tnewlock->convert_pending = 0;\n\tnewlock->lock_pending = 0;\n\tnewlock->unlock_pending = 0;\n\tnewlock->cancel_pending = 0;\n\tnewlock->lksb_kernel_allocated = 0;\n\n\tkref_init(&newlock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\n\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie)\n{\n\tINIT_LIST_HEAD(&newlock->list);\n\tINIT_LIST_HEAD(&newlock->ast_list);\n\tINIT_LIST_HEAD(&newlock->bast_list);\n\tspin_lock_init(&newlock->spinlock);\n\tnewlock->ml.type = type;\n\tnewlock->ml.convert_type = LKM_IVMODE;\n\tnewlock->ml.highest_blocked = LKM_IVMODE;\n\tnewlock->ml.node = node;\n\tnewlock->ml.pad1 = 0;\n\tnewlock->ml.list = 0;\n\tnewlock->ml.flags = 0;\n\tnewlock->ast = NULL;\n\tnewlock->bast = NULL;\n\tnewlock->astdata = NULL;\n\tnewlock->ml.cookie = cpu_to_be64(cookie);\n\tnewlock->ast_pending = 0;\n\tnewlock->bast_pending = 0;\n\tnewlock->convert_pending = 0;\n\tnewlock->lock_pending = 0;\n\tnewlock->unlock_pending = 0;\n\tnewlock->cancel_pending = 0;\n\tnewlock->lksb_kernel_allocated = 0;\n\n\tkref_init(&newlock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_lock_cache",
            "lock"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*lksb)",
            "GFP_NOFS"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "dlm_lock_cache",
            "GFP_NOFS"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}"
  },
  {
    "function_name": "dlm_init_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "394-421",
    "snippet": "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie)\n{\n\tINIT_LIST_HEAD(&newlock->list);\n\tINIT_LIST_HEAD(&newlock->ast_list);\n\tINIT_LIST_HEAD(&newlock->bast_list);\n\tspin_lock_init(&newlock->spinlock);\n\tnewlock->ml.type = type;\n\tnewlock->ml.convert_type = LKM_IVMODE;\n\tnewlock->ml.highest_blocked = LKM_IVMODE;\n\tnewlock->ml.node = node;\n\tnewlock->ml.pad1 = 0;\n\tnewlock->ml.list = 0;\n\tnewlock->ml.flags = 0;\n\tnewlock->ast = NULL;\n\tnewlock->bast = NULL;\n\tnewlock->astdata = NULL;\n\tnewlock->ml.cookie = cpu_to_be64(cookie);\n\tnewlock->ast_pending = 0;\n\tnewlock->bast_pending = 0;\n\tnewlock->convert_pending = 0;\n\tnewlock->lock_pending = 0;\n\tnewlock->unlock_pending = 0;\n\tnewlock->cancel_pending = 0;\n\tnewlock->lksb_kernel_allocated = 0;\n\n\tkref_init(&newlock->lock_refs);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&newlock->lock_refs"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "cookie"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&newlock->spinlock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&newlock->bast_list"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&newlock->ast_list"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&newlock->list"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\n\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie)\n{\n\tINIT_LIST_HEAD(&newlock->list);\n\tINIT_LIST_HEAD(&newlock->ast_list);\n\tINIT_LIST_HEAD(&newlock->bast_list);\n\tspin_lock_init(&newlock->spinlock);\n\tnewlock->ml.type = type;\n\tnewlock->ml.convert_type = LKM_IVMODE;\n\tnewlock->ml.highest_blocked = LKM_IVMODE;\n\tnewlock->ml.node = node;\n\tnewlock->ml.pad1 = 0;\n\tnewlock->ml.list = 0;\n\tnewlock->ml.flags = 0;\n\tnewlock->ast = NULL;\n\tnewlock->bast = NULL;\n\tnewlock->astdata = NULL;\n\tnewlock->ml.cookie = cpu_to_be64(cookie);\n\tnewlock->ast_pending = 0;\n\tnewlock->bast_pending = 0;\n\tnewlock->convert_pending = 0;\n\tnewlock->lock_pending = 0;\n\tnewlock->unlock_pending = 0;\n\tnewlock->cancel_pending = 0;\n\tnewlock->lksb_kernel_allocated = 0;\n\n\tkref_init(&newlock->lock_refs);\n}"
  },
  {
    "function_name": "dlm_lock_detach_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "382-392",
    "snippet": "static void dlm_lock_detach_lockres(struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = lock->lockres;\n\tif (res) {\n\t\tlock->lockres = NULL;\n\t\tmlog(0, \"removing lock's lockres reference\\n\");\n\t\tdlm_lockres_put(res);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"removing lock's lockres reference\\n\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = lock->lockres;\n\tif (res) {\n\t\tlock->lockres = NULL;\n\t\tmlog(0, \"removing lock's lockres reference\\n\");\n\t\tdlm_lockres_put(res);\n\t}\n}"
  },
  {
    "function_name": "dlm_lock_attach_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "374-379",
    "snippet": "void dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}"
  },
  {
    "function_name": "dlm_lock_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "352-371",
    "snippet": "static void dlm_lock_release(struct kref *kref)\n{\n\tstruct dlm_lock *lock;\n\n\tlock = container_of(kref, struct dlm_lock, lock_refs);\n\n\tBUG_ON(!list_empty(&lock->list));\n\tBUG_ON(!list_empty(&lock->ast_list));\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tBUG_ON(lock->ast_pending);\n\tBUG_ON(lock->bast_pending);\n\n\tdlm_lock_detach_lockres(lock);\n\n\tif (lock->lksb_kernel_allocated) {\n\t\tmlog(0, \"freeing kernel-allocated lksb\\n\");\n\t\tkfree(lock->lksb);\n\t}\n\tkmem_cache_free(dlm_lock_cache, lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lock_cache;",
      "static void dlm_lock_release(struct kref *kref);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_lock_cache",
            "lock"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lock->lksb"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"freeing kernel-allocated lksb\\n\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_detach_lockres",
          "args": [
            "lock"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_detach_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "382-392",
          "snippet": "static void dlm_lock_detach_lockres(struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = lock->lockres;\n\tif (res) {\n\t\tlock->lockres = NULL;\n\t\tmlog(0, \"removing lock's lockres reference\\n\");\n\t\tdlm_lockres_put(res);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tres = lock->lockres;\n\tif (res) {\n\t\tlock->lockres = NULL;\n\t\tmlog(0, \"removing lock's lockres reference\\n\");\n\t\tdlm_lockres_put(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->bast_pending"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ast_pending"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->bast_list)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->ast_list)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->list)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_lock",
            "lock_refs"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\nstatic void dlm_lock_release(struct kref *kref);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic void dlm_lock_release(struct kref *kref)\n{\n\tstruct dlm_lock *lock;\n\n\tlock = container_of(kref, struct dlm_lock, lock_refs);\n\n\tBUG_ON(!list_empty(&lock->list));\n\tBUG_ON(!list_empty(&lock->ast_list));\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tBUG_ON(lock->ast_pending);\n\tBUG_ON(lock->bast_pending);\n\n\tdlm_lock_detach_lockres(lock);\n\n\tif (lock->lksb_kernel_allocated) {\n\t\tmlog(0, \"freeing kernel-allocated lksb\\n\");\n\t\tkfree(lock->lksb);\n\t}\n\tkmem_cache_free(dlm_lock_cache, lock);\n}"
  },
  {
    "function_name": "dlm_lock_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "347-350",
    "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&lock->lock_refs",
            "dlm_lock_release"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
  },
  {
    "function_name": "dlm_lock_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "342-345",
    "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lock->lock_refs"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
  },
  {
    "function_name": "dlm_send_remote_lock_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "301-340",
    "snippet": "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags)\n{\n\tstruct dlm_create_lock create;\n\tint tmpret, status = 0;\n\tenum dlm_status ret;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.node_idx = dlm->node_num;\n\tcreate.requested_type = lock->ml.type;\n\tcreate.cookie = lock->ml.cookie;\n\tcreate.namelen = res->lockname.len;\n\tcreate.flags = cpu_to_be32(flags);\n\tmemcpy(create.name, res->lockname.name, create.namelen);\n\n\ttmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\n\t\t\t\t    sizeof(create), res->owner, &status);\n\tif (tmpret >= 0) {\n\t\tret = status;\n\t\tif (ret == DLM_REJECTED) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\", dlm->name, create.namelen,\n\t\t\t     create.name, res->owner);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\", dlm->name, create.namelen, create.name,\n\t\t     tmpret, res->owner);\n\t\tif (dlm_is_host_down(tmpret))\n\t\t\tret = DLM_RECOVERING;\n\t\telse\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_err_to_dlm_status",
          "args": [
            "tmpret"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_err_to_dlm_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1095-1109",
          "snippet": "static inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "tmpret"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\"",
            "dlm->name",
            "create.namelen",
            "create.name",
            "tmpret",
            "res->owner"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\"",
            "dlm->name",
            "create.namelen",
            "create.name",
            "res->owner"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_CREATE_LOCK_MSG",
            "dlm->key",
            "&create",
            "sizeof(create)",
            "res->owner",
            "&status"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "create.name",
            "res->lockname.name",
            "create.namelen"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "flags"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&create",
            "0",
            "sizeof(create)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags)\n{\n\tstruct dlm_create_lock create;\n\tint tmpret, status = 0;\n\tenum dlm_status ret;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.node_idx = dlm->node_num;\n\tcreate.requested_type = lock->ml.type;\n\tcreate.cookie = lock->ml.cookie;\n\tcreate.namelen = res->lockname.len;\n\tcreate.flags = cpu_to_be32(flags);\n\tmemcpy(create.name, res->lockname.name, create.namelen);\n\n\ttmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\n\t\t\t\t    sizeof(create), res->owner, &status);\n\tif (tmpret >= 0) {\n\t\tret = status;\n\t\tif (ret == DLM_REJECTED) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\", dlm->name, create.namelen,\n\t\t\t     create.name, res->owner);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\", dlm->name, create.namelen, create.name,\n\t\t     tmpret, res->owner);\n\t\tif (dlm_is_host_down(tmpret))\n\t\t\tret = DLM_RECOVERING;\n\t\telse\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlmlock_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "215-291",
    "snippet": "static enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tenum dlm_status status = DLM_DENIED;\n\tint lockres_changed = 1;\n\n\tmlog(0, \"type=%d, lockres %.*s, flags = 0x%x\\n\",\n\t     lock->ml.type, res->lockname.len,\n\t     res->lockname.name, flags);\n\n\t/*\n\t * Wait if resource is getting recovered, remastered, etc.\n\t * If the resource was remastered and new owner is self, then exit.\n\t */\n\tspin_lock(&res->spinlock);\n\t__dlm_wait_on_lockres(res);\n\tif (res->owner == dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn DLM_RECOVERING;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\t/* add lock to local (secondary) queue */\n\tdlm_lock_get(lock);\n\tlist_add_tail(&lock->list, &res->blocked);\n\tlock->lock_pending = 1;\n\tspin_unlock(&res->spinlock);\n\n\t/* spec seems to say that you will get DLM_NORMAL when the lock\n\t * has been queued, meaning we need to wait for a reply here. */\n\tstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->lock_pending = 0;\n\tif (status != DLM_NORMAL) {\n\t\tif (status == DLM_RECOVERING &&\n\t\t    dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\t/* recovery lock was mastered by dead node.\n\t\t\t * we need to have calc_usage shoot down this\n\t\t\t * lockres and completely remaster it. */\n\t\t\tmlog(0, \"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\",\n\t\t\t     dlm->name, res->owner);\n\t\t} else if (status != DLM_NOTQUEUED) {\n\t\t\t/*\n\t\t\t * DO NOT call calc_usage, as this would unhash\n\t\t\t * the remote lockres before we ever get to use\n\t\t\t * it.  treat as if we never made any change to\n\t\t\t * the lockres.\n\t\t\t */\n\t\t\tlockres_changed = 0;\n\t\t\tdlm_error(status);\n\t\t}\n\t\tdlm_revert_pending_lock(res, lock);\n\t\tdlm_lock_put(lock);\n\t} else if (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\tres->lockname.len)) {\n\t\t/* special case for the $RECOVERY lock.\n\t\t * there will never be an AST delivered to put\n\t\t * this lock on the proper secondary queue\n\t\t * (granted), so do it manually. */\n\t\tmlog(0, \"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\",\n\t\t     dlm->name, dlm->node_num, res->owner);\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (lockres_changed)\n\t\tdlm_lockres_calc_usage(dlm, res);\n\n\twake_up(&res->wq);\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\"",
            "dlm->name",
            "dlm->node_num",
            "res->owner"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_revert_pending_lock",
          "args": [
            "res",
            "lock"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_revert_pending_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "199-205",
          "snippet": "void dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\"",
            "dlm->name",
            "res->owner"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_remote_lock_request",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_remote_lock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "301-340",
          "snippet": "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags)\n{\n\tstruct dlm_create_lock create;\n\tint tmpret, status = 0;\n\tenum dlm_status ret;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.node_idx = dlm->node_num;\n\tcreate.requested_type = lock->ml.type;\n\tcreate.cookie = lock->ml.cookie;\n\tcreate.namelen = res->lockname.len;\n\tcreate.flags = cpu_to_be32(flags);\n\tmemcpy(create.name, res->lockname.name, create.namelen);\n\n\ttmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\n\t\t\t\t    sizeof(create), res->owner, &status);\n\tif (tmpret >= 0) {\n\t\tret = status;\n\t\tif (ret == DLM_REJECTED) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\", dlm->name, create.namelen,\n\t\t\t     create.name, res->owner);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\", dlm->name, create.namelen, create.name,\n\t\t     tmpret, res->owner);\n\t\tif (dlm_is_host_down(tmpret))\n\t\t\tret = DLM_RECOVERING;\n\t\telse\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags)\n{\n\tstruct dlm_create_lock create;\n\tint tmpret, status = 0;\n\tenum dlm_status ret;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.node_idx = dlm->node_num;\n\tcreate.requested_type = lock->ml.type;\n\tcreate.cookie = lock->ml.cookie;\n\tcreate.namelen = res->lockname.len;\n\tcreate.flags = cpu_to_be32(flags);\n\tmemcpy(create.name, res->lockname.name, create.namelen);\n\n\ttmpret = o2net_send_message(DLM_CREATE_LOCK_MSG, dlm->key, &create,\n\t\t\t\t    sizeof(create), res->owner, &status);\n\tif (tmpret >= 0) {\n\t\tret = status;\n\t\tif (ret == DLM_REJECTED) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Stale lockres no longer \"\n\t\t\t     \"owned by node %u. That node is coming back up \"\n\t\t\t     \"currently.\\n\", dlm->name, create.namelen,\n\t\t\t     create.name, res->owner);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send CREATE LOCK to \"\n\t\t     \"node %u\\n\", dlm->name, create.namelen, create.name,\n\t\t     tmpret, res->owner);\n\t\tif (dlm_is_host_down(tmpret))\n\t\t\tret = DLM_RECOVERING;\n\t\telse\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->list",
            "&res->blocked"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "res"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"type=%d, lockres %.*s, flags = 0x%x\\n\"",
            "lock->ml.type",
            "res->lockname.len",
            "res->lockname.name",
            "flags"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlmlock_remote(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tenum dlm_status status = DLM_DENIED;\n\tint lockres_changed = 1;\n\n\tmlog(0, \"type=%d, lockres %.*s, flags = 0x%x\\n\",\n\t     lock->ml.type, res->lockname.len,\n\t     res->lockname.name, flags);\n\n\t/*\n\t * Wait if resource is getting recovered, remastered, etc.\n\t * If the resource was remastered and new owner is self, then exit.\n\t */\n\tspin_lock(&res->spinlock);\n\t__dlm_wait_on_lockres(res);\n\tif (res->owner == dlm->node_num) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn DLM_RECOVERING;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\t/* add lock to local (secondary) queue */\n\tdlm_lock_get(lock);\n\tlist_add_tail(&lock->list, &res->blocked);\n\tlock->lock_pending = 1;\n\tspin_unlock(&res->spinlock);\n\n\t/* spec seems to say that you will get DLM_NORMAL when the lock\n\t * has been queued, meaning we need to wait for a reply here. */\n\tstatus = dlm_send_remote_lock_request(dlm, res, lock, flags);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->lock_pending = 0;\n\tif (status != DLM_NORMAL) {\n\t\tif (status == DLM_RECOVERING &&\n\t\t    dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\t/* recovery lock was mastered by dead node.\n\t\t\t * we need to have calc_usage shoot down this\n\t\t\t * lockres and completely remaster it. */\n\t\t\tmlog(0, \"%s: recovery lock was owned by \"\n\t\t\t     \"dead node %u, remaster it now.\\n\",\n\t\t\t     dlm->name, res->owner);\n\t\t} else if (status != DLM_NOTQUEUED) {\n\t\t\t/*\n\t\t\t * DO NOT call calc_usage, as this would unhash\n\t\t\t * the remote lockres before we ever get to use\n\t\t\t * it.  treat as if we never made any change to\n\t\t\t * the lockres.\n\t\t\t */\n\t\t\tlockres_changed = 0;\n\t\t\tdlm_error(status);\n\t\t}\n\t\tdlm_revert_pending_lock(res, lock);\n\t\tdlm_lock_put(lock);\n\t} else if (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\tres->lockname.len)) {\n\t\t/* special case for the $RECOVERY lock.\n\t\t * there will never be an AST delivered to put\n\t\t * this lock on the proper secondary queue\n\t\t * (granted), so do it manually. */\n\t\tmlog(0, \"%s: $RECOVERY lock for this node (%u) is \"\n\t\t     \"mastered by %u; got lock, manually granting (no ast)\\n\",\n\t\t     dlm->name, dlm->node_num, res->owner);\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (lockres_changed)\n\t\tdlm_lockres_calc_usage(dlm, res);\n\n\twake_up(&res->wq);\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_revert_pending_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "199-205",
    "snippet": "void dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}"
  },
  {
    "function_name": "dlmlock_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "119-197",
    "snippet": "static enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_queue_ast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_queue_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "146-154",
          "snippet": "void dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->list",
            "&res->blocked"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\"",
            "dlm->name",
            "lock->ml.node"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"I can grant this lock right away\\n\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_can_grant_new_lock",
          "args": [
            "res",
            "lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_can_grant_new_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "91-110",
          "snippet": "static int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type,\n\t\t\t\t\t lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type,\n\t\t\t\t\t lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "res"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_state_to_status",
          "args": [
            "res"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_state_to_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "796-811",
          "snippet": "static inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"type=%d\\n\"",
            "lock->ml.type"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic enum dlm_status dlmlock_master(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock, int flags)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status = DLM_NORMAL;\n\n\tmlog(0, \"type=%d\\n\", lock->ml.type);\n\n\tspin_lock(&res->spinlock);\n\t/* if called from dlm_create_lock_handler, need to\n\t * ensure it will not sleep in dlm_wait_on_lockres */\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL &&\n\t    lock->ml.node != dlm->node_num) {\n\t\t/* erf.  state changed after lock was dropped. */\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\treturn status;\n\t}\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\n\tif (dlm_can_grant_new_lock(res, lock)) {\n\t\tmlog(0, \"I can grant this lock right away\\n\");\n\t\t/* got it right away */\n\t\tlock->lksb->status = DLM_NORMAL;\n\t\tstatus = DLM_NORMAL;\n\t\tdlm_lock_get(lock);\n\t\tlist_add_tail(&lock->list, &res->granted);\n\n\t\t/* for the recovery lock, we can't allow the ast\n\t\t * to be queued since the dlmthread is already\n\t\t * frozen.  but the recovery lock is always locked\n\t\t * with LKM_NOQUEUE so we do not need the ast in\n\t\t * this special case */\n\t\tif (!dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t  res->lockname.len)) {\n\t\t\tkick_thread = 1;\n\t\t\tcall_ast = 1;\n\t\t} else {\n\t\t\tmlog(0, \"%s: returning DLM_NORMAL to \"\n\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t     lock->ml.node);\n\t\t}\n\t} else {\n\t\t/* for NOQUEUE request, unless we get the\n\t\t * lock right away, return DLM_NOTQUEUED */\n\t\tif (flags & LKM_NOQUEUE) {\n\t\t\tstatus = DLM_NOTQUEUED;\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tmlog(0, \"%s: returning NOTQUEUED to \"\n\t\t\t\t     \"node %u for reco lock\\n\", dlm->name,\n\t\t\t\t     lock->ml.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = DLM_NORMAL;\n\t\t\tdlm_lock_get(lock);\n\t\t\tlist_add_tail(&lock->list, &res->blocked);\n\t\t\tkick_thread = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_can_grant_new_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "91-110",
    "snippet": "static int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type,\n\t\t\t\t\t lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lock_compatible",
          "args": [
            "tmplock->ml.convert_type",
            "lock->ml.type"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1064-1080",
          "snippet": "static inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmplock",
            "&res->converting",
            "list"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmplock",
            "&res->granted",
            "list"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstatic int dlm_can_grant_new_lock(struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, lock->ml.type))\n\t\t\treturn 0;\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type,\n\t\t\t\t\t lock->ml.type))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dlm_destroy_lock_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "78-82",
    "snippet": "void dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lock_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlm_lock_cache"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nvoid dlm_destroy_lock_cache(void)\n{\n\tif (dlm_lock_cache)\n\t\tkmem_cache_destroy(dlm_lock_cache);\n}"
  },
  {
    "function_name": "dlm_init_lock_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
    "lines": "68-76",
    "snippet": "int dlm_init_lock_cache(void)\n{\n\tdlm_lock_cache = kmem_cache_create(\"o2dlm_lock\",\n\t\t\t\t\t   sizeof(struct dlm_lock),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dlm_lock_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lock_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"o2dlm_lock\"",
            "sizeof(struct dlm_lock)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\n\nint dlm_init_lock_cache(void)\n{\n\tdlm_lock_cache = kmem_cache_create(\"o2dlm_lock\",\n\t\t\t\t\t   sizeof(struct dlm_lock),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (dlm_lock_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]