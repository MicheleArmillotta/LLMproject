[
  {
    "function_name": "quota_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/netlink.c",
    "lines": "101-107",
    "snippet": "static int __init quota_init(void)\n{\n\tif (genl_register_family(&quota_genl_family) != 0)\n\t\tprintk(KERN_ERR\n\t\t       \"VFS: Failed to create quota netlink interface.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <net/genetlink.h>",
      "#include <net/netlink.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"VFS: Failed to create quota netlink interface.\\n\""
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genl_register_family",
          "args": [
            "&quota_genl_family"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cred.h>\n\nstatic struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};\n\nstatic int __init quota_init(void)\n{\n\tif (genl_register_family(&quota_genl_family) != 0)\n\t\tprintk(KERN_ERR\n\t\t       \"VFS: Failed to create quota netlink interface.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "quota_send_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/netlink.c",
    "lines": "44-98",
    "snippet": "void quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}",
    "includes": [
      "#include <net/genetlink.h>",
      "#include <net/netlink.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"VFS: Not enough space to compose quota message!\\n\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genlmsg_multicast",
          "args": [
            "&quota_genl_family",
            "skb",
            "0",
            "0",
            "GFP_NOFS"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_end",
          "args": [
            "skb",
            "msg_head"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u64",
          "args": [
            "skb",
            "QUOTA_NL_A_CAUSED_ID",
            "from_kuid_munged(&init_user_ns, current_uid())"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "skb",
            "QUOTA_NL_A_DEV_MINOR",
            "MINOR(dev)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "skb",
            "QUOTA_NL_A_DEV_MAJOR",
            "MAJOR(dev)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "skb",
            "QUOTA_NL_A_WARNING",
            "warntype"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u64",
          "args": [
            "skb",
            "QUOTA_NL_A_EXCESS_ID",
            "from_kqid_munged(&init_user_ns, qid)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid_munged",
          "args": [
            "&init_user_ns",
            "qid"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "skb",
            "QUOTA_NL_A_QTYPE",
            "qid.type"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_put",
          "args": [
            "skb",
            "0",
            "atomic_add_return(1, &seq)",
            "&quota_genl_family",
            "0",
            "QUOTA_NL_C_WARNING"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&seq"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_new",
          "args": [
            "msg_size",
            "GFP_NOFS"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_total_size",
          "args": [
            "sizeof(u64)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_total_size",
          "args": [
            "sizeof(u32)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cred.h>\n\nstatic struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};\n\nvoid quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}"
  }
]