[
  {
    "function_name": "o2net_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2212-2219",
    "snippet": "void o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_handshake *o2net_hand;",
      "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_debugfs_exit",
          "args": [],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debugfs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "138-140",
          "snippet": "static inline void o2net_debugfs_exit(void)\n{\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline void o2net_debugfs_exit(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_keep_resp"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_keep_req"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_hand"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_exit",
          "args": [],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "335-340",
          "snippet": "void o2quo_exit(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tflush_work(&qs->qs_work);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nvoid o2quo_exit(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tflush_work(&qs->qs_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nvoid o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}"
  },
  {
    "function_name": "o2net_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2164-2210",
    "snippet": "int o2net_init(void)\n{\n\tunsigned long i;\n\n\to2quo_init();\n\n\tif (o2net_debugfs_init())\n\t\tgoto out;\n\n\to2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);\n\to2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\to2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\tif (!o2net_hand || !o2net_keep_req || !o2net_keep_resp)\n\t\tgoto out;\n\n\to2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\n\to2net_hand->connector_id = cpu_to_be64(1);\n\n\to2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\n\to2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(i);\n\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tspin_lock_init(&nn->nn_lock);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_expired,\n\t\t\t\t  o2net_connect_expired);\n\t\tINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\n\t\t/* until we see hb from a node we'll return einval */\n\t\tnn->nn_persistent_error = -ENOTCONN;\n\t\tinit_waitqueue_head(&nn->nn_sc_wq);\n\t\tidr_init(&nn->nn_status_idr);\n\t\tINIT_LIST_HEAD(&nn->nn_status_list);\n\t}\n\n\treturn 0;\n\nout:\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\n\to2quo_exit();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];",
      "static struct o2net_handshake *o2net_hand;",
      "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2quo_exit",
          "args": [],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "335-340",
          "snippet": "void o2quo_exit(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tflush_work(&qs->qs_work);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nvoid o2quo_exit(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tflush_work(&qs->qs_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_keep_resp"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_keep_req"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o2net_hand"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->nn_status_list"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&nn->nn_status_idr"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&nn->nn_sc_wq"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&nn->nn_still_up",
            "o2net_still_up"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&nn->nn_connect_expired",
            "o2net_connect_expired"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&nn->nn_connect_work",
            "o2net_start_connect"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "i"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "o2net_nodes"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "O2NET_MSG_KEEP_RESP_MAGIC"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "O2NET_MSG_KEEP_REQ_MAGIC"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "1"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "O2NET_PROTOCOL_VERSION"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2net_msg)",
            "GFP_KERNEL"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2net_msg)",
            "GFP_KERNEL"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2net_handshake)",
            "GFP_KERNEL"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_debugfs_init",
          "args": [],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "134-137",
          "snippet": "static inline int o2net_debugfs_init(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline int o2net_debugfs_init(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2quo_init",
          "args": [],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "327-333",
          "snippet": "void o2quo_init(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_init(&qs->qs_lock);\n\tINIT_WORK(&qs->qs_work, o2quo_make_decision);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nvoid o2quo_init(void)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock_init(&qs->qs_lock);\n\tINIT_WORK(&qs->qs_work, o2quo_make_decision);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nint o2net_init(void)\n{\n\tunsigned long i;\n\n\to2quo_init();\n\n\tif (o2net_debugfs_init())\n\t\tgoto out;\n\n\to2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);\n\to2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\to2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\tif (!o2net_hand || !o2net_keep_req || !o2net_keep_resp)\n\t\tgoto out;\n\n\to2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\n\to2net_hand->connector_id = cpu_to_be64(1);\n\n\to2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\n\to2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(i);\n\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tspin_lock_init(&nn->nn_lock);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_expired,\n\t\t\t\t  o2net_connect_expired);\n\t\tINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\n\t\t/* until we see hb from a node we'll return einval */\n\t\tnn->nn_persistent_error = -ENOTCONN;\n\t\tinit_waitqueue_head(&nn->nn_sc_wq);\n\t\tidr_init(&nn->nn_status_idr);\n\t\tINIT_LIST_HEAD(&nn->nn_status_list);\n\t}\n\n\treturn 0;\n\nout:\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\n\to2quo_exit();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "o2net_stop_listening",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2129-2160",
    "snippet": "void o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];",
      "static struct socket *o2net_listen_sock;",
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2quo_conn_err",
          "args": [
            "node->nd_num"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "304-325",
          "snippet": "void o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "o2net_listen_sock"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "o2net_wq"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_KTHREAD",
            "\"waiting for o2net thread to exit....\\n\""
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "node"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_disconnect_node",
          "args": [
            "node"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_disconnect_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1755-1771",
          "snippet": "void o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\n\nvoid o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "i"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "o2net_nodes"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sock->sk->sk_callback_lock"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sock->sk->sk_callback_lock"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "o2net_listen_sock == NULL"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "o2net_wq == NULL"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\nstatic struct socket *o2net_listen_sock;\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nvoid o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}"
  },
  {
    "function_name": "o2net_start_listening",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2102-2125",
    "snippet": "int o2net_start_listening(struct o2nm_node *node)\n{\n\tint ret = 0;\n\n\tBUG_ON(o2net_wq != NULL);\n\tBUG_ON(o2net_listen_sock != NULL);\n\n\tmlog(ML_KTHREAD, \"starting o2net thread...\\n\");\n\to2net_wq = create_singlethread_workqueue(\"o2net\");\n\tif (o2net_wq == NULL) {\n\t\tmlog(ML_ERROR, \"unable to launch o2net thread\\n\");\n\t\treturn -ENOMEM; /* ? */\n\t}\n\n\tret = o2net_open_listening_sock(node->nd_ipv4_address,\n\t\t\t\t\tnode->nd_ipv4_port);\n\tif (ret) {\n\t\tdestroy_workqueue(o2net_wq);\n\t\to2net_wq = NULL;\n\t} else\n\t\to2quo_conn_up(node->nd_num);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *o2net_listen_sock;",
      "static struct workqueue_struct *o2net_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2quo_conn_up",
          "args": [
            "node->nd_num"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "278-298",
          "snippet": "void o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "o2net_wq"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_open_listening_sock",
          "args": [
            "node->nd_ipv4_address",
            "node->nd_ipv4_port"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_open_listening_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2047-2093",
          "snippet": "static int o2net_open_listening_sock(__be32 addr, __be16 port)\n{\n\tstruct socket *sock = NULL;\n\tint ret;\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = PF_INET,\n\t\t.sin_addr = { .s_addr = addr },\n\t\t.sin_port = port,\n\t};\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while creating socket\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = o2net_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\to2net_listen_sock = sock;\n\tINIT_WORK(&o2net_listen_work, o2net_accept_many);\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while binding socket at \"\n\t\t       \"%pI4:%u\\n\", ret, &addr, ntohs(port)); \n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\",\n\t\t       ret, &addr, ntohs(port));\n\nout:\n\tif (ret) {\n\t\to2net_listen_sock = NULL;\n\t\tif (sock)\n\t\t\tsock_release(sock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *o2net_listen_sock;",
            "static struct work_struct o2net_listen_work;",
            "static void o2net_listen_data_ready(struct sock *sk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct socket *o2net_listen_sock;\nstatic struct work_struct o2net_listen_work;\nstatic void o2net_listen_data_ready(struct sock *sk);\n\nstatic int o2net_open_listening_sock(__be32 addr, __be16 port)\n{\n\tstruct socket *sock = NULL;\n\tint ret;\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = PF_INET,\n\t\t.sin_addr = { .s_addr = addr },\n\t\t.sin_port = port,\n\t};\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while creating socket\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = o2net_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\to2net_listen_sock = sock;\n\tINIT_WORK(&o2net_listen_work, o2net_accept_many);\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while binding socket at \"\n\t\t       \"%pI4:%u\\n\", ret, &addr, ntohs(port)); \n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\",\n\t\t       ret, &addr, ntohs(port));\n\nout:\n\tif (ret) {\n\t\to2net_listen_sock = NULL;\n\t\tif (sock)\n\t\t\tsock_release(sock);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to launch o2net thread\\n\""
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"o2net\""
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "o2net_listen_sock != NULL"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "o2net_wq != NULL"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct socket *o2net_listen_sock;\nstatic struct workqueue_struct *o2net_wq;\n\nint o2net_start_listening(struct o2nm_node *node)\n{\n\tint ret = 0;\n\n\tBUG_ON(o2net_wq != NULL);\n\tBUG_ON(o2net_listen_sock != NULL);\n\n\tmlog(ML_KTHREAD, \"starting o2net thread...\\n\");\n\to2net_wq = create_singlethread_workqueue(\"o2net\");\n\tif (o2net_wq == NULL) {\n\t\tmlog(ML_ERROR, \"unable to launch o2net thread\\n\");\n\t\treturn -ENOMEM; /* ? */\n\t}\n\n\tret = o2net_open_listening_sock(node->nd_ipv4_address,\n\t\t\t\t\tnode->nd_ipv4_port);\n\tif (ret) {\n\t\tdestroy_workqueue(o2net_wq);\n\t\to2net_wq = NULL;\n\t} else\n\t\to2quo_conn_up(node->nd_num);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_open_listening_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2047-2093",
    "snippet": "static int o2net_open_listening_sock(__be32 addr, __be16 port)\n{\n\tstruct socket *sock = NULL;\n\tint ret;\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = PF_INET,\n\t\t.sin_addr = { .s_addr = addr },\n\t\t.sin_port = port,\n\t};\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while creating socket\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = o2net_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\to2net_listen_sock = sock;\n\tINIT_WORK(&o2net_listen_work, o2net_accept_many);\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while binding socket at \"\n\t\t       \"%pI4:%u\\n\", ret, &addr, ntohs(port)); \n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\",\n\t\t       ret, &addr, ntohs(port));\n\nout:\n\tif (ret) {\n\t\to2net_listen_sock = NULL;\n\t\tif (sock)\n\t\t\tsock_release(sock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *o2net_listen_sock;",
      "static struct work_struct o2net_listen_work;",
      "static void o2net_listen_data_ready(struct sock *sk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sock"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\"",
            "ret",
            "&addr",
            "ntohs(port)"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->listen",
          "args": [
            "sock",
            "64"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->bind",
          "args": [
            "sock",
            "(struct sockaddr *)&sin",
            "sizeof(sin)"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&o2net_listen_work",
            "o2net_accept_many"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sock->sk->sk_callback_lock"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sock->sk->sk_callback_lock"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&sock"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct socket *o2net_listen_sock;\nstatic struct work_struct o2net_listen_work;\nstatic void o2net_listen_data_ready(struct sock *sk);\n\nstatic int o2net_open_listening_sock(__be32 addr, __be16 port)\n{\n\tstruct socket *sock = NULL;\n\tint ret;\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = PF_INET,\n\t\t.sin_addr = { .s_addr = addr },\n\t\t.sin_port = port,\n\t};\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while creating socket\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_user_data = sock->sk->sk_data_ready;\n\tsock->sk->sk_data_ready = o2net_listen_data_ready;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\to2net_listen_sock = sock;\n\tINIT_WORK(&o2net_listen_work, o2net_accept_many);\n\n\tsock->sk->sk_reuse = SK_CAN_REUSE;\n\tret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"o2net: Error %d while binding socket at \"\n\t\t       \"%pI4:%u\\n\", ret, &addr, ntohs(port)); \n\t\tgoto out;\n\t}\n\n\tret = sock->ops->listen(sock, 64);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"o2net: Error %d while listening on %pI4:%u\\n\",\n\t\t       ret, &addr, ntohs(port));\n\nout:\n\tif (ret) {\n\t\to2net_listen_sock = NULL;\n\t\tif (sock)\n\t\t\tsock_release(sock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_listen_data_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "2011-2045",
    "snippet": "static void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) { /* check for teardown race */\n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t/* This callback may called twice when a new connection\n\t * is  being established as a child socket inherits everything\n\t * from a parent LISTEN socket, including the data_ready cb of\n\t * the parent. This leads to a hazard. In o2net_accept_one()\n\t * we are still initializing the child socket but have not\n\t * changed the inherited data_ready callback yet when\n\t * data starts arriving.\n\t * We avoid this hazard by checking the state.\n\t * For the listening socket,  the state will be TCP_LISTEN; for the new\n\t * socket, will be  TCP_ESTABLISHED. Also, in this case,\n\t * sk->sk_user_data is not a valid function pointer.\n\t */\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static struct work_struct o2net_listen_work;",
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_idle_timer(unsigned long data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ready",
          "args": [
            "sk"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_listen_data_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2011-2045",
          "snippet": "static void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) { /* check for teardown race */\n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t/* This callback may called twice when a new connection\n\t * is  being established as a child socket inherits everything\n\t * from a parent LISTEN socket, including the data_ready cb of\n\t * the parent. This leads to a hazard. In o2net_accept_one()\n\t * we are still initializing the child socket but have not\n\t * changed the inherited data_ready callback yet when\n\t * data starts arriving.\n\t * We avoid this hazard by checking the state.\n\t * For the listening socket,  the state will be TCP_LISTEN; for the new\n\t * socket, will be  TCP_ESTABLISHED. Also, in this case,\n\t * sk->sk_user_data is not a valid function pointer.\n\t */\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "o2net_wq",
            "&o2net_listen_work"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic struct work_struct o2net_listen_work;\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_idle_timer(unsigned long data);\n\nstatic void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) { /* check for teardown race */\n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t/* This callback may called twice when a new connection\n\t * is  being established as a child socket inherits everything\n\t * from a parent LISTEN socket, including the data_ready cb of\n\t * the parent. This leads to a hazard. In o2net_accept_one()\n\t * we are still initializing the child socket but have not\n\t * changed the inherited data_ready callback yet when\n\t * data starts arriving.\n\t * We avoid this hazard by checking the state.\n\t * For the listening socket,  the state will be TCP_LISTEN; for the new\n\t * socket, will be  TCP_ESTABLISHED. Also, in this case,\n\t * sk->sk_user_data is not a valid function pointer.\n\t */\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}"
  },
  {
    "function_name": "o2net_accept_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1985-2009",
    "snippet": "static void o2net_accept_many(struct work_struct *work)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tint\tmore;\n\tint\terr;\n\n\t/*\n\t * It is critical to note that due to interrupt moderation\n\t * at the network driver level, we can't assume to get a\n\t * softIRQ for every single conn since tcp SYN packets\n\t * can arrive back-to-back, and therefore many pending\n\t * accepts may result in just 1 softIRQ. If we terminate\n\t * the o2net_accept_one() loop upon seeing an err, what happens\n\t * to the rest of the conns in the queue? If no new SYN\n\t * arrives for hours, no softIRQ  will be delivered,\n\t * and the connections will just sit in the queue.\n\t */\n\n\tfor (;;) {\n\t\terr = o2net_accept_one(sock, &more);\n\t\tif (!more)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *o2net_listen_sock;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_accept_one",
          "args": [
            "sock",
            "&more"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_accept_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1840-1977",
          "snippet": "static int o2net_accept_one(struct socket *sock, int *more)\n{\n\tint ret, slen;\n\tstruct sockaddr_in sin;\n\tstruct socket *new_sock = NULL;\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_node *local_node = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create_lite allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\tBUG_ON(sock == NULL);\n\t*more = 0;\n\tret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\n\t\t\t       sock->sk->sk_protocol, &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_sock->type = sock->type;\n\tnew_sock->ops = sock->ops;\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*more = 1;\n\tnew_sock->sk->sk_allocation = GFP_ATOMIC;\n\n\tret = o2net_set_nodelay(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tslen = sizeof(sin);\n\tret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin,\n\t\t\t\t       &slen, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\n\tif (node == NULL) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from unknown \"\n\t\t       \"node at %pI4:%d\\n\", &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (o2nm_this_node() >= node->nd_num) {\n\t\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\t\tif (local_node)\n\t\t\tprintk(KERN_NOTICE \"o2net: Unexpected connect attempt \"\n\t\t\t\t\t\"seen at node '%s' (%u, %pI4:%d) from \"\n\t\t\t\t\t\"node '%s' (%u, %pI4:%d)\\n\",\n\t\t\t\t\tlocal_node->nd_name, local_node->nd_num,\n\t\t\t\t\t&(local_node->nd_ipv4_address),\n\t\t\t\t\tntohs(local_node->nd_ipv4_port),\n\t\t\t\t\tnode->nd_name,\n\t\t\t\t\tnode->nd_num, &sin.sin_addr.s_addr,\n\t\t\t\t\tntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this happens all the time when the other node sees our heartbeat\n\t * and tries to connect before we see their heartbeat */\n\tif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\n\t\tmlog(ML_CONN, \"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\",\n\t\t     node->nd_name, &sin.sin_addr.s_addr,\n\t\t     ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnn = o2net_nn_from_num(node->nd_num);\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\tspin_unlock(&nn->nn_lock);\n\tif (ret) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\",\n\t\t       node->nd_name, &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tgoto out;\n\t}\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->sc_sock = new_sock;\n\tnew_sock = NULL;\n\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\nout:\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (local_node)\n\t\to2nm_node_put(local_node);\n\tif (sc)\n\t\tsc_put(sc);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_handshake *o2net_hand;",
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_accept_one(struct socket *sock, int *more)\n{\n\tint ret, slen;\n\tstruct sockaddr_in sin;\n\tstruct socket *new_sock = NULL;\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_node *local_node = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create_lite allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\tBUG_ON(sock == NULL);\n\t*more = 0;\n\tret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\n\t\t\t       sock->sk->sk_protocol, &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_sock->type = sock->type;\n\tnew_sock->ops = sock->ops;\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*more = 1;\n\tnew_sock->sk->sk_allocation = GFP_ATOMIC;\n\n\tret = o2net_set_nodelay(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tslen = sizeof(sin);\n\tret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin,\n\t\t\t\t       &slen, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\n\tif (node == NULL) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from unknown \"\n\t\t       \"node at %pI4:%d\\n\", &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (o2nm_this_node() >= node->nd_num) {\n\t\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\t\tif (local_node)\n\t\t\tprintk(KERN_NOTICE \"o2net: Unexpected connect attempt \"\n\t\t\t\t\t\"seen at node '%s' (%u, %pI4:%d) from \"\n\t\t\t\t\t\"node '%s' (%u, %pI4:%d)\\n\",\n\t\t\t\t\tlocal_node->nd_name, local_node->nd_num,\n\t\t\t\t\t&(local_node->nd_ipv4_address),\n\t\t\t\t\tntohs(local_node->nd_ipv4_port),\n\t\t\t\t\tnode->nd_name,\n\t\t\t\t\tnode->nd_num, &sin.sin_addr.s_addr,\n\t\t\t\t\tntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this happens all the time when the other node sees our heartbeat\n\t * and tries to connect before we see their heartbeat */\n\tif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\n\t\tmlog(ML_CONN, \"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\",\n\t\t     node->nd_name, &sin.sin_addr.s_addr,\n\t\t     ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnn = o2net_nn_from_num(node->nd_num);\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\tspin_unlock(&nn->nn_lock);\n\tif (ret) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\",\n\t\t       node->nd_name, &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tgoto out;\n\t}\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->sc_sock = new_sock;\n\tnew_sock = NULL;\n\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\nout:\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (local_node)\n\t\to2nm_node_put(local_node);\n\tif (sc)\n\t\tsc_put(sc);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct socket *o2net_listen_sock;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nstatic void o2net_accept_many(struct work_struct *work)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tint\tmore;\n\tint\terr;\n\n\t/*\n\t * It is critical to note that due to interrupt moderation\n\t * at the network driver level, we can't assume to get a\n\t * softIRQ for every single conn since tcp SYN packets\n\t * can arrive back-to-back, and therefore many pending\n\t * accepts may result in just 1 softIRQ. If we terminate\n\t * the o2net_accept_one() loop upon seeing an err, what happens\n\t * to the rest of the conns in the queue? If no new SYN\n\t * arrives for hours, no softIRQ  will be delivered,\n\t * and the connections will just sit in the queue.\n\t */\n\n\tfor (;;) {\n\t\terr = o2net_accept_one(sock, &more);\n\t\tif (!more)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "o2net_accept_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1840-1977",
    "snippet": "static int o2net_accept_one(struct socket *sock, int *more)\n{\n\tint ret, slen;\n\tstruct sockaddr_in sin;\n\tstruct socket *new_sock = NULL;\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_node *local_node = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create_lite allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\tBUG_ON(sock == NULL);\n\t*more = 0;\n\tret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\n\t\t\t       sock->sk->sk_protocol, &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_sock->type = sock->type;\n\tnew_sock->ops = sock->ops;\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*more = 1;\n\tnew_sock->sk->sk_allocation = GFP_ATOMIC;\n\n\tret = o2net_set_nodelay(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tslen = sizeof(sin);\n\tret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin,\n\t\t\t\t       &slen, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\n\tif (node == NULL) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from unknown \"\n\t\t       \"node at %pI4:%d\\n\", &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (o2nm_this_node() >= node->nd_num) {\n\t\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\t\tif (local_node)\n\t\t\tprintk(KERN_NOTICE \"o2net: Unexpected connect attempt \"\n\t\t\t\t\t\"seen at node '%s' (%u, %pI4:%d) from \"\n\t\t\t\t\t\"node '%s' (%u, %pI4:%d)\\n\",\n\t\t\t\t\tlocal_node->nd_name, local_node->nd_num,\n\t\t\t\t\t&(local_node->nd_ipv4_address),\n\t\t\t\t\tntohs(local_node->nd_ipv4_port),\n\t\t\t\t\tnode->nd_name,\n\t\t\t\t\tnode->nd_num, &sin.sin_addr.s_addr,\n\t\t\t\t\tntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this happens all the time when the other node sees our heartbeat\n\t * and tries to connect before we see their heartbeat */\n\tif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\n\t\tmlog(ML_CONN, \"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\",\n\t\t     node->nd_name, &sin.sin_addr.s_addr,\n\t\t     ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnn = o2net_nn_from_num(node->nd_num);\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\tspin_unlock(&nn->nn_lock);\n\tif (ret) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\",\n\t\t       node->nd_name, &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tgoto out;\n\t}\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->sc_sock = new_sock;\n\tnew_sock = NULL;\n\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\nout:\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (local_node)\n\t\to2nm_node_put(local_node);\n\tif (sc)\n\t\tsc_put(sc);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_handshake *o2net_hand;",
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memalloc_noio_restore",
          "args": [
            "noio_flag"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "local_node"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "new_sock"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_sendpage",
          "args": [
            "sc",
            "o2net_hand",
            "sizeof(*o2net_hand)"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sendpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "946-973",
          "snippet": "static void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_initialize_handshake",
          "args": [],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_initialize_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1492-1501",
          "snippet": "static void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_handshake *o2net_hand;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\n\nstatic void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_queue_work",
          "args": [
            "sc",
            "&sc->sc_rx_work"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_register_callbacks",
          "args": [
            "sc->sc_sock->sk",
            "sc"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_register_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "661-684",
          "snippet": "static void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_idle_timer(unsigned long data);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "sc",
            "0",
            "0"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_alloc",
          "args": [
            "node"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "sc_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "425-470",
          "snippet": "static struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\"",
            "node->nd_name",
            "&sin.sin_addr.s_addr",
            "ntohs(sin.sin_port)"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sin.sin_port"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "node->nd_num"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_CONN",
            "\"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\"",
            "node->nd_name",
            "&sin.sin_addr.s_addr",
            "ntohs(sin.sin_port)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sin.sin_port"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2hb_check_node_heartbeating_from_callback",
          "args": [
            "node->nd_num"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_check_node_heartbeating_from_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2594-2607",
          "snippet": "int o2hb_check_node_heartbeating_from_callback(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\to2hb_fill_node_map_from_callback(testing_map, sizeof(testing_map));\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint o2hb_check_node_heartbeating_from_callback(u8 node_num)\n{\n\tunsigned long testing_map[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\n\to2hb_fill_node_map_from_callback(testing_map, sizeof(testing_map));\n\tif (!test_bit(node_num, testing_map)) {\n\t\tmlog(ML_HEARTBEAT,\n\t\t     \"node (%u) does not have heartbeating enabled.\\n\",\n\t\t     node_num);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sin.sin_port"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "local_node->nd_ipv4_port"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "o2nm_this_node()"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sin.sin_port"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_ip",
          "args": [
            "sin.sin_addr.s_addr"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "112-128",
          "snippet": "struct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_sock->ops->getname",
          "args": [
            "new_sock",
            "(struct sockaddr *) &sin",
            "&slen",
            "1"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"set TCP_USER_TIMEOUT failed with %d\\n\"",
            "ret"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_usertimeout",
          "args": [
            "new_sock"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_usertimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1484-1490",
          "snippet": "static int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nodelay",
          "args": [
            "new_sock"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1459-1482",
          "snippet": "static int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock->ops->accept",
          "args": [
            "sock",
            "new_sock",
            "O_NONBLOCK"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_lite",
          "args": [
            "sock->sk->sk_family",
            "sock->sk->sk_type",
            "sock->sk->sk_protocol",
            "&new_sock"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sock == NULL"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_noio_save",
          "args": [],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_accept_one(struct socket *sock, int *more)\n{\n\tint ret, slen;\n\tstruct sockaddr_in sin;\n\tstruct socket *new_sock = NULL;\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_node *local_node = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create_lite allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\tBUG_ON(sock == NULL);\n\t*more = 0;\n\tret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\n\t\t\t       sock->sk->sk_protocol, &new_sock);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_sock->type = sock->type;\n\tnew_sock->ops = sock->ops;\n\tret = sock->ops->accept(sock, new_sock, O_NONBLOCK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*more = 1;\n\tnew_sock->sk->sk_allocation = GFP_ATOMIC;\n\n\tret = o2net_set_nodelay(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(new_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tslen = sizeof(sin);\n\tret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin,\n\t\t\t\t       &slen, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\n\tif (node == NULL) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from unknown \"\n\t\t       \"node at %pI4:%d\\n\", &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (o2nm_this_node() >= node->nd_num) {\n\t\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\t\tif (local_node)\n\t\t\tprintk(KERN_NOTICE \"o2net: Unexpected connect attempt \"\n\t\t\t\t\t\"seen at node '%s' (%u, %pI4:%d) from \"\n\t\t\t\t\t\"node '%s' (%u, %pI4:%d)\\n\",\n\t\t\t\t\tlocal_node->nd_name, local_node->nd_num,\n\t\t\t\t\t&(local_node->nd_ipv4_address),\n\t\t\t\t\tntohs(local_node->nd_ipv4_port),\n\t\t\t\t\tnode->nd_name,\n\t\t\t\t\tnode->nd_num, &sin.sin_addr.s_addr,\n\t\t\t\t\tntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this happens all the time when the other node sees our heartbeat\n\t * and tries to connect before we see their heartbeat */\n\tif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\n\t\tmlog(ML_CONN, \"attempt to connect from node '%s' at \"\n\t\t     \"%pI4:%d but it isn't heartbeating\\n\",\n\t\t     node->nd_name, &sin.sin_addr.s_addr,\n\t\t     ntohs(sin.sin_port));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnn = o2net_nn_from_num(node->nd_num);\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\tspin_unlock(&nn->nn_lock);\n\tif (ret) {\n\t\tprintk(KERN_NOTICE \"o2net: Attempt to connect from node '%s' \"\n\t\t       \"at %pI4:%d but it already has an open connection\\n\",\n\t\t       node->nd_name, &sin.sin_addr.s_addr,\n\t\t       ntohs(sin.sin_port));\n\t\tgoto out;\n\t}\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsc->sc_sock = new_sock;\n\tnew_sock = NULL;\n\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\nout:\n\tif (new_sock)\n\t\tsock_release(new_sock);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (local_node)\n\t\to2nm_node_put(local_node);\n\tif (sc)\n\t\tsc_put(sc);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_register_hb_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1819-1836",
    "snippet": "int o2net_register_hb_callbacks(void)\n{\n\tint ret;\n\n\to2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    o2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\n\to2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    o2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\n\n\tret = o2hb_register_callback(NULL, &o2net_hb_up);\n\tif (ret == 0)\n\t\tret = o2hb_register_callback(NULL, &o2net_hb_down);\n\n\tif (ret)\n\t\to2net_unregister_hb_callbacks();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define O2NET_HB_PRI 0x1"
    ],
    "globals_used": [
      "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_unregister_hb_callbacks",
          "args": [],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_hb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1813-1817",
          "snippet": "void o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nvoid o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_register_callback",
          "args": [
            "NULL",
            "&o2net_hb_down"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_register_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2492-2533",
          "snippet": "int o2hb_register_callback(const char *region_uuid,\n\t\t\t   struct o2hb_callback_func *hc)\n{\n\tstruct o2hb_callback_func *f;\n\tstruct o2hb_callback *hbcall;\n\tint ret;\n\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\tBUG_ON(!list_empty(&hc->hc_item));\n\n\thbcall = hbcall_from_type(hc->hc_type);\n\tif (IS_ERR(hbcall)) {\n\t\tret = PTR_ERR(hbcall);\n\t\tgoto out;\n\t}\n\n\tif (region_uuid) {\n\t\tret = o2hb_region_inc_user(region_uuid);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tif (hc->hc_priority < f->hc_priority) {\n\t\t\tlist_add_tail(&hc->hc_item, &f->hc_item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&hc->hc_item))\n\t\tlist_add_tail(&hc->hc_item, &hbcall->list);\n\n\tup_write(&o2hb_callback_sem);\n\tret = 0;\nout:\n\tmlog(ML_CLUSTER, \"returning %d on behalf of %p for funcs %p\\n\",\n\t     ret, __builtin_return_address(0), hc);\n\treturn ret;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static int o2hb_region_pin(const char *region_uuid);",
            "static void o2hb_region_unpin(const char *region_uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic int o2hb_region_pin(const char *region_uuid);\nstatic void o2hb_region_unpin(const char *region_uuid);\n\nint o2hb_register_callback(const char *region_uuid,\n\t\t\t   struct o2hb_callback_func *hc)\n{\n\tstruct o2hb_callback_func *f;\n\tstruct o2hb_callback *hbcall;\n\tint ret;\n\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\tBUG_ON(!list_empty(&hc->hc_item));\n\n\thbcall = hbcall_from_type(hc->hc_type);\n\tif (IS_ERR(hbcall)) {\n\t\tret = PTR_ERR(hbcall);\n\t\tgoto out;\n\t}\n\n\tif (region_uuid) {\n\t\tret = o2hb_region_inc_user(region_uuid);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_for_each_entry(f, &hbcall->list, hc_item) {\n\t\tif (hc->hc_priority < f->hc_priority) {\n\t\t\tlist_add_tail(&hc->hc_item, &f->hc_item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&hc->hc_item))\n\t\tlist_add_tail(&hc->hc_item, &hbcall->list);\n\n\tup_write(&o2hb_callback_sem);\n\tret = 0;\nout:\n\tmlog(ML_CLUSTER, \"returning %d on behalf of %p for funcs %p\\n\",\n\t     ret, __builtin_return_address(0), hc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_setup_callback",
          "args": [
            "&o2net_hb_up",
            "O2HB_NODE_UP_CB",
            "o2net_hb_node_up_cb",
            "NULL",
            "O2NET_HB_PRI"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_setup_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2337-2349",
          "snippet": "void o2hb_setup_callback(struct o2hb_callback_func *hc,\n\t\t\t enum o2hb_callback_type type,\n\t\t\t o2hb_cb_func *func,\n\t\t\t void *data,\n\t\t\t int priority)\n{\n\tINIT_LIST_HEAD(&hc->hc_item);\n\thc->hc_func = func;\n\thc->hc_data = data;\n\thc->hc_priority = priority;\n\thc->hc_type = type;\n\thc->hc_magic = O2HB_CB_MAGIC;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type);\n\nvoid o2hb_setup_callback(struct o2hb_callback_func *hc,\n\t\t\t enum o2hb_callback_type type,\n\t\t\t o2hb_cb_func *func,\n\t\t\t void *data,\n\t\t\t int priority)\n{\n\tINIT_LIST_HEAD(&hc->hc_item);\n\thc->hc_func = func;\n\thc->hc_data = data;\n\thc->hc_priority = priority;\n\thc->hc_type = type;\n\thc->hc_magic = O2HB_CB_MAGIC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define O2NET_HB_PRI 0x1\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nint o2net_register_hb_callbacks(void)\n{\n\tint ret;\n\n\to2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    o2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\n\to2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    o2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\n\n\tret = o2hb_register_callback(NULL, &o2net_hb_up);\n\tif (ret == 0)\n\t\tret = o2hb_register_callback(NULL, &o2net_hb_down);\n\n\tif (ret)\n\t\to2net_unregister_hb_callbacks();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_unregister_hb_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1813-1817",
    "snippet": "void o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2hb_unregister_callback",
          "args": [
            "NULL",
            "&o2net_hb_down"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_unregister_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2536-2556",
          "snippet": "void o2hb_unregister_callback(const char *region_uuid,\n\t\t\t      struct o2hb_callback_func *hc)\n{\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\n\tmlog(ML_CLUSTER, \"on behalf of %p for funcs %p\\n\",\n\t     __builtin_return_address(0), hc);\n\n\t/* XXX Can this happen _with_ a region reference? */\n\tif (list_empty(&hc->hc_item))\n\t\treturn;\n\n\tif (region_uuid)\n\t\to2hb_region_dec_user(region_uuid);\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_del_init(&hc->hc_item);\n\n\tup_write(&o2hb_callback_sem);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(o2hb_callback_sem);",
            "static int o2hb_region_pin(const char *region_uuid);",
            "static void o2hb_region_unpin(const char *region_uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(o2hb_callback_sem);\nstatic int o2hb_region_pin(const char *region_uuid);\nstatic void o2hb_region_unpin(const char *region_uuid);\n\nvoid o2hb_unregister_callback(const char *region_uuid,\n\t\t\t      struct o2hb_callback_func *hc)\n{\n\tBUG_ON(hc->hc_magic != O2HB_CB_MAGIC);\n\n\tmlog(ML_CLUSTER, \"on behalf of %p for funcs %p\\n\",\n\t     __builtin_return_address(0), hc);\n\n\t/* XXX Can this happen _with_ a region reference? */\n\tif (list_empty(&hc->hc_item))\n\t\treturn;\n\n\tif (region_uuid)\n\t\to2hb_region_dec_user(region_uuid);\n\n\tdown_write(&o2hb_callback_sem);\n\n\tlist_del_init(&hc->hc_item);\n\n\tup_write(&o2hb_callback_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nvoid o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}"
  },
  {
    "function_name": "o2net_hb_node_up_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1787-1811",
    "snippet": "static void o2net_hb_node_up_cb(struct o2nm_node *node, int node_num,\n\t\t\t\tvoid *data)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node_num);\n\n\to2quo_hb_up(node_num);\n\n\tBUG_ON(!node);\n\n\t/* ensure an immediate connect attempt */\n\tnn->nn_last_connect_attempt = jiffies -\n\t\t(msecs_to_jiffies(o2net_reconnect_delay()) + 1);\n\n\tif (node_num != o2nm_this_node()) {\n\t\t/* believe it or not, accept and node hearbeating testing\n\t\t * can succeed for this node before we got here.. so\n\t\t * only use set_nn_state to clear the persistent error\n\t\t * if that hasn't already happened */\n\t\tspin_lock(&nn->nn_lock);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tif (nn->nn_persistent_error)\n\t\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t\tspin_unlock(&nn->nn_lock);\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "NULL",
            "0",
            "0"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_reconnect_delay()"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_reconnect_delay",
          "args": [],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_reconnect_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "265-268",
          "snippet": "static inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!node"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_hb_up",
          "args": [
            "node_num"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_hb_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "210-230",
          "snippet": "void o2quo_hb_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_heartbeating++;\n\tmlog_bug_on_msg(qs->qs_heartbeating == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\tif (!test_bit(node, qs->qs_conn_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_hb_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_heartbeating++;\n\tmlog_bug_on_msg(qs->qs_heartbeating == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\tif (!test_bit(node, qs->qs_conn_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "node_num"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nstatic void o2net_hb_node_up_cb(struct o2nm_node *node, int node_num,\n\t\t\t\tvoid *data)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node_num);\n\n\to2quo_hb_up(node_num);\n\n\tBUG_ON(!node);\n\n\t/* ensure an immediate connect attempt */\n\tnn->nn_last_connect_attempt = jiffies -\n\t\t(msecs_to_jiffies(o2net_reconnect_delay()) + 1);\n\n\tif (node_num != o2nm_this_node()) {\n\t\t/* believe it or not, accept and node hearbeating testing\n\t\t * can succeed for this node before we got here.. so\n\t\t * only use set_nn_state to clear the persistent error\n\t\t * if that hasn't already happened */\n\t\tspin_lock(&nn->nn_lock);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tif (nn->nn_persistent_error)\n\t\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t\tspin_unlock(&nn->nn_lock);\n\t}\n}"
  },
  {
    "function_name": "o2net_hb_node_down_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1773-1785",
    "snippet": "static void o2net_hb_node_down_cb(struct o2nm_node *node, int node_num,\n\t\t\t\t  void *data)\n{\n\to2quo_hb_down(node_num);\n\n\tif (!node)\n\t\treturn;\n\n\tif (node_num != o2nm_this_node())\n\t\to2net_disconnect_node(node);\n\n\tBUG_ON(atomic_read(&o2net_connected_peers) < 0);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);",
      "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&o2net_connected_peers) < 0"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&o2net_connected_peers"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_disconnect_node",
          "args": [
            "node"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_disconnect_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1755-1771",
          "snippet": "void o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\n\nvoid o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2quo_hb_down",
          "args": [
            "node_num"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_hb_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "234-252",
          "snippet": "void o2quo_hb_down(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_heartbeating--;\n\tmlog_bug_on_msg(qs->qs_heartbeating < 0,\n\t\t\t\"node %u, %d heartbeating\\n\",\n\t\t\tnode, qs->qs_heartbeating);\n\tmlog_bug_on_msg(!test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tclear_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_hb_down(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_heartbeating--;\n\tmlog_bug_on_msg(qs->qs_heartbeating < 0,\n\t\t\t\"node %u, %d heartbeating\\n\",\n\t\t\tnode, qs->qs_heartbeating);\n\tmlog_bug_on_msg(!test_bit(node, qs->qs_hb_bm), \"node %u\\n\", node);\n\tclear_bit(node, qs->qs_hb_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_heartbeating);\n\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_hb_node_down_cb(struct o2nm_node *node, int node_num,\n\t\t\t\t  void *data)\n{\n\to2quo_hb_down(node_num);\n\n\tif (!node)\n\t\treturn;\n\n\tif (node_num != o2nm_this_node())\n\t\to2net_disconnect_node(node);\n\n\tBUG_ON(atomic_read(&o2net_connected_peers) < 0);\n}"
  },
  {
    "function_name": "o2net_disconnect_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1755-1771",
    "snippet": "void o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "o2net_wq"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nn->nn_still_up"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nn->nn_connect_work"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nn->nn_connect_expired"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "NULL",
            "0",
            "-ENOTCONN"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "node->nd_num"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\n\nvoid o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}"
  },
  {
    "function_name": "o2net_still_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1745-1751",
    "snippet": "static void o2net_still_up(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_still_up.work);\n\n\to2quo_hb_still_up(o2net_num_from_nn(nn));\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2quo_hb_still_up",
          "args": [
            "o2net_num_from_nn(nn)"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_hb_still_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "259-271",
          "snippet": "void o2quo_hb_still_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tmlog(0, \"node %u\\n\", node);\n\n\tqs->qs_pending = 1;\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nvoid o2quo_hb_still_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tmlog(0, \"node %u\\n\", node);\n\n\tqs->qs_pending = 1;\n\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_node",
            "nn_still_up.work"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nstatic void o2net_still_up(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_still_up.work);\n\n\to2quo_hb_still_up(o2net_num_from_nn(nn));\n}"
  },
  {
    "function_name": "o2net_connect_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1726-1743",
    "snippet": "static void o2net_connect_expired(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_expired.work);\n\n\tspin_lock(&nn->nn_lock);\n\tif (!nn->nn_sc_valid) {\n\t\tprintk(KERN_NOTICE \"o2net: No connection established with \"\n\t\t       \"node %u after %u.%u seconds, check network and\"\n\t\t       \" cluster configuration.\\n\",\n\t\t     o2net_num_from_nn(nn),\n\t\t     o2net_idle_timeout() / 1000,\n\t\t     o2net_idle_timeout() % 1000);\n\n\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "NULL",
            "0",
            "0"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: No connection established with \"\n\t\t       \"node %u after %u.%u seconds, check network and\"\n\t\t       \" cluster configuration.\\n\"",
            "o2net_num_from_nn(nn)",
            "o2net_idle_timeout() / 1000",
            "o2net_idle_timeout() % 1000"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_node",
            "nn_connect_expired.work"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nstatic void o2net_connect_expired(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_expired.work);\n\n\tspin_lock(&nn->nn_lock);\n\tif (!nn->nn_sc_valid) {\n\t\tprintk(KERN_NOTICE \"o2net: No connection established with \"\n\t\t       \"node %u after %u.%u seconds, check network and\"\n\t\t       \" cluster configuration.\\n\",\n\t\t     o2net_num_from_nn(nn),\n\t\t     o2net_idle_timeout() / 1000,\n\t\t     o2net_idle_timeout() % 1000);\n\n\t\to2net_set_nn_state(nn, NULL, 0, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n}"
  },
  {
    "function_name": "o2net_start_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1595-1724",
    "snippet": "static void o2net_start_connect(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_work.work);\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2nm_node *node = NULL, *mynode = NULL;\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_in myaddr = {0, }, remoteaddr = {0, };\n\tint ret = 0, stop;\n\tunsigned int timeout;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\t/* if we're greater we initiate tx, otherwise we accept */\n\tif (o2nm_this_node() <= o2net_num_from_nn(nn))\n\t\tgoto out;\n\n\t/* watch for racing with tearing a node down */\n\tnode = o2nm_get_node_by_num(o2net_num_from_nn(nn));\n\tif (node == NULL) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmynode = o2nm_get_node_by_num(o2nm_this_node());\n\tif (mynode == NULL) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&nn->nn_lock);\n\t/*\n\t * see if we already have one pending or have given up.\n\t * For nn_timeout, it is set when we close the connection\n\t * because of the idle time out. So it means that we have\n\t * at least connected to that node successfully once,\n\t * now try to connect to it again.\n\t */\n\ttimeout = atomic_read(&nn->nn_timeout);\n\tstop = (nn->nn_sc ||\n\t\t(nn->nn_persistent_error &&\n\t\t(nn->nn_persistent_error != -ENOTCONN || timeout == 0)));\n\tspin_unlock(&nn->nn_lock);\n\tif (stop)\n\t\tgoto out;\n\n\tnn->nn_last_connect_attempt = jiffies;\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tmlog(0, \"couldn't allocate sc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tmlog(0, \"can't create socket: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tsc->sc_sock = sock; /* freed by sc_kref_release */\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\tmyaddr.sin_family = AF_INET;\n\tmyaddr.sin_addr.s_addr = mynode->nd_ipv4_address;\n\tmyaddr.sin_port = htons(0); /* any port */\n\n\tret = sock->ops->bind(sock, (struct sockaddr *)&myaddr,\n\t\t\t      sizeof(myaddr));\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"bind failed with %d at address %pI4\\n\",\n\t\t     ret, &mynode->nd_ipv4_address);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_nodelay(sc->sc_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\n\tspin_lock(&nn->nn_lock);\n\t/* handshake completion will set nn->nn_sc_valid */\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\tremoteaddr.sin_family = AF_INET;\n\tremoteaddr.sin_addr.s_addr = node->nd_ipv4_address;\n\tremoteaddr.sin_port = node->nd_ipv4_port;\n\n\tret = sc->sc_sock->ops->connect(sc->sc_sock,\n\t\t\t\t\t(struct sockaddr *)&remoteaddr,\n\t\t\t\t\tsizeof(remoteaddr),\n\t\t\t\t\tO_NONBLOCK);\n\tif (ret == -EINPROGRESS)\n\t\tret = 0;\n\nout:\n\tif (ret && sc) {\n\t\tprintk(KERN_NOTICE \"o2net: Connect attempt to \" SC_NODEF_FMT\n\t\t       \" failed with errno %d\\n\", SC_NODEF_ARGS(sc), ret);\n\t\t/* 0 err so that another will be queued and attempted\n\t\t * from set_nn_state */\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\tif (sc)\n\t\tsc_put(sc);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (mynode)\n\t\to2nm_node_put(mynode);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memalloc_noio_restore",
          "args": [
            "noio_flag"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "mynode"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_ensure_shutdown",
          "args": [
            "nn",
            "sc",
            "0"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_ensure_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "709-717",
          "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: Connect attempt to \" SC_NODEF_FMT\n\t\t       \" failed with errno %d\\n\"",
            "SC_NODEF_ARGS(sc)",
            "ret"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_sock->ops->connect",
          "args": [
            "sc->sc_sock",
            "(struct sockaddr *)&remoteaddr",
            "sizeof(remoteaddr)",
            "O_NONBLOCK"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "sc",
            "0",
            "0"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_register_callbacks",
          "args": [
            "sc->sc_sock->sk",
            "sc"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_register_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "661-684",
          "snippet": "static void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_idle_timer(unsigned long data);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"set TCP_USER_TIMEOUT failed with %d\\n\"",
            "ret"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_usertimeout",
          "args": [
            "sock"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_usertimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1484-1490",
          "snippet": "static int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nodelay",
          "args": [
            "sc->sc_sock"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1459-1482",
          "snippet": "static int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bind failed with %d at address %pI4\\n\"",
            "ret",
            "&mynode->nd_ipv4_address"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock->ops->bind",
          "args": [
            "sock",
            "(struct sockaddr *)&myaddr",
            "sizeof(myaddr)"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "0"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "IPPROTO_TCP",
            "&sock"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"couldn't allocate sc\\n\""
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_alloc",
          "args": [
            "node"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "sc_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "425-470",
          "snippet": "static struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nn->nn_timeout"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "o2nm_this_node()"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noio_save",
          "args": [],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_node",
            "nn_connect_work.work"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_start_connect(struct work_struct *work)\n{\n\tstruct o2net_node *nn =\n\t\tcontainer_of(work, struct o2net_node, nn_connect_work.work);\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2nm_node *node = NULL, *mynode = NULL;\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_in myaddr = {0, }, remoteaddr = {0, };\n\tint ret = 0, stop;\n\tunsigned int timeout;\n\tunsigned int noio_flag;\n\n\t/*\n\t * sock_create allocates the sock with GFP_KERNEL. We must set\n\t * per-process flag PF_MEMALLOC_NOIO so that all allocations done\n\t * by this process are done as if GFP_NOIO was specified. So we\n\t * are not reentering filesystem while doing memory reclaim.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\t/* if we're greater we initiate tx, otherwise we accept */\n\tif (o2nm_this_node() <= o2net_num_from_nn(nn))\n\t\tgoto out;\n\n\t/* watch for racing with tearing a node down */\n\tnode = o2nm_get_node_by_num(o2net_num_from_nn(nn));\n\tif (node == NULL) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmynode = o2nm_get_node_by_num(o2nm_this_node());\n\tif (mynode == NULL) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&nn->nn_lock);\n\t/*\n\t * see if we already have one pending or have given up.\n\t * For nn_timeout, it is set when we close the connection\n\t * because of the idle time out. So it means that we have\n\t * at least connected to that node successfully once,\n\t * now try to connect to it again.\n\t */\n\ttimeout = atomic_read(&nn->nn_timeout);\n\tstop = (nn->nn_sc ||\n\t\t(nn->nn_persistent_error &&\n\t\t(nn->nn_persistent_error != -ENOTCONN || timeout == 0)));\n\tspin_unlock(&nn->nn_lock);\n\tif (stop)\n\t\tgoto out;\n\n\tnn->nn_last_connect_attempt = jiffies;\n\n\tsc = sc_alloc(node);\n\tif (sc == NULL) {\n\t\tmlog(0, \"couldn't allocate sc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (ret < 0) {\n\t\tmlog(0, \"can't create socket: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tsc->sc_sock = sock; /* freed by sc_kref_release */\n\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\n\tmyaddr.sin_family = AF_INET;\n\tmyaddr.sin_addr.s_addr = mynode->nd_ipv4_address;\n\tmyaddr.sin_port = htons(0); /* any port */\n\n\tret = sock->ops->bind(sock, (struct sockaddr *)&myaddr,\n\t\t\t      sizeof(myaddr));\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"bind failed with %d at address %pI4\\n\",\n\t\t     ret, &mynode->nd_ipv4_address);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_nodelay(sc->sc_sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"setting TCP_NODELAY failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = o2net_set_usertimeout(sock);\n\tif (ret) {\n\t\tmlog(ML_ERROR, \"set TCP_USER_TIMEOUT failed with %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\to2net_register_callbacks(sc->sc_sock->sk, sc);\n\n\tspin_lock(&nn->nn_lock);\n\t/* handshake completion will set nn->nn_sc_valid */\n\to2net_set_nn_state(nn, sc, 0, 0);\n\tspin_unlock(&nn->nn_lock);\n\n\tremoteaddr.sin_family = AF_INET;\n\tremoteaddr.sin_addr.s_addr = node->nd_ipv4_address;\n\tremoteaddr.sin_port = node->nd_ipv4_port;\n\n\tret = sc->sc_sock->ops->connect(sc->sc_sock,\n\t\t\t\t\t(struct sockaddr *)&remoteaddr,\n\t\t\t\t\tsizeof(remoteaddr),\n\t\t\t\t\tO_NONBLOCK);\n\tif (ret == -EINPROGRESS)\n\t\tret = 0;\n\nout:\n\tif (ret && sc) {\n\t\tprintk(KERN_NOTICE \"o2net: Connect attempt to \" SC_NODEF_FMT\n\t\t       \" failed with errno %d\\n\", SC_NODEF_ARGS(sc), ret);\n\t\t/* 0 err so that another will be queued and attempted\n\t\t * from set_nn_state */\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\tif (sc)\n\t\tsc_put(sc);\n\tif (node)\n\t\to2nm_node_put(node);\n\tif (mynode)\n\t\to2nm_node_put(mynode);\n\n\tmemalloc_noio_restore(noio_flag);\n\treturn;\n}"
  },
  {
    "function_name": "o2net_sc_postpone_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1574-1588",
    "snippet": "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\t/* clear fence decision since the connection recover from timeout*/\n\tif (atomic_read(&nn->nn_timeout)) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t}\n\n\t/* Only push out an existing timer */\n\tif (timer_pending(&sc->sc_idle_timeout))\n\t\to2net_sc_reset_idle_timer(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_sc_reset_idle_timer",
          "args": [
            "sc"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_reset_idle_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1564-1572",
          "snippet": "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&sc->sc_idle_timeout"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nn->nn_still_up"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_conn_up",
          "args": [
            "o2net_num_from_nn(nn)"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "278-298",
          "snippet": "void o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nn->nn_timeout"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\t/* clear fence decision since the connection recover from timeout*/\n\tif (atomic_read(&nn->nn_timeout)) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t}\n\n\t/* Only push out an existing timer */\n\tif (timer_pending(&sc->sc_idle_timeout))\n\t\to2net_sc_reset_idle_timer(sc);\n}"
  },
  {
    "function_name": "o2net_sc_reset_idle_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1564-1572",
    "snippet": "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&sc->sc_idle_timeout",
            "jiffies + msecs_to_jiffies(o2net_idle_timeout())"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_idle_timeout()"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_sock_timer",
          "args": [
            "sc"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_sock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "184-187",
          "snippet": "static inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_timer = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_timer = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_queue_delayed_work",
          "args": [
            "sc",
            "&sc->sc_keepalive_work",
            "msecs_to_jiffies(o2net_keepalive_delay())"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_keepalive_delay()"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_keepalive_delay",
          "args": [],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_keepalive_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "270-273",
          "snippet": "static inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_cancel_delayed_work",
          "args": [
            "sc",
            "&sc->sc_keepalive_work"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_cancel_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "489-494",
          "snippet": "static void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}"
  },
  {
    "function_name": "o2net_idle_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1536-1562",
    "snippet": "static void o2net_idle_timer(unsigned long data)\n{\n\tstruct o2net_sock_container *sc = (struct o2net_sock_container *)data;\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n#ifdef CONFIG_DEBUG_FS\n\tunsigned long msecs = ktime_to_ms(ktime_get()) -\n\t\tktime_to_ms(sc->sc_tv_timer);\n#else\n\tunsigned long msecs = o2net_idle_timeout();\n#endif\n\n\tprintk(KERN_NOTICE \"o2net: Connection to \" SC_NODEF_FMT \" has been \"\n\t       \"idle for %lu.%lu secs.\\n\",\n\t       SC_NODEF_ARGS(sc), msecs / 1000, msecs % 1000);\n\n\t/* idle timerout happen, don't shutdown the connection, but\n\t * make fence decision. Maybe the connection can recover before\n\t * the decision is made.\n\t */\n\tatomic_set(&nn->nn_timeout, 1);\n\to2quo_conn_err(o2net_num_from_nn(nn));\n\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\tmsecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\n\to2net_sc_reset_idle_timer(sc);\n\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_idle_timer(unsigned long data);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_sc_reset_idle_timer",
          "args": [
            "sc"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_reset_idle_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1564-1572",
          "snippet": "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "o2net_wq",
            "&nn->nn_still_up",
            "msecs_to_jiffies(O2NET_QUORUM_DELAY_MS)"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "O2NET_QUORUM_DELAY_MS"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_conn_err",
          "args": [
            "o2net_num_from_nn(nn)"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "304-325",
          "snippet": "void o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "1"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: Connection to \" SC_NODEF_FMT \" has been \"\n\t       \"idle for %lu.%lu secs.\\n\"",
            "SC_NODEF_ARGS(sc)",
            "msecs / 1000",
            "msecs % 1000"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ms",
          "args": [
            "sc->sc_tv_timer"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ms",
          "args": [
            "ktime_get()"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_idle_timer(unsigned long data)\n{\n\tstruct o2net_sock_container *sc = (struct o2net_sock_container *)data;\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n#ifdef CONFIG_DEBUG_FS\n\tunsigned long msecs = ktime_to_ms(ktime_get()) -\n\t\tktime_to_ms(sc->sc_tv_timer);\n#else\n\tunsigned long msecs = o2net_idle_timeout();\n#endif\n\n\tprintk(KERN_NOTICE \"o2net: Connection to \" SC_NODEF_FMT \" has been \"\n\t       \"idle for %lu.%lu secs.\\n\",\n\t       SC_NODEF_ARGS(sc), msecs / 1000, msecs % 1000);\n\n\t/* idle timerout happen, don't shutdown the connection, but\n\t * make fence decision. Maybe the connection can recover before\n\t * the decision is made.\n\t */\n\tatomic_set(&nn->nn_timeout, 1);\n\to2quo_conn_err(o2net_num_from_nn(nn));\n\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\tmsecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\n\to2net_sc_reset_idle_timer(sc);\n\n}"
  },
  {
    "function_name": "o2net_sc_send_keep_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1523-1531",
    "snippet": "static void o2net_sc_send_keep_req(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_keepalive_work.work);\n\n\to2net_sendpage(sc, o2net_keep_req, sizeof(*o2net_keep_req));\n\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sendpage",
          "args": [
            "sc",
            "o2net_keep_req",
            "sizeof(*o2net_keep_req)"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sendpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "946-973",
          "snippet": "static void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_sock_container",
            "sc_keepalive_work.work"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_send_keep_req(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_keepalive_work.work);\n\n\to2net_sendpage(sc, o2net_keep_req, sizeof(*o2net_keep_req));\n\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_sc_connect_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1507-1520",
    "snippet": "static void o2net_sc_connect_completed(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_connect_work);\n\n\tmlog(ML_MSG, \"sc sending handshake with ver %llu id %llx\\n\",\n              (unsigned long long)O2NET_PROTOCOL_VERSION,\n\t      (unsigned long long)be64_to_cpu(o2net_hand->connector_id));\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_handshake *o2net_hand;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sendpage",
          "args": [
            "sc",
            "o2net_hand",
            "sizeof(*o2net_hand)"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sendpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "946-973",
          "snippet": "static void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_initialize_handshake",
          "args": [],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_initialize_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1492-1501",
          "snippet": "static void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_handshake *o2net_hand;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\n\nstatic void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_MSG",
            "\"sc sending handshake with ver %llu id %llx\\n\"",
            "(unsigned long long)O2NET_PROTOCOL_VERSION",
            "(unsigned long long)be64_to_cpu(o2net_hand->connector_id)"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "o2net_hand->connector_id"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_sock_container",
            "sc_connect_work"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_connect_completed(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_connect_work);\n\n\tmlog(ML_MSG, \"sc sending handshake with ver %llu id %llx\\n\",\n              (unsigned long long)O2NET_PROTOCOL_VERSION,\n\t      (unsigned long long)be64_to_cpu(o2net_hand->connector_id));\n\n\to2net_initialize_handshake();\n\to2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\n\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_initialize_handshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1492-1501",
    "snippet": "static void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_handshake *o2net_hand;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "o2net_reconnect_delay()"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_reconnect_delay",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_reconnect_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "265-268",
          "snippet": "static inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "o2net_keepalive_delay()"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_keepalive_delay",
          "args": [],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_keepalive_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "270-273",
          "snippet": "static inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "o2net_idle_timeout()"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "O2HB_MAX_WRITE_TIMEOUT_MS"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\n\nstatic void o2net_initialize_handshake(void)\n{\n\to2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\n\t\tO2HB_MAX_WRITE_TIMEOUT_MS);\n\to2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\n\to2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\n\t\to2net_keepalive_delay());\n\to2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\n\t\to2net_reconnect_delay());\n}"
  },
  {
    "function_name": "o2net_set_usertimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1484-1490",
    "snippet": "static int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "sock",
            "SOL_TCP",
            "TCP_USER_TIMEOUT",
            "(char *)&user_timeout",
            "sizeof(user_timeout)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_usertimeout(struct socket *sock)\n{\n\tint user_timeout = O2NET_TCP_USER_TIMEOUT;\n\n\treturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t(char *)&user_timeout, sizeof(user_timeout));\n}"
  },
  {
    "function_name": "o2net_set_nodelay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1459-1482",
    "snippet": "static int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "oldfs"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock->ops->setsockopt",
          "args": [
            "sock",
            "SOL_TCP",
            "TCP_NODELAY",
            "(char __user *)&val",
            "sizeof(val)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_set_nodelay(struct socket *sock)\n{\n\tint ret, val = 1;\n\tmm_segment_t oldfs;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/*\n\t * Dear unsuspecting programmer,\n\t *\n\t * Don't use sock_setsockopt() for SOL_TCP.  It doesn't check its level\n\t * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will\n\t * silently turn into SO_DEBUG.\n\t *\n\t * Yours,\n\t * Keeper of hilariously fragile interfaces.\n\t */\n\tret = sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY,\n\t\t\t\t    (char __user *)&val, sizeof(val));\n\n\tset_fs(oldfs);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_rx_until_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1439-1457",
    "snippet": "static void o2net_rx_until_empty(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container, sc_rx_work);\n\tint ret;\n\n\tdo {\n\t\tret = o2net_advance_rx(sc);\n\t} while (ret > 0);\n\n\tif (ret <= 0 && ret != -EAGAIN) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\t\tsclog(sc, \"saw error %d, closing\\n\", ret);\n\t\t/* not permanent so read failed handshake can retry */\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\n\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_ensure_shutdown",
          "args": [
            "nn",
            "sc",
            "0"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_ensure_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "709-717",
          "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"saw error %d, closing\\n\"",
            "ret"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_advance_rx",
          "args": [
            "sc"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_advance_rx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1349-1434",
          "snippet": "static int o2net_advance_rx(struct o2net_sock_container *sc)\n{\n\tstruct o2net_msg *hdr;\n\tint ret = 0;\n\tvoid *data;\n\tsize_t datalen;\n\n\tsclog(sc, \"receiving\\n\");\n\to2net_set_advance_start_time(sc);\n\n\tif (unlikely(sc->sc_handshake_ok == 0)) {\n\t\tif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\n\t\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\t\tdatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\n\t\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\t\tif (ret > 0)\n\t\t\t\tsc->sc_page_off += ret;\n\t\t}\n\n\t\tif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\n\t\t\to2net_check_handshake(sc);\n\t\t\tif (unlikely(sc->sc_handshake_ok == 0))\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* do we need more header? */\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0) {\n\t\t\tsc->sc_page_off += ret;\n\t\t\t/* only swab incoming here.. we can\n\t\t\t * only get here once as we cross from\n\t\t\t * being under to over */\n\t\t\tif (sc->sc_page_off == sizeof(struct o2net_msg)) {\n\t\t\t\thdr = page_address(sc->sc_page);\n\t\t\t\tif (be16_to_cpu(hdr->data_len) >\n\t\t\t\t    O2NET_MAX_PAYLOAD_BYTES)\n\t\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\t/* oof, still don't have a header */\n\t\tgoto out;\n\t}\n\n\t/* this was swabbed above when we first read it */\n\thdr = page_address(sc->sc_page);\n\n\tmsglog(hdr, \"at page_off %zu\\n\", sc->sc_page_off);\n\n\t/* do we need more payload? */\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\n\t\t/* need more payload */\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\n\t\t\t  sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0)\n\t\t\tsc->sc_page_off += ret;\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\n\t\t/* we can only get here once, the first time we read\n\t\t * the payload.. so set ret to progress if the handler\n\t\t * works out. after calling this the message is toast */\n\t\tret = o2net_process_message(sc, hdr);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\tsc->sc_page_off = 0;\n\t}\n\nout:\n\tsclog(sc, \"ret = %d\\n\", ret);\n\to2net_set_advance_stop_time(sc);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_advance_rx(struct o2net_sock_container *sc)\n{\n\tstruct o2net_msg *hdr;\n\tint ret = 0;\n\tvoid *data;\n\tsize_t datalen;\n\n\tsclog(sc, \"receiving\\n\");\n\to2net_set_advance_start_time(sc);\n\n\tif (unlikely(sc->sc_handshake_ok == 0)) {\n\t\tif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\n\t\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\t\tdatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\n\t\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\t\tif (ret > 0)\n\t\t\t\tsc->sc_page_off += ret;\n\t\t}\n\n\t\tif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\n\t\t\to2net_check_handshake(sc);\n\t\t\tif (unlikely(sc->sc_handshake_ok == 0))\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* do we need more header? */\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0) {\n\t\t\tsc->sc_page_off += ret;\n\t\t\t/* only swab incoming here.. we can\n\t\t\t * only get here once as we cross from\n\t\t\t * being under to over */\n\t\t\tif (sc->sc_page_off == sizeof(struct o2net_msg)) {\n\t\t\t\thdr = page_address(sc->sc_page);\n\t\t\t\tif (be16_to_cpu(hdr->data_len) >\n\t\t\t\t    O2NET_MAX_PAYLOAD_BYTES)\n\t\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\t/* oof, still don't have a header */\n\t\tgoto out;\n\t}\n\n\t/* this was swabbed above when we first read it */\n\thdr = page_address(sc->sc_page);\n\n\tmsglog(hdr, \"at page_off %zu\\n\", sc->sc_page_off);\n\n\t/* do we need more payload? */\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\n\t\t/* need more payload */\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\n\t\t\t  sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0)\n\t\t\tsc->sc_page_off += ret;\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\n\t\t/* we can only get here once, the first time we read\n\t\t * the payload.. so set ret to progress if the handler\n\t\t * works out. after calling this the message is toast */\n\t\tret = o2net_process_message(sc, hdr);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\tsc->sc_page_off = 0;\n\t}\n\nout:\n\tsclog(sc, \"ret = %d\\n\", ret);\n\to2net_set_advance_stop_time(sc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_sock_container",
            "sc_rx_work"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_rx_until_empty(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container, sc_rx_work);\n\tint ret;\n\n\tdo {\n\t\tret = o2net_advance_rx(sc);\n\t} while (ret > 0);\n\n\tif (ret <= 0 && ret != -EAGAIN) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\t\tsclog(sc, \"saw error %d, closing\\n\", ret);\n\t\t/* not permanent so read failed handshake can retry */\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t}\n\n\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_advance_rx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1349-1434",
    "snippet": "static int o2net_advance_rx(struct o2net_sock_container *sc)\n{\n\tstruct o2net_msg *hdr;\n\tint ret = 0;\n\tvoid *data;\n\tsize_t datalen;\n\n\tsclog(sc, \"receiving\\n\");\n\to2net_set_advance_start_time(sc);\n\n\tif (unlikely(sc->sc_handshake_ok == 0)) {\n\t\tif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\n\t\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\t\tdatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\n\t\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\t\tif (ret > 0)\n\t\t\t\tsc->sc_page_off += ret;\n\t\t}\n\n\t\tif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\n\t\t\to2net_check_handshake(sc);\n\t\t\tif (unlikely(sc->sc_handshake_ok == 0))\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* do we need more header? */\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0) {\n\t\t\tsc->sc_page_off += ret;\n\t\t\t/* only swab incoming here.. we can\n\t\t\t * only get here once as we cross from\n\t\t\t * being under to over */\n\t\t\tif (sc->sc_page_off == sizeof(struct o2net_msg)) {\n\t\t\t\thdr = page_address(sc->sc_page);\n\t\t\t\tif (be16_to_cpu(hdr->data_len) >\n\t\t\t\t    O2NET_MAX_PAYLOAD_BYTES)\n\t\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\t/* oof, still don't have a header */\n\t\tgoto out;\n\t}\n\n\t/* this was swabbed above when we first read it */\n\thdr = page_address(sc->sc_page);\n\n\tmsglog(hdr, \"at page_off %zu\\n\", sc->sc_page_off);\n\n\t/* do we need more payload? */\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\n\t\t/* need more payload */\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\n\t\t\t  sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0)\n\t\t\tsc->sc_page_off += ret;\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\n\t\t/* we can only get here once, the first time we read\n\t\t * the payload.. so set ret to progress if the handler\n\t\t * works out. after calling this the message is toast */\n\t\tret = o2net_process_message(sc, hdr);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\tsc->sc_page_off = 0;\n\t}\n\nout:\n\tsclog(sc, \"ret = %d\\n\", ret);\n\to2net_set_advance_stop_time(sc);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_set_advance_stop_time",
          "args": [
            "sc"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_advance_stop_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "199-202",
          "snippet": "static inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_stop = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_stop = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"ret = %d\\n\"",
            "ret"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_process_message",
          "args": [
            "sc",
            "hdr"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_process_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1183-1269",
          "snippet": "static int o2net_process_message(struct o2net_sock_container *sc,\n\t\t\t\t struct o2net_msg *hdr)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tint ret = 0, handler_status;\n\tenum  o2net_system_error syserr;\n\tstruct o2net_msg_handler *nmh = NULL;\n\tvoid *ret_data = NULL;\n\n\tmsglog(hdr, \"processing message\\n\");\n\n\to2net_sc_postpone_idle(sc);\n\n\tswitch(be16_to_cpu(hdr->magic)) {\n\t\tcase O2NET_MSG_STATUS_MAGIC:\n\t\t\t/* special type for returning message status */\n\t\t\to2net_complete_nsw(nn, NULL,\n\t\t\t\t\t   be32_to_cpu(hdr->msg_num),\n\t\t\t\t\t   be32_to_cpu(hdr->sys_status),\n\t\t\t\t\t   be32_to_cpu(hdr->status));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_REQ_MAGIC:\n\t\t\to2net_sendpage(sc, o2net_keep_resp,\n\t\t\t\t       sizeof(*o2net_keep_resp));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_RESP_MAGIC:\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_MAGIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmsglog(hdr, \"bad magic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\n\t/* find a handler for it */\n\thandler_status = 0;\n\tnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\n\t\t\t\tbe32_to_cpu(hdr->key));\n\tif (!nmh) {\n\t\tmlog(ML_TCP, \"couldn't find handler for type %u key %08x\\n\",\n\t\t     be16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\n\t\tsyserr = O2NET_ERR_NO_HNDLR;\n\t\tgoto out_respond;\n\t}\n\n\tsyserr = O2NET_ERR_NONE;\n\n\tif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\n\t\tsyserr = O2NET_ERR_OVERFLOW;\n\n\tif (syserr != O2NET_ERR_NONE)\n\t\tgoto out_respond;\n\n\to2net_set_func_start_time(sc);\n\tsc->sc_msg_key = be32_to_cpu(hdr->key);\n\tsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\n\thandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len),\n\t\t\t\t\tnmh->nh_func_data, &ret_data);\n\to2net_set_func_stop_time(sc);\n\n\to2net_update_recv_stats(sc);\n\nout_respond:\n\t/* this destroys the hdr, so don't use it after this */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\n\t\t\t\t      handler_status);\n\tmutex_unlock(&sc->sc_send_lock);\n\thdr = NULL;\n\tmlog(0, \"sending handler status %d, syserr %d returned %d\\n\",\n\t     handler_status, syserr, ret);\n\n\tif (nmh) {\n\t\tBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\n\t\tif (nmh->nh_post_func)\n\t\t\t(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\n\t\t\t\t\t    ret_data);\n\t}\n\nout:\n\tif (nmh)\n\t\to2net_handler_put(nmh);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_process_message(struct o2net_sock_container *sc,\n\t\t\t\t struct o2net_msg *hdr)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tint ret = 0, handler_status;\n\tenum  o2net_system_error syserr;\n\tstruct o2net_msg_handler *nmh = NULL;\n\tvoid *ret_data = NULL;\n\n\tmsglog(hdr, \"processing message\\n\");\n\n\to2net_sc_postpone_idle(sc);\n\n\tswitch(be16_to_cpu(hdr->magic)) {\n\t\tcase O2NET_MSG_STATUS_MAGIC:\n\t\t\t/* special type for returning message status */\n\t\t\to2net_complete_nsw(nn, NULL,\n\t\t\t\t\t   be32_to_cpu(hdr->msg_num),\n\t\t\t\t\t   be32_to_cpu(hdr->sys_status),\n\t\t\t\t\t   be32_to_cpu(hdr->status));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_REQ_MAGIC:\n\t\t\to2net_sendpage(sc, o2net_keep_resp,\n\t\t\t\t       sizeof(*o2net_keep_resp));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_RESP_MAGIC:\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_MAGIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmsglog(hdr, \"bad magic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\n\t/* find a handler for it */\n\thandler_status = 0;\n\tnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\n\t\t\t\tbe32_to_cpu(hdr->key));\n\tif (!nmh) {\n\t\tmlog(ML_TCP, \"couldn't find handler for type %u key %08x\\n\",\n\t\t     be16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\n\t\tsyserr = O2NET_ERR_NO_HNDLR;\n\t\tgoto out_respond;\n\t}\n\n\tsyserr = O2NET_ERR_NONE;\n\n\tif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\n\t\tsyserr = O2NET_ERR_OVERFLOW;\n\n\tif (syserr != O2NET_ERR_NONE)\n\t\tgoto out_respond;\n\n\to2net_set_func_start_time(sc);\n\tsc->sc_msg_key = be32_to_cpu(hdr->key);\n\tsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\n\thandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len),\n\t\t\t\t\tnmh->nh_func_data, &ret_data);\n\to2net_set_func_stop_time(sc);\n\n\to2net_update_recv_stats(sc);\n\nout_respond:\n\t/* this destroys the hdr, so don't use it after this */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\n\t\t\t\t      handler_status);\n\tmutex_unlock(&sc->sc_send_lock);\n\thdr = NULL;\n\tmlog(0, \"sending handler status %d, syserr %d returned %d\\n\",\n\t     handler_status, syserr, ret);\n\n\tif (nmh) {\n\t\tBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\n\t\tif (nmh->nh_post_func)\n\t\t\t(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\n\t\t\t\t\t    ret_data);\n\t}\n\nout:\n\tif (nmh)\n\t\to2net_handler_put(nmh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_recv_tcp_msg",
          "args": [
            "sc->sc_sock",
            "data",
            "datalen"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_recv_tcp_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "917-922",
          "snippet": "static int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\n{\n\tstruct kvec vec = { .iov_len = len, .iov_base = data, };\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\n\treturn kernel_recvmsg(sock, &msg, &vec, 1, len, msg.msg_flags);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nstatic int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\n{\n\tstruct kvec vec = { .iov_len = len, .iov_base = data, };\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\n\treturn kernel_recvmsg(sock, &msg, &vec, 1, len, msg.msg_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msglog",
          "args": [
            "hdr",
            "\"at page_off %zu\\n\"",
            "sc->sc_page_off"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sc->sc_handshake_ok == 0"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_check_handshake",
          "args": [
            "sc"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_check_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1271-1344",
          "snippet": "static int o2net_check_handshake(struct o2net_sock_container *sc)\n{\n\tstruct o2net_handshake *hand = page_address(sc->sc_page);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" Advertised net \"\n\t\t       \"protocol version %llu but %llu is required. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       (unsigned long long)be64_to_cpu(hand->protocol_version),\n\t\t       O2NET_PROTOCOL_VERSION);\n\n\t\t/* don't bother reconnecting if its the wrong version. */\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ensure timeouts are consistent with other nodes, otherwise\n\t * we can end up with one node thinking that the other must be down,\n\t * but isn't. This can ultimately cause corruption.\n\t */\n\tif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\n\t\t\t\to2net_idle_timeout()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a network \"\n\t\t       \"idle timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_idle_timeout_ms),\n\t\t       o2net_idle_timeout());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\n\t\t\to2net_keepalive_delay()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a keepalive \"\n\t\t       \"delay of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_keepalive_delay_ms),\n\t\t       o2net_keepalive_delay());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\n\t\t\tO2HB_MAX_WRITE_TIMEOUT_MS) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\n\t\t       O2HB_MAX_WRITE_TIMEOUT_MS);\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tsc->sc_handshake_ok = 1;\n\n\tspin_lock(&nn->nn_lock);\n\t/* set valid and queue the idle timers only if it hasn't been\n\t * shut down already */\n\tif (nn->nn_sc == sc) {\n\t\to2net_sc_reset_idle_timer(sc);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\to2net_set_nn_state(nn, sc, 1, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\t/* shift everything up as though it wasn't there */\n\tsc->sc_page_off -= sizeof(struct o2net_handshake);\n\tif (sc->sc_page_off)\n\t\tmemmove(hand, hand + 1, sc->sc_page_off);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_check_handshake(struct o2net_sock_container *sc)\n{\n\tstruct o2net_handshake *hand = page_address(sc->sc_page);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" Advertised net \"\n\t\t       \"protocol version %llu but %llu is required. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       (unsigned long long)be64_to_cpu(hand->protocol_version),\n\t\t       O2NET_PROTOCOL_VERSION);\n\n\t\t/* don't bother reconnecting if its the wrong version. */\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ensure timeouts are consistent with other nodes, otherwise\n\t * we can end up with one node thinking that the other must be down,\n\t * but isn't. This can ultimately cause corruption.\n\t */\n\tif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\n\t\t\t\to2net_idle_timeout()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a network \"\n\t\t       \"idle timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_idle_timeout_ms),\n\t\t       o2net_idle_timeout());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\n\t\t\to2net_keepalive_delay()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a keepalive \"\n\t\t       \"delay of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_keepalive_delay_ms),\n\t\t       o2net_keepalive_delay());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\n\t\t\tO2HB_MAX_WRITE_TIMEOUT_MS) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\n\t\t       O2HB_MAX_WRITE_TIMEOUT_MS);\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tsc->sc_handshake_ok = 1;\n\n\tspin_lock(&nn->nn_lock);\n\t/* set valid and queue the idle timers only if it hasn't been\n\t * shut down already */\n\tif (nn->nn_sc == sc) {\n\t\to2net_sc_reset_idle_timer(sc);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\to2net_set_nn_state(nn, sc, 1, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\t/* shift everything up as though it wasn't there */\n\tsc->sc_page_off -= sizeof(struct o2net_handshake);\n\tif (sc->sc_page_off)\n\t\tmemmove(hand, hand + 1, sc->sc_page_off);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sc->sc_handshake_ok == 0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_set_advance_start_time",
          "args": [
            "sc"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_advance_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "194-197",
          "snippet": "static inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_start = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_start = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"receiving\\n\""
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_advance_rx(struct o2net_sock_container *sc)\n{\n\tstruct o2net_msg *hdr;\n\tint ret = 0;\n\tvoid *data;\n\tsize_t datalen;\n\n\tsclog(sc, \"receiving\\n\");\n\to2net_set_advance_start_time(sc);\n\n\tif (unlikely(sc->sc_handshake_ok == 0)) {\n\t\tif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\n\t\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\t\tdatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\n\t\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\t\tif (ret > 0)\n\t\t\t\tsc->sc_page_off += ret;\n\t\t}\n\n\t\tif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\n\t\t\to2net_check_handshake(sc);\n\t\t\tif (unlikely(sc->sc_handshake_ok == 0))\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* do we need more header? */\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0) {\n\t\t\tsc->sc_page_off += ret;\n\t\t\t/* only swab incoming here.. we can\n\t\t\t * only get here once as we cross from\n\t\t\t * being under to over */\n\t\t\tif (sc->sc_page_off == sizeof(struct o2net_msg)) {\n\t\t\t\thdr = page_address(sc->sc_page);\n\t\t\t\tif (be16_to_cpu(hdr->data_len) >\n\t\t\t\t    O2NET_MAX_PAYLOAD_BYTES)\n\t\t\t\t\tret = -EOVERFLOW;\n\t\t\t}\n\t\t}\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off < sizeof(struct o2net_msg)) {\n\t\t/* oof, still don't have a header */\n\t\tgoto out;\n\t}\n\n\t/* this was swabbed above when we first read it */\n\thdr = page_address(sc->sc_page);\n\n\tmsglog(hdr, \"at page_off %zu\\n\", sc->sc_page_off);\n\n\t/* do we need more payload? */\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\n\t\t/* need more payload */\n\t\tdata = page_address(sc->sc_page) + sc->sc_page_off;\n\t\tdatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\n\t\t\t  sc->sc_page_off;\n\t\tret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\n\t\tif (ret > 0)\n\t\t\tsc->sc_page_off += ret;\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\n\t\t/* we can only get here once, the first time we read\n\t\t * the payload.. so set ret to progress if the handler\n\t\t * works out. after calling this the message is toast */\n\t\tret = o2net_process_message(sc, hdr);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\tsc->sc_page_off = 0;\n\t}\n\nout:\n\tsclog(sc, \"ret = %d\\n\", ret);\n\to2net_set_advance_stop_time(sc);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_check_handshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1271-1344",
    "snippet": "static int o2net_check_handshake(struct o2net_sock_container *sc)\n{\n\tstruct o2net_handshake *hand = page_address(sc->sc_page);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" Advertised net \"\n\t\t       \"protocol version %llu but %llu is required. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       (unsigned long long)be64_to_cpu(hand->protocol_version),\n\t\t       O2NET_PROTOCOL_VERSION);\n\n\t\t/* don't bother reconnecting if its the wrong version. */\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ensure timeouts are consistent with other nodes, otherwise\n\t * we can end up with one node thinking that the other must be down,\n\t * but isn't. This can ultimately cause corruption.\n\t */\n\tif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\n\t\t\t\to2net_idle_timeout()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a network \"\n\t\t       \"idle timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_idle_timeout_ms),\n\t\t       o2net_idle_timeout());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\n\t\t\to2net_keepalive_delay()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a keepalive \"\n\t\t       \"delay of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_keepalive_delay_ms),\n\t\t       o2net_keepalive_delay());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\n\t\t\tO2HB_MAX_WRITE_TIMEOUT_MS) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\n\t\t       O2HB_MAX_WRITE_TIMEOUT_MS);\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tsc->sc_handshake_ok = 1;\n\n\tspin_lock(&nn->nn_lock);\n\t/* set valid and queue the idle timers only if it hasn't been\n\t * shut down already */\n\tif (nn->nn_sc == sc) {\n\t\to2net_sc_reset_idle_timer(sc);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\to2net_set_nn_state(nn, sc, 1, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\t/* shift everything up as though it wasn't there */\n\tsc->sc_page_off -= sizeof(struct o2net_handshake);\n\tif (sc->sc_page_off)\n\t\tmemmove(hand, hand + 1, sc->sc_page_off);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "hand",
            "hand + 1",
            "sc->sc_page_off"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "sc",
            "1",
            "0"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nn->nn_timeout",
            "0"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_sc_reset_idle_timer",
          "args": [
            "sc"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_reset_idle_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1564-1572",
          "snippet": "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\n{\n\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\to2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\n\t\t      msecs_to_jiffies(o2net_keepalive_delay()));\n\to2net_set_sock_timer(sc);\n\tmod_timer(&sc->sc_idle_timeout,\n\t       jiffies + msecs_to_jiffies(o2net_idle_timeout()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_ensure_shutdown",
          "args": [
            "nn",
            "sc",
            "-ENOTCONN"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_ensure_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "709-717",
          "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\"",
            "SC_NODEF_ARGS(sc)",
            "be32_to_cpu(hand->o2hb_heartbeat_timeout_ms)",
            "O2HB_MAX_WRITE_TIMEOUT_MS"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2hb_heartbeat_timeout_ms"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2hb_heartbeat_timeout_ms"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_keepalive_delay",
          "args": [],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_keepalive_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "270-273",
          "snippet": "static inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2net_keepalive_delay_ms"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2net_keepalive_delay_ms"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2net_idle_timeout_ms"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hand->o2net_idle_timeout_ms"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hand->protocol_version"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "O2NET_PROTOCOL_VERSION"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sc->sc_page"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_check_handshake(struct o2net_sock_container *sc)\n{\n\tstruct o2net_handshake *hand = page_address(sc->sc_page);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" Advertised net \"\n\t\t       \"protocol version %llu but %llu is required. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       (unsigned long long)be64_to_cpu(hand->protocol_version),\n\t\t       O2NET_PROTOCOL_VERSION);\n\n\t\t/* don't bother reconnecting if its the wrong version. */\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ensure timeouts are consistent with other nodes, otherwise\n\t * we can end up with one node thinking that the other must be down,\n\t * but isn't. This can ultimately cause corruption.\n\t */\n\tif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\n\t\t\t\to2net_idle_timeout()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a network \"\n\t\t       \"idle timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_idle_timeout_ms),\n\t\t       o2net_idle_timeout());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\n\t\t\to2net_keepalive_delay()) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a keepalive \"\n\t\t       \"delay of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2net_keepalive_delay_ms),\n\t\t       o2net_keepalive_delay());\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\n\t\t\tO2HB_MAX_WRITE_TIMEOUT_MS) {\n\t\tprintk(KERN_NOTICE \"o2net: \" SC_NODEF_FMT \" uses a heartbeat \"\n\t\t       \"timeout of %u ms, but we use %u ms locally. \"\n\t\t       \"Disconnecting.\\n\", SC_NODEF_ARGS(sc),\n\t\t       be32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\n\t\t       O2HB_MAX_WRITE_TIMEOUT_MS);\n\t\to2net_ensure_shutdown(nn, sc, -ENOTCONN);\n\t\treturn -1;\n\t}\n\n\tsc->sc_handshake_ok = 1;\n\n\tspin_lock(&nn->nn_lock);\n\t/* set valid and queue the idle timers only if it hasn't been\n\t * shut down already */\n\tif (nn->nn_sc == sc) {\n\t\to2net_sc_reset_idle_timer(sc);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\to2net_set_nn_state(nn, sc, 1, 0);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\t/* shift everything up as though it wasn't there */\n\tsc->sc_page_off -= sizeof(struct o2net_handshake);\n\tif (sc->sc_page_off)\n\t\tmemmove(hand, hand + 1, sc->sc_page_off);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "o2net_process_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1183-1269",
    "snippet": "static int o2net_process_message(struct o2net_sock_container *sc,\n\t\t\t\t struct o2net_msg *hdr)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tint ret = 0, handler_status;\n\tenum  o2net_system_error syserr;\n\tstruct o2net_msg_handler *nmh = NULL;\n\tvoid *ret_data = NULL;\n\n\tmsglog(hdr, \"processing message\\n\");\n\n\to2net_sc_postpone_idle(sc);\n\n\tswitch(be16_to_cpu(hdr->magic)) {\n\t\tcase O2NET_MSG_STATUS_MAGIC:\n\t\t\t/* special type for returning message status */\n\t\t\to2net_complete_nsw(nn, NULL,\n\t\t\t\t\t   be32_to_cpu(hdr->msg_num),\n\t\t\t\t\t   be32_to_cpu(hdr->sys_status),\n\t\t\t\t\t   be32_to_cpu(hdr->status));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_REQ_MAGIC:\n\t\t\to2net_sendpage(sc, o2net_keep_resp,\n\t\t\t\t       sizeof(*o2net_keep_resp));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_RESP_MAGIC:\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_MAGIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmsglog(hdr, \"bad magic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\n\t/* find a handler for it */\n\thandler_status = 0;\n\tnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\n\t\t\t\tbe32_to_cpu(hdr->key));\n\tif (!nmh) {\n\t\tmlog(ML_TCP, \"couldn't find handler for type %u key %08x\\n\",\n\t\t     be16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\n\t\tsyserr = O2NET_ERR_NO_HNDLR;\n\t\tgoto out_respond;\n\t}\n\n\tsyserr = O2NET_ERR_NONE;\n\n\tif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\n\t\tsyserr = O2NET_ERR_OVERFLOW;\n\n\tif (syserr != O2NET_ERR_NONE)\n\t\tgoto out_respond;\n\n\to2net_set_func_start_time(sc);\n\tsc->sc_msg_key = be32_to_cpu(hdr->key);\n\tsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\n\thandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len),\n\t\t\t\t\tnmh->nh_func_data, &ret_data);\n\to2net_set_func_stop_time(sc);\n\n\to2net_update_recv_stats(sc);\n\nout_respond:\n\t/* this destroys the hdr, so don't use it after this */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\n\t\t\t\t      handler_status);\n\tmutex_unlock(&sc->sc_send_lock);\n\thdr = NULL;\n\tmlog(0, \"sending handler status %d, syserr %d returned %d\\n\",\n\t     handler_status, syserr, ret);\n\n\tif (nmh) {\n\t\tBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\n\t\tif (nmh->nh_post_func)\n\t\t\t(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\n\t\t\t\t\t    ret_data);\n\t}\n\nout:\n\tif (nmh)\n\t\to2net_handler_put(nmh);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_handler_put",
          "args": [
            "nmh"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_handler_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "805-808",
          "snippet": "static void o2net_handler_put(struct o2net_msg_handler *nmh)\n{\n\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_handler_put(struct o2net_msg_handler *nmh)\n{\n\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "handler_status",
            "nmh->nh_func_data",
            "ret_data"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret_data != NULL && nmh->nh_post_func == NULL"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"sending handler status %d, syserr %d returned %d\\n\"",
            "handler_status",
            "syserr",
            "ret"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_status_magic",
          "args": [
            "sc->sc_sock",
            "hdr",
            "syserr",
            "handler_status"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_status_magic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1159-1179",
          "snippet": "static int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\n\t\t\t\t   enum o2net_system_error syserr, int err)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = hdr,\n\t\t.iov_len = sizeof(struct o2net_msg),\n\t};\n\n\tBUG_ON(syserr >= O2NET_ERR_MAX);\n\n\t/* leave other fields intact from the incoming message, msg_num\n\t * in particular */\n\thdr->sys_status = cpu_to_be32(syserr);\n\thdr->status = cpu_to_be32(err);\n\thdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);  // twiddle the magic\n\thdr->data_len = 0;\n\n\tmsglog(hdr, \"about to send status magic %d\\n\", err);\n\t/* hdr has been in host byteorder this whole time */\n\treturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\n\t\t\t\t   enum o2net_system_error syserr, int err)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = hdr,\n\t\t.iov_len = sizeof(struct o2net_msg),\n\t};\n\n\tBUG_ON(syserr >= O2NET_ERR_MAX);\n\n\t/* leave other fields intact from the incoming message, msg_num\n\t * in particular */\n\thdr->sys_status = cpu_to_be32(syserr);\n\thdr->status = cpu_to_be32(err);\n\thdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);  // twiddle the magic\n\thdr->data_len = 0;\n\n\tmsglog(hdr, \"about to send status magic %d\\n\", err);\n\t/* hdr has been in host byteorder this whole time */\n\treturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_update_recv_stats",
          "args": [
            "sc"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_update_recv_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "250-255",
          "snippet": "static void o2net_update_recv_stats(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\n\t\t\t\t\t    o2net_get_func_run_time(sc));\n\tsc->sc_recv_count++;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_update_recv_stats(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\n\t\t\t\t\t    o2net_get_func_run_time(sc));\n\tsc->sc_recv_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_func_stop_time",
          "args": [
            "sc"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_func_stop_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "209-212",
          "snippet": "static inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_stop = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_stop = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "hdr",
            "sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len)",
            "nmh->nh_func_data",
            "&ret_data"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->msg_type"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->key"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_set_func_start_time",
          "args": [
            "sc"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_func_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "204-207",
          "snippet": "static inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_start = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_start = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->data_len"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_TCP",
            "\"couldn't find handler for type %u key %08x\\n\"",
            "be16_to_cpu(hdr->msg_type)",
            "be32_to_cpu(hdr->key)"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->key"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->msg_type"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_handler_get",
          "args": [
            "be16_to_cpu(hdr->msg_type)",
            "be32_to_cpu(hdr->key)"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_handler_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "902-913",
          "snippet": "static struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\n{\n\tstruct o2net_msg_handler *nmh;\n\n\tread_lock(&o2net_handler_lock);\n\tnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\n\tif (nmh)\n\t\tkref_get(&nmh->nh_kref);\n\tread_unlock(&o2net_handler_lock);\n\n\treturn nmh;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(o2net_handler_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\n\nstatic struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\n{\n\tstruct o2net_msg_handler *nmh;\n\n\tread_lock(&o2net_handler_lock);\n\tnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\n\tif (nmh)\n\t\tkref_get(&nmh->nh_kref);\n\tread_unlock(&o2net_handler_lock);\n\n\treturn nmh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->key"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->msg_type"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msglog",
          "args": [
            "hdr",
            "\"bad magic\\n\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_sendpage",
          "args": [
            "sc",
            "o2net_keep_resp",
            "sizeof(*o2net_keep_resp)"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sendpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "946-973",
          "snippet": "static void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_complete_nsw",
          "args": [
            "nn",
            "NULL",
            "be32_to_cpu(hdr->msg_num)",
            "be32_to_cpu(hdr->sys_status)",
            "be32_to_cpu(hdr->status)"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_complete_nsw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "341-361",
          "snippet": "static void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->status"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->sys_status"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->msg_num"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->magic"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_sc_postpone_idle",
          "args": [
            "sc"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_postpone_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1574-1588",
          "snippet": "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\t/* clear fence decision since the connection recover from timeout*/\n\tif (atomic_read(&nn->nn_timeout)) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t}\n\n\t/* Only push out an existing timer */\n\tif (timer_pending(&sc->sc_idle_timeout))\n\t\to2net_sc_reset_idle_timer(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\t/* clear fence decision since the connection recover from timeout*/\n\tif (atomic_read(&nn->nn_timeout)) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t}\n\n\t/* Only push out an existing timer */\n\tif (timer_pending(&sc->sc_idle_timeout))\n\t\to2net_sc_reset_idle_timer(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msglog",
          "args": [
            "hdr",
            "\"processing message\\n\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_process_message(struct o2net_sock_container *sc,\n\t\t\t\t struct o2net_msg *hdr)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tint ret = 0, handler_status;\n\tenum  o2net_system_error syserr;\n\tstruct o2net_msg_handler *nmh = NULL;\n\tvoid *ret_data = NULL;\n\n\tmsglog(hdr, \"processing message\\n\");\n\n\to2net_sc_postpone_idle(sc);\n\n\tswitch(be16_to_cpu(hdr->magic)) {\n\t\tcase O2NET_MSG_STATUS_MAGIC:\n\t\t\t/* special type for returning message status */\n\t\t\to2net_complete_nsw(nn, NULL,\n\t\t\t\t\t   be32_to_cpu(hdr->msg_num),\n\t\t\t\t\t   be32_to_cpu(hdr->sys_status),\n\t\t\t\t\t   be32_to_cpu(hdr->status));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_REQ_MAGIC:\n\t\t\to2net_sendpage(sc, o2net_keep_resp,\n\t\t\t\t       sizeof(*o2net_keep_resp));\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_KEEP_RESP_MAGIC:\n\t\t\tgoto out;\n\t\tcase O2NET_MSG_MAGIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmsglog(hdr, \"bad magic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\n\t/* find a handler for it */\n\thandler_status = 0;\n\tnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\n\t\t\t\tbe32_to_cpu(hdr->key));\n\tif (!nmh) {\n\t\tmlog(ML_TCP, \"couldn't find handler for type %u key %08x\\n\",\n\t\t     be16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\n\t\tsyserr = O2NET_ERR_NO_HNDLR;\n\t\tgoto out_respond;\n\t}\n\n\tsyserr = O2NET_ERR_NONE;\n\n\tif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\n\t\tsyserr = O2NET_ERR_OVERFLOW;\n\n\tif (syserr != O2NET_ERR_NONE)\n\t\tgoto out_respond;\n\n\to2net_set_func_start_time(sc);\n\tsc->sc_msg_key = be32_to_cpu(hdr->key);\n\tsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\n\thandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\n\t\t\t\t\t     be16_to_cpu(hdr->data_len),\n\t\t\t\t\tnmh->nh_func_data, &ret_data);\n\to2net_set_func_stop_time(sc);\n\n\to2net_update_recv_stats(sc);\n\nout_respond:\n\t/* this destroys the hdr, so don't use it after this */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\n\t\t\t\t      handler_status);\n\tmutex_unlock(&sc->sc_send_lock);\n\thdr = NULL;\n\tmlog(0, \"sending handler status %d, syserr %d returned %d\\n\",\n\t     handler_status, syserr, ret);\n\n\tif (nmh) {\n\t\tBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\n\t\tif (nmh->nh_post_func)\n\t\t\t(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\n\t\t\t\t\t    ret_data);\n\t}\n\nout:\n\tif (nmh)\n\t\to2net_handler_put(nmh);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_send_status_magic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1159-1179",
    "snippet": "static int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\n\t\t\t\t   enum o2net_system_error syserr, int err)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = hdr,\n\t\t.iov_len = sizeof(struct o2net_msg),\n\t};\n\n\tBUG_ON(syserr >= O2NET_ERR_MAX);\n\n\t/* leave other fields intact from the incoming message, msg_num\n\t * in particular */\n\thdr->sys_status = cpu_to_be32(syserr);\n\thdr->status = cpu_to_be32(err);\n\thdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);  // twiddle the magic\n\thdr->data_len = 0;\n\n\tmsglog(hdr, \"about to send status magic %d\\n\", err);\n\t/* hdr has been in host byteorder this whole time */\n\treturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_send_tcp_msg",
          "args": [
            "sock",
            "&vec",
            "1",
            "sizeof(struct o2net_msg)"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_tcp_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "924-944",
          "snippet": "static int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msglog",
          "args": [
            "hdr",
            "\"about to send status magic %d\\n\"",
            "err"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "O2NET_MSG_STATUS_MAGIC"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "err"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "syserr"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "syserr >= O2NET_ERR_MAX"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\n\t\t\t\t   enum o2net_system_error syserr, int err)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = hdr,\n\t\t.iov_len = sizeof(struct o2net_msg),\n\t};\n\n\tBUG_ON(syserr >= O2NET_ERR_MAX);\n\n\t/* leave other fields intact from the incoming message, msg_num\n\t * in particular */\n\thdr->sys_status = cpu_to_be32(syserr);\n\thdr->status = cpu_to_be32(err);\n\thdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);  // twiddle the magic\n\thdr->data_len = 0;\n\n\tmsglog(hdr, \"about to send status magic %d\\n\", err);\n\t/* hdr has been in host byteorder this whole time */\n\treturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\n}"
  },
  {
    "function_name": "o2net_send_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1147-1156",
    "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_send_message_vec",
          "args": [
            "msg_type",
            "key",
            "&vec",
            "1",
            "target_node",
            "status"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1029-1144",
          "snippet": "int o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
  },
  {
    "function_name": "o2net_send_message_vec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1029-1144",
    "snippet": "int o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_complete_nsw",
          "args": [
            "nn",
            "&nsw",
            "0",
            "0",
            "0"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_complete_nsw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "341-361",
          "snippet": "static void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vec"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_debug_del_nst",
          "args": [
            "&nst"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debug_del_nst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "144-146",
          "snippet": "static inline void o2net_debug_del_nst(struct o2net_send_tracking *nst)\n{\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline void o2net_debug_del_nst(struct o2net_send_tracking *nst)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"woken, returning system status %d, user status %d\\n\"",
            "ret",
            "nsw.ns_status"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sys_err_to_errno",
          "args": [
            "nsw.ns_sys_status"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sys_err_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "280-289",
          "snippet": "static inline int o2net_sys_err_to_errno(enum o2net_system_error err)\n{\n\tint trans;\n\tBUG_ON(err >= O2NET_ERR_MAX);\n\ttrans = o2net_sys_err_translations[err];\n\n\t/* Just in case we mess up the translation table above */\n\tBUG_ON(err != O2NET_ERR_NONE && trans == 0);\n\treturn trans;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int o2net_sys_err_translations[O2NET_ERR_MAX] =\n\t\t{[O2NET_ERR_NONE]\t= 0,\n\t\t [O2NET_ERR_NO_HNDLR]\t= -ENOPROTOOPT,\n\t\t [O2NET_ERR_OVERFLOW]\t= -EOVERFLOW,\n\t\t [O2NET_ERR_DIED]\t= -EHOSTDOWN,};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_sys_err_translations[O2NET_ERR_MAX] =\n\t\t{[O2NET_ERR_NONE]\t= 0,\n\t\t [O2NET_ERR_NO_HNDLR]\t= -ENOPROTOOPT,\n\t\t [O2NET_ERR_OVERFLOW]\t= -EOVERFLOW,\n\t\t [O2NET_ERR_DIED]\t= -EHOSTDOWN,};\n\nstatic inline int o2net_sys_err_to_errno(enum o2net_system_error err)\n{\n\tint trans;\n\tBUG_ON(err >= O2NET_ERR_MAX);\n\ttrans = o2net_sys_err_translations[err];\n\n\t/* Just in case we mess up the translation table above */\n\tBUG_ON(err != O2NET_ERR_NONE && trans == 0);\n\treturn trans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_update_send_stats",
          "args": [
            "&nst",
            "sc"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_update_send_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "235-248",
          "snippet": "static void o2net_update_send_stats(struct o2net_send_tracking *nst,\n\t\t\t\t    struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\n\t\t\t\t\t   ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time));\n\tsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\n\t\t\t\t\t ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time));\n\tsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\n\t\t\t\t\t    ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time));\n\tsc->sc_send_count++;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_update_send_stats(struct o2net_send_tracking *nst,\n\t\t\t\t    struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\n\t\t\t\t\t   ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time));\n\tsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\n\t\t\t\t\t ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time));\n\tsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\n\t\t\t\t\t    ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time));\n\tsc->sc_send_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "nsw.ns_wq",
            "o2net_nsw_completed(nn, &nsw)"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nsw_completed",
          "args": [
            "nn",
            "&nsw"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nsw_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "379-387",
          "snippet": "static int o2net_nsw_completed(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw)\n{\n\tint completed;\n\tspin_lock(&nn->nn_lock);\n\tcompleted = list_empty(&nsw->ns_node_item);\n\tspin_unlock(&nn->nn_lock);\n\treturn completed;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_nsw_completed(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw)\n{\n\tint completed;\n\tspin_lock(&nn->nn_lock);\n\tcompleted = list_empty(&nsw->ns_node_item);\n\tspin_unlock(&nn->nn_lock);\n\treturn completed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nst_status_time",
          "args": [
            "&nst"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nst_status_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "167-170",
          "snippet": "static inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_status_time = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_status_time = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"error returned from o2net_send_tcp_msg=%d\\n\"",
            "ret"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msglog",
          "args": [
            "msg",
            "\"sending returned %d\\n\"",
            "ret"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_tcp_msg",
          "args": [
            "sc->sc_sock",
            "vec",
            "veclen",
            "sizeof(struct o2net_msg) + caller_bytes"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_tcp_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "924-944",
          "snippet": "static int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_set_nst_send_time",
          "args": [
            "&nst"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nst_send_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "162-165",
          "snippet": "static inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_send_time = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_send_time = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nst_msg_id",
          "args": [
            "&nst",
            "nsw.ns_id"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nst_msg_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "178-182",
          "snippet": "static inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\n\t\t\t\t\tu32 msg_id)\n{\n\tnst->st_id = msg_id;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\n\t\t\t\t\tu32 msg_id)\n{\n\tnst->st_id = msg_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nsw.ns_id"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_prep_nsw",
          "args": [
            "nn",
            "&nsw"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_prep_nsw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "305-323",
          "snippet": "static int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\n{\n\tint ret;\n\n\tspin_lock(&nn->nn_lock);\n\tret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\n\tif (ret >= 0) {\n\t\tnsw->ns_id = ret;\n\t\tlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&nsw->ns_wq);\n\tnsw->ns_sys_status = O2NET_ERR_NONE;\n\tnsw->ns_status = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\n{\n\tint ret;\n\n\tspin_lock(&nn->nn_lock);\n\tret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\n\tif (ret >= 0) {\n\t\tnsw->ns_id = ret;\n\t\tlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&nsw->ns_wq);\n\tnsw->ns_sys_status = O2NET_ERR_NONE;\n\tnsw->ns_status = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vec[1]",
            "caller_vec",
            "caller_veclen * sizeof(struct kvec)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_init_msg",
          "args": [
            "msg",
            "caller_bytes",
            "msg_type",
            "key"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_init_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "975-984",
          "snippet": "static void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\n{\n\tmemset(msg, 0, sizeof(struct o2net_msg));\n\tmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\n\tmsg->data_len = cpu_to_be16(data_len);\n\tmsg->msg_type = cpu_to_be16(msg_type);\n\tmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\n\tmsg->status = 0;\n\tmsg->key = cpu_to_be32(key);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\n{\n\tmemset(msg, 0, sizeof(struct o2net_msg));\n\tmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\n\tmsg->data_len = cpu_to_be16(data_len);\n\tmsg->msg_type = cpu_to_be16(msg_type);\n\tmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\n\tmsg->status = 0;\n\tmsg->key = cpu_to_be32(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"failed to allocate a o2net_msg!\\n\""
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct o2net_msg)",
            "GFP_ATOMIC"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nst_sock_container",
          "args": [
            "&nst",
            "sc"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nst_sock_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "172-176",
          "snippet": "static inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\n\t\t\t\t\t\tstruct o2net_sock_container *sc)\n{\n\tnst->st_sc = sc;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\n\t\t\t\t\t\tstruct o2net_sock_container *sc)\n{\n\tnst->st_sc = sc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "nn->nn_sc_wq",
            "o2net_tx_can_proceed(nn, &sc, &ret)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_tx_can_proceed",
          "args": [
            "nn",
            "&sc",
            "&ret"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_tx_can_proceed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "986-1007",
          "snippet": "static int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nst_sock_time",
          "args": [
            "&nst"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nst_sock_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "157-160",
          "snippet": "static inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_sock_time = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_sock_time = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_debug_add_nst",
          "args": [
            "&nst"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debug_add_nst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "141-143",
          "snippet": "static inline void o2net_debug_add_nst(struct o2net_send_tracking *nst)\n{\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline void o2net_debug_add_nst(struct o2net_send_tracking *nst)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "(struct iovec *)caller_vec",
            "caller_veclen"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_init_nst",
          "args": [
            "&nst",
            "msg_type",
            "key",
            "current",
            "target_node"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_init_nst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "147-155",
          "snippet": "static void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\n\t\t\t   u32 msgkey, struct task_struct *task, u8 node)\n{\n\tINIT_LIST_HEAD(&nst->st_net_debug_item);\n\tnst->st_task = task;\n\tnst->st_msg_type = msgtype;\n\tnst->st_msg_key = msgkey;\n\tnst->st_node = node;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\n\t\t\t   u32 msgkey, struct task_struct *task, u8 node)\n{\n\tINIT_LIST_HEAD(&nst->st_net_debug_item);\n\tnst->st_task = task;\n\tnst->st_msg_type = msgtype;\n\tnst->st_msg_key = msgkey;\n\tnst->st_node = node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "nsw.ns_node_item"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "target_node"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_fill_node_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "1010-1026",
    "snippet": "void o2net_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2net_sock_container *sc;\n\tint node, ret;\n\n\tBUG_ON(bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long)));\n\n\tmemset(map, 0, bytes);\n\tfor (node = 0; node < O2NM_MAX_NODES; ++node) {\n\t\tif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\n\t\t\tcontinue;\n\t\tif (!ret) {\n\t\t\tset_bit(node, map);\n\t\t\tsc_put(sc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "node",
            "map"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_tx_can_proceed",
          "args": [
            "o2net_nn_from_num(node)",
            "&sc",
            "&ret"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_tx_can_proceed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "986-1007",
          "snippet": "static int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "node"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "map",
            "0",
            "bytes"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long))"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nvoid o2net_fill_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2net_sock_container *sc;\n\tint node, ret;\n\n\tBUG_ON(bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long)));\n\n\tmemset(map, 0, bytes);\n\tfor (node = 0; node < O2NM_MAX_NODES; ++node) {\n\t\tif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\n\t\t\tcontinue;\n\t\tif (!ret) {\n\t\t\tset_bit(node, map);\n\t\t\tsc_put(sc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "o2net_tx_can_proceed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "986-1007",
    "snippet": "static int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&nn->nn_sc->sc_kref"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_tx_can_proceed(struct o2net_node *nn,\n\t\t\t        struct o2net_sock_container **sc_ret,\n\t\t\t\tint *error)\n{\n\tint ret = 0;\n\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_persistent_error) {\n\t\tret = 1;\n\t\t*sc_ret = NULL;\n\t\t*error = nn->nn_persistent_error;\n\t} else if (nn->nn_sc_valid) {\n\t\tkref_get(&nn->nn_sc->sc_kref);\n\n\t\tret = 1;\n\t\t*sc_ret = nn->nn_sc;\n\t\t*error = 0;\n\t}\n\tspin_unlock(&nn->nn_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_init_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "975-984",
    "snippet": "static void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\n{\n\tmemset(msg, 0, sizeof(struct o2net_msg));\n\tmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\n\tmsg->data_len = cpu_to_be16(data_len);\n\tmsg->msg_type = cpu_to_be16(msg_type);\n\tmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\n\tmsg->status = 0;\n\tmsg->key = cpu_to_be32(key);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "key"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "O2NET_ERR_NONE"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "msg_type"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "data_len"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "O2NET_MSG_MAGIC"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "sizeof(struct o2net_msg)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\n{\n\tmemset(msg, 0, sizeof(struct o2net_msg));\n\tmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\n\tmsg->data_len = cpu_to_be16(data_len);\n\tmsg->msg_type = cpu_to_be16(msg_type);\n\tmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\n\tmsg->status = 0;\n\tmsg->key = cpu_to_be32(key);\n}"
  },
  {
    "function_name": "o2net_sendpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "946-973",
    "snippet": "static void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_ensure_shutdown",
          "args": [
            "nn",
            "sc",
            "0"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_ensure_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "709-717",
          "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\"",
            "size",
            "SC_NODEF_ARGS(sc)",
            "ret"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\"",
            "size",
            "SC_NODEF_ARGS(sc)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_sock->ops->sendpage",
          "args": [
            "sc->sc_sock",
            "virt_to_page(kmalloced_virt)",
            "(long)kmalloced_virt & ~PAGE_MASK",
            "size",
            "MSG_DONTWAIT"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "kmalloced_virt"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\n\t\t\t   void *kmalloced_virt,\n\t\t\t   size_t size)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\tssize_t ret;\n\n\twhile (1) {\n\t\tmutex_lock(&sc->sc_send_lock);\n\t\tret = sc->sc_sock->ops->sendpage(sc->sc_sock,\n\t\t\t\t\t\t virt_to_page(kmalloced_virt),\n\t\t\t\t\t\t (long)kmalloced_virt & ~PAGE_MASK,\n\t\t\t\t\t\t size, MSG_DONTWAIT);\n\t\tmutex_unlock(&sc->sc_send_lock);\n\t\tif (ret == size)\n\t\t\tbreak;\n\t\tif (ret == (ssize_t)-EAGAIN) {\n\t\t\tmlog(0, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t\t     \" returned EAGAIN\\n\", size, SC_NODEF_ARGS(sc));\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\t\tmlog(ML_ERROR, \"sendpage of size %zu to \" SC_NODEF_FMT\n\t\t     \" failed with %zd\\n\", size, SC_NODEF_ARGS(sc), ret);\n\t\to2net_ensure_shutdown(nn, sc, 0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "o2net_send_tcp_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "924-944",
    "snippet": "static int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"returning error: %d\\n\"",
            "ret"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"sendmsg returned %d instead of %zu\\n\"",
            "ret",
            "total"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret == total"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_sendmsg",
          "args": [
            "sock",
            "&msg",
            "vec",
            "veclen",
            "total"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\n\t\t\t      size_t veclen, size_t total)\n{\n\tint ret;\n\tstruct msghdr msg = {.msg_flags = 0,};\n\n\tif (sock == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kernel_sendmsg(sock, &msg, vec, veclen, total);\n\tif (likely(ret == total))\n\t\treturn 0;\n\tmlog(ML_ERROR, \"sendmsg returned %d instead of %zu\\n\", ret, total);\n\tif (ret >= 0)\n\t\tret = -EPIPE; /* should be smarter, I bet */\nout:\n\tmlog(0, \"returning error: %d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_recv_tcp_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "917-922",
    "snippet": "static int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\n{\n\tstruct kvec vec = { .iov_len = len, .iov_base = data, };\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\n\treturn kernel_recvmsg(sock, &msg, &vec, 1, len, msg.msg_flags);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_recvmsg",
          "args": [
            "sock",
            "&msg",
            "&vec",
            "1",
            "len",
            "msg.msg_flags"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nstatic int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\n{\n\tstruct kvec vec = { .iov_len = len, .iov_base = data, };\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\n\treturn kernel_recvmsg(sock, &msg, &vec, 1, len, msg.msg_flags);\n}"
  },
  {
    "function_name": "o2net_handler_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "902-913",
    "snippet": "static struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\n{\n\tstruct o2net_msg_handler *nmh;\n\n\tread_lock(&o2net_handler_lock);\n\tnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\n\tif (nmh)\n\t\tkref_get(&nmh->nh_kref);\n\tread_unlock(&o2net_handler_lock);\n\n\treturn nmh;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(o2net_handler_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&nmh->nh_kref"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_handler_tree_lookup",
          "args": [
            "msg_type",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_handler_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "765-795",
          "snippet": "static struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root o2net_handler_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nstatic struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\n\nstatic struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\n{\n\tstruct o2net_msg_handler *nmh;\n\n\tread_lock(&o2net_handler_lock);\n\tnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\n\tif (nmh)\n\t\tkref_get(&nmh->nh_kref);\n\tread_unlock(&o2net_handler_lock);\n\n\treturn nmh;\n}"
  },
  {
    "function_name": "o2net_unregister_handler_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "886-899",
    "snippet": "void o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(o2net_handler_lock);",
      "static struct rb_root o2net_handler_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&nmh->nh_kref",
            "o2net_handler_kref_release"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&nmh->nh_unregister_item"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&nmh->nh_node",
            "&o2net_handler_tree"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_TCP",
            "\"unregistering handler func %p type %u key %08x\\n\"",
            "nmh->nh_func",
            "nmh->nh_msg_type",
            "nmh->nh_key"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "nmh",
            "n",
            "list",
            "nh_unregister_item"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nvoid o2net_unregister_handler_list(struct list_head *list)\n{\n\tstruct o2net_msg_handler *nmh, *n;\n\n\twrite_lock(&o2net_handler_lock);\n\tlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\n\t\tmlog(ML_TCP, \"unregistering handler func %p type %u key %08x\\n\",\n\t\t     nmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\n\t\trb_erase(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_del_init(&nmh->nh_unregister_item);\n\t\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n}"
  },
  {
    "function_name": "o2net_register_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "812-883",
    "snippet": "int o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(o2net_handler_lock);",
      "static struct rb_root o2net_handler_tree = RB_ROOT;",
      "static void o2net_idle_timer(unsigned long data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nmh"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL",
            "\"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\"",
            "msg_type",
            "key"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_handler_tree_lookup",
          "args": [
            "msg_type",
            "key",
            "&p",
            "&parent"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_handler_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "765-795",
          "snippet": "static struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root o2net_handler_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nstatic struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_TCP",
            "\"registered handler func %p type %u key %08x\\n\"",
            "func",
            "msg_type",
            "key"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nmh->nh_unregister_item",
            "unreg_list"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&nmh->nh_node",
            "&o2net_handler_tree"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&nmh->nh_node",
            "parent",
            "p"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&o2net_handler_lock"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nmh->nh_unregister_item"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&nmh->nh_kref"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2net_msg_handler)",
            "GFP_NOFS"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"no message handler provided: %u, %p\\n\"",
            "msg_type",
            "func"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"max_len for message handler out of range: %u\\n\"",
            "max_len"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(o2net_handler_lock);\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\n\t\t\t   o2net_msg_handler_func *func, void *data,\n\t\t\t   o2net_post_msg_handler_func *post_func,\n\t\t\t   struct list_head *unreg_list)\n{\n\tstruct o2net_msg_handler *nmh = NULL;\n\tstruct rb_node **p, *parent;\n\tint ret = 0;\n\n\tif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"max_len for message handler out of range: %u\\n\",\n\t\t\tmax_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!msg_type) {\n\t\tmlog(0, \"no message type provided: %u, %p\\n\", msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\n\t}\n\tif (!func) {\n\t\tmlog(0, \"no message handler provided: %u, %p\\n\",\n\t\t       msg_type, func);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n       \tnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\n\tif (nmh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnmh->nh_func = func;\n\tnmh->nh_func_data = data;\n\tnmh->nh_post_func = post_func;\n\tnmh->nh_msg_type = msg_type;\n\tnmh->nh_max_len = max_len;\n\tnmh->nh_key = key;\n\t/* the tree and list get this ref.. they're both removed in\n\t * unregister when this ref is dropped */\n\tkref_init(&nmh->nh_kref);\n\tINIT_LIST_HEAD(&nmh->nh_unregister_item);\n\n\twrite_lock(&o2net_handler_lock);\n\tif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t        rb_link_node(&nmh->nh_node, parent, p);\n\t\trb_insert_color(&nmh->nh_node, &o2net_handler_tree);\n\t\tlist_add_tail(&nmh->nh_unregister_item, unreg_list);\n\n\t\tmlog(ML_TCP, \"registered handler func %p type %u key %08x\\n\",\n\t\t     func, msg_type, key);\n\t\t/* we've had some trouble with handlers seemingly vanishing. */\n\t\tmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\n\t\t\t\t\t\t\t  &parent) == NULL,\n\t\t\t        \"couldn't find handler we *just* registered \"\n\t\t\t\t\"for type %u key %08x\\n\", msg_type, key);\n\t}\n\twrite_unlock(&o2net_handler_lock);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tif (ret)\n\t\tkfree(nmh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_handler_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "805-808",
    "snippet": "static void o2net_handler_put(struct o2net_msg_handler *nmh)\n{\n\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&nmh->nh_kref",
            "o2net_handler_kref_release"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_handler_put(struct o2net_msg_handler *nmh)\n{\n\tkref_put(&nmh->nh_kref, o2net_handler_kref_release);\n}"
  },
  {
    "function_name": "o2net_handler_kref_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "797-803",
    "snippet": "static void o2net_handler_kref_release(struct kref *kref)\n{\n\tstruct o2net_msg_handler *nmh;\n\tnmh = container_of(kref, struct o2net_msg_handler, nh_kref);\n\n\tkfree(nmh);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nmh"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structo2net_msg_handler",
            "nh_kref"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_handler_kref_release(struct kref *kref)\n{\n\tstruct o2net_msg_handler *nmh;\n\tnmh = container_of(kref, struct o2net_msg_handler, nh_kref);\n\n\tkfree(nmh);\n}"
  },
  {
    "function_name": "o2net_handler_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "765-795",
    "snippet": "static struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root o2net_handler_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_handler_cmp",
          "args": [
            "nmh",
            "msg_type",
            "key"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_handler_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "754-763",
          "snippet": "static int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\n\t\t\t     u32 key)\n{\n\tint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\n\n\tif (ret == 0)\n\t\tret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\n\t\t\t     u32 key)\n{\n\tint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\n\n\tif (ret == 0)\n\t\tret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structo2net_msg_handler",
            "nh_node"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root o2net_handler_tree = RB_ROOT;\n\nstatic struct o2net_msg_handler *\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\n\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &o2net_handler_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2net_msg_handler *nmh, *ret = NULL;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\n\t\tcmp = o2net_handler_cmp(nmh, msg_type, key);\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = nmh;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_handler_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "754-763",
    "snippet": "static int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\n\t\t\t     u32 key)\n{\n\tint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\n\n\tif (ret == 0)\n\t\tret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&nmh->nh_msg_type",
            "&msg_type",
            "sizeof(msg_type)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&nmh->nh_key",
            "&key",
            "sizeof(key)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\n\t\t\t     u32 key)\n{\n\tint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\n\n\tif (ret == 0)\n\t\tret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_shutdown_sc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "727-750",
    "snippet": "static void o2net_shutdown_sc(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_shutdown_work);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tsclog(sc, \"shutting down\\n\");\n\n\t/* drop the callbacks ref and call shutdown only once */\n\tif (o2net_unregister_callbacks(sc->sc_sock->sk, sc)) {\n\t\t/* we shouldn't flush as we're in the thread, the\n\t\t * races with pending sc work structs are harmless */\n\t\tdel_timer_sync(&sc->sc_idle_timeout);\n\t\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\t\tsc_put(sc);\n\t\tkernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);\n\t}\n\n\t/* not fatal so failed connects before the other guy has our\n\t * heartbeat can be retried */\n\to2net_ensure_shutdown(nn, sc, 0);\n\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_ensure_shutdown",
          "args": [
            "nn",
            "sc",
            "0"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_ensure_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "709-717",
          "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_sock_shutdown",
          "args": [
            "sc->sc_sock",
            "SHUT_RDWR"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_sc_cancel_delayed_work",
          "args": [
            "sc",
            "&sc->sc_keepalive_work"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_cancel_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "489-494",
          "snippet": "static void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sc->sc_idle_timeout"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_unregister_callbacks",
          "args": [
            "sc->sc_sock->sk",
            "sc"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "686-701",
          "snippet": "static int o2net_unregister_callbacks(struct sock *sk,\n\t\t\t           struct o2net_sock_container *sc)\n{\n\tint ret = 0;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data == sc) {\n\t\tret = 1;\n\t\tsk->sk_user_data = NULL;\n\t\tsk->sk_data_ready = sc->sc_data_ready;\n\t\tsk->sk_state_change = sc->sc_state_change;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_unregister_callbacks(struct sock *sk,\n\t\t\t           struct o2net_sock_container *sc)\n{\n\tint ret = 0;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data == sc) {\n\t\tret = 1;\n\t\tsk->sk_user_data = NULL;\n\t\tsk->sk_data_ready = sc->sc_data_ready;\n\t\tsk->sk_state_change = sc->sc_state_change;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"shutting down\\n\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_nn_from_num",
          "args": [
            "sc->sc_node->nd_num"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_nn_from_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "291-295",
          "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structo2net_sock_container",
            "sc_shutdown_work"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_shutdown_sc(struct work_struct *work)\n{\n\tstruct o2net_sock_container *sc =\n\t\tcontainer_of(work, struct o2net_sock_container,\n\t\t\t     sc_shutdown_work);\n\tstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\n\n\tsclog(sc, \"shutting down\\n\");\n\n\t/* drop the callbacks ref and call shutdown only once */\n\tif (o2net_unregister_callbacks(sc->sc_sock->sk, sc)) {\n\t\t/* we shouldn't flush as we're in the thread, the\n\t\t * races with pending sc work structs are harmless */\n\t\tdel_timer_sync(&sc->sc_idle_timeout);\n\t\to2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\n\t\tsc_put(sc);\n\t\tkernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);\n\t}\n\n\t/* not fatal so failed connects before the other guy has our\n\t * heartbeat can be retried */\n\to2net_ensure_shutdown(nn, sc, 0);\n\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_ensure_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "709-717",
    "snippet": "static void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_nn_state",
          "args": [
            "nn",
            "NULL",
            "0",
            "err"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_nn_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "503-597",
          "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
          ],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\n\t\t\t           struct o2net_sock_container *sc,\n\t\t\t\t   int err)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nn->nn_sc == sc)\n\t\to2net_set_nn_state(nn, NULL, 0, err);\n\tspin_unlock(&nn->nn_lock);\n}"
  },
  {
    "function_name": "o2net_unregister_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "686-701",
    "snippet": "static int o2net_unregister_callbacks(struct sock *sk,\n\t\t\t           struct o2net_sock_container *sc)\n{\n\tint ret = 0;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data == sc) {\n\t\tret = 1;\n\t\tsk->sk_user_data = NULL;\n\t\tsk->sk_data_ready = sc->sc_data_ready;\n\t\tsk->sk_state_change = sc->sc_state_change;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic int o2net_unregister_callbacks(struct sock *sk,\n\t\t\t           struct o2net_sock_container *sc)\n{\n\tint ret = 0;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (sk->sk_user_data == sc) {\n\t\tret = 1;\n\t\tsk->sk_user_data = NULL;\n\t\tsk->sk_data_ready = sc->sc_data_ready;\n\t\tsk->sk_state_change = sc->sc_state_change;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2net_register_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "661-684",
    "snippet": "static void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_idle_timer(unsigned long data);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sc->sc_send_lock"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_get",
          "args": [
            "sc"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "sc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "420-424",
          "snippet": "static void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sk->sk_user_data != NULL"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_register_callbacks(struct sock *sk,\n\t\t\t\t     struct o2net_sock_container *sc)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\t/* accepted sockets inherit the old listen socket data ready */\n\tif (sk->sk_data_ready == o2net_listen_data_ready) {\n\t\tsk->sk_data_ready = sk->sk_user_data;\n\t\tsk->sk_user_data = NULL;\n\t}\n\n\tBUG_ON(sk->sk_user_data != NULL);\n\tsk->sk_user_data = sc;\n\tsc_get(sc);\n\n\tsc->sc_data_ready = sk->sk_data_ready;\n\tsc->sc_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = o2net_data_ready;\n\tsk->sk_state_change = o2net_state_change;\n\n\tmutex_init(&sc->sc_send_lock);\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}"
  },
  {
    "function_name": "o2net_state_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "620-654",
    "snippet": "static void o2net_state_change(struct sock *sk)\n{\n\tvoid (*state_change)(struct sock *sk);\n\tstruct o2net_sock_container *sc;\n\n\tread_lock(&sk->sk_callback_lock);\n\tsc = sk->sk_user_data;\n\tif (sc == NULL) {\n\t\tstate_change = sk->sk_state_change;\n\t\tgoto out;\n\t}\n\n\tsclog(sc, \"state_change to %d\\n\", sk->sk_state);\n\n\tstate_change = sc->sc_state_change;\n\n\tswitch(sk->sk_state) {\n\t/* ignore connecting sockets as they make progress */\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\to2net_sc_queue_work(sc, &sc->sc_connect_work);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"o2net: Connection to \" SC_NODEF_FMT\n\t\t\t\" shutdown, state %d\\n\",\n\t\t\tSC_NODEF_ARGS(sc), sk->sk_state);\n\t\to2net_sc_queue_work(sc, &sc->sc_shutdown_work);\n\t\tbreak;\n\t}\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tstate_change(sk);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state_change",
          "args": [
            "sk"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_state_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "620-654",
          "snippet": "static void o2net_state_change(struct sock *sk)\n{\n\tvoid (*state_change)(struct sock *sk);\n\tstruct o2net_sock_container *sc;\n\n\tread_lock(&sk->sk_callback_lock);\n\tsc = sk->sk_user_data;\n\tif (sc == NULL) {\n\t\tstate_change = sk->sk_state_change;\n\t\tgoto out;\n\t}\n\n\tsclog(sc, \"state_change to %d\\n\", sk->sk_state);\n\n\tstate_change = sc->sc_state_change;\n\n\tswitch(sk->sk_state) {\n\t/* ignore connecting sockets as they make progress */\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\to2net_sc_queue_work(sc, &sc->sc_connect_work);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"o2net: Connection to \" SC_NODEF_FMT\n\t\t\t\" shutdown, state %d\\n\",\n\t\t\tSC_NODEF_ARGS(sc), sk->sk_state);\n\t\to2net_sc_queue_work(sc, &sc->sc_shutdown_work);\n\t\tbreak;\n\t}\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tstate_change(sk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_queue_work",
          "args": [
            "sc",
            "&sc->sc_shutdown_work"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"o2net: Connection to \" SC_NODEF_FMT\n\t\t\t\" shutdown, state %d\\n\"",
            "SC_NODEF_ARGS(sc)",
            "sk->sk_state"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"state_change to %d\\n\"",
            "sk->sk_state"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_state_change(struct sock *sk)\n{\n\tvoid (*state_change)(struct sock *sk);\n\tstruct o2net_sock_container *sc;\n\n\tread_lock(&sk->sk_callback_lock);\n\tsc = sk->sk_user_data;\n\tif (sc == NULL) {\n\t\tstate_change = sk->sk_state_change;\n\t\tgoto out;\n\t}\n\n\tsclog(sc, \"state_change to %d\\n\", sk->sk_state);\n\n\tstate_change = sc->sc_state_change;\n\n\tswitch(sk->sk_state) {\n\t/* ignore connecting sockets as they make progress */\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\to2net_sc_queue_work(sc, &sc->sc_connect_work);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"o2net: Connection to \" SC_NODEF_FMT\n\t\t\t\" shutdown, state %d\\n\",\n\t\t\tSC_NODEF_ARGS(sc), sk->sk_state);\n\t\to2net_sc_queue_work(sc, &sc->sc_shutdown_work);\n\t\tbreak;\n\t}\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tstate_change(sk);\n}"
  },
  {
    "function_name": "o2net_data_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "600-617",
    "snippet": "static void o2net_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_user_data) {\n\t\tstruct o2net_sock_container *sc = sk->sk_user_data;\n\t\tsclog(sc, \"data_ready hit\\n\");\n\t\to2net_set_data_ready_time(sc);\n\t\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\t\tready = sc->sc_data_ready;\n\t} else {\n\t\tready = sk->sk_data_ready;\n\t}\n\tread_unlock(&sk->sk_callback_lock);\n\n\tready(sk);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_listen_data_ready(struct sock *sk);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ready",
          "args": [
            "sk"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_listen_data_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2011-2045",
          "snippet": "static void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) { /* check for teardown race */\n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t/* This callback may called twice when a new connection\n\t * is  being established as a child socket inherits everything\n\t * from a parent LISTEN socket, including the data_ready cb of\n\t * the parent. This leads to a hazard. In o2net_accept_one()\n\t * we are still initializing the child socket but have not\n\t * changed the inherited data_ready callback yet when\n\t * data starts arriving.\n\t * We avoid this hazard by checking the state.\n\t * For the listening socket,  the state will be TCP_LISTEN; for the new\n\t * socket, will be  TCP_ESTABLISHED. Also, in this case,\n\t * sk->sk_user_data is not a valid function pointer.\n\t */\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static struct work_struct o2net_listen_work;",
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic struct work_struct o2net_listen_work;\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_idle_timer(unsigned long data);\n\nstatic void o2net_listen_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tready = sk->sk_user_data;\n\tif (ready == NULL) { /* check for teardown race */\n\t\tready = sk->sk_data_ready;\n\t\tgoto out;\n\t}\n\n\t/* This callback may called twice when a new connection\n\t * is  being established as a child socket inherits everything\n\t * from a parent LISTEN socket, including the data_ready cb of\n\t * the parent. This leads to a hazard. In o2net_accept_one()\n\t * we are still initializing the child socket but have not\n\t * changed the inherited data_ready callback yet when\n\t * data starts arriving.\n\t * We avoid this hazard by checking the state.\n\t * For the listening socket,  the state will be TCP_LISTEN; for the new\n\t * socket, will be  TCP_ESTABLISHED. Also, in this case,\n\t * sk->sk_user_data is not a valid function pointer.\n\t */\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tqueue_work(o2net_wq, &o2net_listen_work);\n\t} else {\n\t\tready = NULL;\n\t}\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (ready != NULL)\n\t\tready(sk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_queue_work",
          "args": [
            "sc",
            "&sc->sc_rx_work"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_set_data_ready_time",
          "args": [
            "sc"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_set_data_ready_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "189-192",
          "snippet": "static inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_data_ready = ktime_get();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_data_ready = ktime_get();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"data_ready hit\\n\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_data_ready(struct sock *sk)\n{\n\tvoid (*ready)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_user_data) {\n\t\tstruct o2net_sock_container *sc = sk->sk_user_data;\n\t\tsclog(sc, \"data_ready hit\\n\");\n\t\to2net_set_data_ready_time(sc);\n\t\to2net_sc_queue_work(sc, &sc->sc_rx_work);\n\t\tready = sc->sc_data_ready;\n\t} else {\n\t\tready = sk->sk_data_ready;\n\t}\n\tread_unlock(&sk->sk_callback_lock);\n\n\tready(sk);\n}"
  },
  {
    "function_name": "o2net_set_nn_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "503-597",
    "snippet": "static void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\""
    ],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);",
      "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "old_sc"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_sc_queue_work",
          "args": [
            "old_sc",
            "&old_sc->sc_shutdown_work"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_get",
          "args": [
            "sc"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "420-424",
          "snippet": "static void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "o2net_wq",
            "&nn->nn_connect_expired",
            "delay"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_idle_timeout()"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_idle_timeout",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_idle_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "275-278",
          "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_CONN",
            "\"queueing conn attempt in %lu jiffies\\n\"",
            "delay"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_reconnect_delay()"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_reconnect_delay",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_reconnect_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "265-268",
          "snippet": "static inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "o2net_reconnect_delay()"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\"",
            "o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\"",
            "SC_NODEF_ARGS(sc)"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "sc"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nn->nn_connect_expired"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_conn_up",
          "args": [
            "o2net_num_from_nn(nn)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "278-298",
          "snippet": "void o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_up(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tqs->qs_connected++;\n\tmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\n\t\t        \"node %u\\n\", node);\n\tmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), \"node %u\\n\", node);\n\tset_bit(node, qs->qs_conn_bm);\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (!test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\telse\n\t\to2quo_clear_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_complete_nodes_nsw",
          "args": [
            "nn"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_complete_nodes_nsw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "363-377",
          "snippet": "static void o2net_complete_nodes_nsw(struct o2net_node *nn)\n{\n\tstruct o2net_status_wait *nsw, *tmp;\n\tunsigned int num_kills = 0;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\n\t\to2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\n\t\tnum_kills++;\n\t}\n\n\tmlog(0, \"completed %d messages for node %u\\n\", num_kills,\n\t     o2net_num_from_nn(nn));\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nodes_nsw(struct o2net_node *nn)\n{\n\tstruct o2net_status_wait *nsw, *tmp;\n\tunsigned int num_kills = 0;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\n\t\to2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\n\t\tnum_kills++;\n\t}\n\n\tmlog(0, \"completed %d messages for node %u\\n\", num_kills,\n\t     o2net_num_from_nn(nn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_NODEF_ARGS",
          "args": [
            "old_sc"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "O2NET_QUORUM_DELAY_MS"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2quo_conn_err",
          "args": [
            "o2net_num_from_nn(nn)"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "o2quo_conn_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/quorum.c",
          "lines": "304-325",
          "snippet": "void o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}",
          "includes": [
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/reboot.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include <linux/reboot.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\nstatic struct o2quo_state {\n\tspinlock_t\t\tqs_lock;\n\tstruct work_struct\tqs_work;\n\tint\t\t\tqs_pending;\n\tint\t\t\tqs_heartbeating;\n\tunsigned long\t\tqs_hb_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_connected;\n\tunsigned long\t\tqs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint\t\t\tqs_holds;\n\tunsigned long\t\tqs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];\n} o2quo_state;\n\nvoid o2quo_conn_err(u8 node)\n{\n\tstruct o2quo_state *qs = &o2quo_state;\n\n\tspin_lock(&qs->qs_lock);\n\n\tif (test_bit(node, qs->qs_conn_bm)) {\n\t\tqs->qs_connected--;\n\t\tmlog_bug_on_msg(qs->qs_connected < 0,\n\t\t\t\t\"node %u, connected %d\\n\",\n\t\t\t\tnode, qs->qs_connected);\n\n\t\tclear_bit(node, qs->qs_conn_bm);\n\t}\n\n\tmlog(0, \"node %u, %d total\\n\", node, qs->qs_connected);\n\n\tif (test_bit(node, qs->qs_hb_bm))\n\t\to2quo_set_hold(qs, node);\n\n\tspin_unlock(&qs->qs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&nn->nn_sc_wq"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_CONN",
            "\"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\"",
            "o2net_num_from_nn(nn)",
            "nn->nn_sc",
            "sc",
            "nn->nn_sc_valid",
            "valid",
            "nn->nn_persistent_error",
            "err"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "valid && !sc",
            "\"valid %u sc %p\\n\"",
            "valid",
            "sc"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "err && valid",
            "\"err %d valid %u\\n\"",
            "err",
            "valid"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sc && nn->nn_sc && nn->nn_sc != sc"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&o2net_connected_peers"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&o2net_connected_peers"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define SC_NODEF_FMT \"node %s (num %u) at %pI4:%u\"\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nstatic void o2net_set_nn_state(struct o2net_node *nn,\n\t\t\t       struct o2net_sock_container *sc,\n\t\t\t       unsigned valid, int err)\n{\n\tint was_valid = nn->nn_sc_valid;\n\tint was_err = nn->nn_persistent_error;\n\tstruct o2net_sock_container *old_sc = nn->nn_sc;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (old_sc && !sc)\n\t\tatomic_dec(&o2net_connected_peers);\n\telse if (!old_sc && sc)\n\t\tatomic_inc(&o2net_connected_peers);\n\n\t/* the node num comparison and single connect/accept path should stop\n\t * an non-null sc from being overwritten with another */\n\tBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\n\tmlog_bug_on_msg(err && valid, \"err %d valid %u\\n\", err, valid);\n\tmlog_bug_on_msg(valid && !sc, \"valid %u sc %p\\n\", valid, sc);\n\n\tif (was_valid && !valid && err == 0)\n\t\terr = -ENOTCONN;\n\n\tmlog(ML_CONN, \"node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\\n\",\n\t     o2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\n\t     nn->nn_persistent_error, err);\n\n\tnn->nn_sc = sc;\n\tnn->nn_sc_valid = valid ? 1 : 0;\n\tnn->nn_persistent_error = err;\n\n\t/* mirrors o2net_tx_can_proceed() */\n\tif (nn->nn_persistent_error || nn->nn_sc_valid)\n\t\twake_up(&nn->nn_sc_wq);\n\n\tif (was_valid && !was_err && nn->nn_persistent_error) {\n\t\to2quo_conn_err(o2net_num_from_nn(nn));\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_still_up,\n\t\t\t\t   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\n\t}\n\n\tif (was_valid && !valid) {\n\t\tif (old_sc)\n\t\t\tprintk(KERN_NOTICE \"o2net: No longer connected to \"\n\t\t\t\tSC_NODEF_FMT \"\\n\", SC_NODEF_ARGS(old_sc));\n\t\to2net_complete_nodes_nsw(nn);\n\t}\n\n\tif (!was_valid && valid) {\n\t\to2quo_conn_up(o2net_num_from_nn(nn));\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tprintk(KERN_NOTICE \"o2net: %s \" SC_NODEF_FMT \"\\n\",\n\t\t       o2nm_this_node() > sc->sc_node->nd_num ?\n\t\t       \"Connected to\" : \"Accepted connection from\",\n\t\t       SC_NODEF_ARGS(sc));\n\t}\n\n\t/* trigger the connecting worker func as long as we're not valid,\n\t * it will back off if it shouldn't connect.  This can be called\n\t * from node config teardown and so needs to be careful about\n\t * the work queue actually being up. */\n\tif (!valid && o2net_wq) {\n\t\tunsigned long delay;\n\t\t/* delay if we're within a RECONNECT_DELAY of the\n\t\t * last attempt */\n\t\tdelay = (nn->nn_last_connect_attempt +\n\t\t\t msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\t- jiffies;\n\t\tif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\n\t\t\tdelay = 0;\n\t\tmlog(ML_CONN, \"queueing conn attempt in %lu jiffies\\n\", delay);\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\n\n\t\t/*\n\t\t * Delay the expired work after idle timeout.\n\t\t *\n\t\t * We might have lots of failed connection attempts that run\n\t\t * through here but we only cancel the connect_expired work when\n\t\t * a connection attempt succeeds.  So only the first enqueue of\n\t\t * the connect_expired work will do anything.  The rest will see\n\t\t * that it's already queued and do nothing.\n\t\t */\n\t\tdelay += msecs_to_jiffies(o2net_idle_timeout());\n\t\tqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\n\t}\n\n\t/* keep track of the nn's sc ref for the caller */\n\tif ((old_sc == NULL) && sc)\n\t\tsc_get(sc);\n\tif (old_sc && (old_sc != sc)) {\n\t\to2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\n\t\tsc_put(old_sc);\n\t}\n}"
  },
  {
    "function_name": "o2net_num_connected_peers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "498-501",
    "snippet": "int o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&o2net_connected_peers"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nint o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}"
  },
  {
    "function_name": "o2net_sc_cancel_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "489-494",
    "snippet": "static void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "work"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\t struct delayed_work *work)\n{\n\tif (cancel_delayed_work(work))\n\t\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_sc_queue_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "481-488",
    "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "o2net_wq",
            "work",
            "delay"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sc_get",
          "args": [
            "sc"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "420-424",
          "snippet": "static void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
  },
  {
    "function_name": "o2net_sc_queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "474-480",
    "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *o2net_wq;",
      "static void o2net_sc_connect_completed(struct work_struct *work);",
      "static void o2net_rx_until_empty(struct work_struct *work);",
      "static void o2net_shutdown_sc(struct work_struct *work);",
      "static void o2net_sc_send_keep_req(struct work_struct *work);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_put",
          "args": [
            "sc"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "sc_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "415-419",
          "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "o2net_wq",
            "work"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "474-480",
          "snippet": "static void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sc_get",
          "args": [
            "sc"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "420-424",
          "snippet": "static void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\n\t\t\t\tstruct work_struct *work)\n{\n\tsc_get(sc);\n\tif (!queue_work(o2net_wq, work))\n\t\tsc_put(sc);\n}"
  },
  {
    "function_name": "sc_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "425-470",
    "snippet": "static struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_idle_timer(unsigned long data);",
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sc"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_debug_add_sc",
          "args": [
            "sc"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debug_add_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "147-149",
          "snippet": "static inline void o2net_debug_add_sc(struct o2net_sock_container *sc)\n{\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline void o2net_debug_add_sc(struct o2net_sock_container *sc)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"alloced\\n\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_timer",
          "args": [
            "&sc->sc_idle_timeout"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sc->sc_keepalive_work",
            "o2net_sc_send_keep_req"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sc->sc_shutdown_work",
            "o2net_shutdown_sc"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sc->sc_rx_work",
            "o2net_rx_until_empty"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sc->sc_connect_work",
            "o2net_sc_connect_completed"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "node"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_depend_item",
          "args": [
            "&node->nd_item"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_depend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "892-895",
          "snippet": "int o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_get",
          "args": [
            "node"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "137-140",
          "snippet": "void o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&sc->sc_kref"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sc)",
            "GFP_NOFS"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\n{\n\tstruct o2net_sock_container *sc, *ret = NULL;\n\tstruct page *page = NULL;\n\tint status = 0;\n\n\tpage = alloc_page(GFP_NOFS);\n\tsc = kzalloc(sizeof(*sc), GFP_NOFS);\n\tif (sc == NULL || page == NULL)\n\t\tgoto out;\n\n\tkref_init(&sc->sc_kref);\n\to2nm_node_get(node);\n\tsc->sc_node = node;\n\n\t/* pin the node item of the remote node */\n\tstatus = o2nm_depend_item(&node->nd_item);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\to2nm_node_put(node);\n\t\tgoto out;\n\t}\n\tINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\n\tINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\n\tINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\n\tINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\n\n\tinit_timer(&sc->sc_idle_timeout);\n\tsc->sc_idle_timeout.function = o2net_idle_timer;\n\tsc->sc_idle_timeout.data = (unsigned long)sc;\n\n\tsclog(sc, \"alloced\\n\");\n\n\tret = sc;\n\tsc->sc_page = page;\n\to2net_debug_add_sc(sc);\n\tsc = NULL;\n\tpage = NULL;\n\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(sc);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sc_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "420-424",
    "snippet": "static void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&sc->sc_kref"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"get\\n\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_get(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"get\\n\");\n\tkref_get(&sc->sc_kref);\n}"
  },
  {
    "function_name": "sc_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "415-419",
    "snippet": "static void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&sc->sc_kref",
            "sc_kref_release"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"put\\n\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_put(struct o2net_sock_container *sc)\n{\n\tsclog(sc, \"put\\n\");\n\tkref_put(&sc->sc_kref, sc_kref_release);\n}"
  },
  {
    "function_name": "sc_kref_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "391-413",
    "snippet": "static void sc_kref_release(struct kref *kref)\n{\n\tstruct o2net_sock_container *sc = container_of(kref,\n\t\t\t\t\tstruct o2net_sock_container, sc_kref);\n\tBUG_ON(timer_pending(&sc->sc_idle_timeout));\n\n\tsclog(sc, \"releasing\\n\");\n\n\tif (sc->sc_sock) {\n\t\tsock_release(sc->sc_sock);\n\t\tsc->sc_sock = NULL;\n\t}\n\n\to2nm_undepend_item(&sc->sc_node->nd_item);\n\to2nm_node_put(sc->sc_node);\n\tsc->sc_node = NULL;\n\n\to2net_debug_del_sc(sc);\n\n\tif (sc->sc_page)\n\t\t__free_page(sc->sc_page);\n\tkfree(sc);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sc"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "sc->sc_page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_debug_del_sc",
          "args": [
            "sc"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_debug_del_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "150-152",
          "snippet": "static inline void o2net_debug_del_sc(struct o2net_sock_container *sc)\n{\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline void o2net_debug_del_sc(struct o2net_sock_container *sc)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "sc->sc_node"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_undepend_item",
          "args": [
            "&sc->sc_node->nd_item"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_undepend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "897-900",
          "snippet": "void o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "sc->sc_sock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sclog",
          "args": [
            "sc",
            "\"releasing\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "timer_pending(&sc->sc_idle_timeout)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&sc->sc_idle_timeout"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structo2net_sock_container",
            "sc_kref"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void sc_kref_release(struct kref *kref)\n{\n\tstruct o2net_sock_container *sc = container_of(kref,\n\t\t\t\t\tstruct o2net_sock_container, sc_kref);\n\tBUG_ON(timer_pending(&sc->sc_idle_timeout));\n\n\tsclog(sc, \"releasing\\n\");\n\n\tif (sc->sc_sock) {\n\t\tsock_release(sc->sc_sock);\n\t\tsc->sc_sock = NULL;\n\t}\n\n\to2nm_undepend_item(&sc->sc_node->nd_item);\n\to2nm_node_put(sc->sc_node);\n\tsc->sc_node = NULL;\n\n\to2net_debug_del_sc(sc);\n\n\tif (sc->sc_page)\n\t\t__free_page(sc->sc_page);\n\tkfree(sc);\n}"
  },
  {
    "function_name": "o2net_nsw_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "379-387",
    "snippet": "static int o2net_nsw_completed(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw)\n{\n\tint completed;\n\tspin_lock(&nn->nn_lock);\n\tcompleted = list_empty(&nsw->ns_node_item);\n\tspin_unlock(&nn->nn_lock);\n\treturn completed;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nsw->ns_node_item"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_nsw_completed(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw)\n{\n\tint completed;\n\tspin_lock(&nn->nn_lock);\n\tcompleted = list_empty(&nsw->ns_node_item);\n\tspin_unlock(&nn->nn_lock);\n\treturn completed;\n}"
  },
  {
    "function_name": "o2net_complete_nodes_nsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "363-377",
    "snippet": "static void o2net_complete_nodes_nsw(struct o2net_node *nn)\n{\n\tstruct o2net_status_wait *nsw, *tmp;\n\tunsigned int num_kills = 0;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\n\t\to2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\n\t\tnum_kills++;\n\t}\n\n\tmlog(0, \"completed %d messages for node %u\\n\", num_kills,\n\t     o2net_num_from_nn(nn));\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"completed %d messages for node %u\\n\"",
            "num_kills",
            "o2net_num_from_nn(nn)"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_from_nn",
          "args": [
            "nn"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_from_nn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "297-301",
          "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_complete_nsw_locked",
          "args": [
            "nn",
            "nsw",
            "O2NET_ERR_DIED",
            "0"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_complete_nsw_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "325-339",
          "snippet": "static void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "nsw",
            "tmp",
            "&nn->nn_status_list",
            "ns_node_item"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nodes_nsw(struct o2net_node *nn)\n{\n\tstruct o2net_status_wait *nsw, *tmp;\n\tunsigned int num_kills = 0;\n\n\tassert_spin_locked(&nn->nn_lock);\n\n\tlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\n\t\to2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\n\t\tnum_kills++;\n\t}\n\n\tmlog(0, \"completed %d messages for node %u\\n\", num_kills,\n\t     o2net_num_from_nn(nn));\n}"
  },
  {
    "function_name": "o2net_complete_nsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "341-361",
    "snippet": "static void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_complete_nsw_locked",
          "args": [
            "nn",
            "nsw",
            "sys_status",
            "status"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_complete_nsw_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "325-339",
          "snippet": "static void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&nn->nn_status_idr",
            "id"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "343-351",
          "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw(struct o2net_node *nn,\n\t\t\t       struct o2net_status_wait *nsw,\n\t\t\t       u64 id, enum o2net_system_error sys_status,\n\t\t\t       s32 status)\n{\n\tspin_lock(&nn->nn_lock);\n\tif (nsw == NULL) {\n\t\tif (id > INT_MAX)\n\t\t\tgoto out;\n\n\t\tnsw = idr_find(&nn->nn_status_idr, id);\n\t\tif (nsw == NULL)\n\t\t\tgoto out;\n\t}\n\n\to2net_complete_nsw_locked(nn, nsw, sys_status, status);\n\nout:\n\tspin_unlock(&nn->nn_lock);\n\treturn;\n}"
  },
  {
    "function_name": "o2net_complete_nsw_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "325-339",
    "snippet": "static void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&nsw->ns_wq"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&nn->nn_status_idr",
            "nsw->ns_id"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&nsw->ns_node_item"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nsw->ns_node_item"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_complete_nsw_locked(struct o2net_node *nn,\n\t\t\t\t      struct o2net_status_wait *nsw,\n\t\t\t\t      enum o2net_system_error sys_status,\n\t\t\t\t      s32 status)\n{\n\tassert_spin_locked(&nn->nn_lock);\n\n\tif (!list_empty(&nsw->ns_node_item)) {\n\t\tlist_del_init(&nsw->ns_node_item);\n\t\tnsw->ns_sys_status = sys_status;\n\t\tnsw->ns_status = status;\n\t\tidr_remove(&nn->nn_status_idr, nsw->ns_id);\n\t\twake_up(&nsw->ns_wq);\n\t}\n}"
  },
  {
    "function_name": "o2net_prep_nsw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "305-323",
    "snippet": "static int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\n{\n\tint ret;\n\n\tspin_lock(&nn->nn_lock);\n\tret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\n\tif (ret >= 0) {\n\t\tnsw->ns_id = ret;\n\t\tlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&nsw->ns_wq);\n\tnsw->ns_sys_status = O2NET_ERR_NONE;\n\tnsw->ns_status = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&nsw->ns_wq"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nsw->ns_node_item",
            "&nn->nn_status_list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&nn->nn_status_idr",
            "nsw",
            "0",
            "0",
            "GFP_ATOMIC"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->nn_lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\n{\n\tint ret;\n\n\tspin_lock(&nn->nn_lock);\n\tret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\n\tif (ret >= 0) {\n\t\tnsw->ns_id = ret;\n\t\tlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\n\t}\n\tspin_unlock(&nn->nn_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&nsw->ns_wq);\n\tnsw->ns_sys_status = O2NET_ERR_NONE;\n\tnsw->ns_status = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "o2net_num_from_nn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "297-301",
    "snippet": "static u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nn == NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\n{\n\tBUG_ON(nn == NULL);\n\treturn nn - o2net_nodes;\n}"
  },
  {
    "function_name": "o2net_nn_from_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "291-295",
    "snippet": "static struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node_num >= ARRAY_SIZE(o2net_nodes)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "o2net_nodes"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\n\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\n{\n\tBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\n\treturn &o2net_nodes[node_num];\n}"
  },
  {
    "function_name": "o2net_sys_err_to_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "280-289",
    "snippet": "static inline int o2net_sys_err_to_errno(enum o2net_system_error err)\n{\n\tint trans;\n\tBUG_ON(err >= O2NET_ERR_MAX);\n\ttrans = o2net_sys_err_translations[err];\n\n\t/* Just in case we mess up the translation table above */\n\tBUG_ON(err != O2NET_ERR_NONE && trans == 0);\n\treturn trans;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int o2net_sys_err_translations[O2NET_ERR_MAX] =\n\t\t{[O2NET_ERR_NONE]\t= 0,\n\t\t [O2NET_ERR_NO_HNDLR]\t= -ENOPROTOOPT,\n\t\t [O2NET_ERR_OVERFLOW]\t= -EOVERFLOW,\n\t\t [O2NET_ERR_DIED]\t= -EHOSTDOWN,};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != O2NET_ERR_NONE && trans == 0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err >= O2NET_ERR_MAX"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic int o2net_sys_err_translations[O2NET_ERR_MAX] =\n\t\t{[O2NET_ERR_NONE]\t= 0,\n\t\t [O2NET_ERR_NO_HNDLR]\t= -ENOPROTOOPT,\n\t\t [O2NET_ERR_OVERFLOW]\t= -EOVERFLOW,\n\t\t [O2NET_ERR_DIED]\t= -EHOSTDOWN,};\n\nstatic inline int o2net_sys_err_to_errno(enum o2net_system_error err)\n{\n\tint trans;\n\tBUG_ON(err >= O2NET_ERR_MAX);\n\ttrans = o2net_sys_err_translations[err];\n\n\t/* Just in case we mess up the translation table above */\n\tBUG_ON(err != O2NET_ERR_NONE && trans == 0);\n\treturn trans;\n}"
  },
  {
    "function_name": "o2net_idle_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "275-278",
    "snippet": "static inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_idle_timeout(void)\n{\n\treturn o2nm_single_cluster->cl_idle_timeout_ms;\n}"
  },
  {
    "function_name": "o2net_keepalive_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "270-273",
    "snippet": "static inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_keepalive_delay(void)\n{\n\treturn o2nm_single_cluster->cl_keepalive_delay_ms;\n}"
  },
  {
    "function_name": "o2net_reconnect_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "265-268",
    "snippet": "static inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned int o2net_reconnect_delay(void)\n{\n\treturn o2nm_single_cluster->cl_reconnect_delay_ms;\n}"
  },
  {
    "function_name": "o2net_update_recv_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "250-255",
    "snippet": "static void o2net_update_recv_stats(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\n\t\t\t\t\t    o2net_get_func_run_time(sc));\n\tsc->sc_recv_count++;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "sc->sc_tv_process_total",
            "o2net_get_func_run_time(sc)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_get_func_run_time",
          "args": [
            "sc"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_get_func_run_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "230-233",
          "snippet": "static ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\n{\n\treturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\n{\n\treturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_update_recv_stats(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\n\t\t\t\t\t    o2net_get_func_run_time(sc));\n\tsc->sc_recv_count++;\n}"
  },
  {
    "function_name": "o2net_update_send_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "235-248",
    "snippet": "static void o2net_update_send_stats(struct o2net_send_tracking *nst,\n\t\t\t\t    struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\n\t\t\t\t\t   ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time));\n\tsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\n\t\t\t\t\t ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time));\n\tsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\n\t\t\t\t\t    ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time));\n\tsc->sc_send_count++;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "sc->sc_tv_acquiry_total",
            "ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "nst->st_send_time",
            "nst->st_sock_time"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "sc->sc_tv_send_total",
            "ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "nst->st_status_time",
            "nst->st_send_time"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "sc->sc_tv_status_total",
            "ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "nst->st_status_time"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_update_send_stats(struct o2net_send_tracking *nst,\n\t\t\t\t    struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\n\t\t\t\t\t   ktime_sub(ktime_get(),\n\t\t\t\t\t\t     nst->st_status_time));\n\tsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\n\t\t\t\t\t ktime_sub(nst->st_status_time,\n\t\t\t\t\t\t   nst->st_send_time));\n\tsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\n\t\t\t\t\t    ktime_sub(nst->st_send_time,\n\t\t\t\t\t\t      nst->st_sock_time));\n\tsc->sc_send_count++;\n}"
  },
  {
    "function_name": "o2net_get_func_run_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "230-233",
    "snippet": "static ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\n{\n\treturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "sc->sc_tv_func_stop",
            "sc->sc_tv_func_start"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\n{\n\treturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\n}"
  },
  {
    "function_name": "o2net_set_func_stop_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "209-212",
    "snippet": "static inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_stop = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_stop = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_func_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "204-207",
    "snippet": "static inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_start = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_func_start = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_advance_stop_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "199-202",
    "snippet": "static inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_stop = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_stop = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_advance_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "194-197",
    "snippet": "static inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_start = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_advance_start = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_data_ready_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "189-192",
    "snippet": "static inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_data_ready = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_data_ready = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_sock_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "184-187",
    "snippet": "static inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_timer = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\n{\n\tsc->sc_tv_timer = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_nst_msg_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "178-182",
    "snippet": "static inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\n\t\t\t\t\tu32 msg_id)\n{\n\tnst->st_id = msg_id;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\n\t\t\t\t\tu32 msg_id)\n{\n\tnst->st_id = msg_id;\n}"
  },
  {
    "function_name": "o2net_set_nst_sock_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "172-176",
    "snippet": "static inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\n\t\t\t\t\t\tstruct o2net_sock_container *sc)\n{\n\tnst->st_sc = sc;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
      "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\n\t\t\t\t\t\tstruct o2net_sock_container *sc)\n{\n\tnst->st_sc = sc;\n}"
  },
  {
    "function_name": "o2net_set_nst_status_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "167-170",
    "snippet": "static inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_status_time = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_status_time = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_nst_send_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "162-165",
    "snippet": "static inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_send_time = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_send_time = ktime_get();\n}"
  },
  {
    "function_name": "o2net_set_nst_sock_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "157-160",
    "snippet": "static inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_sock_time = ktime_get();\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\n{\n\tnst->st_sock_time = ktime_get();\n}"
  },
  {
    "function_name": "o2net_init_nst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
    "lines": "147-155",
    "snippet": "static void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\n\t\t\t   u32 msgkey, struct task_struct *task, u8 node)\n{\n\tINIT_LIST_HEAD(&nst->st_net_debug_item);\n\tnst->st_task = task;\n\tnst->st_msg_type = msgtype;\n\tnst->st_msg_key = msgkey;\n\tnst->st_node = node;\n}",
    "includes": [
      "#include \"tcp_internal.h\"",
      "#include \"quorum.h\"",
      "#include \"masklog.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include \"heartbeat.h\"",
      "#include <asm/uaccess.h>",
      "#include <net/tcp.h>",
      "#include <linux/export.h>",
      "#include <linux/net.h>",
      "#include <linux/kref.h>",
      "#include <linux/idr.h>",
      "#include <linux/slab.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nst->st_net_debug_item"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\n\t\t\t   u32 msgkey, struct task_struct *task, u8 node)\n{\n\tINIT_LIST_HEAD(&nst->st_net_debug_item);\n\tnst->st_task = task;\n\tnst->st_msg_type = msgtype;\n\tnst->st_msg_key = msgkey;\n\tnst->st_node = node;\n}"
  }
]