[
  {
    "function_name": "nlmsvc_traverse_shares",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
    "lines": "92-106",
    "snippet": "void nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file,\n\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_share\t*share, **shpp;\n\n\tshpp = &file->f_shares;\n\twhile ((share = *shpp) !=  NULL) {\n\t\tif (match(share->s_host, host)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\tcontinue;\n\t\t}\n\t\tshpp = &share->s_next;\n\t}\n}",
    "includes": [
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/unistd.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "share"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "share->s_host",
            "host"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_cookie_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "169-176",
          "snippet": "static inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\nvoid nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file,\n\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_share\t*share, **shpp;\n\n\tshpp = &file->f_shares;\n\twhile ((share = *shpp) !=  NULL) {\n\t\tif (match(share->s_host, host)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\tcontinue;\n\t\t}\n\t\tshpp = &share->s_next;\n\t}\n}"
  },
  {
    "function_name": "nlmsvc_unshare_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
    "lines": "67-86",
    "snippet": "__be32\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share, **shpp;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\n\tfor (shpp = &file->f_shares; (share = *shpp) != NULL;\n\t\t\t\t\tshpp = &share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\treturn nlm_granted;\n\t\t}\n\t}\n\n\t/* X/Open spec says return success even if there was no\n\t * corresponding share. */\n\treturn nlm_granted;\n}",
    "includes": [
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/unistd.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "share"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_cmp_owner",
          "args": [
            "share",
            "oh"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_cmp_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
          "lines": "19-24",
          "snippet": "static inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}",
          "includes": [
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/unistd.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\nstatic inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\n__be32\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share, **shpp;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\n\tfor (shpp = &file->f_shares; (share = *shpp) != NULL;\n\t\t\t\t\tshpp = &share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\treturn nlm_granted;\n\t\t}\n\t}\n\n\t/* X/Open spec says return success even if there was no\n\t * corresponding share. */\n\treturn nlm_granted;\n}"
  },
  {
    "function_name": "nlmsvc_share_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
    "lines": "26-62",
    "snippet": "__be32\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\tu8\t\t\t*ohdata;\n\n\tfor (share = file->f_shares; share; share = share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh))\n\t\t\tgoto update;\n\t\tif ((argp->fsm_access & share->s_mode)\n\t\t || (argp->fsm_mode   & share->s_access ))\n\t\t\treturn nlm_lck_denied;\n\t}\n\n\tshare = kmalloc(sizeof(*share) + oh->len,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (share == NULL)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Copy owner handle */\n\tohdata = (u8 *) (share + 1);\n\tmemcpy(ohdata, oh->data, oh->len);\n\n\tshare->s_file\t    = file;\n\tshare->s_host       = host;\n\tshare->s_owner.data = ohdata;\n\tshare->s_owner.len  = oh->len;\n\tshare->s_next       = file->f_shares;\n\tfile->f_shares      = share;\n\nupdate:\n\tshare->s_access = argp->fsm_access;\n\tshare->s_mode   = argp->fsm_mode;\n\treturn nlm_granted;\n}",
    "includes": [
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/unistd.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ohdata",
            "oh->data",
            "oh->len"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*share) + oh->len",
            "GFP_KERNEL"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_cmp_owner",
          "args": [
            "share",
            "oh"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_cmp_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
          "lines": "19-24",
          "snippet": "static inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}",
          "includes": [
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/unistd.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\nstatic inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\n__be32\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\tu8\t\t\t*ohdata;\n\n\tfor (share = file->f_shares; share; share = share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh))\n\t\t\tgoto update;\n\t\tif ((argp->fsm_access & share->s_mode)\n\t\t || (argp->fsm_mode   & share->s_access ))\n\t\t\treturn nlm_lck_denied;\n\t}\n\n\tshare = kmalloc(sizeof(*share) + oh->len,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (share == NULL)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Copy owner handle */\n\tohdata = (u8 *) (share + 1);\n\tmemcpy(ohdata, oh->data, oh->len);\n\n\tshare->s_file\t    = file;\n\tshare->s_host       = host;\n\tshare->s_owner.data = ohdata;\n\tshare->s_owner.len  = oh->len;\n\tshare->s_next       = file->f_shares;\n\tfile->f_shares      = share;\n\nupdate:\n\tshare->s_access = argp->fsm_access;\n\tshare->s_mode   = argp->fsm_mode;\n\treturn nlm_granted;\n}"
  },
  {
    "function_name": "nlm_cmp_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
    "lines": "19-24",
    "snippet": "static inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}",
    "includes": [
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/unistd.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "share->s_owner.data",
            "oh->data",
            "oh->len"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\nstatic inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}"
  }
]