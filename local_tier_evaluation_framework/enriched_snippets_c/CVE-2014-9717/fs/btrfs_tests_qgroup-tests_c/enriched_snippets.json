[
  {
    "function_name": "btrfs_test_qgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "389-469",
    "snippet": "int btrfs_test_qgroups(void)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tmp_root;\n\tint ret = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* We are using this root as our extent root */\n\troot->fs_info->extent_root = root;\n\n\t/*\n\t * Some of the paths we test assume we have a filled out fs_info, so we\n\t * just need to add the root in there so we don't panic.\n\t */\n\troot->fs_info->tree_root = root;\n\troot->fs_info->quota_root = root;\n\troot->fs_info->quota_enabled = 1;\n\n\t/*\n\t * Can't use bytenr 0, some things freak out\n\t * *cough*backref walking code*cough*\n\t */\n\troot->node = alloc_test_extent_buffer(root->fs_info, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbtrfs_set_header_level(root->node, 0);\n\tbtrfs_set_header_nritems(root->node, 0);\n\troot->alloc_bytenr += 8192;\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 5;\n\troot->fs_info->fs_root = tmp_root;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 256;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttest_msg(\"Running qgroup tests\\n\");\n\tret = test_no_shared_qgroup(root);\n\tif (ret)\n\t\tgoto out;\n\tret = test_multiple_refs(root);\nout:\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_dummy_root",
          "args": [
            "root"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "161-170",
          "snippet": "void btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_multiple_refs",
          "args": [
            "root"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "test_multiple_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "293-387",
          "snippet": "static int test_multiple_refs(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup multiple refs test\\n\");\n\n\t/* We have 5 created already from the previous test */\n\tret = btrfs_create_qgroup(NULL, fs_info, 256, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = add_tree_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_multiple_refs(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup multiple refs test\\n\");\n\n\t/* We have 5 created already from the previous test */\n\tret = btrfs_create_qgroup(NULL, fs_info, 256, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = add_tree_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_no_shared_qgroup",
          "args": [
            "root"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "test_no_shared_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "226-286",
          "snippet": "static int test_no_shared_qgroup(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup basic add\\n\");\n\tret = btrfs_create_qgroup(NULL, fs_info, 5, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_item(root, 4096, 4096);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove space from the qgroup %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_no_shared_qgroup(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup basic add\\n\");\n\tret = btrfs_create_qgroup(NULL, fs_info, 5, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_item(root, 4096, 4096);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove space from the qgroup %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running qgroup tests\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't insert fs root %d\\n\"",
            "ret"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_fs_root",
          "args": [
            "root->fs_info",
            "tmp_root"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1605-1624",
          "snippet": "int btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp_root"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate a fs root\\n\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_root"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_root",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1298-1310",
          "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't insert fs root %d\\n\"",
            "ret"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp_root"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate a fs root\\n\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_root"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "root->node",
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "root->node",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy buffer\\n\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_test_extent_buffer",
          "args": [
            "root->fs_info",
            "4096"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_test_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4780-4823",
          "snippet": "struct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy fs info\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_fs_info",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "79-126",
          "snippet": "struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate root\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nint btrfs_test_qgroups(void)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tmp_root;\n\tint ret = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* We are using this root as our extent root */\n\troot->fs_info->extent_root = root;\n\n\t/*\n\t * Some of the paths we test assume we have a filled out fs_info, so we\n\t * just need to add the root in there so we don't panic.\n\t */\n\troot->fs_info->tree_root = root;\n\troot->fs_info->quota_root = root;\n\troot->fs_info->quota_enabled = 1;\n\n\t/*\n\t * Can't use bytenr 0, some things freak out\n\t * *cough*backref walking code*cough*\n\t */\n\troot->node = alloc_test_extent_buffer(root->fs_info, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbtrfs_set_header_level(root->node, 0);\n\tbtrfs_set_header_nritems(root->node, 0);\n\troot->alloc_bytenr += 8192;\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 5;\n\troot->fs_info->fs_root = tmp_root;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 256;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttest_msg(\"Running qgroup tests\\n\");\n\tret = test_no_shared_qgroup(root);\n\tif (ret)\n\t\tgoto out;\n\tret = test_multiple_refs(root);\nout:\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_multiple_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "293-387",
    "snippet": "static int test_multiple_refs(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup multiple refs test\\n\");\n\n\t/* We have 5 created already from the previous test */\n\tret = btrfs_create_qgroup(NULL, fs_info, 256, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = add_tree_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_verify_qgroup_counts",
          "args": [
            "fs_info",
            "5",
            "4096",
            "4096"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_verify_qgroup_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "250-261",
          "snippet": "int btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup accounting failed %d\\n\"",
            "ret"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_qgroup_accounting",
          "args": [
            "&trans",
            "fs_info"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_qgroup_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2109-2128",
          "snippet": "int btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup record ref failed %d\\n\"",
            "ret"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_record_ref",
          "args": [
            "&trans",
            "fs_info",
            "256",
            "4096",
            "4096",
            "BTRFS_QGROUP_OPER_SUB_SHARED",
            "0"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_record_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1319-1373",
          "snippet": "int btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_ref",
          "args": [
            "root",
            "4096",
            "4096",
            "0",
            "256"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "170-224",
          "snippet": "static int remove_extent_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs - 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find backref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int remove_extent_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs - 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find backref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup accounting failed %d\\n\"",
            "ret"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup record ref failed %d\\n\"",
            "ret"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_tree_ref",
          "args": [
            "root",
            "4096",
            "4096",
            "0",
            "256"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "add_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "86-136",
          "snippet": "static int add_tree_ref(struct btrfs_root *root, u64 bytenr, u64 num_bytes,\n\t\t\tu64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs + 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_insert_empty_item(&trans, root, path, &key, 0);\n\tif (ret)\n\t\ttest_msg(\"Failed to insert backref\\n\");\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int add_tree_ref(struct btrfs_root *root, u64 bytenr, u64 num_bytes,\n\t\t\tu64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs + 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_insert_empty_item(&trans, root, path, &key, 0);\n\tif (ret)\n\t\ttest_msg(\"Failed to insert backref\\n\");\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Delayed qgroup accounting failed %d\\n\"",
            "ret"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add space to a qgroup %d\\n\"",
            "ret"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_normal_tree_ref",
          "args": [
            "root",
            "4096",
            "4096",
            "0",
            "5"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "insert_normal_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "33-84",
          "snippet": "static int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't create a qgroup %d\\n\"",
            "ret"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_qgroup",
          "args": [
            "NULL",
            "fs_info",
            "256",
            "NULL"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1097-1129",
          "snippet": "int btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup multiple refs test\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_multiple_refs(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup multiple refs test\\n\");\n\n\t/* We have 5 created already from the previous test */\n\tret = btrfs_create_qgroup(NULL, fs_info, 256, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = add_tree_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 4096, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_ref(root, 4096, 4096, 0, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 256, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_SHARED, 0);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup record ref failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 256, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_no_shared_qgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "226-286",
    "snippet": "static int test_no_shared_qgroup(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup basic add\\n\");\n\tret = btrfs_create_qgroup(NULL, fs_info, 5, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_item(root, 4096, 4096);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove space from the qgroup %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_verify_qgroup_counts",
          "args": [
            "fs_info",
            "5",
            "0",
            "0"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_verify_qgroup_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "250-261",
          "snippet": "int btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup accounting failed %d\\n\"",
            "ret"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_qgroup_accounting",
          "args": [
            "&trans",
            "fs_info"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_qgroup_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2109-2128",
          "snippet": "int btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove space from the qgroup %d\\n\"",
            "ret"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_record_ref",
          "args": [
            "&trans",
            "fs_info",
            "5",
            "4096",
            "4096",
            "BTRFS_QGROUP_OPER_SUB_EXCL",
            "0"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_record_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1319-1373",
          "snippet": "int btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_item",
          "args": [
            "root",
            "4096",
            "4096"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "138-168",
          "snippet": "static int remove_extent_item(struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Didn't find our key %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int remove_extent_item(struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Didn't find our key %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup counts didn't match expected values\\n\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Delayed qgroup accounting failed %d\\n\"",
            "ret"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_normal_tree_ref",
          "args": [
            "root",
            "4096",
            "4096",
            "0",
            "5"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "insert_normal_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "33-84",
          "snippet": "static int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add space to a qgroup %d\\n\"",
            "ret"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't create a qgroup %d\\n\"",
            "ret"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_qgroup",
          "args": [
            "NULL",
            "fs_info",
            "5",
            "NULL"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1097-1129",
          "snippet": "int btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Qgroup basic add\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_no_shared_qgroup(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\ttest_msg(\"Qgroup basic add\\n\");\n\tret = btrfs_create_qgroup(NULL, fs_info, 5, NULL);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_ADD_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to a qgroup %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = insert_normal_tree_ref(root, 4096, 4096, 0, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Delayed qgroup accounting failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 4096, 4096)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remove_extent_item(root, 4096, 4096);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = btrfs_qgroup_record_ref(&trans, fs_info, 5, 4096, 4096,\n\t\t\t\t      BTRFS_QGROUP_OPER_SUB_EXCL, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove space from the qgroup %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = btrfs_delayed_qgroup_accounting(&trans, fs_info);\n\tif (ret) {\n\t\ttest_msg(\"Qgroup accounting failed %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrfs_verify_qgroup_counts(fs_info, 5, 0, 0)) {\n\t\ttest_msg(\"Qgroup counts didn't match expected values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_extent_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "170-224",
    "snippet": "static int remove_extent_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs - 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find backref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "&trans",
            "root",
            "path"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find backref %d\\n\"",
            "ret"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "&trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_refs",
          "args": [
            "path->nodes[0]",
            "item",
            "refs - 1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_refs",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find extent ref\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate path\\n\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int remove_extent_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs - 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find backref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "remove_extent_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "138-168",
    "snippet": "static int remove_extent_item(struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Didn't find our key %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "&trans",
            "root",
            "path"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Didn't find our key %d\\n\"",
            "ret"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "&trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate path\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int remove_extent_item(struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(&trans, root, &key, path, -1, 1);\n\tif (ret) {\n\t\ttest_msg(\"Didn't find our key %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tbtrfs_del_item(&trans, root, path);\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "add_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "86-136",
    "snippet": "static int add_tree_ref(struct btrfs_root *root, u64 bytenr, u64 num_bytes,\n\t\t\tu64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs + 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_insert_empty_item(&trans, root, path, &key, 0);\n\tif (ret)\n\t\ttest_msg(\"Failed to insert backref\\n\");\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to insert backref\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "&trans",
            "root",
            "path",
            "&key",
            "0"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_refs",
          "args": [
            "path->nodes[0]",
            "item",
            "refs + 1"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_refs",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find extent ref\\n\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "&trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate path\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int add_tree_ref(struct btrfs_root *root, u64 bytenr, u64 num_bytes,\n\t\t\tu64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 refs;\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tkey.objectid = bytenr;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(&trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't find extent ref\\n\");\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_extent_item);\n\trefs = btrfs_extent_refs(path->nodes[0], item);\n\tbtrfs_set_extent_refs(path->nodes[0], item, refs + 1);\n\tbtrfs_release_path(path);\n\n\tkey.objectid = bytenr;\n\tif (parent) {\n\t\tkey.type = BTRFS_SHARED_BLOCK_REF_KEY;\n\t\tkey.offset = parent;\n\t} else {\n\t\tkey.type = BTRFS_TREE_BLOCK_REF_KEY;\n\t\tkey.offset = root_objectid;\n\t}\n\n\tret = btrfs_insert_empty_item(&trans, root, path, &key, 0);\n\tif (ret)\n\t\ttest_msg(\"Failed to insert backref\\n\");\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "insert_normal_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "33-84",
    "snippet": "static int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_inline_ref_offset",
          "args": [
            "leaf",
            "iref",
            "root_objectid"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_inline_ref_type",
          "args": [
            "leaf",
            "iref",
            "BTRFS_TREE_BLOCK_REF_KEY"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_inline_ref_offset",
          "args": [
            "leaf",
            "iref",
            "parent"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_inline_ref_type",
          "args": [
            "leaf",
            "iref",
            "BTRFS_SHARED_BLOCK_REF_KEY"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_tree_block_level",
          "args": [
            "leaf",
            "block_info",
            "1"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_flags",
          "args": [
            "leaf",
            "item",
            "BTRFS_EXTENT_FLAG_TREE_BLOCK"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_generation",
          "args": [
            "leaf",
            "item",
            "1"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_refs",
          "args": [
            "leaf",
            "item",
            "1"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't insert ref %d\\n\"",
            "ret"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "&trans",
            "root",
            "path",
            "&ins",
            "size"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate path\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dummy_trans",
          "args": [
            "&trans"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "init_dummy_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "25-31",
          "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int insert_normal_tree_ref(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t  u64 num_bytes, u64 parent, u64 root_objectid)\n{\n\tstruct btrfs_trans_handle trans;\n\tstruct btrfs_extent_item *item;\n\tstruct btrfs_extent_inline_ref *iref;\n\tstruct btrfs_tree_block_info *block_info;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key ins;\n\tu32 size = sizeof(*item) + sizeof(*iref) + sizeof(*block_info);\n\tint ret;\n\n\tinit_dummy_trans(&trans);\n\n\tins.objectid = bytenr;\n\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\tins.offset = num_bytes;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Couldn't allocate path\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(&trans, root, path, &ins, size);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert ref %d\\n\", ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_extent_item);\n\tbtrfs_set_extent_refs(leaf, item, 1);\n\tbtrfs_set_extent_generation(leaf, item, 1);\n\tbtrfs_set_extent_flags(leaf, item, BTRFS_EXTENT_FLAG_TREE_BLOCK);\n\tblock_info = (struct btrfs_tree_block_info *)(item + 1);\n\tbtrfs_set_tree_block_level(leaf, block_info, 1);\n\tiref = (struct btrfs_extent_inline_ref *)(block_info + 1);\n\tif (parent > 0) {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref,\n\t\t\t\t\t\t BTRFS_SHARED_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, parent);\n\t} else {\n\t\tbtrfs_set_extent_inline_ref_type(leaf, iref, BTRFS_TREE_BLOCK_REF_KEY);\n\t\tbtrfs_set_extent_inline_ref_offset(leaf, iref, root_objectid);\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_dummy_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
    "lines": "25-31",
    "snippet": "static void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../transaction.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trans->qgroup_ref_list"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "trans",
            "0",
            "sizeof(*trans)"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void init_dummy_trans(struct btrfs_trans_handle *trans)\n{\n\tmemset(trans, 0, sizeof(*trans));\n\ttrans->transid = 1;\n\tINIT_LIST_HEAD(&trans->qgroup_ref_list);\n\ttrans->type = __TRANS_DUMMY;\n}"
  }
]