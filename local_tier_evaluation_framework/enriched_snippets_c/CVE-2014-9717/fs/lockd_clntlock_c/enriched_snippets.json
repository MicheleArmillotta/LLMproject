[
  {
    "function_name": "reclaimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "226-301",
    "snippet": "static int\nreclaimer(void *ptr)\n{\n\tstruct nlm_host\t  *host = (struct nlm_host *) ptr;\n\tstruct nlm_wait\t  *block;\n\tstruct nlm_rqst   *req;\n\tstruct file_lock *fl, *next;\n\tu32 nsmstate;\n\tstruct net *net = host->net;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req) {\n\t\tprintk(KERN_ERR \"lockd: reclaimer unable to alloc memory.\"\n\t\t\t\t\" Locks for %s won't be reclaimed!\\n\",\n\t\t\t\thost->h_name);\n\t\treturn 0;\n\t}\n\n\tallow_signal(SIGKILL);\n\n\tdown_write(&host->h_rwsem);\n\tlockd_up(net);\t/* note: this cannot fail as lockd is already running */\n\n\tdprintk(\"lockd: reclaiming locks for host %s\\n\", host->h_name);\n\nrestart:\n\tnsmstate = host->h_nsmstate;\n\n\t/* Force a portmap getport - the peer's lockd will\n\t * most likely end up on a different port.\n\t */\n\thost->h_nextrebind = jiffies;\n\tnlm_rebind_host(host);\n\n\t/* First, reclaim all locks that have been granted. */\n\tlist_splice_init(&host->h_granted, &host->h_reclaim);\n\tlist_for_each_entry_safe(fl, next, &host->h_reclaim, fl_u.nfs_fl.list) {\n\t\tlist_del_init(&fl->fl_u.nfs_fl.list);\n\n\t\t/*\n\t\t * sending this thread a SIGKILL will result in any unreclaimed\n\t\t * locks being removed from the h_granted list. This means that\n\t\t * the kernel will not attempt to reclaim them again if a new\n\t\t * reclaimer thread is spawned for this host.\n\t\t */\n\t\tif (signalled())\n\t\t\tcontinue;\n\t\tif (nlmclnt_reclaim(host, fl, req) != 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&fl->fl_u.nfs_fl.list, &host->h_granted);\n\t\tif (host->h_nsmstate != nsmstate) {\n\t\t\t/* Argh! The server rebooted again! */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\thost->h_reclaiming = 0;\n\tup_write(&host->h_rwsem);\n\tdprintk(\"NLM: done reclaiming locks for host %s\\n\", host->h_name);\n\n\t/* Now, wake up all processes that sleep on a blocked lock */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (block->b_host == host) {\n\t\t\tblock->b_status = nlm_lck_denied_grace_period;\n\t\t\twake_up(&block->b_wait);\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\t/* Release host handle after use */\n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n\tkfree(req);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\treclaimer(void *ptr);",
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "406-432",
          "snippet": "void\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;",
            "static struct task_struct\t*nlmsvc_task;",
            "static struct svc_rqst\t\t*nlmsvc_rqst;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct task_struct\t*nlmsvc_task;\nstatic struct svc_rqst\t\t*nlmsvc_rqst;\n\nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "host"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&block->b_wait"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NLM: done reclaiming locks for host %s\\n\"",
            "host->h_name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fl->fl_u.nfs_fl.list",
            "&host->h_granted"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_reclaim",
          "args": [
            "host",
            "fl",
            "req"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "618-654",
          "snippet": "int\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl,\n\t\tstruct nlm_rqst *req)\n{\n\tint\t\tstatus;\n\n\tmemset(req, 0, sizeof(*req));\n\tlocks_init_lock(&req->a_args.lock.fl);\n\tlocks_init_lock(&req->a_res.lock.fl);\n\treq->a_host  = host;\n\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.reclaim = 1;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\n\tif (status >= 0 && req->a_res.status == nlm_granted)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\", fl->fl_pid,\n\t\t\t\tstatus, ntohl(req->a_res.status));\n\n\t/*\n\t * FIXME: This is a serious failure. We can\n\t *\n\t *  a.\tIgnore the problem\n\t *  b.\tSend the owning process some signal (Linux doesn't have\n\t *\tSIGLOST, though...)\n\t *  c.\tRetry the operation\n\t *\n\t * Until someone comes up with a simple implementation\n\t * for b or c, I'll choose option a.\n\t */\n\n\treturn -ENOLCK;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nint\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl,\n\t\tstruct nlm_rqst *req)\n{\n\tint\t\tstatus;\n\n\tmemset(req, 0, sizeof(*req));\n\tlocks_init_lock(&req->a_args.lock.fl);\n\tlocks_init_lock(&req->a_res.lock.fl);\n\treq->a_host  = host;\n\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.reclaim = 1;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\n\tif (status >= 0 && req->a_res.status == nlm_granted)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\", fl->fl_pid,\n\t\t\t\tstatus, ntohl(req->a_res.status));\n\n\t/*\n\t * FIXME: This is a serious failure. We can\n\t *\n\t *  a.\tIgnore the problem\n\t *  b.\tSend the owning process some signal (Linux doesn't have\n\t *\tSIGLOST, though...)\n\t *  c.\tRetry the operation\n\t *\n\t * Until someone comes up with a simple implementation\n\t * for b or c, I'll choose option a.\n\t */\n\n\treturn -ENOLCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signalled",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_u.nfs_fl.list"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "next",
            "&host->h_reclaim",
            "fl_u.nfs_fl.list"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&host->h_granted",
            "&host->h_reclaim"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_rebind_host",
          "args": [
            "host"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_rebind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "488-496",
          "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: reclaiming locks for host %s\\n\"",
            "host->h_name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockd_up",
          "args": [
            "net"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "365-400",
          "snippet": "int lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\n\nint lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGKILL"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"lockd: reclaimer unable to alloc memory.\"\n\t\t\t\t\" Locks for %s won't be reclaimed!\\n\"",
            "host->h_name"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*req)",
            "GFP_KERNEL"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int\t\t\treclaimer(void *ptr);\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic int\nreclaimer(void *ptr)\n{\n\tstruct nlm_host\t  *host = (struct nlm_host *) ptr;\n\tstruct nlm_wait\t  *block;\n\tstruct nlm_rqst   *req;\n\tstruct file_lock *fl, *next;\n\tu32 nsmstate;\n\tstruct net *net = host->net;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req) {\n\t\tprintk(KERN_ERR \"lockd: reclaimer unable to alloc memory.\"\n\t\t\t\t\" Locks for %s won't be reclaimed!\\n\",\n\t\t\t\thost->h_name);\n\t\treturn 0;\n\t}\n\n\tallow_signal(SIGKILL);\n\n\tdown_write(&host->h_rwsem);\n\tlockd_up(net);\t/* note: this cannot fail as lockd is already running */\n\n\tdprintk(\"lockd: reclaiming locks for host %s\\n\", host->h_name);\n\nrestart:\n\tnsmstate = host->h_nsmstate;\n\n\t/* Force a portmap getport - the peer's lockd will\n\t * most likely end up on a different port.\n\t */\n\thost->h_nextrebind = jiffies;\n\tnlm_rebind_host(host);\n\n\t/* First, reclaim all locks that have been granted. */\n\tlist_splice_init(&host->h_granted, &host->h_reclaim);\n\tlist_for_each_entry_safe(fl, next, &host->h_reclaim, fl_u.nfs_fl.list) {\n\t\tlist_del_init(&fl->fl_u.nfs_fl.list);\n\n\t\t/*\n\t\t * sending this thread a SIGKILL will result in any unreclaimed\n\t\t * locks being removed from the h_granted list. This means that\n\t\t * the kernel will not attempt to reclaim them again if a new\n\t\t * reclaimer thread is spawned for this host.\n\t\t */\n\t\tif (signalled())\n\t\t\tcontinue;\n\t\tif (nlmclnt_reclaim(host, fl, req) != 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&fl->fl_u.nfs_fl.list, &host->h_granted);\n\t\tif (host->h_nsmstate != nsmstate) {\n\t\t\t/* Argh! The server rebooted again! */\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\thost->h_reclaiming = 0;\n\tup_write(&host->h_rwsem);\n\tdprintk(\"NLM: done reclaiming locks for host %s\\n\", host->h_name);\n\n\t/* Now, wake up all processes that sleep on a blocked lock */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (block->b_host == host) {\n\t\t\tblock->b_status = nlm_lck_denied_grace_period;\n\t\t\twake_up(&block->b_wait);\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\t/* Release host handle after use */\n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n\tkfree(req);\n\treturn 0;\n}"
  },
  {
    "function_name": "nlmclnt_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "211-224",
    "snippet": "void\nnlmclnt_recovery(struct nlm_host *host)\n{\n\tstruct task_struct *task;\n\n\tif (!host->h_reclaiming++) {\n\t\tnlm_get_host(host);\n\t\ttask = kthread_run(reclaimer, host, \"%s-reclaim\", host->h_name);\n\t\tif (IS_ERR(task))\n\t\t\tprintk(KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\", host->h_name, PTR_ERR(task));\n\t}\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\"",
            "host->h_name",
            "PTR_ERR(task)"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "reclaimer",
            "host",
            "\"%s-reclaim\"",
            "host->h_name"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nvoid\nnlmclnt_recovery(struct nlm_host *host)\n{\n\tstruct task_struct *task;\n\n\tif (!host->h_reclaiming++) {\n\t\tnlm_get_host(host);\n\t\ttask = kthread_run(reclaimer, host, \"%s-reclaim\", host->h_name);\n\t\tif (IS_ERR(task))\n\t\t\tprintk(KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\", host->h_name, PTR_ERR(task));\n\t}\n}"
  },
  {
    "function_name": "nlmclnt_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "162-200",
    "snippet": "__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\tconst struct nfs_fh *fh = &lock->fh;\n\tstruct nlm_wait\t*block;\n\t__be32 res = nlm_lck_denied;\n\n\t/*\n\t * Look up blocked request based on arguments. \n\t * Warning: must not use cookie to match it!\n\t */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tstruct file_lock *fl_blocked = block->b_lock;\n\n\t\tif (fl_blocked->fl_start != fl->fl_start)\n\t\t\tcontinue;\n\t\tif (fl_blocked->fl_end != fl->fl_end)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Careful! The NLM server will return the 32-bit \"pid\" that\n\t\t * we put on the wire: in this case the lockowner \"pid\".\n\t\t */\n\t\tif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\n\t\t\tcontinue;\n\t\tif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)) ,fh) != 0)\n\t\t\tcontinue;\n\t\t/* Alright, we found a lock. Set the return status\n\t\t * and wake up the caller\n\t\t */\n\t\tblock->b_status = nlm_granted;\n\t\twake_up(&block->b_wait);\n\t\tres = nlm_granted;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\treturn res;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&block->b_wait"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_compare_fh",
          "args": [
            "NFS_FH(file_inode(fl_blocked->fl_file))",
            "fh"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "file_inode(fl_blocked->fl_file)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "fl_blocked->fl_file"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "nlm_addr(block->b_host)",
            "addr"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_addr",
          "args": [
            "block->b_host"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\n__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\tconst struct nfs_fh *fh = &lock->fh;\n\tstruct nlm_wait\t*block;\n\t__be32 res = nlm_lck_denied;\n\n\t/*\n\t * Look up blocked request based on arguments. \n\t * Warning: must not use cookie to match it!\n\t */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tstruct file_lock *fl_blocked = block->b_lock;\n\n\t\tif (fl_blocked->fl_start != fl->fl_start)\n\t\t\tcontinue;\n\t\tif (fl_blocked->fl_end != fl->fl_end)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Careful! The NLM server will return the 32-bit \"pid\" that\n\t\t * we put on the wire: in this case the lockowner \"pid\".\n\t\t */\n\t\tif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\n\t\t\tcontinue;\n\t\tif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)) ,fh) != 0)\n\t\t\tcontinue;\n\t\t/* Alright, we found a lock. Set the return status\n\t\t * and wake up the caller\n\t\t */\n\t\tblock->b_status = nlm_granted;\n\t\twake_up(&block->b_wait);\n\t\tres = nlm_granted;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "nlmclnt_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "129-157",
    "snippet": "int nlmclnt_block(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\n{\n\tlong ret;\n\n\t/* A borken server might ask us to block even if we didn't\n\t * request it. Just say no!\n\t */\n\tif (block == NULL)\n\t\treturn -EAGAIN;\n\n\t/* Go to sleep waiting for GRANT callback. Some servers seem\n\t * to lose callbacks, however, so we're going to poll from\n\t * time to time just to make sure.\n\t *\n\t * For now, the retry frequency is pretty high; normally \n\t * a 1 minute timeout would do. See the comment before\n\t * nlmclnt_lock for an explanation.\n\t */\n\tret = wait_event_interruptible_timeout(block->b_wait,\n\t\t\tblock->b_status != nlm_lck_blocked,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\t/* Reset the lock status after a server reboot so we resend */\n\tif (block->b_status == nlm_lck_denied_grace_period)\n\t\tblock->b_status = nlm_lck_blocked;\n\treq->a_res.status = block->b_status;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "block->b_wait",
            "block->b_status != nlm_lck_blocked",
            "timeout"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nlmclnt_block(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\n{\n\tlong ret;\n\n\t/* A borken server might ask us to block even if we didn't\n\t * request it. Just say no!\n\t */\n\tif (block == NULL)\n\t\treturn -EAGAIN;\n\n\t/* Go to sleep waiting for GRANT callback. Some servers seem\n\t * to lose callbacks, however, so we're going to poll from\n\t * time to time just to make sure.\n\t *\n\t * For now, the retry frequency is pretty high; normally \n\t * a 1 minute timeout would do. See the comment before\n\t * nlmclnt_lock for an explanation.\n\t */\n\tret = wait_event_interruptible_timeout(block->b_wait,\n\t\t\tblock->b_status != nlm_lck_blocked,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\t/* Reset the lock status after a server reboot so we resend */\n\tif (block->b_status == nlm_lck_denied_grace_period)\n\t\tblock->b_status = nlm_lck_blocked;\n\treq->a_res.status = block->b_status;\n\treturn 0;\n}"
  },
  {
    "function_name": "nlmclnt_finish_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "116-124",
    "snippet": "void nlmclnt_finish_block(struct nlm_wait *block)\n{\n\tif (block == NULL)\n\t\treturn;\n\tspin_lock(&nlm_blocked_lock);\n\tlist_del(&block->b_list);\n\tspin_unlock(&nlm_blocked_lock);\n\tkfree(block);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "block"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&block->b_list"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nvoid nlmclnt_finish_block(struct nlm_wait *block)\n{\n\tif (block == NULL)\n\t\treturn;\n\tspin_lock(&nlm_blocked_lock);\n\tlist_del(&block->b_list);\n\tspin_unlock(&nlm_blocked_lock);\n\tkfree(block);\n}"
  },
  {
    "function_name": "nlmclnt_prepare_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "98-114",
    "snippet": "struct nlm_wait *nlmclnt_prepare_block(struct nlm_host *host, struct file_lock *fl)\n{\n\tstruct nlm_wait *block;\n\n\tblock = kmalloc(sizeof(*block), GFP_KERNEL);\n\tif (block != NULL) {\n\t\tblock->b_host = host;\n\t\tblock->b_lock = fl;\n\t\tinit_waitqueue_head(&block->b_wait);\n\t\tblock->b_status = nlm_lck_blocked;\n\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_add(&block->b_list, &nlm_blocked);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t}\n\treturn block;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&block->b_list",
            "&nlm_blocked"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&block->b_wait"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*block)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstruct nlm_wait *nlmclnt_prepare_block(struct nlm_host *host, struct file_lock *fl)\n{\n\tstruct nlm_wait *block;\n\n\tblock = kmalloc(sizeof(*block), GFP_KERNEL);\n\tif (block != NULL) {\n\t\tblock->b_host = host;\n\t\tblock->b_lock = fl;\n\t\tinit_waitqueue_head(&block->b_wait);\n\t\tblock->b_status = nlm_lck_blocked;\n\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_add(&block->b_list, &nlm_blocked);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t}\n\treturn block;\n}"
  },
  {
    "function_name": "nlmclnt_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "86-92",
    "snippet": "void nlmclnt_done(struct nlm_host *host)\n{\n\tstruct net *net = host->net;\n\n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "406-432",
          "snippet": "void\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;",
            "static struct task_struct\t*nlmsvc_task;",
            "static struct svc_rqst\t\t*nlmsvc_rqst;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct task_struct\t*nlmsvc_task;\nstatic struct svc_rqst\t\t*nlmsvc_rqst;\n\nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "host"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nvoid nlmclnt_done(struct nlm_host *host)\n{\n\tstruct net *net = host->net;\n\n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n}"
  },
  {
    "function_name": "nlmclnt_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
    "lines": "53-78",
    "snippet": "struct nlm_host *nlmclnt_init(const struct nlmclnt_initdata *nlm_init)\n{\n\tstruct nlm_host *host;\n\tu32 nlm_version = (nlm_init->nfs_version == 2) ? 1 : 4;\n\tint status;\n\n\tstatus = lockd_up(nlm_init->net);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\thost = nlmclnt_lookup_host(nlm_init->address, nlm_init->addrlen,\n\t\t\t\t   nlm_init->protocol, nlm_version,\n\t\t\t\t   nlm_init->hostname, nlm_init->noresvport,\n\t\t\t\t   nlm_init->net);\n\tif (host == NULL)\n\t\tgoto out_nohost;\n\tif (host->h_rpcclnt == NULL && nlm_bind_host(host) == NULL)\n\t\tgoto out_nobind;\n\n\treturn host;\nout_nobind:\n\tnlmclnt_release_host(host);\nout_nohost:\n\tlockd_down(nlm_init->net);\n\treturn ERR_PTR(-ENOLCK);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOLCK"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "nlm_init->net"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "406-432",
          "snippet": "void\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;",
            "static struct task_struct\t*nlmsvc_task;",
            "static struct svc_rqst\t\t*nlmsvc_rqst;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct task_struct\t*nlmsvc_task;\nstatic struct svc_rqst\t\t*nlmsvc_rqst;\n\nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "host"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_bind_host",
          "args": [
            "host"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "417-483",
          "snippet": "struct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_lookup_host",
          "args": [
            "nlm_init->address",
            "nlm_init->addrlen",
            "nlm_init->protocol",
            "nlm_version",
            "nlm_init->hostname",
            "nlm_init->noresvport",
            "nlm_init->net"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_lookup_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "209-275",
          "snippet": "struct nlm_host *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t     const size_t salen,\n\t\t\t\t     const unsigned short protocol,\n\t\t\t\t     const u32 version,\n\t\t\t\t     const char *hostname,\n\t\t\t\t     int noresvport,\n\t\t\t\t     struct net *net)\n{\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 0,\n\t\t.sap\t\t= sap,\n\t\t.salen\t\t= salen,\n\t\t.protocol\t= protocol,\n\t\t.version\t= version,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= strlen(hostname),\n\t\t.noresvport\t= noresvport,\n\t\t.net\t\t= net,\n\t};\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(hostname ? hostname : \"<none>\"), version,\n\t\t\t(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tchain = &nlm_client_hosts[nlm_hash_address(sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != version)\n\t\t\tcontinue;\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\", __func__,\n\t\t\thost->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\", __func__,\n\t\thost->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];",
            "static unsigned long\t\tnrhosts;",
            "static DEFINE_MUTEX(nlm_host_mutex);",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_host *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t     const size_t salen,\n\t\t\t\t     const unsigned short protocol,\n\t\t\t\t     const u32 version,\n\t\t\t\t     const char *hostname,\n\t\t\t\t     int noresvport,\n\t\t\t\t     struct net *net)\n{\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 0,\n\t\t.sap\t\t= sap,\n\t\t.salen\t\t= salen,\n\t\t.protocol\t= protocol,\n\t\t.version\t= version,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= strlen(hostname),\n\t\t.noresvport\t= noresvport,\n\t\t.net\t\t= net,\n\t};\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(hostname ? hostname : \"<none>\"), version,\n\t\t\t(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tchain = &nlm_client_hosts[nlm_hash_address(sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != version)\n\t\t\tcontinue;\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\", __func__,\n\t\t\thost->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\", __func__,\n\t\thost->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockd_up",
          "args": [
            "nlm_init->net"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "365-400",
          "snippet": "int lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\n\nint lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstruct nlm_host *nlmclnt_init(const struct nlmclnt_initdata *nlm_init)\n{\n\tstruct nlm_host *host;\n\tu32 nlm_version = (nlm_init->nfs_version == 2) ? 1 : 4;\n\tint status;\n\n\tstatus = lockd_up(nlm_init->net);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\thost = nlmclnt_lookup_host(nlm_init->address, nlm_init->addrlen,\n\t\t\t\t   nlm_init->protocol, nlm_version,\n\t\t\t\t   nlm_init->hostname, nlm_init->noresvport,\n\t\t\t\t   nlm_init->net);\n\tif (host == NULL)\n\t\tgoto out_nohost;\n\tif (host->h_rpcclnt == NULL && nlm_bind_host(host) == NULL)\n\t\tgoto out_nobind;\n\n\treturn host;\nout_nobind:\n\tnlmclnt_release_host(host);\nout_nohost:\n\tlockd_down(nlm_init->net);\n\treturn ERR_PTR(-ENOLCK);\n}"
  }
]