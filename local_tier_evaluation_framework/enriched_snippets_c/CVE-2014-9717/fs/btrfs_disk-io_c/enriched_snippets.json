[
  {
    "function_name": "btrfs_cleanup_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4235-4286",
    "snippet": "static int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->transaction_kthread_mutex"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_all_delalloc_inodes",
          "args": [
            "root->fs_info"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_all_delalloc_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4095-4118",
          "snippet": "static void btrfs_destroy_all_delalloc_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\t delalloc_root);\n\t\tlist_del_init(&root->delalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tbtrfs_destroy_delalloc_inodes(root);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_all_delalloc_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\t delalloc_root);\n\t\tlist_del_init(&root->delalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tbtrfs_destroy_delalloc_inodes(root);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_pinned_extent",
          "args": [
            "root",
            "root->fs_info->pinned_extents"
          ],
          "line": 4281
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_pinned_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4153-4185",
          "snippet": "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_delayed_root_empty",
          "args": [
            "root"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_delayed_root_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1406-1411",
          "snippet": "void btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_delayed_inodes",
          "args": [
            "root"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_delayed_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1978-1993",
          "snippet": "void btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_all_ordered_extents",
          "args": [
            "root->fs_info"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_all_ordered_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3976-3998",
          "snippet": "static void btrfs_destroy_all_ordered_extents(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\t\tbtrfs_destroy_ordered_extents(root);\n\n\t\tcond_resched();\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&fs_info->ordered_root_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_all_ordered_extents(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\t\tbtrfs_destroy_ordered_extents(root);\n\n\t\tcond_resched();\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&fs_info->ordered_root_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_transaction_commit",
          "args": [
            "root"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "t"
          ],
          "line": 4273
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&t->list"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_one_transaction",
          "args": [
            "t",
            "root"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_one_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4206-4233",
          "snippet": "void btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "t->writer_wait",
            "atomic_read(&t->num_writers) == 0"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&t->num_writers"
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_for_commit",
          "args": [
            "root",
            "t->transid"
          ],
          "line": 4248
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "635-691",
          "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&t->use_count"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&root->fs_info->trans_list",
            "structbtrfs_transaction",
            "list"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->fs_info->trans_list"
          ],
          "line": 4242
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->transaction_kthread_mutex"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_cleanup_one_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4206-4233",
    "snippet": "void btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&cur_trans->commit_wait"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_pinned_extent",
          "args": [
            "root",
            "root->fs_info->pinned_extents"
          ],
          "line": 4223
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_pinned_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4153-4185",
          "snippet": "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_marked_extents",
          "args": [
            "root",
            "&cur_trans->dirty_pages",
            "EXTENT_DIRTY"
          ],
          "line": 4221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4120-4151",
          "snippet": "static int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t\t    mark, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(dirty_pages, start, end, mark, GFP_NOFS);\n\t\twhile (start <= end) {\n\t\t\teb = btrfs_find_tree_block(root, start);\n\t\t\tstart += root->nodesize;\n\t\t\tif (!eb)\n\t\t\t\tcontinue;\n\t\t\twait_on_extent_buffer_writeback(eb);\n\n\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY,\n\t\t\t\t\t       &eb->bflags))\n\t\t\t\tclear_extent_buffer_dirty(eb);\n\t\t\tfree_extent_buffer_stale(eb);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t\t    mark, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(dirty_pages, start, end, mark, GFP_NOFS);\n\t\twhile (start <= end) {\n\t\t\teb = btrfs_find_tree_block(root, start);\n\t\t\tstart += root->nodesize;\n\t\t\tif (!eb)\n\t\t\t\tcontinue;\n\t\t\twait_on_extent_buffer_writeback(eb);\n\n\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY,\n\t\t\t\t\t       &eb->bflags))\n\t\t\t\tclear_extent_buffer_dirty(eb);\n\t\t\tfree_extent_buffer_stale(eb);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_delayed_root_empty",
          "args": [
            "root"
          ],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_delayed_root_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1406-1411",
          "snippet": "void btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_delayed_inodes",
          "args": [
            "root"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_delayed_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1978-1993",
          "snippet": "void btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_destroy_delayed_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tstruct btrfs_delayed_node *curr_node, *prev_node;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tcurr_node = btrfs_first_delayed_node(delayed_root);\n\twhile (curr_node) {\n\t\t__btrfs_kill_delayed_node(curr_node);\n\n\t\tprev_node = curr_node;\n\t\tcurr_node = btrfs_next_delayed_node(curr_node);\n\t\tbtrfs_release_delayed_node(prev_node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_pending_ordered",
          "args": [
            "cur_trans",
            "root->fs_info"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_pending_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4187-4204",
          "snippet": "static void btrfs_free_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_free_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_delayed_refs",
          "args": [
            "cur_trans",
            "root"
          ],
          "line": 4209
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4000-4066",
          "snippet": "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_node *ref;\n\tint ret = 0;\n\n\tdelayed_refs = &trans->delayed_refs;\n\n\tspin_lock(&delayed_refs->lock);\n\tif (atomic_read(&delayed_refs->num_entries) == 0) {\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tbtrfs_info(root->fs_info, \"delayed_refs has NO entry\");\n\t\treturn ret;\n\t}\n\n\twhile ((node = rb_first(&delayed_refs->href_root)) != NULL) {\n\t\tstruct btrfs_delayed_ref_head *head;\n\t\tbool pin_bytes = false;\n\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tspin_lock(&delayed_refs->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\twhile ((node = rb_first(&head->ref_root)) != NULL) {\n\t\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t\t       rb_node);\n\t\t\tref->in_tree = 0;\n\t\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t\t\tatomic_dec(&delayed_refs->num_entries);\n\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t}\n\t\tif (head->must_insert_reserved)\n\t\t\tpin_bytes = true;\n\t\tbtrfs_free_delayed_extent_op(head->extent_op);\n\t\tdelayed_refs->num_heads--;\n\t\tif (head->processing == 0)\n\t\t\tdelayed_refs->num_heads_ready--;\n\t\tatomic_dec(&delayed_refs->num_entries);\n\t\thead->node.in_tree = 0;\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t\tspin_unlock(&head->lock);\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tmutex_unlock(&head->mutex);\n\n\t\tif (pin_bytes)\n\t\t\tbtrfs_pin_extent(root, head->node.bytenr,\n\t\t\t\t\t head->node.num_bytes, 1);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\tcond_resched();\n\t\tspin_lock(&delayed_refs->lock);\n\t}\n\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_node *ref;\n\tint ret = 0;\n\n\tdelayed_refs = &trans->delayed_refs;\n\n\tspin_lock(&delayed_refs->lock);\n\tif (atomic_read(&delayed_refs->num_entries) == 0) {\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tbtrfs_info(root->fs_info, \"delayed_refs has NO entry\");\n\t\treturn ret;\n\t}\n\n\twhile ((node = rb_first(&delayed_refs->href_root)) != NULL) {\n\t\tstruct btrfs_delayed_ref_head *head;\n\t\tbool pin_bytes = false;\n\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tspin_lock(&delayed_refs->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\twhile ((node = rb_first(&head->ref_root)) != NULL) {\n\t\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t\t       rb_node);\n\t\t\tref->in_tree = 0;\n\t\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t\t\tatomic_dec(&delayed_refs->num_entries);\n\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t}\n\t\tif (head->must_insert_reserved)\n\t\t\tpin_bytes = true;\n\t\tbtrfs_free_delayed_extent_op(head->extent_op);\n\t\tdelayed_refs->num_heads--;\n\t\tif (head->processing == 0)\n\t\t\tdelayed_refs->num_heads_ready--;\n\t\tatomic_dec(&delayed_refs->num_entries);\n\t\thead->node.in_tree = 0;\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t\tspin_unlock(&head->lock);\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tmutex_unlock(&head->mutex);\n\n\t\tif (pin_bytes)\n\t\t\tbtrfs_pin_extent(root, head->node.bytenr,\n\t\t\t\t\t head->node.num_bytes, 1);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\tcond_resched();\n\t\tspin_lock(&delayed_refs->lock);\n\t}\n\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}"
  },
  {
    "function_name": "btrfs_free_pending_ordered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4187-4204",
    "snippet": "static void btrfs_free_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->trans_list"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&cur_trans->pending_ordered",
            "structbtrfs_ordered_extent",
            "trans_list"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur_trans->pending_ordered"
          ],
          "line": 4193
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_free_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}"
  },
  {
    "function_name": "btrfs_destroy_pinned_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4153-4185",
    "snippet": "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_error_unpin_extent_range",
          "args": [
            "root",
            "start",
            "end"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_dirty",
          "args": [
            "unpin",
            "start",
            "end",
            "GFP_NOFS"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1299-1305",
          "snippet": "int clear_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end,\n\t\t\t\tEXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DO_ACCOUNTING, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end,\n\t\t\t\tEXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DO_ACCOUNTING, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "unpin",
            "0",
            "&start",
            "&end",
            "EXTENT_DIRTY",
            "NULL"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_destroy_marked_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4120-4151",
    "snippet": "static int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t\t    mark, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(dirty_pages, start, end, mark, GFP_NOFS);\n\t\twhile (start <= end) {\n\t\t\teb = btrfs_find_tree_block(root, start);\n\t\t\tstart += root->nodesize;\n\t\t\tif (!eb)\n\t\t\t\tcontinue;\n\t\t\twait_on_extent_buffer_writeback(eb);\n\n\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY,\n\t\t\t\t\t       &eb->bflags))\n\t\t\t\tclear_extent_buffer_dirty(eb);\n\t\t\tfree_extent_buffer_stale(eb);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer_stale",
          "args": [
            "eb"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_buffer_dirty",
          "args": [
            "eb"
          ],
          "line": 4145
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5033-5061",
          "snippet": "void clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_extent_buffer_writeback",
          "args": [
            "eb"
          ],
          "line": 4141
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_extent_buffer_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3550-3554",
          "snippet": "void wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_tree_block",
          "args": [
            "root",
            "start"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1122-1126",
          "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "dirty_pages",
            "start",
            "end",
            "mark",
            "GFP_NOFS"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "dirty_pages",
            "start",
            "&start",
            "&end",
            "mark",
            "NULL"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_marked_extents(struct btrfs_root *root,\n\t\t\t\t\tstruct extent_io_tree *dirty_pages,\n\t\t\t\t\tint mark)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t\t    mark, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(dirty_pages, start, end, mark, GFP_NOFS);\n\t\twhile (start <= end) {\n\t\t\teb = btrfs_find_tree_block(root, start);\n\t\t\tstart += root->nodesize;\n\t\t\tif (!eb)\n\t\t\t\tcontinue;\n\t\t\twait_on_extent_buffer_writeback(eb);\n\n\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY,\n\t\t\t\t\t       &eb->bflags))\n\t\t\t\tclear_extent_buffer_dirty(eb);\n\t\t\tfree_extent_buffer_stale(eb);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_destroy_all_delalloc_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4095-4118",
    "snippet": "static void btrfs_destroy_all_delalloc_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\t delalloc_root);\n\t\tlist_del_init(&root->delalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tbtrfs_destroy_delalloc_inodes(root);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->delalloc_root_lock"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->delalloc_root_lock"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_fs_root",
          "args": [
            "root"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "108-112",
          "snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_delalloc_inodes",
          "args": [
            "root"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_delalloc_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4068-4093",
          "snippet": "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_inode *btrfs_inode;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&root->delalloc_lock);\n\tlist_splice_init(&root->delalloc_inodes, &splice);\n\n\twhile (!list_empty(&splice)) {\n\t\tbtrfs_inode = list_first_entry(&splice, struct btrfs_inode,\n\t\t\t\t\t       delalloc_inodes);\n\n\t\tlist_del_init(&btrfs_inode->delalloc_inodes);\n\t\tclear_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t  &btrfs_inode->runtime_flags);\n\t\tspin_unlock(&root->delalloc_lock);\n\n\t\tbtrfs_invalidate_inodes(btrfs_inode->root);\n\n\t\tspin_lock(&root->delalloc_lock);\n\t}\n\n\tspin_unlock(&root->delalloc_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_inode *btrfs_inode;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&root->delalloc_lock);\n\tlist_splice_init(&root->delalloc_inodes, &splice);\n\n\twhile (!list_empty(&splice)) {\n\t\tbtrfs_inode = list_first_entry(&splice, struct btrfs_inode,\n\t\t\t\t\t       delalloc_inodes);\n\n\t\tlist_del_init(&btrfs_inode->delalloc_inodes);\n\t\tclear_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t  &btrfs_inode->runtime_flags);\n\t\tspin_unlock(&root->delalloc_lock);\n\n\t\tbtrfs_invalidate_inodes(btrfs_inode->root);\n\n\t\tspin_lock(&root->delalloc_lock);\n\t}\n\n\tspin_unlock(&root->delalloc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_grab_fs_root",
          "args": [
            "root"
          ],
          "line": 4108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_grab_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "101-106",
          "snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root->delalloc_root"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&splice",
            "structbtrfs_root",
            "delalloc_root"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&splice"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&fs_info->delalloc_roots",
            "&splice"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&splice"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_all_delalloc_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\t delalloc_root);\n\t\tlist_del_init(&root->delalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tbtrfs_destroy_delalloc_inodes(root);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n}"
  },
  {
    "function_name": "btrfs_destroy_delalloc_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4068-4093",
    "snippet": "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_inode *btrfs_inode;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&root->delalloc_lock);\n\tlist_splice_init(&root->delalloc_inodes, &splice);\n\n\twhile (!list_empty(&splice)) {\n\t\tbtrfs_inode = list_first_entry(&splice, struct btrfs_inode,\n\t\t\t\t\t       delalloc_inodes);\n\n\t\tlist_del_init(&btrfs_inode->delalloc_inodes);\n\t\tclear_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t  &btrfs_inode->runtime_flags);\n\t\tspin_unlock(&root->delalloc_lock);\n\n\t\tbtrfs_invalidate_inodes(btrfs_inode->root);\n\n\t\tspin_lock(&root->delalloc_lock);\n\t}\n\n\tspin_unlock(&root->delalloc_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->delalloc_lock"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->delalloc_lock"
          ],
          "line": 4089
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_invalidate_inodes",
          "args": [
            "btrfs_inode->root"
          ],
          "line": 4087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_invalidate_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5212-5273",
          "snippet": "void btrfs_invalidate_inodes(struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\tu64 objectid = 0;\n\n\tif (!test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\tWARN_ON(btrfs_root_refs(&root->root_item) != 0);\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tif (atomic_read(&inode->i_count) > 1)\n\t\t\t\td_prune_aliases(inode);\n\t\t\t/*\n\t\t\t * btrfs_drop_inode will have it removed from\n\t\t\t * the inode cache when its usage count\n\t\t\t * hits zero.\n\t\t\t */\n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&root->inode_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_invalidate_inodes(struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\tu64 objectid = 0;\n\n\tif (!test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\tWARN_ON(btrfs_root_refs(&root->root_item) != 0);\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tif (atomic_read(&inode->i_count) > 1)\n\t\t\t\td_prune_aliases(inode);\n\t\t\t/*\n\t\t\t * btrfs_drop_inode will have it removed from\n\t\t\t * the inode cache when its usage count\n\t\t\t * hits zero.\n\t\t\t */\n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&root->inode_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_INODE_IN_DELALLOC_LIST",
            "&btrfs_inode->runtime_flags"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&btrfs_inode->delalloc_inodes"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&splice",
            "structbtrfs_inode",
            "delalloc_inodes"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&splice"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&root->delalloc_inodes",
            "&splice"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&splice"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root)\n{\n\tstruct btrfs_inode *btrfs_inode;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&root->delalloc_lock);\n\tlist_splice_init(&root->delalloc_inodes, &splice);\n\n\twhile (!list_empty(&splice)) {\n\t\tbtrfs_inode = list_first_entry(&splice, struct btrfs_inode,\n\t\t\t\t\t       delalloc_inodes);\n\n\t\tlist_del_init(&btrfs_inode->delalloc_inodes);\n\t\tclear_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t  &btrfs_inode->runtime_flags);\n\t\tspin_unlock(&root->delalloc_lock);\n\n\t\tbtrfs_invalidate_inodes(btrfs_inode->root);\n\n\t\tspin_lock(&root->delalloc_lock);\n\t}\n\n\tspin_unlock(&root->delalloc_lock);\n}"
  },
  {
    "function_name": "btrfs_destroy_delayed_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "4000-4066",
    "snippet": "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_node *ref;\n\tint ret = 0;\n\n\tdelayed_refs = &trans->delayed_refs;\n\n\tspin_lock(&delayed_refs->lock);\n\tif (atomic_read(&delayed_refs->num_entries) == 0) {\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tbtrfs_info(root->fs_info, \"delayed_refs has NO entry\");\n\t\treturn ret;\n\t}\n\n\twhile ((node = rb_first(&delayed_refs->href_root)) != NULL) {\n\t\tstruct btrfs_delayed_ref_head *head;\n\t\tbool pin_bytes = false;\n\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tspin_lock(&delayed_refs->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\twhile ((node = rb_first(&head->ref_root)) != NULL) {\n\t\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t\t       rb_node);\n\t\t\tref->in_tree = 0;\n\t\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t\t\tatomic_dec(&delayed_refs->num_entries);\n\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t}\n\t\tif (head->must_insert_reserved)\n\t\t\tpin_bytes = true;\n\t\tbtrfs_free_delayed_extent_op(head->extent_op);\n\t\tdelayed_refs->num_heads--;\n\t\tif (head->processing == 0)\n\t\t\tdelayed_refs->num_heads_ready--;\n\t\tatomic_dec(&delayed_refs->num_entries);\n\t\thead->node.in_tree = 0;\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t\tspin_unlock(&head->lock);\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tmutex_unlock(&head->mutex);\n\n\t\tif (pin_bytes)\n\t\t\tbtrfs_pin_extent(root, head->node.bytenr,\n\t\t\t\t\t head->node.num_bytes, 1);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\tcond_resched();\n\t\tspin_lock(&delayed_refs->lock);\n\t}\n\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_delayed_ref",
          "args": [
            "&head->node"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_delayed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "172-193",
          "snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pin_extent",
          "args": [
            "root",
            "head->node.bytenr",
            "head->node.num_bytes",
            "1"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pin_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5503-5515",
          "snippet": "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, bytenr);\n\tBUG_ON(!cache); /* Logic error */\n\n\tpin_down_extent(root, cache, bytenr, num_bytes, reserved);\n\n\tbtrfs_put_block_group(cache);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, bytenr);\n\tBUG_ON(!cache); /* Logic error */\n\n\tpin_down_extent(root, cache, bytenr, num_bytes, reserved);\n\n\tbtrfs_put_block_group(cache);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->mutex"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&head->href_node",
            "&delayed_refs->href_root"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_delayed_extent_op",
          "args": [
            "head->extent_op"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_delayed_extent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "165-170",
          "snippet": "static inline void\nbtrfs_free_delayed_extent_op(struct btrfs_delayed_extent_op *op)\n{\n\tif (op)\n\t\tkmem_cache_free(btrfs_delayed_extent_op_cachep, op);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nbtrfs_free_delayed_extent_op(struct btrfs_delayed_extent_op *op)\n{\n\tif (op)\n\t\tkmem_cache_free(btrfs_delayed_extent_op_cachep, op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&ref->rb_node",
            "&head->ref_root"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&head->ref_root"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->mutex"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&head->mutex"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&head->node.refs"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&head->mutex"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&delayed_refs->href_root"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"delayed_refs has NO entry\""
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_node *ref;\n\tint ret = 0;\n\n\tdelayed_refs = &trans->delayed_refs;\n\n\tspin_lock(&delayed_refs->lock);\n\tif (atomic_read(&delayed_refs->num_entries) == 0) {\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tbtrfs_info(root->fs_info, \"delayed_refs has NO entry\");\n\t\treturn ret;\n\t}\n\n\twhile ((node = rb_first(&delayed_refs->href_root)) != NULL) {\n\t\tstruct btrfs_delayed_ref_head *head;\n\t\tbool pin_bytes = false;\n\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tspin_lock(&delayed_refs->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\twhile ((node = rb_first(&head->ref_root)) != NULL) {\n\t\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t\t       rb_node);\n\t\t\tref->in_tree = 0;\n\t\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t\t\tatomic_dec(&delayed_refs->num_entries);\n\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t}\n\t\tif (head->must_insert_reserved)\n\t\t\tpin_bytes = true;\n\t\tbtrfs_free_delayed_extent_op(head->extent_op);\n\t\tdelayed_refs->num_heads--;\n\t\tif (head->processing == 0)\n\t\t\tdelayed_refs->num_heads_ready--;\n\t\tatomic_dec(&delayed_refs->num_entries);\n\t\thead->node.in_tree = 0;\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t\tspin_unlock(&head->lock);\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tmutex_unlock(&head->mutex);\n\n\t\tif (pin_bytes)\n\t\t\tbtrfs_pin_extent(root, head->node.bytenr,\n\t\t\t\t\t head->node.num_bytes, 1);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\tcond_resched();\n\t\tspin_lock(&delayed_refs->lock);\n\t}\n\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_destroy_all_ordered_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3976-3998",
    "snippet": "static void btrfs_destroy_all_ordered_extents(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\t\tbtrfs_destroy_ordered_extents(root);\n\n\t\tcond_resched();\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&fs_info->ordered_root_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->ordered_root_lock"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->ordered_root_lock"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_ordered_extents",
          "args": [
            "root"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_ordered_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3961-3974",
          "snippet": "static void btrfs_destroy_ordered_extents(struct btrfs_root *root)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&root->ordered_extent_lock);\n\t/*\n\t * This will just short circuit the ordered completion stuff which will\n\t * make sure the ordered extent gets properly cleaned up.\n\t */\n\tlist_for_each_entry(ordered, &root->ordered_extents,\n\t\t\t    root_extent_list)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &ordered->flags);\n\tspin_unlock(&root->ordered_extent_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&root->ordered_extent_lock);\n\t/*\n\t * This will just short circuit the ordered completion stuff which will\n\t * make sure the ordered extent gets properly cleaned up.\n\t */\n\tlist_for_each_entry(ordered, &root->ordered_extents,\n\t\t\t    root_extent_list)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &ordered->flags);\n\tspin_unlock(&root->ordered_extent_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&root->ordered_root",
            "&fs_info->ordered_roots"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&splice",
            "structbtrfs_root",
            "ordered_root"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&splice"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&fs_info->ordered_roots",
            "&splice"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&splice"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_all_ordered_extents(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice)) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\t\tbtrfs_destroy_ordered_extents(root);\n\n\t\tcond_resched();\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&fs_info->ordered_root_lock);\n}"
  },
  {
    "function_name": "btrfs_destroy_ordered_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3961-3974",
    "snippet": "static void btrfs_destroy_ordered_extents(struct btrfs_root *root)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&root->ordered_extent_lock);\n\t/*\n\t * This will just short circuit the ordered completion stuff which will\n\t * make sure the ordered extent gets properly cleaned up.\n\t */\n\tlist_for_each_entry(ordered, &root->ordered_extents,\n\t\t\t    root_extent_list)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &ordered->flags);\n\tspin_unlock(&root->ordered_extent_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_IOERR",
            "&ordered->flags"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ordered",
            "&root->ordered_extents",
            "root_extent_list"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&root->ordered_extent_lock);\n\t/*\n\t * This will just short circuit the ordered completion stuff which will\n\t * make sure the ordered extent gets properly cleaned up.\n\t */\n\tlist_for_each_entry(ordered, &root->ordered_extents,\n\t\t\t    root_extent_list)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &ordered->flags);\n\tspin_unlock(&root->ordered_extent_lock);\n}"
  },
  {
    "function_name": "btrfs_error_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3948-3959",
    "snippet": "static void btrfs_error_commit_super(struct btrfs_root *root)\n{\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\t/* cleanup FS via transaction */\n\tbtrfs_cleanup_transaction(root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_cleanup_transaction",
          "args": [
            "root"
          ],
          "line": 3958
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4235-4286",
          "snippet": "static int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->cleanup_work_sem"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->cleanup_work_sem"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_iputs",
          "args": [
            "root"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_error_commit_super(struct btrfs_root *root)\n{\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\t/* cleanup FS via transaction */\n\tbtrfs_cleanup_transaction(root);\n}"
  },
  {
    "function_name": "btrfs_check_super_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3837-3946",
    "snippet": "static int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t      int read_only)\n{\n\tstruct btrfs_super_block *sb = fs_info->super_copy;\n\tint ret = 0;\n\n\tif (btrfs_super_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: tree_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_chunk_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: chunk_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_chunk_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_log_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: log_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_log_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The common minimum, we don't know if we can trust the nodesize/sectorsize\n\t * items yet, they'll be verified later. Issue just a warning.\n\t */\n\tif (!IS_ALIGNED(btrfs_super_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: tree_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_chunk_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: chunk_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_chunk_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_log_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: log_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_log_root(sb));\n\n\t/*\n\t * Check the lower bound, the alignment and other constraints are\n\t * checked later.\n\t */\n\tif (btrfs_super_nodesize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: nodesize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_nodesize(sb));\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sectorsize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: sectorsize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_sectorsize(sb));\n\t\tret = -EINVAL;\n\t}\n\n\tif (memcmp(fs_info->fsid, sb->dev_item.fsid, BTRFS_UUID_SIZE) != 0) {\n\t\tprintk(KERN_ERR \"BTRFS: dev_item UUID does not match fsid: %pU != %pU\\n\",\n\t\t\t\tfs_info->fsid, sb->dev_item.fsid);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Hint to catch really bogus numbers, bitflips or so, more exact checks are\n\t * done later\n\t */\n\tif (btrfs_super_num_devices(sb) > (1UL << 31))\n\t\tprintk(KERN_WARNING \"BTRFS: suspicious number of devices: %llu\\n\",\n\t\t\t\tbtrfs_super_num_devices(sb));\n\tif (btrfs_super_num_devices(sb) == 0) {\n\t\tprintk(KERN_ERR \"BTRFS: number of devices is 0\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (btrfs_super_bytenr(sb) != BTRFS_SUPER_INFO_OFFSET) {\n\t\tprintk(KERN_ERR \"BTRFS: super offset mismatch %llu != %u\\n\",\n\t\t\t\tbtrfs_super_bytenr(sb), BTRFS_SUPER_INFO_OFFSET);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Obvious sys_chunk_array corruptions, it must hold at least one key\n\t * and one chunk\n\t */\n\tif (btrfs_super_sys_array_size(sb) > BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too big %u > %u\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tBTRFS_SYSTEM_CHUNK_ARRAY_SIZE);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sys_array_size(sb) < sizeof(struct btrfs_disk_key)\n\t\t\t+ sizeof(struct btrfs_chunk)) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too small %u < %zu\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tsizeof(struct btrfs_disk_key)\n\t\t\t\t+ sizeof(struct btrfs_chunk));\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The generation is a global counter, we'll trust it more than the others\n\t * but it's still possible that it's the one that's wrong.\n\t */\n\tif (btrfs_super_generation(sb) < btrfs_super_chunk_root_generation(sb))\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < chunk_root_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_chunk_root_generation(sb));\n\tif (btrfs_super_generation(sb) < btrfs_super_cache_generation(sb)\n\t    && btrfs_super_cache_generation(sb) != (u64)-1)\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < cache_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_cache_generation(sb));\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    int read_only);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < cache_generation: %llu < %llu\\n\"",
            "btrfs_super_generation(sb)",
            "btrfs_super_cache_generation(sb)"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_cache_generation",
          "args": [
            "sb"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "sb"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_cache_generation",
          "args": [
            "sb"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_cache_generation",
          "args": [
            "sb"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "sb"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root_generation",
          "args": [
            "sb"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "sb"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root_generation",
          "args": [
            "sb"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "sb"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "sb"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "sb"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "sb"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sys_array_size",
          "args": [
            "sb"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "sb"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "sb"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: number of devices is 0\\n\""
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "sb"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "sb"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "sb"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fs_info->fsid",
            "sb->dev_item.fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sectorsize",
          "args": [
            "sb"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sectorsize",
          "args": [
            "sb"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "sb"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "sb"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "sb"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "btrfs_super_log_root(sb)",
            "4096"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "sb"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "sb"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "btrfs_super_chunk_root(sb)",
            "4096"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "sb"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "sb"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "btrfs_super_root(sb)",
            "4096"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "sb"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root_level",
          "args": [
            "sb"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root_level",
          "args": [
            "sb"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root_level",
          "args": [
            "sb"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root_level",
          "args": [
            "sb"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root_level",
          "args": [
            "sb"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root_level",
          "args": [
            "sb"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    int read_only);\n\nstatic int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t      int read_only)\n{\n\tstruct btrfs_super_block *sb = fs_info->super_copy;\n\tint ret = 0;\n\n\tif (btrfs_super_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: tree_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_chunk_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: chunk_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_chunk_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_log_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: log_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_log_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The common minimum, we don't know if we can trust the nodesize/sectorsize\n\t * items yet, they'll be verified later. Issue just a warning.\n\t */\n\tif (!IS_ALIGNED(btrfs_super_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: tree_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_chunk_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: chunk_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_chunk_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_log_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: log_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_log_root(sb));\n\n\t/*\n\t * Check the lower bound, the alignment and other constraints are\n\t * checked later.\n\t */\n\tif (btrfs_super_nodesize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: nodesize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_nodesize(sb));\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sectorsize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: sectorsize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_sectorsize(sb));\n\t\tret = -EINVAL;\n\t}\n\n\tif (memcmp(fs_info->fsid, sb->dev_item.fsid, BTRFS_UUID_SIZE) != 0) {\n\t\tprintk(KERN_ERR \"BTRFS: dev_item UUID does not match fsid: %pU != %pU\\n\",\n\t\t\t\tfs_info->fsid, sb->dev_item.fsid);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Hint to catch really bogus numbers, bitflips or so, more exact checks are\n\t * done later\n\t */\n\tif (btrfs_super_num_devices(sb) > (1UL << 31))\n\t\tprintk(KERN_WARNING \"BTRFS: suspicious number of devices: %llu\\n\",\n\t\t\t\tbtrfs_super_num_devices(sb));\n\tif (btrfs_super_num_devices(sb) == 0) {\n\t\tprintk(KERN_ERR \"BTRFS: number of devices is 0\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (btrfs_super_bytenr(sb) != BTRFS_SUPER_INFO_OFFSET) {\n\t\tprintk(KERN_ERR \"BTRFS: super offset mismatch %llu != %u\\n\",\n\t\t\t\tbtrfs_super_bytenr(sb), BTRFS_SUPER_INFO_OFFSET);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Obvious sys_chunk_array corruptions, it must hold at least one key\n\t * and one chunk\n\t */\n\tif (btrfs_super_sys_array_size(sb) > BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too big %u > %u\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tBTRFS_SYSTEM_CHUNK_ARRAY_SIZE);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sys_array_size(sb) < sizeof(struct btrfs_disk_key)\n\t\t\t+ sizeof(struct btrfs_chunk)) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too small %u < %zu\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tsizeof(struct btrfs_disk_key)\n\t\t\t\t+ sizeof(struct btrfs_chunk));\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The generation is a global counter, we'll trust it more than the others\n\t * but it's still possible that it's the one that's wrong.\n\t */\n\tif (btrfs_super_generation(sb) < btrfs_super_chunk_root_generation(sb))\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < chunk_root_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_chunk_root_generation(sb));\n\tif (btrfs_super_generation(sb) < btrfs_super_cache_generation(sb)\n\t    && btrfs_super_cache_generation(sb) != (u64)-1)\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < cache_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_cache_generation(sb));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_read_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3831-3835",
    "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_read_extent_buffer_pages",
          "args": [
            "root",
            "buf",
            "0",
            "parent_transid"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "buf->pages[0]->mapping->host"
          ],
          "line": 3833
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
  },
  {
    "function_name": "btrfs_btree_balance_dirty_nodelay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3826-3829",
    "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_btree_balance_dirty",
          "args": [
            "root",
            "0"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_btree_balance_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3797-3819",
          "snippet": "static void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
  },
  {
    "function_name": "btrfs_btree_balance_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3821-3824",
    "snippet": "void btrfs_btree_balance_dirty(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 1);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_btree_balance_dirty",
          "args": [
            "root",
            "1"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_btree_balance_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3797-3819",
          "snippet": "static void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 1);\n}"
  },
  {
    "function_name": "__btrfs_btree_balance_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3797-3819",
    "snippet": "static void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "root->fs_info->btree_inode->i_mapping"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_compare",
          "args": [
            "&root->fs_info->dirty_metadata_bytes",
            "BTRFS_DIRTY_METADATA_THRESH"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_balance_delayed_items",
          "args": [
            "root"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1426-1451",
          "snippet": "void btrfs_balance_delayed_items(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn;\n\n\tif (atomic_read(&delayed_root->items) >= BTRFS_DELAYED_WRITEBACK) {\n\t\tint seq;\n\t\tint ret;\n\n\t\tseq = atomic_read(&delayed_root->items_seq);\n\n\t\tret = btrfs_wq_run_delayed_node(delayed_root, root, 0);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\twait_event_interruptible(delayed_root->wait,\n\t\t\t\t\t could_end_wait(delayed_root, seq));\n\t\treturn;\n\t}\n\n\tbtrfs_wq_run_delayed_node(delayed_root, root, BTRFS_DELAYED_BATCH);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BTRFS_DELAYED_BATCH\t\t16",
            "#define BTRFS_DELAYED_BACKGROUND\t128",
            "#define BTRFS_DELAYED_WRITEBACK\t\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\n#define BTRFS_DELAYED_BATCH\t\t16\n#define BTRFS_DELAYED_BACKGROUND\t128\n#define BTRFS_DELAYED_WRITEBACK\t\t512\n\nvoid btrfs_balance_delayed_items(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\n\tdelayed_root = btrfs_get_delayed_root(root);\n\n\tif (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)\n\t\treturn;\n\n\tif (atomic_read(&delayed_root->items) >= BTRFS_DELAYED_WRITEBACK) {\n\t\tint seq;\n\t\tint ret;\n\n\t\tseq = atomic_read(&delayed_root->items_seq);\n\n\t\tret = btrfs_wq_run_delayed_node(delayed_root, root, 0);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\twait_event_interruptible(delayed_root->wait,\n\t\t\t\t\t could_end_wait(delayed_root, seq));\n\t\treturn;\n\t}\n\n\tbtrfs_wq_run_delayed_node(delayed_root, root, BTRFS_DELAYED_BATCH);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __btrfs_btree_balance_dirty(struct btrfs_root *root,\n\t\t\t\t\tint flush_delayed)\n{\n\t/*\n\t * looks as though older kernels can get into trouble with\n\t * this code, they end up stuck in balance_dirty_pages forever\n\t */\n\tint ret;\n\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn;\n\n\tif (flush_delayed)\n\t\tbtrfs_balance_delayed_items(root);\n\n\tret = percpu_counter_compare(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\tif (ret > 0) {\n\t\tbalance_dirty_pages_ratelimited(\n\t\t\t\t   root->fs_info->btree_inode->i_mapping);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "btrfs_mark_buffer_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3763-3795",
    "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_print_leaf",
          "args": [
            "root",
            "buf"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_print_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/print-tree.c",
          "lines": "172-311",
          "snippet": "void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nvoid btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_leaf",
          "args": [
            "root",
            "buf"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "check_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "543-602",
          "snippet": "static noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_counter_add",
          "args": [
            "&root->fs_info->dirty_metadata_bytes",
            "buf->len",
            "root->fs_info->dirty_metadata_batch"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_extent_buffer_dirty",
          "args": [
            "buf"
          ],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5063-5080",
          "snippet": "int set_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tint was_dirty = 0;\n\n\tcheck_buffer_tree_ref(eb);\n\n\twas_dirty = test_and_set_bit(EXTENT_BUFFER_DIRTY, &eb->bflags);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tWARN_ON(!test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags));\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tset_page_dirty(eb->pages[i]);\n\treturn was_dirty;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tint was_dirty = 0;\n\n\tcheck_buffer_tree_ref(eb);\n\n\twas_dirty = test_and_set_bit(EXTENT_BUFFER_DIRTY, &eb->bflags);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tWARN_ON(!test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags));\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tset_page_dirty(eb->pages[i]);\n\treturn was_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\"",
            "buf->start",
            "transid",
            "root->fs_info->generation"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "buf"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "buf->pages[0]->mapping->host"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_DUMMY",
            "&buf->bflags"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
  },
  {
    "function_name": "btrfs_set_buffer_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3758-3761",
    "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_buffer_uptodate",
          "args": [
            "buf"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5098-5111",
          "snippet": "int set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
  },
  {
    "function_name": "btrfs_buffer_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3741-3756",
    "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify_parent_transid",
          "args": [
            "&BTRFS_I(btree_inode)->io_tree",
            "buf",
            "parent_transid",
            "atomic"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "verify_parent_transid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "344-392",
          "snippet": "static int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "btree_inode"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "buf"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
  },
  {
    "function_name": "close_ctree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3639-3739",
    "snippet": "void close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_chunks",
          "args": [
            "root"
          ],
          "line": 3738
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "536-539",
          "snippet": "static inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline void unlock_chunks(struct btrfs_root *root)\n{\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fs_info->pinned_chunks",
            "structextent_map",
            "list"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->pinned_chunks"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_rsv",
          "args": [
            "root",
            "root->orphan_block_rsv"
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4694-4701",
          "snippet": "void btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_stripe_hash_table",
          "args": [
            "fs_info"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_stripe_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "451-461",
          "snippet": "void btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nvoid btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&fs_info->bdi"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->bio_counter"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->delalloc_bytes"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->dirty_metadata_bytes"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mapping_tree_free",
          "args": [
            "&fs_info->mapping_tree"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mapping_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4721-4738",
          "snippet": "void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_close_devices",
          "args": [
            "fs_info->fs_devices"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "746-772",
          "snippet": "int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_unmount",
          "args": [
            "root",
            "fs_info->fs_devices"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3165-3248",
          "snippet": "void btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nvoid btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "CHECK_INTEGRITY"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "fs_info->btree_inode"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_root_pointers",
          "args": [
            "fs_info",
            "1"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "free_root_pointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2099-2110",
          "snippet": "static void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stop_all_workers",
          "args": [
            "fs_info"
          ],
          "line": 3703
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stop_all_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2066-2086",
          "snippet": "static void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_groups",
          "args": [
            "fs_info"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8831-8925",
          "snippet": "int btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tdown_write(&info->commit_root_sem);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tput_caching_control(caching_ctl);\n\t}\n\tup_write(&info->commit_root_sem);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group_cache,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\t\twait_block_group_cache_done(block_group);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tfree_excluded_extents(info->extent_root, block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\t/* now that all the block groups are freed, go through and\n\t * free all the space_info structs.  This is only called during\n\t * the final stages of unmount, and so we know nobody is\n\t * using them.  We call synchronize_rcu() once before we start,\n\t * just to be on the safe side.\n\t */\n\tsynchronize_rcu();\n\n\trelease_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tint i;\n\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\t\tif (btrfs_test_opt(info->tree_root, ENOSPC_DEBUG)) {\n\t\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0)) {\n\t\t\t\tdump_space_info(space_info, 0, 0);\n\t\t\t}\n\t\t}\n\t\tlist_del(&space_info->list);\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tstruct kobject *kobj;\n\t\t\tkobj = space_info->block_group_kobjs[i];\n\t\t\tspace_info->block_group_kobjs[i] = NULL;\n\t\t\tif (kobj) {\n\t\t\t\tkobject_del(kobj);\n\t\t\t\tkobject_put(kobj);\n\t\t\t}\n\t\t}\n\t\tkobject_del(&space_info->kobj);\n\t\tkobject_put(&space_info->kobj);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tdown_write(&info->commit_root_sem);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tput_caching_control(caching_ctl);\n\t}\n\tup_write(&info->commit_root_sem);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group_cache,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\t\twait_block_group_cache_done(block_group);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tfree_excluded_extents(info->extent_root, block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\t/* now that all the block groups are freed, go through and\n\t * free all the space_info structs.  This is only called during\n\t * the final stages of unmount, and so we know nobody is\n\t * using them.  We call synchronize_rcu() once before we start,\n\t * just to be on the safe side.\n\t */\n\tsynchronize_rcu();\n\n\trelease_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tint i;\n\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\t\tif (btrfs_test_opt(info->tree_root, ENOSPC_DEBUG)) {\n\t\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0)) {\n\t\t\t\tdump_space_info(space_info, 0, 0);\n\t\t\t}\n\t\t}\n\t\tlist_del(&space_info->list);\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tstruct kobject *kobj;\n\t\t\tkobj = space_info->block_group_kobjs[i];\n\t\t\tspace_info->block_group_kobjs[i] = NULL;\n\t\t\tif (kobj) {\n\t\t\t\tkobject_del(kobj);\n\t\t\t\tkobject_put(kobj);\n\t\t\t}\n\t\t}\n\t\tkobject_del(&space_info->kobj);\n\t\tkobject_put(&space_info->kobj);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_block_group_cache",
          "args": [
            "fs_info"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_fs_roots",
          "args": [
            "fs_info"
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2112-2147",
          "snippet": "void btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\n\nvoid btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sysfs_remove_one",
          "args": [
            "fs_info"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sysfs_remove_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "516-528",
          "snippet": "void btrfs_sysfs_remove_one(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->space_info_kobj) {\n\t\tsysfs_remove_files(fs_info->space_info_kobj, allocation_attrs);\n\t\tkobject_del(fs_info->space_info_kobj);\n\t\tkobject_put(fs_info->space_info_kobj);\n\t}\n\tkobject_del(fs_info->device_dir_kobj);\n\tkobject_put(fs_info->device_dir_kobj);\n\taddrm_unknown_feature_attrs(fs_info, false);\n\tsysfs_remove_group(&fs_info->super_kobj, &btrfs_feature_attr_group);\n\t__btrfs_sysfs_remove_one(fs_info);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};",
            "static const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\nstatic const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};\n\nvoid btrfs_sysfs_remove_one(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->space_info_kobj) {\n\t\tsysfs_remove_files(fs_info->space_info_kobj, allocation_attrs);\n\t\tkobject_del(fs_info->space_info_kobj);\n\t\tkobject_put(fs_info->space_info_kobj);\n\t}\n\tkobject_del(fs_info->device_dir_kobj);\n\tkobject_put(fs_info->device_dir_kobj);\n\taddrm_unknown_feature_attrs(fs_info, false);\n\tsysfs_remove_group(&fs_info->super_kobj, &btrfs_feature_attr_group);\n\t__btrfs_sysfs_remove_one(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"at unmount delalloc count %lld\"",
            "percpu_counter_sum(&fs_info->delalloc_bytes)"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&fs_info->delalloc_bytes"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&fs_info->delalloc_bytes"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_qgroup_config",
          "args": [
            "root->fs_info"
          ],
          "line": 3683
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_qgroup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "458-475",
          "snippet": "void btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "fs_info->cleaner_kthread"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "fs_info->transaction_kthread"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_error_commit_super",
          "args": [
            "root"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3948-3959",
          "snippet": "static void btrfs_error_commit_super(struct btrfs_root *root)\n{\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\t/* cleanup FS via transaction */\n\tbtrfs_cleanup_transaction(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btrfs_error_commit_super(struct btrfs_root *root)\n{\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\t/* cleanup FS via transaction */\n\tbtrfs_cleanup_transaction(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"commit super ret %d\"",
            "ret"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_super",
          "args": [
            "root"
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3620-3637",
          "snippet": "int btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void end_workqueue_fn(struct btrfs_work *work);",
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&fs_info->async_reclaim_work"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_defrag_inodes",
          "args": [
            "fs_info"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_defrag_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "264-285",
          "snippet": "void btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nvoid btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->transaction_wait",
            "(atomic_read(&fs_info->defrag_running) == 0)"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->defrag_running"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel",
          "args": [
            "fs_info"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3781-3800",
          "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_suspend_for_unmount",
          "args": [
            "fs_info"
          ],
          "line": 3655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_suspend_for_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "737-760",
          "snippet": "void btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pause_balance",
          "args": [
            "fs_info"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pause_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3624-3651",
          "snippet": "int btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4235-4286",
          "snippet": "static int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1233-1275",
          "snippet": "int follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}"
  },
  {
    "function_name": "btrfs_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3620-3637",
    "snippet": "int btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);",
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 3636
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->cleanup_work_sem"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->cleanup_work_sem"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "root->fs_info->cleaner_kthread"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_iputs",
          "args": [
            "root"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}"
  },
  {
    "function_name": "btrfs_cleanup_fs_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3569-3618",
    "snippet": "int btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_fs_root",
          "args": [
            "gang[i]"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "108-112",
          "snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_orphan_cleanup",
          "args": [
            "gang[i]"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3300-3498",
          "snippet": "int btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_grab_fs_root",
          "args": [
            "gang[i]"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_grab_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "101-106",
          "snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&gang[i]->root_item"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&fs_info->fs_roots_radix",
            "(void **)gang",
            "root_objectid",
            "ARRAY_SIZE(gang)"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "gang"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_free_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3564-3567",
    "snippet": "void btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_fs_root",
          "args": [
            "root"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3564-3567",
          "snippet": "void btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}"
  },
  {
    "function_name": "free_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3546-3562",
    "snippet": "static void free_fs_root(struct btrfs_root *root)\n{\n\tiput(root->ino_cache_inode);\n\tWARN_ON(!RB_EMPTY_ROOT(&root->inode_tree));\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\tif (root->anon_dev)\n\t\tfree_anon_bdev(root->anon_dev);\n\tif (root->subv_writers)\n\t\tbtrfs_free_subvolume_writers(root->subv_writers);\n\tfree_extent_buffer(root->node);\n\tfree_extent_buffer(root->commit_root);\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\tkfree(root->name);\n\tbtrfs_put_fs_root(root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_fs_root",
          "args": [
            "root"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "108-112",
          "snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root->name"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root->free_ino_pinned"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root->free_ino_ctl"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root->commit_root"
          ],
          "line": 3557
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_subvolume_writers",
          "args": [
            "root->subv_writers"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_subvolume_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1207-1212",
          "snippet": "static void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_anon_bdev",
          "args": [
            "root->anon_dev"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_rsv",
          "args": [
            "root",
            "root->orphan_block_rsv"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4694-4701",
          "snippet": "void btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&root->inode_tree)"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&root->inode_tree"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root->ino_cache_inode"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void free_fs_root(struct btrfs_root *root)\n{\n\tiput(root->ino_cache_inode);\n\tWARN_ON(!RB_EMPTY_ROOT(&root->inode_tree));\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\tif (root->anon_dev)\n\t\tfree_anon_bdev(root->anon_dev);\n\tif (root->subv_writers)\n\t\tbtrfs_free_subvolume_writers(root->subv_writers);\n\tfree_extent_buffer(root->node);\n\tfree_extent_buffer(root->commit_root);\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\tkfree(root->name);\n\tbtrfs_put_fs_root(root);\n}"
  },
  {
    "function_name": "btrfs_drop_and_free_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3525-3544",
    "snippet": "void btrfs_drop_and_free_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_delete(&fs_info->fs_roots_radix,\n\t\t\t  (unsigned long)root->root_key.objectid);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\tsynchronize_srcu(&fs_info->subvol_srcu);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_free_log(NULL, root);\n\n\tif (root->free_ino_pinned)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_pinned);\n\tif (root->free_ino_ctl)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_ctl);\n\tfree_fs_root(root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_fs_root",
          "args": [
            "root"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3564-3567",
          "snippet": "void btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "root->free_ino_ctl"
          ],
          "line": 3542
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_log",
          "args": [
            "NULL",
            "root"
          ],
          "line": 3537
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_log_root_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2811-2819",
          "snippet": "int btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 3531
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&fs_info->fs_roots_radix",
            "(unsigned long)root->root_key.objectid"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_drop_and_free_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_delete(&fs_info->fs_roots_radix,\n\t\t\t  (unsigned long)root->root_key.objectid);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\tsynchronize_srcu(&fs_info->subvol_srcu);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_free_log(NULL, root);\n\n\tif (root->free_ino_pinned)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_pinned);\n\tif (root->free_ino_ctl)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_ctl);\n\tfree_fs_root(root);\n}"
  },
  {
    "function_name": "write_ctree_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3518-3522",
    "snippet": "int write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_all_supers",
          "args": [
            "root",
            "max_mirrors"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "write_all_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3426-3516",
          "snippet": "static int write_all_supers(struct btrfs_root *root, int max_mirrors)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_super_block *sb;\n\tstruct btrfs_dev_item *dev_item;\n\tint ret;\n\tint do_barriers;\n\tint max_errors;\n\tint total_errors = 0;\n\tu64 flags;\n\n\tdo_barriers = !btrfs_test_opt(root, NOBARRIER);\n\tbackup_super_roots(root->fs_info);\n\n\tsb = root->fs_info->super_for_commit;\n\tdev_item = &sb->dev_item;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\thead = &root->fs_info->fs_devices->devices;\n\tmax_errors = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\n\tif (do_barriers) {\n\t\tret = barrier_all_devices(root->fs_info);\n\t\tif (ret) {\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"errors while submitting device barriers.\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev) {\n\t\t\ttotal_errors++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tbtrfs_set_stack_device_generation(dev_item, 0);\n\t\tbtrfs_set_stack_device_type(dev_item, dev->type);\n\t\tbtrfs_set_stack_device_id(dev_item, dev->devid);\n\t\tbtrfs_set_stack_device_total_bytes(dev_item,\n\t\t\t\t\t\t   dev->commit_total_bytes);\n\t\tbtrfs_set_stack_device_bytes_used(dev_item,\n\t\t\t\t\t\t  dev->commit_bytes_used);\n\t\tbtrfs_set_stack_device_io_align(dev_item, dev->io_align);\n\t\tbtrfs_set_stack_device_io_width(dev_item, dev->io_width);\n\t\tbtrfs_set_stack_device_sector_size(dev_item, dev->sector_size);\n\t\tmemcpy(dev_item->uuid, dev->uuid, BTRFS_UUID_SIZE);\n\t\tmemcpy(dev_item->fsid, dev->fs_devices->fsid, BTRFS_UUID_SIZE);\n\n\t\tflags = btrfs_super_flags(sb);\n\t\tbtrfs_set_super_flags(sb, flags | BTRFS_HEADER_FLAG_WRITTEN);\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 0, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tif (total_errors > max_errors) {\n\t\tbtrfs_err(root->fs_info, \"%d errors while writing supers\",\n\t\t       total_errors);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t\t/* FUA is masked off if unsupported and can't be the reason */\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\n\ttotal_errors = 0;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 1, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tif (total_errors > max_errors) {\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int write_all_supers(struct btrfs_root *root, int max_mirrors)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_super_block *sb;\n\tstruct btrfs_dev_item *dev_item;\n\tint ret;\n\tint do_barriers;\n\tint max_errors;\n\tint total_errors = 0;\n\tu64 flags;\n\n\tdo_barriers = !btrfs_test_opt(root, NOBARRIER);\n\tbackup_super_roots(root->fs_info);\n\n\tsb = root->fs_info->super_for_commit;\n\tdev_item = &sb->dev_item;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\thead = &root->fs_info->fs_devices->devices;\n\tmax_errors = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\n\tif (do_barriers) {\n\t\tret = barrier_all_devices(root->fs_info);\n\t\tif (ret) {\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"errors while submitting device barriers.\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev) {\n\t\t\ttotal_errors++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tbtrfs_set_stack_device_generation(dev_item, 0);\n\t\tbtrfs_set_stack_device_type(dev_item, dev->type);\n\t\tbtrfs_set_stack_device_id(dev_item, dev->devid);\n\t\tbtrfs_set_stack_device_total_bytes(dev_item,\n\t\t\t\t\t\t   dev->commit_total_bytes);\n\t\tbtrfs_set_stack_device_bytes_used(dev_item,\n\t\t\t\t\t\t  dev->commit_bytes_used);\n\t\tbtrfs_set_stack_device_io_align(dev_item, dev->io_align);\n\t\tbtrfs_set_stack_device_io_width(dev_item, dev->io_width);\n\t\tbtrfs_set_stack_device_sector_size(dev_item, dev->sector_size);\n\t\tmemcpy(dev_item->uuid, dev->uuid, BTRFS_UUID_SIZE);\n\t\tmemcpy(dev_item->fsid, dev->fs_devices->fsid, BTRFS_UUID_SIZE);\n\n\t\tflags = btrfs_super_flags(sb);\n\t\tbtrfs_set_super_flags(sb, flags | BTRFS_HEADER_FLAG_WRITTEN);\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 0, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tif (total_errors > max_errors) {\n\t\tbtrfs_err(root->fs_info, \"%d errors while writing supers\",\n\t\t       total_errors);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t\t/* FUA is masked off if unsupported and can't be the reason */\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\n\ttotal_errors = 0;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 1, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tif (total_errors > max_errors) {\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}"
  },
  {
    "function_name": "write_all_supers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3426-3516",
    "snippet": "static int write_all_supers(struct btrfs_root *root, int max_mirrors)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_super_block *sb;\n\tstruct btrfs_dev_item *dev_item;\n\tint ret;\n\tint do_barriers;\n\tint max_errors;\n\tint total_errors = 0;\n\tu64 flags;\n\n\tdo_barriers = !btrfs_test_opt(root, NOBARRIER);\n\tbackup_super_roots(root->fs_info);\n\n\tsb = root->fs_info->super_for_commit;\n\tdev_item = &sb->dev_item;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\thead = &root->fs_info->fs_devices->devices;\n\tmax_errors = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\n\tif (do_barriers) {\n\t\tret = barrier_all_devices(root->fs_info);\n\t\tif (ret) {\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"errors while submitting device barriers.\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev) {\n\t\t\ttotal_errors++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tbtrfs_set_stack_device_generation(dev_item, 0);\n\t\tbtrfs_set_stack_device_type(dev_item, dev->type);\n\t\tbtrfs_set_stack_device_id(dev_item, dev->devid);\n\t\tbtrfs_set_stack_device_total_bytes(dev_item,\n\t\t\t\t\t\t   dev->commit_total_bytes);\n\t\tbtrfs_set_stack_device_bytes_used(dev_item,\n\t\t\t\t\t\t  dev->commit_bytes_used);\n\t\tbtrfs_set_stack_device_io_align(dev_item, dev->io_align);\n\t\tbtrfs_set_stack_device_io_width(dev_item, dev->io_width);\n\t\tbtrfs_set_stack_device_sector_size(dev_item, dev->sector_size);\n\t\tmemcpy(dev_item->uuid, dev->uuid, BTRFS_UUID_SIZE);\n\t\tmemcpy(dev_item->fsid, dev->fs_devices->fsid, BTRFS_UUID_SIZE);\n\n\t\tflags = btrfs_super_flags(sb);\n\t\tbtrfs_set_super_flags(sb, flags | BTRFS_HEADER_FLAG_WRITTEN);\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 0, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tif (total_errors > max_errors) {\n\t\tbtrfs_err(root->fs_info, \"%d errors while writing supers\",\n\t\t       total_errors);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t\t/* FUA is masked off if unsupported and can't be the reason */\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\n\ttotal_errors = 0;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 1, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tif (total_errors > max_errors) {\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "-EIO",
            "\"%d errors while writing supers\"",
            "total_errors"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dev_supers",
          "args": [
            "dev",
            "sb",
            "do_barriers",
            "1",
            "max_mirrors"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "write_dev_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3137-3220",
          "snippet": "static int write_dev_supers(struct btrfs_device *device,\n\t\t\t    struct btrfs_super_block *sb,\n\t\t\t    int do_barriers, int wait, int max_mirrors)\n{\n\tstruct buffer_head *bh;\n\tint i;\n\tint ret;\n\tint errors = 0;\n\tu32 crc;\n\tu64 bytenr;\n\n\tif (max_mirrors == 0)\n\t\tmax_mirrors = BTRFS_SUPER_MIRROR_MAX;\n\n\tfor (i = 0; i < max_mirrors; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t    device->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tif (wait) {\n\t\t\tbh = __find_get_block(device->bdev, bytenr / 4096,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terrors++;\n\n\t\t\t/* drop our reference */\n\t\t\tbrelse(bh);\n\n\t\t\t/* drop the reference from the wait == 0 run */\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbtrfs_set_super_bytenr(sb, bytenr);\n\n\t\t\tcrc = ~(u32)0;\n\t\t\tcrc = btrfs_csum_data((char *)sb +\n\t\t\t\t\t      BTRFS_CSUM_SIZE, crc,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE -\n\t\t\t\t\t      BTRFS_CSUM_SIZE);\n\t\t\tbtrfs_csum_final(crc, sb->csum);\n\n\t\t\t/*\n\t\t\t * one reference for us, and we leave it for the\n\t\t\t * caller\n\t\t\t */\n\t\t\tbh = __getblk(device->bdev, bytenr / 4096,\n\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\tprintk(KERN_ERR \"BTRFS: couldn't get super \"\n\t\t\t\t       \"buffer head for bytenr %Lu\\n\", bytenr);\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(bh->b_data, sb, BTRFS_SUPER_INFO_SIZE);\n\n\t\t\t/* one reference for submit_bh */\n\t\t\tget_bh(bh);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = btrfs_end_buffer_write_sync;\n\t\t\tbh->b_private = device;\n\t\t}\n\n\t\t/*\n\t\t * we fua the first super.  The others we allow\n\t\t * to go down lazy.\n\t\t */\n\t\tif (i == 0)\n\t\t\tret = btrfsic_submit_bh(WRITE_FUA, bh);\n\t\telse\n\t\t\tret = btrfsic_submit_bh(WRITE_SYNC, bh);\n\t\tif (ret)\n\t\t\terrors++;\n\t}\n\treturn errors < i ? 0 : -1;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int write_dev_supers(struct btrfs_device *device,\n\t\t\t    struct btrfs_super_block *sb,\n\t\t\t    int do_barriers, int wait, int max_mirrors)\n{\n\tstruct buffer_head *bh;\n\tint i;\n\tint ret;\n\tint errors = 0;\n\tu32 crc;\n\tu64 bytenr;\n\n\tif (max_mirrors == 0)\n\t\tmax_mirrors = BTRFS_SUPER_MIRROR_MAX;\n\n\tfor (i = 0; i < max_mirrors; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t    device->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tif (wait) {\n\t\t\tbh = __find_get_block(device->bdev, bytenr / 4096,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terrors++;\n\n\t\t\t/* drop our reference */\n\t\t\tbrelse(bh);\n\n\t\t\t/* drop the reference from the wait == 0 run */\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbtrfs_set_super_bytenr(sb, bytenr);\n\n\t\t\tcrc = ~(u32)0;\n\t\t\tcrc = btrfs_csum_data((char *)sb +\n\t\t\t\t\t      BTRFS_CSUM_SIZE, crc,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE -\n\t\t\t\t\t      BTRFS_CSUM_SIZE);\n\t\t\tbtrfs_csum_final(crc, sb->csum);\n\n\t\t\t/*\n\t\t\t * one reference for us, and we leave it for the\n\t\t\t * caller\n\t\t\t */\n\t\t\tbh = __getblk(device->bdev, bytenr / 4096,\n\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\tprintk(KERN_ERR \"BTRFS: couldn't get super \"\n\t\t\t\t       \"buffer head for bytenr %Lu\\n\", bytenr);\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(bh->b_data, sb, BTRFS_SUPER_INFO_SIZE);\n\n\t\t\t/* one reference for submit_bh */\n\t\t\tget_bh(bh);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = btrfs_end_buffer_write_sync;\n\t\t\tbh->b_private = device;\n\t\t}\n\n\t\t/*\n\t\t * we fua the first super.  The others we allow\n\t\t * to go down lazy.\n\t\t */\n\t\tif (i == 0)\n\t\t\tret = btrfsic_submit_bh(WRITE_FUA, bh);\n\t\telse\n\t\t\tret = btrfsic_submit_bh(WRITE_SYNC, bh);\n\t\tif (ret)\n\t\t\terrors++;\n\t}\n\treturn errors < i ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "-EIO",
            "\"%d errors while writing supers\"",
            "total_errors"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"%d errors while writing supers\"",
            "total_errors"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_flags",
          "args": [
            "sb",
            "flags | BTRFS_HEADER_FLAG_WRITTEN"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_flags",
          "args": [
            "sb"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dev_item->fsid",
            "dev->fs_devices->fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dev_item->uuid",
            "dev->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_sector_size",
          "args": [
            "dev_item",
            "dev->sector_size"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_io_width",
          "args": [
            "dev_item",
            "dev->io_width"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_io_align",
          "args": [
            "dev_item",
            "dev->io_align"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_bytes_used",
          "args": [
            "dev_item",
            "dev->commit_bytes_used"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_total_bytes",
          "args": [
            "dev_item",
            "dev->commit_total_bytes"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_id",
          "args": [
            "dev_item",
            "dev->devid"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_type",
          "args": [
            "dev_item",
            "dev->type"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_device_generation",
          "args": [
            "dev_item",
            "0"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_all_devices",
          "args": [
            "root->fs_info"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "barrier_all_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3302-3346",
          "snippet": "static int barrier_all_devices(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tint errors_send = 0;\n\tint errors_wait = 0;\n\tint ret;\n\n\t/* send down all the barriers */\n\thead = &info->fs_devices->devices;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_send++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 0);\n\t\tif (ret)\n\t\t\terrors_send++;\n\t}\n\n\t/* wait for all the barriers */\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_wait++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 1);\n\t\tif (ret)\n\t\t\terrors_wait++;\n\t}\n\tif (errors_send > info->num_tolerated_disk_barrier_failures ||\n\t    errors_wait > info->num_tolerated_disk_barrier_failures)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int barrier_all_devices(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tint errors_send = 0;\n\tint errors_wait = 0;\n\tint ret;\n\n\t/* send down all the barriers */\n\thead = &info->fs_devices->devices;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_send++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 0);\n\t\tif (ret)\n\t\t\terrors_send++;\n\t}\n\n\t/* wait for all the barriers */\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_wait++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 1);\n\t\tif (ret)\n\t\t\terrors_wait++;\n\t}\n\tif (errors_send > info->num_tolerated_disk_barrier_failures ||\n\t    errors_wait > info->num_tolerated_disk_barrier_failures)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_super_roots",
          "args": [
            "root->fs_info"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "backup_super_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1924-2011",
          "snippet": "static void backup_super_roots(struct btrfs_fs_info *info)\n{\n\tint next_backup;\n\tstruct btrfs_root_backup *root_backup;\n\tint last_backup;\n\n\tnext_backup = info->backup_root_index;\n\tlast_backup = (next_backup + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\tBTRFS_NUM_BACKUP_ROOTS;\n\n\t/*\n\t * just overwrite the last backup if we're at the same generation\n\t * this happens only at umount\n\t */\n\troot_backup = info->super_for_commit->super_roots + last_backup;\n\tif (btrfs_backup_tree_root_gen(root_backup) ==\n\t    btrfs_header_generation(info->tree_root->node))\n\t\tnext_backup = last_backup;\n\n\troot_backup = info->super_for_commit->super_roots + next_backup;\n\n\t/*\n\t * make sure all of our padding and empty slots get zero filled\n\t * regardless of which ones we use today\n\t */\n\tmemset(root_backup, 0, sizeof(*root_backup));\n\n\tinfo->backup_root_index = (next_backup + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\n\tbtrfs_set_backup_tree_root(root_backup, info->tree_root->node->start);\n\tbtrfs_set_backup_tree_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->tree_root->node));\n\n\tbtrfs_set_backup_tree_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->tree_root->node));\n\n\tbtrfs_set_backup_chunk_root(root_backup, info->chunk_root->node->start);\n\tbtrfs_set_backup_chunk_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->chunk_root->node));\n\tbtrfs_set_backup_chunk_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->chunk_root->node));\n\n\tbtrfs_set_backup_extent_root(root_backup, info->extent_root->node->start);\n\tbtrfs_set_backup_extent_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->extent_root->node));\n\tbtrfs_set_backup_extent_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->extent_root->node));\n\n\t/*\n\t * we might commit during log recovery, which happens before we set\n\t * the fs_root.  Make sure it is valid before we fill it in.\n\t */\n\tif (info->fs_root && info->fs_root->node) {\n\t\tbtrfs_set_backup_fs_root(root_backup,\n\t\t\t\t\t info->fs_root->node->start);\n\t\tbtrfs_set_backup_fs_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->fs_root->node));\n\t\tbtrfs_set_backup_fs_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->fs_root->node));\n\t}\n\n\tbtrfs_set_backup_dev_root(root_backup, info->dev_root->node->start);\n\tbtrfs_set_backup_dev_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->dev_root->node));\n\tbtrfs_set_backup_dev_root_level(root_backup,\n\t\t\t\t       btrfs_header_level(info->dev_root->node));\n\n\tbtrfs_set_backup_csum_root(root_backup, info->csum_root->node->start);\n\tbtrfs_set_backup_csum_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->csum_root->node));\n\tbtrfs_set_backup_csum_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->csum_root->node));\n\n\tbtrfs_set_backup_total_bytes(root_backup,\n\t\t\t     btrfs_super_total_bytes(info->super_copy));\n\tbtrfs_set_backup_bytes_used(root_backup,\n\t\t\t     btrfs_super_bytes_used(info->super_copy));\n\tbtrfs_set_backup_num_devices(root_backup,\n\t\t\t     btrfs_super_num_devices(info->super_copy));\n\n\t/*\n\t * if we don't copy this out to the super_copy, it won't get remembered\n\t * for the next commit\n\t */\n\tmemcpy(&info->super_copy->super_roots,\n\t       &info->super_for_commit->super_roots,\n\t       sizeof(*root_backup) * BTRFS_NUM_BACKUP_ROOTS);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void backup_super_roots(struct btrfs_fs_info *info)\n{\n\tint next_backup;\n\tstruct btrfs_root_backup *root_backup;\n\tint last_backup;\n\n\tnext_backup = info->backup_root_index;\n\tlast_backup = (next_backup + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\tBTRFS_NUM_BACKUP_ROOTS;\n\n\t/*\n\t * just overwrite the last backup if we're at the same generation\n\t * this happens only at umount\n\t */\n\troot_backup = info->super_for_commit->super_roots + last_backup;\n\tif (btrfs_backup_tree_root_gen(root_backup) ==\n\t    btrfs_header_generation(info->tree_root->node))\n\t\tnext_backup = last_backup;\n\n\troot_backup = info->super_for_commit->super_roots + next_backup;\n\n\t/*\n\t * make sure all of our padding and empty slots get zero filled\n\t * regardless of which ones we use today\n\t */\n\tmemset(root_backup, 0, sizeof(*root_backup));\n\n\tinfo->backup_root_index = (next_backup + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\n\tbtrfs_set_backup_tree_root(root_backup, info->tree_root->node->start);\n\tbtrfs_set_backup_tree_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->tree_root->node));\n\n\tbtrfs_set_backup_tree_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->tree_root->node));\n\n\tbtrfs_set_backup_chunk_root(root_backup, info->chunk_root->node->start);\n\tbtrfs_set_backup_chunk_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->chunk_root->node));\n\tbtrfs_set_backup_chunk_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->chunk_root->node));\n\n\tbtrfs_set_backup_extent_root(root_backup, info->extent_root->node->start);\n\tbtrfs_set_backup_extent_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->extent_root->node));\n\tbtrfs_set_backup_extent_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->extent_root->node));\n\n\t/*\n\t * we might commit during log recovery, which happens before we set\n\t * the fs_root.  Make sure it is valid before we fill it in.\n\t */\n\tif (info->fs_root && info->fs_root->node) {\n\t\tbtrfs_set_backup_fs_root(root_backup,\n\t\t\t\t\t info->fs_root->node->start);\n\t\tbtrfs_set_backup_fs_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->fs_root->node));\n\t\tbtrfs_set_backup_fs_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->fs_root->node));\n\t}\n\n\tbtrfs_set_backup_dev_root(root_backup, info->dev_root->node->start);\n\tbtrfs_set_backup_dev_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->dev_root->node));\n\tbtrfs_set_backup_dev_root_level(root_backup,\n\t\t\t\t       btrfs_header_level(info->dev_root->node));\n\n\tbtrfs_set_backup_csum_root(root_backup, info->csum_root->node->start);\n\tbtrfs_set_backup_csum_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->csum_root->node));\n\tbtrfs_set_backup_csum_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->csum_root->node));\n\n\tbtrfs_set_backup_total_bytes(root_backup,\n\t\t\t     btrfs_super_total_bytes(info->super_copy));\n\tbtrfs_set_backup_bytes_used(root_backup,\n\t\t\t     btrfs_super_bytes_used(info->super_copy));\n\tbtrfs_set_backup_num_devices(root_backup,\n\t\t\t     btrfs_super_num_devices(info->super_copy));\n\n\t/*\n\t * if we don't copy this out to the super_copy, it won't get remembered\n\t * for the next commit\n\t */\n\tmemcpy(&info->super_copy->super_roots,\n\t       &info->super_for_commit->super_roots,\n\t       sizeof(*root_backup) * BTRFS_NUM_BACKUP_ROOTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NOBARRIER"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int write_all_supers(struct btrfs_root *root, int max_mirrors)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_super_block *sb;\n\tstruct btrfs_dev_item *dev_item;\n\tint ret;\n\tint do_barriers;\n\tint max_errors;\n\tint total_errors = 0;\n\tu64 flags;\n\n\tdo_barriers = !btrfs_test_opt(root, NOBARRIER);\n\tbackup_super_roots(root->fs_info);\n\n\tsb = root->fs_info->super_for_commit;\n\tdev_item = &sb->dev_item;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\thead = &root->fs_info->fs_devices->devices;\n\tmax_errors = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\n\tif (do_barriers) {\n\t\tret = barrier_all_devices(root->fs_info);\n\t\tif (ret) {\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"errors while submitting device barriers.\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev) {\n\t\t\ttotal_errors++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tbtrfs_set_stack_device_generation(dev_item, 0);\n\t\tbtrfs_set_stack_device_type(dev_item, dev->type);\n\t\tbtrfs_set_stack_device_id(dev_item, dev->devid);\n\t\tbtrfs_set_stack_device_total_bytes(dev_item,\n\t\t\t\t\t\t   dev->commit_total_bytes);\n\t\tbtrfs_set_stack_device_bytes_used(dev_item,\n\t\t\t\t\t\t  dev->commit_bytes_used);\n\t\tbtrfs_set_stack_device_io_align(dev_item, dev->io_align);\n\t\tbtrfs_set_stack_device_io_width(dev_item, dev->io_width);\n\t\tbtrfs_set_stack_device_sector_size(dev_item, dev->sector_size);\n\t\tmemcpy(dev_item->uuid, dev->uuid, BTRFS_UUID_SIZE);\n\t\tmemcpy(dev_item->fsid, dev->fs_devices->fsid, BTRFS_UUID_SIZE);\n\n\t\tflags = btrfs_super_flags(sb);\n\t\tbtrfs_set_super_flags(sb, flags | BTRFS_HEADER_FLAG_WRITTEN);\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 0, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tif (total_errors > max_errors) {\n\t\tbtrfs_err(root->fs_info, \"%d errors while writing supers\",\n\t\t       total_errors);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t\t/* FUA is masked off if unsupported and can't be the reason */\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\n\ttotal_errors = 0;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_supers(dev, sb, do_barriers, 1, max_mirrors);\n\t\tif (ret)\n\t\t\ttotal_errors++;\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tif (total_errors > max_errors) {\n\t\tbtrfs_error(root->fs_info, -EIO,\n\t\t\t    \"%d errors while writing supers\", total_errors);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_calc_num_tolerated_disk_barrier_failures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3348-3424",
    "snippet": "int btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sinfo->groups_sem"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_block_group_info",
          "args": [
            "&sinfo->block_groups[c]",
            "&space"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_block_group_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3833-3847",
          "snippet": "void btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sinfo->block_groups[c]"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sinfo->groups_sem"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "tmp",
            "&fs_info->space_info",
            "list"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}"
  },
  {
    "function_name": "barrier_all_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3302-3346",
    "snippet": "static int barrier_all_devices(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tint errors_send = 0;\n\tint errors_wait = 0;\n\tint ret;\n\n\t/* send down all the barriers */\n\thead = &info->fs_devices->devices;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_send++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 0);\n\t\tif (ret)\n\t\t\terrors_send++;\n\t}\n\n\t/* wait for all the barriers */\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_wait++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 1);\n\t\tif (ret)\n\t\t\terrors_wait++;\n\t}\n\tif (errors_send > info->num_tolerated_disk_barrier_failures ||\n\t    errors_wait > info->num_tolerated_disk_barrier_failures)\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_dev_flush",
          "args": [
            "dev",
            "1"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "write_dev_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3245-3296",
          "snippet": "static int write_dev_flush(struct btrfs_device *device, int wait)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tif (device->nobarriers)\n\t\treturn 0;\n\n\tif (wait) {\n\t\tbio = device->flush_bio;\n\t\tif (!bio)\n\t\t\treturn 0;\n\n\t\twait_for_completion(&device->flush_wait);\n\n\t\tif (bio_flagged(bio, BIO_EOPNOTSUPP)) {\n\t\t\tprintk_in_rcu(\"BTRFS: disabling barriers on dev %s\\n\",\n\t\t\t\t      rcu_str_deref(device->name));\n\t\t\tdevice->nobarriers = 1;\n\t\t} else if (!bio_flagged(bio, BIO_UPTODATE)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_dev_stat_inc_and_print(device,\n\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t}\n\n\t\t/* drop the reference from the wait == 0 run */\n\t\tbio_put(bio);\n\t\tdevice->flush_bio = NULL;\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * one reference for us, and we leave it for the\n\t * caller\n\t */\n\tdevice->flush_bio = NULL;\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_end_io = btrfs_end_empty_barrier;\n\tbio->bi_bdev = device->bdev;\n\tinit_completion(&device->flush_wait);\n\tbio->bi_private = &device->flush_wait;\n\tdevice->flush_bio = bio;\n\n\tbio_get(bio);\n\tbtrfsic_submit_bio(WRITE_FLUSH, bio);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int write_dev_flush(struct btrfs_device *device, int wait)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tif (device->nobarriers)\n\t\treturn 0;\n\n\tif (wait) {\n\t\tbio = device->flush_bio;\n\t\tif (!bio)\n\t\t\treturn 0;\n\n\t\twait_for_completion(&device->flush_wait);\n\n\t\tif (bio_flagged(bio, BIO_EOPNOTSUPP)) {\n\t\t\tprintk_in_rcu(\"BTRFS: disabling barriers on dev %s\\n\",\n\t\t\t\t      rcu_str_deref(device->name));\n\t\t\tdevice->nobarriers = 1;\n\t\t} else if (!bio_flagged(bio, BIO_UPTODATE)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_dev_stat_inc_and_print(device,\n\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t}\n\n\t\t/* drop the reference from the wait == 0 run */\n\t\tbio_put(bio);\n\t\tdevice->flush_bio = NULL;\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * one reference for us, and we leave it for the\n\t * caller\n\t */\n\tdevice->flush_bio = NULL;\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_end_io = btrfs_end_empty_barrier;\n\tbio->bi_bdev = device->bdev;\n\tinit_completion(&device->flush_wait);\n\tbio->bi_private = &device->flush_wait;\n\tdevice->flush_bio = bio;\n\n\tbio_get(bio);\n\tbtrfsic_submit_bio(WRITE_FLUSH, bio);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int barrier_all_devices(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head;\n\tstruct btrfs_device *dev;\n\tint errors_send = 0;\n\tint errors_wait = 0;\n\tint ret;\n\n\t/* send down all the barriers */\n\thead = &info->fs_devices->devices;\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_send++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 0);\n\t\tif (ret)\n\t\t\terrors_send++;\n\t}\n\n\t/* wait for all the barriers */\n\tlist_for_each_entry_rcu(dev, head, dev_list) {\n\t\tif (dev->missing)\n\t\t\tcontinue;\n\t\tif (!dev->bdev) {\n\t\t\terrors_wait++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->in_fs_metadata || !dev->writeable)\n\t\t\tcontinue;\n\n\t\tret = write_dev_flush(dev, 1);\n\t\tif (ret)\n\t\t\terrors_wait++;\n\t}\n\tif (errors_send > info->num_tolerated_disk_barrier_failures ||\n\t    errors_wait > info->num_tolerated_disk_barrier_failures)\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "write_dev_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3245-3296",
    "snippet": "static int write_dev_flush(struct btrfs_device *device, int wait)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tif (device->nobarriers)\n\t\treturn 0;\n\n\tif (wait) {\n\t\tbio = device->flush_bio;\n\t\tif (!bio)\n\t\t\treturn 0;\n\n\t\twait_for_completion(&device->flush_wait);\n\n\t\tif (bio_flagged(bio, BIO_EOPNOTSUPP)) {\n\t\t\tprintk_in_rcu(\"BTRFS: disabling barriers on dev %s\\n\",\n\t\t\t\t      rcu_str_deref(device->name));\n\t\t\tdevice->nobarriers = 1;\n\t\t} else if (!bio_flagged(bio, BIO_UPTODATE)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_dev_stat_inc_and_print(device,\n\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t}\n\n\t\t/* drop the reference from the wait == 0 run */\n\t\tbio_put(bio);\n\t\tdevice->flush_bio = NULL;\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * one reference for us, and we leave it for the\n\t * caller\n\t */\n\tdevice->flush_bio = NULL;\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_end_io = btrfs_end_empty_barrier;\n\tbio->bi_bdev = device->bdev;\n\tinit_completion(&device->flush_wait);\n\tbio->bi_private = &device->flush_wait;\n\tdevice->flush_bio = bio;\n\n\tbio_get(bio);\n\tbtrfsic_submit_bio(WRITE_FLUSH, bio);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "WRITE_FLUSH",
            "bio"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&device->flush_wait"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "0"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "device",
            "BTRFS_DEV_STAT_FLUSH_ERRS"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_flagged",
          "args": [
            "bio",
            "BIO_UPTODATE"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "\"BTRFS: disabling barriers on dev %s\\n\"",
            "rcu_str_deref(device->name)"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_flagged",
          "args": [
            "bio",
            "BIO_EOPNOTSUPP"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&device->flush_wait"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2798-2814",
          "snippet": "int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int write_dev_flush(struct btrfs_device *device, int wait)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tif (device->nobarriers)\n\t\treturn 0;\n\n\tif (wait) {\n\t\tbio = device->flush_bio;\n\t\tif (!bio)\n\t\t\treturn 0;\n\n\t\twait_for_completion(&device->flush_wait);\n\n\t\tif (bio_flagged(bio, BIO_EOPNOTSUPP)) {\n\t\t\tprintk_in_rcu(\"BTRFS: disabling barriers on dev %s\\n\",\n\t\t\t\t      rcu_str_deref(device->name));\n\t\t\tdevice->nobarriers = 1;\n\t\t} else if (!bio_flagged(bio, BIO_UPTODATE)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_dev_stat_inc_and_print(device,\n\t\t\t\tBTRFS_DEV_STAT_FLUSH_ERRS);\n\t\t}\n\n\t\t/* drop the reference from the wait == 0 run */\n\t\tbio_put(bio);\n\t\tdevice->flush_bio = NULL;\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * one reference for us, and we leave it for the\n\t * caller\n\t */\n\tdevice->flush_bio = NULL;\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 0);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_end_io = btrfs_end_empty_barrier;\n\tbio->bi_bdev = device->bdev;\n\tinit_completion(&device->flush_wait);\n\tbio->bi_private = &device->flush_wait;\n\tdevice->flush_bio = bio;\n\n\tbio_get(bio);\n\tbtrfsic_submit_bio(WRITE_FLUSH, bio);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_end_empty_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3226-3236",
    "snippet": "static void btrfs_end_empty_barrier(struct bio *bio, int err)\n{\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tset_bit(BIO_EOPNOTSUPP, &bio->bi_flags);\n\t\tclear_bit(BIO_UPTODATE, &bio->bi_flags);\n\t}\n\tif (bio->bi_private)\n\t\tcomplete(bio->bi_private);\n\tbio_put(bio);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "bio->bi_private"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2357-2383",
          "snippet": "static void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BIO_EOPNOTSUPP",
            "&bio->bi_flags"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_end_empty_barrier(struct bio *bio, int err)\n{\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tset_bit(BIO_EOPNOTSUPP, &bio->bi_flags);\n\t\tclear_bit(BIO_UPTODATE, &bio->bi_flags);\n\t}\n\tif (bio->bi_private)\n\t\tcomplete(bio->bi_private);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "write_dev_supers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3137-3220",
    "snippet": "static int write_dev_supers(struct btrfs_device *device,\n\t\t\t    struct btrfs_super_block *sb,\n\t\t\t    int do_barriers, int wait, int max_mirrors)\n{\n\tstruct buffer_head *bh;\n\tint i;\n\tint ret;\n\tint errors = 0;\n\tu32 crc;\n\tu64 bytenr;\n\n\tif (max_mirrors == 0)\n\t\tmax_mirrors = BTRFS_SUPER_MIRROR_MAX;\n\n\tfor (i = 0; i < max_mirrors; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t    device->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tif (wait) {\n\t\t\tbh = __find_get_block(device->bdev, bytenr / 4096,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terrors++;\n\n\t\t\t/* drop our reference */\n\t\t\tbrelse(bh);\n\n\t\t\t/* drop the reference from the wait == 0 run */\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbtrfs_set_super_bytenr(sb, bytenr);\n\n\t\t\tcrc = ~(u32)0;\n\t\t\tcrc = btrfs_csum_data((char *)sb +\n\t\t\t\t\t      BTRFS_CSUM_SIZE, crc,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE -\n\t\t\t\t\t      BTRFS_CSUM_SIZE);\n\t\t\tbtrfs_csum_final(crc, sb->csum);\n\n\t\t\t/*\n\t\t\t * one reference for us, and we leave it for the\n\t\t\t * caller\n\t\t\t */\n\t\t\tbh = __getblk(device->bdev, bytenr / 4096,\n\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\tprintk(KERN_ERR \"BTRFS: couldn't get super \"\n\t\t\t\t       \"buffer head for bytenr %Lu\\n\", bytenr);\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(bh->b_data, sb, BTRFS_SUPER_INFO_SIZE);\n\n\t\t\t/* one reference for submit_bh */\n\t\t\tget_bh(bh);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = btrfs_end_buffer_write_sync;\n\t\t\tbh->b_private = device;\n\t\t}\n\n\t\t/*\n\t\t * we fua the first super.  The others we allow\n\t\t * to go down lazy.\n\t\t */\n\t\tif (i == 0)\n\t\t\tret = btrfsic_submit_bh(WRITE_FUA, bh);\n\t\telse\n\t\t\tret = btrfsic_submit_bh(WRITE_SYNC, bh);\n\t\tif (ret)\n\t\t\terrors++;\n\t}\n\treturn errors < i ? 0 : -1;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_submit_bh",
          "args": [
            "WRITE_SYNC",
            "bh"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2900-2961",
          "snippet": "int btrfsic_submit_bh(int rw, struct buffer_head *bh)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn submit_bh(rw, bh);\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bh() might also be called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bh->b_bdev);\n\n\t/* Only called to write the superblock (incl. FLUSH/FUA) */\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && bh->b_size > 0) {\n\t\tu64 dev_bytenr;\n\n\t\tdev_bytenr = 4096 * bh->b_blocknr;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),\"\n\t\t\t       \" size=%zu, data=%p, bdev=%p)\\n\",\n\t\t\t       rw, (unsigned long long)bh->b_blocknr,\n\t\t\t       dev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      &bh->b_data, 1, NULL,\n\t\t\t\t\t      NULL, bh, rw);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bh->b_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t}\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n\treturn submit_bh(rw, bh);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\n\nint btrfsic_submit_bh(int rw, struct buffer_head *bh)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn submit_bh(rw, bh);\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bh() might also be called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bh->b_bdev);\n\n\t/* Only called to write the superblock (incl. FLUSH/FUA) */\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && bh->b_size > 0) {\n\t\tu64 dev_bytenr;\n\n\t\tdev_bytenr = 4096 * bh->b_blocknr;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),\"\n\t\t\t       \" size=%zu, data=%p, bdev=%p)\\n\",\n\t\t\t       rw, (unsigned long long)bh->b_blocknr,\n\t\t\t       dev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      &bh->b_data, 1, NULL,\n\t\t\t\t\t      NULL, bh, rw);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bh->b_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t}\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n\treturn submit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data",
            "sb",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: couldn't get super \"\n\t\t\t\t       \"buffer head for bytenr %Lu\\n\"",
            "bytenr"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "device->bdev",
            "bytenr / 4096",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "sb->csum"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "(char *)sb +\n\t\t\t\t\t      BTRFS_CSUM_SIZE",
            "crc",
            "BTRFS_SUPER_INFO_SIZE -\n\t\t\t\t\t      BTRFS_CSUM_SIZE"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_bytenr",
          "args": [
            "sb",
            "bytenr"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "device->bdev",
            "bytenr / 4096",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "i"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int write_dev_supers(struct btrfs_device *device,\n\t\t\t    struct btrfs_super_block *sb,\n\t\t\t    int do_barriers, int wait, int max_mirrors)\n{\n\tstruct buffer_head *bh;\n\tint i;\n\tint ret;\n\tint errors = 0;\n\tu32 crc;\n\tu64 bytenr;\n\n\tif (max_mirrors == 0)\n\t\tmax_mirrors = BTRFS_SUPER_MIRROR_MAX;\n\n\tfor (i = 0; i < max_mirrors; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t    device->commit_total_bytes)\n\t\t\tbreak;\n\n\t\tif (wait) {\n\t\t\tbh = __find_get_block(device->bdev, bytenr / 4096,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terrors++;\n\n\t\t\t/* drop our reference */\n\t\t\tbrelse(bh);\n\n\t\t\t/* drop the reference from the wait == 0 run */\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbtrfs_set_super_bytenr(sb, bytenr);\n\n\t\t\tcrc = ~(u32)0;\n\t\t\tcrc = btrfs_csum_data((char *)sb +\n\t\t\t\t\t      BTRFS_CSUM_SIZE, crc,\n\t\t\t\t\t      BTRFS_SUPER_INFO_SIZE -\n\t\t\t\t\t      BTRFS_CSUM_SIZE);\n\t\t\tbtrfs_csum_final(crc, sb->csum);\n\n\t\t\t/*\n\t\t\t * one reference for us, and we leave it for the\n\t\t\t * caller\n\t\t\t */\n\t\t\tbh = __getblk(device->bdev, bytenr / 4096,\n\t\t\t\t      BTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh) {\n\t\t\t\tprintk(KERN_ERR \"BTRFS: couldn't get super \"\n\t\t\t\t       \"buffer head for bytenr %Lu\\n\", bytenr);\n\t\t\t\terrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(bh->b_data, sb, BTRFS_SUPER_INFO_SIZE);\n\n\t\t\t/* one reference for submit_bh */\n\t\t\tget_bh(bh);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = btrfs_end_buffer_write_sync;\n\t\t\tbh->b_private = device;\n\t\t}\n\n\t\t/*\n\t\t * we fua the first super.  The others we allow\n\t\t * to go down lazy.\n\t\t */\n\t\tif (i == 0)\n\t\t\tret = btrfsic_submit_bh(WRITE_FUA, bh);\n\t\telse\n\t\t\tret = btrfsic_submit_bh(WRITE_SYNC, bh);\n\t\tif (ret)\n\t\t\terrors++;\n\t}\n\treturn errors < i ? 0 : -1;\n}"
  },
  {
    "function_name": "btrfs_read_dev_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3084-3124",
    "snippet": "struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_magic",
          "args": [
            "super"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "super"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "bdev",
            "bytenr / 4096",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "i"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstruct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}"
  },
  {
    "function_name": "btrfs_end_buffer_write_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "3063-3082",
    "snippet": "static void btrfs_end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tstruct btrfs_device *device = (struct btrfs_device *)\n\t\t\tbh->b_private;\n\n\t\tprintk_ratelimited_in_rcu(KERN_WARNING \"BTRFS: lost page write due to \"\n\t\t\t\t\t  \"I/O error on %s\\n\",\n\t\t\t\t\t  rcu_str_deref(device->name));\n\t\t/* note, we dont' set_buffer_write_io_error because we have\n\t\t * our own ways of dealing with the IO errors\n\t\t */\n\t\tclear_buffer_uptodate(bh);\n\t\tbtrfs_dev_stat_inc_and_print(device, BTRFS_DEV_STAT_WRITE_ERRS);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "device",
            "BTRFS_DEV_STAT_WRITE_ERRS"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_WARNING \"BTRFS: lost page write due to \"\n\t\t\t\t\t  \"I/O error on %s\\n\"",
            "rcu_str_deref(device->name)"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tstruct btrfs_device *device = (struct btrfs_device *)\n\t\t\tbh->b_private;\n\n\t\tprintk_ratelimited_in_rcu(KERN_WARNING \"BTRFS: lost page write due to \"\n\t\t\t\t\t  \"I/O error on %s\\n\",\n\t\t\t\t\t  rcu_str_deref(device->name));\n\t\t/* note, we dont' set_buffer_write_io_error because we have\n\t\t * our own ways of dealing with the IO errors\n\t\t */\n\t\tclear_buffer_uptodate(bh);\n\t\tbtrfs_dev_stat_inc_and_print(device, BTRFS_DEV_STAT_WRITE_ERRS);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "open_ctree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2149-3061",
    "snippet": "int open_ctree(struct super_block *sb,\n\t       struct btrfs_fs_devices *fs_devices,\n\t       char *options)\n{\n\tu32 sectorsize;\n\tu32 nodesize;\n\tu32 stripesize;\n\tu64 generation;\n\tu64 features;\n\tstruct btrfs_key location;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *tree_root;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_root *csum_root;\n\tstruct btrfs_root *chunk_root;\n\tstruct btrfs_root *dev_root;\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct btrfs_root *log_tree_root;\n\tint ret;\n\tint err = -EINVAL;\n\tint num_backups_tried = 0;\n\tint backup_index = 0;\n\tint max_active;\n\tint flags = WQ_MEM_RECLAIM | WQ_FREEZABLE | WQ_UNBOUND;\n\tbool create_uuid_tree;\n\tbool check_uuid_tree;\n\n\ttree_root = fs_info->tree_root = btrfs_alloc_root(fs_info);\n\tchunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);\n\tif (!tree_root || !chunk_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = init_srcu_struct(&fs_info->subvol_srcu);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail;\n\t}\n\n\tret = setup_bdi(fs_info, &fs_info->bdi);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_srcu;\n\t}\n\n\tret = percpu_counter_init(&fs_info->dirty_metadata_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_bdi;\n\t}\n\tfs_info->dirty_metadata_batch = PAGE_CACHE_SIZE *\n\t\t\t\t\t(1 + ilog2(nr_cpu_ids));\n\n\tret = percpu_counter_init(&fs_info->delalloc_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_dirty_metadata_bytes;\n\t}\n\n\tret = percpu_counter_init(&fs_info->bio_counter, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_delalloc_bytes;\n\t}\n\n\tfs_info->btree_inode = new_inode(sb);\n\tif (!fs_info->btree_inode) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_bio_counter;\n\t}\n\n\tmapping_set_gfp_mask(fs_info->btree_inode->i_mapping, GFP_NOFS);\n\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&fs_info->trans_list);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->delayed_iputs);\n\tINIT_LIST_HEAD(&fs_info->delalloc_roots);\n\tINIT_LIST_HEAD(&fs_info->caching_block_groups);\n\tspin_lock_init(&fs_info->delalloc_root_lock);\n\tspin_lock_init(&fs_info->trans_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->delayed_iput_lock);\n\tspin_lock_init(&fs_info->defrag_inodes_lock);\n\tspin_lock_init(&fs_info->free_chunk_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->unused_bgs_lock);\n\tmutex_init(&fs_info->unused_bg_unpin_mutex);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tmutex_init(&fs_info->reloc_mutex);\n\tmutex_init(&fs_info->delalloc_root_mutex);\n\tseqlock_init(&fs_info->profiles_lock);\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tINIT_LIST_HEAD(&fs_info->dirty_cowonly_roots);\n\tINIT_LIST_HEAD(&fs_info->space_info);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_LIST_HEAD(&fs_info->unused_bgs);\n\tbtrfs_mapping_init(&fs_info->mapping_tree);\n\tbtrfs_init_block_rsv(&fs_info->global_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_GLOBAL);\n\tbtrfs_init_block_rsv(&fs_info->delalloc_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELALLOC);\n\tbtrfs_init_block_rsv(&fs_info->trans_block_rsv, BTRFS_BLOCK_RSV_TRANS);\n\tbtrfs_init_block_rsv(&fs_info->chunk_block_rsv, BTRFS_BLOCK_RSV_CHUNK);\n\tbtrfs_init_block_rsv(&fs_info->empty_block_rsv, BTRFS_BLOCK_RSV_EMPTY);\n\tbtrfs_init_block_rsv(&fs_info->delayed_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELOPS);\n\tatomic_set(&fs_info->nr_async_submits, 0);\n\tatomic_set(&fs_info->async_delalloc_pages, 0);\n\tatomic_set(&fs_info->async_submit_draining, 0);\n\tatomic_set(&fs_info->nr_async_bios, 0);\n\tatomic_set(&fs_info->defrag_running, 0);\n\tatomic_set(&fs_info->qgroup_op_seq, 0);\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tfs_info->sb = sb;\n\tfs_info->max_inline = BTRFS_DEFAULT_MAX_INLINE;\n\tfs_info->metadata_ratio = 0;\n\tfs_info->defrag_inodes = RB_ROOT;\n\tfs_info->free_chunk_space = 0;\n\tfs_info->tree_mod_log = RB_ROOT;\n\tfs_info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\tfs_info->avg_delayed_ref_runtime = div64_u64(NSEC_PER_SEC, 64);\n\t/* readahead state */\n\tINIT_RADIX_TREE(&fs_info->reada_tree, GFP_NOFS & ~__GFP_WAIT);\n\tspin_lock_init(&fs_info->reada_lock);\n\n\tfs_info->thread_pool_size = min_t(unsigned long,\n\t\t\t\t\t  num_online_cpus() + 2, 8);\n\n\tINIT_LIST_HEAD(&fs_info->ordered_roots);\n\tspin_lock_init(&fs_info->ordered_root_lock);\n\tfs_info->delayed_root = kmalloc(sizeof(struct btrfs_delayed_root),\n\t\t\t\t\tGFP_NOFS);\n\tif (!fs_info->delayed_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_iput;\n\t}\n\tbtrfs_init_delayed_root(fs_info->delayed_root);\n\n\tmutex_init(&fs_info->scrub_lock);\n\tatomic_set(&fs_info->scrubs_running, 0);\n\tatomic_set(&fs_info->scrub_pause_req, 0);\n\tatomic_set(&fs_info->scrubs_paused, 0);\n\tatomic_set(&fs_info->scrub_cancel_req, 0);\n\tinit_waitqueue_head(&fs_info->replace_wait);\n\tinit_waitqueue_head(&fs_info->scrub_pause_wait);\n\tfs_info->scrub_workers_refcnt = 0;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tfs_info->check_integrity_print_mask = 0;\n#endif\n\n\tspin_lock_init(&fs_info->balance_lock);\n\tmutex_init(&fs_info->balance_mutex);\n\tatomic_set(&fs_info->balance_running, 0);\n\tatomic_set(&fs_info->balance_pause_req, 0);\n\tatomic_set(&fs_info->balance_cancel_req, 0);\n\tfs_info->balance_ctl = NULL;\n\tinit_waitqueue_head(&fs_info->balance_wait_q);\n\tbtrfs_init_async_reclaim_work(&fs_info->async_reclaim_work);\n\n\tsb->s_blocksize = 4096;\n\tsb->s_blocksize_bits = blksize_bits(4096);\n\tsb->s_bdi = &fs_info->bdi;\n\n\tfs_info->btree_inode->i_ino = BTRFS_BTREE_INODE_OBJECTID;\n\tset_nlink(fs_info->btree_inode, 1);\n\t/*\n\t * we set the i_size on the btree inode to the max possible int.\n\t * the real end of the address space is determined by all of\n\t * the devices in the system\n\t */\n\tfs_info->btree_inode->i_size = OFFSET_MAX;\n\tfs_info->btree_inode->i_mapping->a_ops = &btree_aops;\n\n\tRB_CLEAR_NODE(&BTRFS_I(fs_info->btree_inode)->rb_node);\n\textent_io_tree_init(&BTRFS_I(fs_info->btree_inode)->io_tree,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tBTRFS_I(fs_info->btree_inode)->io_tree.track_uptodate = 0;\n\textent_map_tree_init(&BTRFS_I(fs_info->btree_inode)->extent_tree);\n\n\tBTRFS_I(fs_info->btree_inode)->io_tree.ops = &btree_extent_io_ops;\n\n\tBTRFS_I(fs_info->btree_inode)->root = tree_root;\n\tmemset(&BTRFS_I(fs_info->btree_inode)->location, 0,\n\t       sizeof(struct btrfs_key));\n\tset_bit(BTRFS_INODE_DUMMY,\n\t\t&BTRFS_I(fs_info->btree_inode)->runtime_flags);\n\tbtrfs_insert_inode_hash(fs_info->btree_inode);\n\n\tspin_lock_init(&fs_info->block_group_cache_lock);\n\tfs_info->block_group_cache_tree = RB_ROOT;\n\tfs_info->first_logical_byte = (u64)-1;\n\n\textent_io_tree_init(&fs_info->freed_extents[0],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\textent_io_tree_init(&fs_info->freed_extents[1],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\tfs_info->do_barriers = 1;\n\n\n\tmutex_init(&fs_info->ordered_operations_mutex);\n\tmutex_init(&fs_info->ordered_extent_flush_mutex);\n\tmutex_init(&fs_info->tree_log_mutex);\n\tmutex_init(&fs_info->chunk_mutex);\n\tmutex_init(&fs_info->transaction_kthread_mutex);\n\tmutex_init(&fs_info->cleaner_mutex);\n\tmutex_init(&fs_info->volume_mutex);\n\tinit_rwsem(&fs_info->commit_root_sem);\n\tinit_rwsem(&fs_info->cleanup_work_sem);\n\tinit_rwsem(&fs_info->subvol_sem);\n\tsema_init(&fs_info->uuid_tree_rescan_sem, 1);\n\tfs_info->dev_replace.lock_owner = 0;\n\tatomic_set(&fs_info->dev_replace.nesting_level, 0);\n\tmutex_init(&fs_info->dev_replace.lock_finishing_cancel_unmount);\n\tmutex_init(&fs_info->dev_replace.lock_management_lock);\n\tmutex_init(&fs_info->dev_replace.lock);\n\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_op_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tfs_info->qgroup_seq = 1;\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tfs_info->qgroup_ulist = NULL;\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\n\tbtrfs_init_free_cluster(&fs_info->meta_alloc_cluster);\n\tbtrfs_init_free_cluster(&fs_info->data_alloc_cluster);\n\n\tinit_waitqueue_head(&fs_info->transaction_throttle);\n\tinit_waitqueue_head(&fs_info->transaction_wait);\n\tinit_waitqueue_head(&fs_info->transaction_blocked_wait);\n\tinit_waitqueue_head(&fs_info->async_submit_wait);\n\n\tINIT_LIST_HEAD(&fs_info->pinned_chunks);\n\n\tret = btrfs_alloc_stripe_hash_table(fs_info);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\t__setup_root(4096, 4096, 4096, tree_root,\n\t\t     fs_info, BTRFS_ROOT_TREE_OBJECTID);\n\n\tinvalidate_bdev(fs_devices->latest_bdev);\n\n\t/*\n\t * Read super block and check the signature bytes only\n\t */\n\tbh = btrfs_read_dev_super(fs_devices->latest_bdev);\n\tif (!bh) {\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * We want to check superblock checksum, the type is stored inside.\n\t * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).\n\t */\n\tif (btrfs_check_super_csum(bh->b_data)) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock checksum mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * super_copy is zeroed at allocation time and we never touch the\n\t * following bytes up to INFO_SIZE, the checksum is calculated from\n\t * the whole block of INFO_SIZE\n\t */\n\tmemcpy(fs_info->super_copy, bh->b_data, sizeof(*fs_info->super_copy));\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_for_commit));\n\tbrelse(bh);\n\n\tmemcpy(fs_info->fsid, fs_info->super_copy->fsid, BTRFS_FSID_SIZE);\n\n\tret = btrfs_check_super_valid(fs_info, sb->s_flags & MS_RDONLY);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock contains fatal errors\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\tgoto fail_alloc;\n\n\t/* check FS state, whether FS is broken. */\n\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_ERROR)\n\t\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n\n\t/*\n\t * run through our array of backup supers and setup\n\t * our ring pointer to the oldest one\n\t */\n\tgeneration = btrfs_super_generation(disk_super);\n\tfind_oldest_super_backup(fs_info, generation);\n\n\t/*\n\t * In the long term, we'll store the compression type in the super\n\t * block, and it'll be used for per file compression control.\n\t */\n\tfs_info->compress_type = BTRFS_COMPRESS_ZLIB;\n\n\tret = btrfs_parse_options(tree_root, options);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super) &\n\t\t~BTRFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because of \"\n\t\t       \"unsupported optional features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Leafsize and nodesize were always equal, this is only a sanity check.\n\t */\n\tif (le32_to_cpu(disk_super->__unused_leafsize) !=\n\t    btrfs_super_nodesize(disk_super)) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksizes don't match.  node %d leaf %d\\n\",\n\t\t       btrfs_super_nodesize(disk_super),\n\t\t       le32_to_cpu(disk_super->__unused_leafsize));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\tif (btrfs_super_nodesize(disk_super) > BTRFS_MAX_METADATA_BLOCKSIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksize (%d) was too large\\n\",\n\t\t       btrfs_super_nodesize(disk_super));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tfeatures |= BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF;\n\tif (tree_root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO;\n\n\tif (features & BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA)\n\t\tprintk(KERN_INFO \"BTRFS: has skinny extents\\n\");\n\n\t/*\n\t * flag our filesystem as having big metadata blocks if\n\t * they are bigger than the page size\n\t */\n\tif (btrfs_super_nodesize(disk_super) > PAGE_CACHE_SIZE) {\n\t\tif (!(features & BTRFS_FEATURE_INCOMPAT_BIG_METADATA))\n\t\t\tprintk(KERN_INFO \"BTRFS: flagging fs with big metadata feature\\n\");\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_BIG_METADATA;\n\t}\n\n\tnodesize = btrfs_super_nodesize(disk_super);\n\tsectorsize = btrfs_super_sectorsize(disk_super);\n\tstripesize = btrfs_super_stripesize(disk_super);\n\tfs_info->dirty_metadata_batch = nodesize * (1 + ilog2(nr_cpu_ids));\n\tfs_info->delalloc_batch = sectorsize * 512 * (1 + ilog2(nr_cpu_ids));\n\n\t/*\n\t * mixed block groups end up with duplicate but slightly offset\n\t * extent buffers for the same range.  It leads to corruptions\n\t */\n\tif ((features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS) &&\n\t    (sectorsize != nodesize)) {\n\t\tprintk(KERN_ERR \"BTRFS: unequal leaf/node/sector sizes \"\n\t\t\t\t\"are not allowed for mixed block groups on %s\\n\",\n\t\t\t\tsb->s_id);\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Needn't use the lock because there is no other task which will\n\t * update the flag.\n\t */\n\tbtrfs_set_super_incompat_flags(disk_super, features);\n\n\tfeatures = btrfs_super_compat_ro_flags(disk_super) &\n\t\t~BTRFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported option features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tmax_active = fs_info->thread_pool_size;\n\n\tfs_info->workers =\n\t\tbtrfs_alloc_workqueue(\"worker\", flags | WQ_HIGHPRI,\n\t\t\t\t      max_active, 16);\n\n\tfs_info->delalloc_workers =\n\t\tbtrfs_alloc_workqueue(\"delalloc\", flags, max_active, 2);\n\n\tfs_info->flush_workers =\n\t\tbtrfs_alloc_workqueue(\"flush_delalloc\", flags, max_active, 0);\n\n\tfs_info->caching_workers =\n\t\tbtrfs_alloc_workqueue(\"cache\", flags, max_active, 0);\n\n\t/*\n\t * a higher idle thresh on the submit workers makes it much more\n\t * likely that bios will be send down in a sane order to the\n\t * devices\n\t */\n\tfs_info->submit_workers =\n\t\tbtrfs_alloc_workqueue(\"submit\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 64);\n\n\tfs_info->fixup_workers =\n\t\tbtrfs_alloc_workqueue(\"fixup\", flags, 1, 0);\n\n\t/*\n\t * endios are largely parallel and should have a very\n\t * low idle thresh\n\t */\n\tfs_info->endio_workers =\n\t\tbtrfs_alloc_workqueue(\"endio\", flags, max_active, 4);\n\tfs_info->endio_meta_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta\", flags, max_active, 4);\n\tfs_info->endio_meta_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta-write\", flags, max_active, 2);\n\tfs_info->endio_raid56_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-raid56\", flags, max_active, 4);\n\tfs_info->endio_repair_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-repair\", flags, 1, 0);\n\tfs_info->rmw_workers =\n\t\tbtrfs_alloc_workqueue(\"rmw\", flags, max_active, 2);\n\tfs_info->endio_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-write\", flags, max_active, 2);\n\tfs_info->endio_freespace_worker =\n\t\tbtrfs_alloc_workqueue(\"freespace-write\", flags, max_active, 0);\n\tfs_info->delayed_workers =\n\t\tbtrfs_alloc_workqueue(\"delayed-meta\", flags, max_active, 0);\n\tfs_info->readahead_workers =\n\t\tbtrfs_alloc_workqueue(\"readahead\", flags, max_active, 2);\n\tfs_info->qgroup_rescan_workers =\n\t\tbtrfs_alloc_workqueue(\"qgroup-rescan\", flags, 1, 0);\n\tfs_info->extent_workers =\n\t\tbtrfs_alloc_workqueue(\"extent-refs\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 8);\n\n\tif (!(fs_info->workers && fs_info->delalloc_workers &&\n\t      fs_info->submit_workers && fs_info->flush_workers &&\n\t      fs_info->endio_workers && fs_info->endio_meta_workers &&\n\t      fs_info->endio_meta_write_workers &&\n\t      fs_info->endio_repair_workers &&\n\t      fs_info->endio_write_workers && fs_info->endio_raid56_workers &&\n\t      fs_info->endio_freespace_worker && fs_info->rmw_workers &&\n\t      fs_info->caching_workers && fs_info->readahead_workers &&\n\t      fs_info->fixup_workers && fs_info->delayed_workers &&\n\t      fs_info->extent_workers &&\n\t      fs_info->qgroup_rescan_workers)) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tfs_info->bdi.ra_pages *= btrfs_super_num_devices(disk_super);\n\tfs_info->bdi.ra_pages = max(fs_info->bdi.ra_pages,\n\t\t\t\t    4 * 1024 * 1024 / PAGE_CACHE_SIZE);\n\n\ttree_root->nodesize = nodesize;\n\ttree_root->sectorsize = sectorsize;\n\ttree_root->stripesize = stripesize;\n\n\tsb->s_blocksize = sectorsize;\n\tsb->s_blocksize_bits = blksize_bits(sectorsize);\n\n\tif (btrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\tprintk(KERN_ERR \"BTRFS: valid FS not found on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tif (sectorsize != PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: incompatible sector size (%lu) \"\n\t\t       \"found on %s\\n\", (unsigned long)sectorsize, sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\tret = btrfs_read_sys_array(tree_root);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read the system \"\n\t\t       \"array on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tgeneration = btrfs_super_chunk_root_generation(disk_super);\n\n\t__setup_root(nodesize, sectorsize, stripesize, chunk_root,\n\t\t     fs_info, BTRFS_CHUNK_TREE_OBJECTID);\n\n\tchunk_root->node = read_tree_block(chunk_root,\n\t\t\t\t\t   btrfs_super_chunk_root(disk_super),\n\t\t\t\t\t   generation);\n\tif (!chunk_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &chunk_root->node->bflags)) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk root on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\tbtrfs_set_root_node(&chunk_root->root_item, chunk_root->node);\n\tchunk_root->commit_root = btrfs_root_node(chunk_root);\n\n\tread_extent_buffer(chunk_root->node, fs_info->chunk_tree_uuid,\n\t   btrfs_header_chunk_tree_uuid(chunk_root->node), BTRFS_UUID_SIZE);\n\n\tret = btrfs_read_chunk_tree(chunk_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk tree on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\n\t/*\n\t * keep the device that is marked to be the target device for the\n\t * dev_replace procedure\n\t */\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 0);\n\n\tif (!fs_devices->latest_bdev) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read devices on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\nretry_root_backup:\n\tgeneration = btrfs_super_generation(disk_super);\n\n\ttree_root->node = read_tree_block(tree_root,\n\t\t\t\t\t  btrfs_super_root(disk_super),\n\t\t\t\t\t  generation);\n\tif (!tree_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &tree_root->node->bflags)) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to read tree root on %s\\n\",\n\t\t       sb->s_id);\n\n\t\tgoto recovery_tree_root;\n\t}\n\n\tbtrfs_set_root_node(&tree_root->root_item, tree_root->node);\n\ttree_root->commit_root = btrfs_root_node(tree_root);\n\tbtrfs_set_root_refs(&tree_root->root_item, 1);\n\n\tlocation.objectid = BTRFS_EXTENT_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\textent_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(extent_root)) {\n\t\tret = PTR_ERR(extent_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &extent_root->state);\n\tfs_info->extent_root = extent_root;\n\n\tlocation.objectid = BTRFS_DEV_TREE_OBJECTID;\n\tdev_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(dev_root)) {\n\t\tret = PTR_ERR(dev_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &dev_root->state);\n\tfs_info->dev_root = dev_root;\n\tbtrfs_init_devices_late(fs_info);\n\n\tlocation.objectid = BTRFS_CSUM_TREE_OBJECTID;\n\tcsum_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(csum_root)) {\n\t\tret = PTR_ERR(csum_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &csum_root->state);\n\tfs_info->csum_root = csum_root;\n\n\tlocation.objectid = BTRFS_QUOTA_TREE_OBJECTID;\n\tquota_root = btrfs_read_tree_root(tree_root, &location);\n\tif (!IS_ERR(quota_root)) {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &quota_root->state);\n\t\tfs_info->quota_enabled = 1;\n\t\tfs_info->pending_quota_state = 1;\n\t\tfs_info->quota_root = quota_root;\n\t}\n\n\tlocation.objectid = BTRFS_UUID_TREE_OBJECTID;\n\tuuid_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tif (ret != -ENOENT)\n\t\t\tgoto recovery_tree_root;\n\t\tcreate_uuid_tree = true;\n\t\tcheck_uuid_tree = false;\n\t} else {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &uuid_root->state);\n\t\tfs_info->uuid_root = uuid_root;\n\t\tcreate_uuid_tree = false;\n\t\tcheck_uuid_tree =\n\t\t    generation != btrfs_super_uuid_tree_generation(disk_super);\n\t}\n\n\tfs_info->generation = generation;\n\tfs_info->last_trans_committed = generation;\n\n\tret = btrfs_recover_balance(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to recover balance\\n\");\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_stats(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to init dev_stats: %d\\n\",\n\t\t       ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_replace(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init dev_replace: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 1);\n\n\tret = btrfs_sysfs_add_one(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init sysfs interface: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_space_info(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to initial space info: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\n\tret = btrfs_read_block_groups(extent_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to read block groups: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\tfs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\tif (fs_info->fs_devices->missing_devices >\n\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tprintk(KERN_WARNING \"BTRFS: \"\n\t\t\t\"too many missing devices, writeable mount is not allowed\\n\");\n\t\tgoto fail_sysfs;\n\t}\n\n\tfs_info->cleaner_kthread = kthread_run(cleaner_kthread, tree_root,\n\t\t\t\t\t       \"btrfs-cleaner\");\n\tif (IS_ERR(fs_info->cleaner_kthread))\n\t\tgoto fail_sysfs;\n\n\tfs_info->transaction_kthread = kthread_run(transaction_kthread,\n\t\t\t\t\t\t   tree_root,\n\t\t\t\t\t\t   \"btrfs-transaction\");\n\tif (IS_ERR(fs_info->transaction_kthread))\n\t\tgoto fail_cleaner;\n\n\tif (!btrfs_test_opt(tree_root, SSD) &&\n\t    !btrfs_test_opt(tree_root, NOSSD) &&\n\t    !fs_info->fs_devices->rotating) {\n\t\tprintk(KERN_INFO \"BTRFS: detected SSD devices, enabling SSD \"\n\t\t       \"mode\\n\");\n\t\tbtrfs_set_opt(fs_info->mount_opt, SSD);\n\t}\n\n\t/*\n\t * Mount does not set all options immediatelly, we can do it now and do\n\t * not have to wait for transaction commit\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(tree_root, CHECK_INTEGRITY)) {\n\t\tret = btrfsic_mount(tree_root, fs_devices,\n\t\t\t\t    btrfs_test_opt(tree_root,\n\t\t\t\t\tCHECK_INTEGRITY_INCLUDING_EXTENT_DATA) ?\n\t\t\t\t    1 : 0,\n\t\t\t\t    fs_info->check_integrity_print_mask);\n\t\tif (ret)\n\t\t\tprintk(KERN_WARNING \"BTRFS: failed to initialize\"\n\t\t\t       \" integrity check module %s\\n\", sb->s_id);\n\t}\n#endif\n\tret = btrfs_read_qgroup_config(fs_info);\n\tif (ret)\n\t\tgoto fail_trans_kthread;\n\n\t/* do not make disk changes in broken FS */\n\tif (btrfs_super_log_root(disk_super) != 0) {\n\t\tu64 bytenr = btrfs_super_log_root(disk_super);\n\n\t\tif (fs_devices->rw_devices == 0) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: log replay required \"\n\t\t\t       \"on RO media\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tlog_tree_root = btrfs_alloc_root(fs_info);\n\t\tif (!log_tree_root) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\t__setup_root(nodesize, sectorsize, stripesize,\n\t\t\t     log_tree_root, fs_info, BTRFS_TREE_LOG_OBJECTID);\n\n\t\tlog_tree_root->node = read_tree_block(tree_root, bytenr,\n\t\t\t\t\t\t      generation + 1);\n\t\tif (!log_tree_root->node ||\n\t\t    !extent_buffer_uptodate(log_tree_root->node)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: failed to read log tree\\n\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t\t/* returns with log_tree_root freed on success */\n\t\tret = btrfs_recover_log_trees(log_tree_root);\n\t\tif (ret) {\n\t\t\tbtrfs_error(tree_root->fs_info, ret,\n\t\t\t\t    \"Failed to recover log tree\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tret = btrfs_commit_super(tree_root);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tret = btrfs_find_orphan_roots(tree_root);\n\tif (ret)\n\t\tgoto fail_qgroup;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto fail_qgroup;\n\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(tree_root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"BTRFS: failed to recover relocation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tlocation.objectid = BTRFS_FS_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tfs_info->fs_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(fs_info->fs_root)) {\n\t\terr = PTR_ERR(fs_info->fs_root);\n\t\tgoto fail_qgroup;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_read(&fs_info->cleanup_work_sem);\n\tif ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||\n\t    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {\n\t\tup_read(&fs_info->cleanup_work_sem);\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\tup_read(&fs_info->cleanup_work_sem);\n\n\tret = btrfs_resume_balance_async(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to resume balance\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_resume_dev_replace_async(fs_info);\n\tif (ret) {\n\t\tpr_warn(\"BTRFS: failed to resume dev_replace\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_qgroup_rescan_resume(fs_info);\n\n\tif (create_uuid_tree) {\n\t\tpr_info(\"BTRFS: creating UUID tree\\n\");\n\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to create the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else if (check_uuid_tree ||\n\t\t   btrfs_test_opt(tree_root, RESCAN_UUID_TREE)) {\n\t\tpr_info(\"BTRFS: checking UUID tree\\n\");\n\t\tret = btrfs_check_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to check the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfs_info->update_uuid_tree_gen = 1;\n\t}\n\n\tfs_info->open = 1;\n\n\treturn 0;\n\nfail_qgroup:\n\tbtrfs_free_qgroup_config(fs_info);\nfail_trans_kthread:\n\tkthread_stop(fs_info->transaction_kthread);\n\tbtrfs_cleanup_transaction(fs_info->tree_root);\n\tbtrfs_free_fs_roots(fs_info);\nfail_cleaner:\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\t/*\n\t * make sure we're done with the btree inode before we stop our\n\t * kthreads\n\t */\n\tfilemap_write_and_wait(fs_info->btree_inode->i_mapping);\n\nfail_sysfs:\n\tbtrfs_sysfs_remove_one(fs_info);\n\nfail_block_groups:\n\tbtrfs_put_block_group_cache(fs_info);\n\tbtrfs_free_block_groups(fs_info);\n\nfail_tree_roots:\n\tfree_root_pointers(fs_info, 1);\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\nfail_sb_buffer:\n\tbtrfs_stop_all_workers(fs_info);\nfail_alloc:\nfail_iput:\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tiput(fs_info->btree_inode);\nfail_bio_counter:\n\tpercpu_counter_destroy(&fs_info->bio_counter);\nfail_delalloc_bytes:\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\nfail_dirty_metadata_bytes:\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\nfail_bdi:\n\tbdi_destroy(&fs_info->bdi);\nfail_srcu:\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\nfail:\n\tbtrfs_free_stripe_hash_table(fs_info);\n\tbtrfs_close_devices(fs_info->fs_devices);\n\treturn err;\n\nrecovery_tree_root:\n\tif (!btrfs_test_opt(tree_root, RECOVERY))\n\t\tgoto fail_tree_roots;\n\n\tfree_root_pointers(fs_info, 0);\n\n\t/* don't use the log in recovery mode, it won't be valid */\n\tbtrfs_set_super_log_root(disk_super, 0);\n\n\t/* we can't trust the free space cache either */\n\tbtrfs_set_opt(fs_info->mount_opt, CLEAR_CACHE);\n\n\tret = next_root_backup(fs_info, fs_info->super_copy,\n\t\t\t       &num_backups_tried, &backup_index);\n\tif (ret == -1)\n\t\tgoto fail_block_groups;\n\tgoto retry_root_backup;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct extent_io_ops btree_extent_io_ops;",
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);",
      "static const struct address_space_operations btree_aops = {\n\t.readpage\t= btree_readpage,\n\t.writepages\t= btree_writepages,\n\t.releasepage\t= btree_releasepage,\n\t.invalidatepage = btree_invalidatepage,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= btree_migratepage,\n#endif\n\t.set_page_dirty = btree_set_page_dirty,\n};",
      "static struct extent_io_ops btree_extent_io_ops = {\n\t.readpage_end_io_hook = btree_readpage_end_io_hook,\n\t.readpage_io_failed_hook = btree_io_failed_hook,\n\t.submit_bio_hook = btree_submit_bio_hook,\n\t/* note we're sharing with inode.c for the merge bio hook */\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_root_backup",
          "args": [
            "fs_info",
            "fs_info->super_copy",
            "&num_backups_tried",
            "&backup_index"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "next_root_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2021-2063",
          "snippet": "static noinline int next_root_backup(struct btrfs_fs_info *info,\n\t\t\t\t     struct btrfs_super_block *super,\n\t\t\t\t     int *num_backups_tried, int *backup_index)\n{\n\tstruct btrfs_root_backup *root_backup;\n\tint newest = *backup_index;\n\n\tif (*num_backups_tried == 0) {\n\t\tu64 gen = btrfs_super_generation(super);\n\n\t\tnewest = find_newest_super_backup(info, gen);\n\t\tif (newest == -1)\n\t\t\treturn -1;\n\n\t\t*backup_index = newest;\n\t\t*num_backups_tried = 1;\n\t} else if (*num_backups_tried == BTRFS_NUM_BACKUP_ROOTS) {\n\t\t/* we've tried all the backups, all done */\n\t\treturn -1;\n\t} else {\n\t\t/* jump to the next oldest backup */\n\t\tnewest = (*backup_index + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\t\tBTRFS_NUM_BACKUP_ROOTS;\n\t\t*backup_index = newest;\n\t\t*num_backups_tried += 1;\n\t}\n\troot_backup = super->super_roots + newest;\n\n\tbtrfs_set_super_generation(super,\n\t\t\t\t   btrfs_backup_tree_root_gen(root_backup));\n\tbtrfs_set_super_root(super, btrfs_backup_tree_root(root_backup));\n\tbtrfs_set_super_root_level(super,\n\t\t\t\t   btrfs_backup_tree_root_level(root_backup));\n\tbtrfs_set_super_bytes_used(super, btrfs_backup_bytes_used(root_backup));\n\n\t/*\n\t * fixme: the total bytes and num_devices need to match or we should\n\t * need a fsck\n\t */\n\tbtrfs_set_super_total_bytes(super, btrfs_backup_total_bytes(root_backup));\n\tbtrfs_set_super_num_devices(super, btrfs_backup_num_devices(root_backup));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic noinline int next_root_backup(struct btrfs_fs_info *info,\n\t\t\t\t     struct btrfs_super_block *super,\n\t\t\t\t     int *num_backups_tried, int *backup_index)\n{\n\tstruct btrfs_root_backup *root_backup;\n\tint newest = *backup_index;\n\n\tif (*num_backups_tried == 0) {\n\t\tu64 gen = btrfs_super_generation(super);\n\n\t\tnewest = find_newest_super_backup(info, gen);\n\t\tif (newest == -1)\n\t\t\treturn -1;\n\n\t\t*backup_index = newest;\n\t\t*num_backups_tried = 1;\n\t} else if (*num_backups_tried == BTRFS_NUM_BACKUP_ROOTS) {\n\t\t/* we've tried all the backups, all done */\n\t\treturn -1;\n\t} else {\n\t\t/* jump to the next oldest backup */\n\t\tnewest = (*backup_index + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\t\tBTRFS_NUM_BACKUP_ROOTS;\n\t\t*backup_index = newest;\n\t\t*num_backups_tried += 1;\n\t}\n\troot_backup = super->super_roots + newest;\n\n\tbtrfs_set_super_generation(super,\n\t\t\t\t   btrfs_backup_tree_root_gen(root_backup));\n\tbtrfs_set_super_root(super, btrfs_backup_tree_root(root_backup));\n\tbtrfs_set_super_root_level(super,\n\t\t\t\t   btrfs_backup_tree_root_level(root_backup));\n\tbtrfs_set_super_bytes_used(super, btrfs_backup_bytes_used(root_backup));\n\n\t/*\n\t * fixme: the total bytes and num_devices need to match or we should\n\t * need a fsck\n\t */\n\tbtrfs_set_super_total_bytes(super, btrfs_backup_total_bytes(root_backup));\n\tbtrfs_set_super_num_devices(super, btrfs_backup_num_devices(root_backup));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "fs_info->mount_opt",
            "CLEAR_CACHE"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_log_root",
          "args": [
            "disk_super",
            "0"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_root_pointers",
          "args": [
            "fs_info",
            "0"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "free_root_pointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2099-2110",
          "snippet": "static void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "RECOVERY"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_close_devices",
          "args": [
            "fs_info->fs_devices"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "746-772",
          "snippet": "int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_stripe_hash_table",
          "args": [
            "fs_info"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_stripe_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "451-461",
          "snippet": "void btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nvoid btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&fs_info->bdi"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->dirty_metadata_bytes"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->delalloc_bytes"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&fs_info->bio_counter"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "fs_info->btree_inode"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mapping_tree_free",
          "args": [
            "&fs_info->mapping_tree"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mapping_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4721-4738",
          "snippet": "void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree)\n{\n\tstruct extent_map *em;\n\n\twhile (1) {\n\t\twrite_lock(&tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&tree->map_tree, 0, (u64)-1);\n\t\tif (em)\n\t\t\tremove_extent_mapping(&tree->map_tree, em);\n\t\twrite_unlock(&tree->map_tree.lock);\n\t\tif (!em)\n\t\t\tbreak;\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stop_all_workers",
          "args": [
            "fs_info"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_stop_all_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2066-2086",
          "snippet": "static void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_groups",
          "args": [
            "fs_info"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8831-8925",
          "snippet": "int btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tdown_write(&info->commit_root_sem);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tput_caching_control(caching_ctl);\n\t}\n\tup_write(&info->commit_root_sem);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group_cache,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\t\twait_block_group_cache_done(block_group);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tfree_excluded_extents(info->extent_root, block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\t/* now that all the block groups are freed, go through and\n\t * free all the space_info structs.  This is only called during\n\t * the final stages of unmount, and so we know nobody is\n\t * using them.  We call synchronize_rcu() once before we start,\n\t * just to be on the safe side.\n\t */\n\tsynchronize_rcu();\n\n\trelease_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tint i;\n\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\t\tif (btrfs_test_opt(info->tree_root, ENOSPC_DEBUG)) {\n\t\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0)) {\n\t\t\t\tdump_space_info(space_info, 0, 0);\n\t\t\t}\n\t\t}\n\t\tlist_del(&space_info->list);\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tstruct kobject *kobj;\n\t\t\tkobj = space_info->block_group_kobjs[i];\n\t\t\tspace_info->block_group_kobjs[i] = NULL;\n\t\t\tif (kobj) {\n\t\t\t\tkobject_del(kobj);\n\t\t\t\tkobject_put(kobj);\n\t\t\t}\n\t\t}\n\t\tkobject_del(&space_info->kobj);\n\t\tkobject_put(&space_info->kobj);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tdown_write(&info->commit_root_sem);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tput_caching_control(caching_ctl);\n\t}\n\tup_write(&info->commit_root_sem);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group_cache,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\t\twait_block_group_cache_done(block_group);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tfree_excluded_extents(info->extent_root, block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\t/* now that all the block groups are freed, go through and\n\t * free all the space_info structs.  This is only called during\n\t * the final stages of unmount, and so we know nobody is\n\t * using them.  We call synchronize_rcu() once before we start,\n\t * just to be on the safe side.\n\t */\n\tsynchronize_rcu();\n\n\trelease_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tint i;\n\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\t\tif (btrfs_test_opt(info->tree_root, ENOSPC_DEBUG)) {\n\t\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0)) {\n\t\t\t\tdump_space_info(space_info, 0, 0);\n\t\t\t}\n\t\t}\n\t\tlist_del(&space_info->list);\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tstruct kobject *kobj;\n\t\t\tkobj = space_info->block_group_kobjs[i];\n\t\t\tspace_info->block_group_kobjs[i] = NULL;\n\t\t\tif (kobj) {\n\t\t\t\tkobject_del(kobj);\n\t\t\t\tkobject_put(kobj);\n\t\t\t}\n\t\t}\n\t\tkobject_del(&space_info->kobj);\n\t\tkobject_put(&space_info->kobj);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_block_group_cache",
          "args": [
            "fs_info"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sysfs_remove_one",
          "args": [
            "fs_info"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sysfs_remove_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "516-528",
          "snippet": "void btrfs_sysfs_remove_one(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->space_info_kobj) {\n\t\tsysfs_remove_files(fs_info->space_info_kobj, allocation_attrs);\n\t\tkobject_del(fs_info->space_info_kobj);\n\t\tkobject_put(fs_info->space_info_kobj);\n\t}\n\tkobject_del(fs_info->device_dir_kobj);\n\tkobject_put(fs_info->device_dir_kobj);\n\taddrm_unknown_feature_attrs(fs_info, false);\n\tsysfs_remove_group(&fs_info->super_kobj, &btrfs_feature_attr_group);\n\t__btrfs_sysfs_remove_one(fs_info);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};",
            "static const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\nstatic const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};\n\nvoid btrfs_sysfs_remove_one(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->space_info_kobj) {\n\t\tsysfs_remove_files(fs_info->space_info_kobj, allocation_attrs);\n\t\tkobject_del(fs_info->space_info_kobj);\n\t\tkobject_put(fs_info->space_info_kobj);\n\t}\n\tkobject_del(fs_info->device_dir_kobj);\n\tkobject_put(fs_info->device_dir_kobj);\n\taddrm_unknown_feature_attrs(fs_info, false);\n\tsysfs_remove_group(&fs_info->super_kobj, &btrfs_feature_attr_group);\n\t__btrfs_sysfs_remove_one(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "fs_info->cleaner_kthread"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_fs_roots",
          "args": [
            "fs_info"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2112-2147",
          "snippet": "void btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\n\nvoid btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_transaction",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4235-4286",
          "snippet": "static int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "fs_info->transaction_kthread"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_qgroup_config",
          "args": [
            "fs_info"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_qgroup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "458-475",
          "snippet": "void btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_ctree",
          "args": [
            "tree_root"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "close_ctree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3639-3739",
          "snippet": "void close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"BTRFS: failed to check the UUID tree %d\\n\"",
            "ret"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_uuid_tree",
          "args": [
            "fs_info"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_uuid_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3932-3946",
          "snippet": "int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_rescan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_rescan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_rescan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_rescan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BTRFS: checking UUID tree\\n\""
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "RESCAN_UUID_TREE"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"BTRFS: failed to create the UUID tree %d\\n\"",
            "ret"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_uuid_tree",
          "args": [
            "fs_info"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_uuid_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3890-3930",
          "snippet": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BTRFS: creating UUID tree\\n\""
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_rescan_resume",
          "args": [
            "fs_info"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_rescan_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2820-2826",
          "snippet": "void\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"BTRFS: failed to resume dev_replace\\n\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_resume_dev_replace_async",
          "args": [
            "fs_info"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_resume_dev_replace_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "763-795",
          "snippet": "int btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BTRFS: failed to resume balance\\n\""
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_resume_balance_async",
          "args": [
            "fs_info"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_resume_balance_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3544-3562",
          "snippet": "int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->cleanup_work_sem"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->cleanup_work_sem"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_orphan_cleanup",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3300-3498",
          "snippet": "int btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fs_info->cleanup_work_sem"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_info->fs_root"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_info->fs_root"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&location"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_recover_relocation",
          "args": [
            "tree_root"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recover_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4320-4470",
          "snippet": "int btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_fs_roots",
          "args": [
            "fs_info"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3569-3618",
          "snippet": "int btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_orphan_roots",
          "args": [
            "tree_root"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_orphan_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "222-324",
          "snippet": "int btrfs_find_orphan_roots(struct btrfs_root *tree_root)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key root_key;\n\tstruct btrfs_root *root;\n\tint err = 0;\n\tint ret;\n\tbool can_recover = true;\n\n\tif (tree_root->fs_info->sb->s_flags & MS_RDONLY)\n\t\tcan_recover = false;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = 0;\n\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(tree_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_ORPHAN_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\troot_key.objectid = key.offset;\n\t\tkey.offset++;\n\n\t\troot = btrfs_read_fs_root(tree_root, &root_key);\n\t\terr = PTR_ERR_OR_ZERO(root);\n\t\tif (err && err != -ENOENT) {\n\t\t\tbreak;\n\t\t} else if (err == -ENOENT) {\n\t\t\tstruct btrfs_trans_handle *trans;\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\ttrans = btrfs_join_transaction(tree_root);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tbtrfs_error(tree_root->fs_info, err,\n\t\t\t\t\t    \"Failed to start trans to delete \"\n\t\t\t\t\t    \"orphan item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = btrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t\t    root_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, tree_root);\n\t\t\tif (err) {\n\t\t\t\tbtrfs_error(tree_root->fs_info, err,\n\t\t\t\t\t    \"Failed to delete root orphan \"\n\t\t\t\t\t    \"item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = btrfs_init_fs_root(root);\n\t\tif (err) {\n\t\t\tbtrfs_free_fs_root(root);\n\t\t\tbreak;\n\t\t}\n\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\t\terr = btrfs_insert_fs_root(root->fs_info, root);\n\t\tif (err) {\n\t\t\tBUG_ON(err == -EEXIST);\n\t\t\tbtrfs_free_fs_root(root);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\t\tbtrfs_add_dead_root(root);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn err;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_find_orphan_roots(struct btrfs_root *tree_root)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key root_key;\n\tstruct btrfs_root *root;\n\tint err = 0;\n\tint ret;\n\tbool can_recover = true;\n\n\tif (tree_root->fs_info->sb->s_flags & MS_RDONLY)\n\t\tcan_recover = false;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = 0;\n\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(tree_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_ORPHAN_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\troot_key.objectid = key.offset;\n\t\tkey.offset++;\n\n\t\troot = btrfs_read_fs_root(tree_root, &root_key);\n\t\terr = PTR_ERR_OR_ZERO(root);\n\t\tif (err && err != -ENOENT) {\n\t\t\tbreak;\n\t\t} else if (err == -ENOENT) {\n\t\t\tstruct btrfs_trans_handle *trans;\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\ttrans = btrfs_join_transaction(tree_root);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tbtrfs_error(tree_root->fs_info, err,\n\t\t\t\t\t    \"Failed to start trans to delete \"\n\t\t\t\t\t    \"orphan item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = btrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t\t    root_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, tree_root);\n\t\t\tif (err) {\n\t\t\t\tbtrfs_error(tree_root->fs_info, err,\n\t\t\t\t\t    \"Failed to delete root orphan \"\n\t\t\t\t\t    \"item\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = btrfs_init_fs_root(root);\n\t\tif (err) {\n\t\t\tbtrfs_free_fs_root(root);\n\t\t\tbreak;\n\t\t}\n\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\t\terr = btrfs_insert_fs_root(root->fs_info, root);\n\t\tif (err) {\n\t\t\tBUG_ON(err == -EEXIST);\n\t\t\tbtrfs_free_fs_root(root);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\t\tbtrfs_add_dead_root(root);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_super",
          "args": [
            "tree_root"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3620-3637",
          "snippet": "int btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void end_workqueue_fn(struct btrfs_work *work);",
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_tree_root"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "log_tree_root->node"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "tree_root->fs_info",
            "ret",
            "\"Failed to recover log tree\""
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_recover_log_trees",
          "args": [
            "log_tree_root"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recover_log_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "4529-4667",
          "snippet": "int btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key tmp_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = 0,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfs_info->log_root_recovering = 1;\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_error(fs_info, ret, \"Failed to pin buffers while \"\n\t\t\t    \"recovering log root tree.\");\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't find tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_fs_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't read tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\ttmp_key.objectid = found_key.offset;\n\t\ttmp_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_key.offset = (u64)-1;\n\n\t\twc.replay_dest = btrfs_read_fs_root_no_name(fs_info, &tmp_key);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\t\t\tfree_extent_buffer(log->node);\n\t\t\tfree_extent_buffer(log->commit_root);\n\t\t\tkfree(log);\n\t\t\tbtrfs_error(fs_info, ret, \"Couldn't read target root \"\n\t\t\t\t    \"for tree log recovery.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tbtrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t}\n\n\t\tkey.offset = found_key.offset - 1;\n\t\twc.replay_dest->log_root = NULL;\n\t\tfree_extent_buffer(log->node);\n\t\tfree_extent_buffer(log->commit_root);\n\t\tkfree(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* step one is to pin it all, step two is to replay just inodes */\n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t/* step three is to replay everything */\n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/* step 4: commit the transaction, which also unpins the blocks */\n\tret = btrfs_commit_transaction(trans, fs_info->tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tfree_extent_buffer(log_root_tree->node);\n\tlog_root_tree->log_root = NULL;\n\tfs_info->log_root_recovering = 0;\n\tkfree(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans, fs_info->tree_root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LOG_WALK_REPLAY_ALL 3",
            "#define LOG_WALK_REPLAY_INODES 1"
          ],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_WALK_REPLAY_ALL 3\n#define LOG_WALK_REPLAY_INODES 1\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nint btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key tmp_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = 0,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfs_info->log_root_recovering = 1;\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_error(fs_info, ret, \"Failed to pin buffers while \"\n\t\t\t    \"recovering log root tree.\");\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't find tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_fs_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't read tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\ttmp_key.objectid = found_key.offset;\n\t\ttmp_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_key.offset = (u64)-1;\n\n\t\twc.replay_dest = btrfs_read_fs_root_no_name(fs_info, &tmp_key);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\t\t\tfree_extent_buffer(log->node);\n\t\t\tfree_extent_buffer(log->commit_root);\n\t\t\tkfree(log);\n\t\t\tbtrfs_error(fs_info, ret, \"Couldn't read target root \"\n\t\t\t\t    \"for tree log recovery.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tbtrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t}\n\n\t\tkey.offset = found_key.offset - 1;\n\t\twc.replay_dest->log_root = NULL;\n\t\tfree_extent_buffer(log->node);\n\t\tfree_extent_buffer(log->commit_root);\n\t\tkfree(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* step one is to pin it all, step two is to replay just inodes */\n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t/* step three is to replay everything */\n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/* step 4: commit the transaction, which also unpins the blocks */\n\tret = btrfs_commit_transaction(trans, fs_info->tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tfree_extent_buffer(log_root_tree->node);\n\tlog_root_tree->log_root = NULL;\n\tfs_info->log_root_recovering = 0;\n\tkfree(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans, fs_info->tree_root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_tree_root"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "log_tree_root->node"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "tree_root",
            "bytenr",
            "generation + 1"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_root",
          "args": [
            "nodesize",
            "sectorsize",
            "stripesize",
            "log_tree_root",
            "fs_info",
            "BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1214-1286",
          "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_root",
          "args": [
            "fs_info"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1288-1294",
          "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "disk_super"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "disk_super"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_qgroup_config",
          "args": [
            "fs_info"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_qgroup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "268-450",
          "snippet": "int btrfs_read_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *l;\n\tint slot;\n\tint ret = 0;\n\tu64 flags = 0;\n\tu64 rescan_progress = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* default this to quota off, in case no status key is found */\n\tfs_info->qgroup_flags = 0;\n\n\t/*\n\t * pass 1: read status, all qgroup infos and limits\n\t */\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct btrfs_qgroup *qgroup;\n\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\n\t\t\tstruct btrfs_qgroup_status_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_status_item);\n\n\t\t\tif (btrfs_qgroup_status_version(l, ptr) !=\n\t\t\t    BTRFS_QGROUP_STATUS_VERSION) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t \"old qgroup version, quota disabled\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (btrfs_qgroup_status_generation(l, ptr) !=\n\t\t\t    fs_info->generation) {\n\t\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t\"qgroup generation mismatch, \"\n\t\t\t\t\t\"marked as inconsistent\");\n\t\t\t}\n\t\t\tfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\n\t\t\t\t\t\t\t\t\t  ptr);\n\t\t\trescan_progress = btrfs_qgroup_status_rescan(l, ptr);\n\t\t\tgoto next1;\n\t\t}\n\n\t\tif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\n\t\t    found_key.type != BTRFS_QGROUP_LIMIT_KEY)\n\t\t\tgoto next1;\n\n\t\tqgroup = find_qgroup_rb(fs_info, found_key.offset);\n\t\tif ((qgroup && found_key.type == BTRFS_QGROUP_INFO_KEY) ||\n\t\t    (!qgroup && found_key.type == BTRFS_QGROUP_LIMIT_KEY)) {\n\t\t\tbtrfs_err(fs_info, \"inconsitent qgroup config\");\n\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t}\n\t\tif (!qgroup) {\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (found_key.type) {\n\t\tcase BTRFS_QGROUP_INFO_KEY: {\n\t\t\tstruct btrfs_qgroup_info_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_info_item);\n\t\t\tqgroup->rfer = btrfs_qgroup_info_rfer(l, ptr);\n\t\t\tqgroup->rfer_cmpr = btrfs_qgroup_info_rfer_cmpr(l, ptr);\n\t\t\tqgroup->excl = btrfs_qgroup_info_excl(l, ptr);\n\t\t\tqgroup->excl_cmpr = btrfs_qgroup_info_excl_cmpr(l, ptr);\n\t\t\t/* generation currently unused */\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_QGROUP_LIMIT_KEY: {\n\t\t\tstruct btrfs_qgroup_limit_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_limit_item);\n\t\t\tqgroup->lim_flags = btrfs_qgroup_limit_flags(l, ptr);\n\t\t\tqgroup->max_rfer = btrfs_qgroup_limit_max_rfer(l, ptr);\n\t\t\tqgroup->max_excl = btrfs_qgroup_limit_max_excl(l, ptr);\n\t\t\tqgroup->rsv_rfer = btrfs_qgroup_limit_rsv_rfer(l, ptr);\n\t\t\tqgroup->rsv_excl = btrfs_qgroup_limit_rsv_excl(l, ptr);\n\t\t\tbreak;\n\t\t}\n\t\t}\nnext1:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pass 2: read all qgroup relations\n\t */\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 0);\n\tif (ret)\n\t\tgoto out;\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type != BTRFS_QGROUP_RELATION_KEY)\n\t\t\tgoto next2;\n\n\t\tif (found_key.objectid > found_key.offset) {\n\t\t\t/* parent <- member, not needed to build config */\n\t\t\t/* FIXME should we omit the key completely? */\n\t\t\tgoto next2;\n\t\t}\n\n\t\tret = add_relation_rb(fs_info, found_key.objectid,\n\t\t\t\t      found_key.offset);\n\t\tif (ret == -ENOENT) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"orphan qgroup relation 0x%llx->0x%llx\",\n\t\t\t\tfound_key.objectid, found_key.offset);\n\t\t\tret = 0;\t/* ignore the error */\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\nnext2:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tfs_info->qgroup_flags |= flags;\n\tif (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON)) {\n\t\tfs_info->quota_enabled = 0;\n\t\tfs_info->pending_quota_state = 0;\n\t} else if (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN &&\n\t\t   ret >= 0) {\n\t\tret = qgroup_rescan_init(fs_info, rescan_progress, 0);\n\t}\n\tbtrfs_free_path(path);\n\n\tif (ret < 0) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_read_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *l;\n\tint slot;\n\tint ret = 0;\n\tu64 flags = 0;\n\tu64 rescan_progress = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* default this to quota off, in case no status key is found */\n\tfs_info->qgroup_flags = 0;\n\n\t/*\n\t * pass 1: read status, all qgroup infos and limits\n\t */\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct btrfs_qgroup *qgroup;\n\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\n\t\t\tstruct btrfs_qgroup_status_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_status_item);\n\n\t\t\tif (btrfs_qgroup_status_version(l, ptr) !=\n\t\t\t    BTRFS_QGROUP_STATUS_VERSION) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t \"old qgroup version, quota disabled\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (btrfs_qgroup_status_generation(l, ptr) !=\n\t\t\t    fs_info->generation) {\n\t\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t\"qgroup generation mismatch, \"\n\t\t\t\t\t\"marked as inconsistent\");\n\t\t\t}\n\t\t\tfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\n\t\t\t\t\t\t\t\t\t  ptr);\n\t\t\trescan_progress = btrfs_qgroup_status_rescan(l, ptr);\n\t\t\tgoto next1;\n\t\t}\n\n\t\tif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\n\t\t    found_key.type != BTRFS_QGROUP_LIMIT_KEY)\n\t\t\tgoto next1;\n\n\t\tqgroup = find_qgroup_rb(fs_info, found_key.offset);\n\t\tif ((qgroup && found_key.type == BTRFS_QGROUP_INFO_KEY) ||\n\t\t    (!qgroup && found_key.type == BTRFS_QGROUP_LIMIT_KEY)) {\n\t\t\tbtrfs_err(fs_info, \"inconsitent qgroup config\");\n\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t}\n\t\tif (!qgroup) {\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (found_key.type) {\n\t\tcase BTRFS_QGROUP_INFO_KEY: {\n\t\t\tstruct btrfs_qgroup_info_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_info_item);\n\t\t\tqgroup->rfer = btrfs_qgroup_info_rfer(l, ptr);\n\t\t\tqgroup->rfer_cmpr = btrfs_qgroup_info_rfer_cmpr(l, ptr);\n\t\t\tqgroup->excl = btrfs_qgroup_info_excl(l, ptr);\n\t\t\tqgroup->excl_cmpr = btrfs_qgroup_info_excl_cmpr(l, ptr);\n\t\t\t/* generation currently unused */\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_QGROUP_LIMIT_KEY: {\n\t\t\tstruct btrfs_qgroup_limit_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_limit_item);\n\t\t\tqgroup->lim_flags = btrfs_qgroup_limit_flags(l, ptr);\n\t\t\tqgroup->max_rfer = btrfs_qgroup_limit_max_rfer(l, ptr);\n\t\t\tqgroup->max_excl = btrfs_qgroup_limit_max_excl(l, ptr);\n\t\t\tqgroup->rsv_rfer = btrfs_qgroup_limit_rsv_rfer(l, ptr);\n\t\t\tqgroup->rsv_excl = btrfs_qgroup_limit_rsv_excl(l, ptr);\n\t\t\tbreak;\n\t\t}\n\t\t}\nnext1:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pass 2: read all qgroup relations\n\t */\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 0);\n\tif (ret)\n\t\tgoto out;\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type != BTRFS_QGROUP_RELATION_KEY)\n\t\t\tgoto next2;\n\n\t\tif (found_key.objectid > found_key.offset) {\n\t\t\t/* parent <- member, not needed to build config */\n\t\t\t/* FIXME should we omit the key completely? */\n\t\t\tgoto next2;\n\t\t}\n\n\t\tret = add_relation_rb(fs_info, found_key.objectid,\n\t\t\t\t      found_key.offset);\n\t\tif (ret == -ENOENT) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"orphan qgroup relation 0x%llx->0x%llx\",\n\t\t\t\tfound_key.objectid, found_key.offset);\n\t\t\tret = 0;\t/* ignore the error */\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\nnext2:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tfs_info->qgroup_flags |= flags;\n\tif (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON)) {\n\t\tfs_info->quota_enabled = 0;\n\t\tfs_info->pending_quota_state = 0;\n\t} else if (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN &&\n\t\t   ret >= 0) {\n\t\tret = qgroup_rescan_init(fs_info, rescan_progress, 0);\n\t}\n\tbtrfs_free_path(path);\n\n\tif (ret < 0) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BTRFS: failed to initialize\"\n\t\t\t       \" integrity check module %s\\n\"",
            "sb->s_id"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_mount",
          "args": [
            "tree_root",
            "fs_devices",
            "btrfs_test_opt(tree_root,\n\t\t\t\t\tCHECK_INTEGRITY_INCLUDING_EXTENT_DATA) ?\n\t\t\t\t    1 : 0",
            "fs_info->check_integrity_print_mask"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3073-3163",
          "snippet": "int btrfsic_mount(struct btrfs_root *root,\n\t\t  struct btrfs_fs_devices *fs_devices,\n\t\t  int including_extent_data, u32 print_mask)\n{\n\tint ret;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (root->nodesize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->nodesize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tif (root->sectorsize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->sectorsize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!state) {\n\t\tstate = vzalloc(sizeof(*state));\n\t\tif (!state) {\n\t\t\tprintk(KERN_INFO \"btrfs check-integrity: vzalloc() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!btrfsic_is_initialized) {\n\t\tmutex_init(&btrfsic_mutex);\n\t\tbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\n\t\tbtrfsic_is_initialized = 1;\n\t}\n\tmutex_lock(&btrfsic_mutex);\n\tstate->root = root;\n\tstate->print_mask = print_mask;\n\tstate->include_extent_data = including_extent_data;\n\tstate->csum_size = 0;\n\tstate->metablock_size = root->nodesize;\n\tstate->datablock_size = root->sectorsize;\n\tINIT_LIST_HEAD(&state->all_blocks_list);\n\tbtrfsic_block_hashtable_init(&state->block_hashtable);\n\tbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\n\tstate->max_superblock_generation = 0;\n\tstate->latest_superblock = NULL;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\t\tchar *p;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_alloc();\n\t\tif (NULL == ds) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfs check-integrity: kmalloc() failed!\\n\");\n\t\t\tmutex_unlock(&btrfsic_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tds->bdev = device->bdev;\n\t\tds->state = state;\n\t\tbdevname(ds->bdev, ds->name);\n\t\tds->name[BDEVNAME_SIZE - 1] = '\\0';\n\t\tfor (p = ds->name; *p != '\\0'; p++);\n\t\twhile (p > ds->name && *p != '/')\n\t\t\tp--;\n\t\tif (*p == '/')\n\t\t\tp++;\n\t\tstrlcpy(ds->name, p, sizeof(ds->name));\n\t\tbtrfsic_dev_state_hashtable_add(ds,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\t}\n\n\tret = btrfsic_process_superblock(state, fs_devices);\n\tif (0 != ret) {\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\tbtrfsic_unmount(root, fs_devices);\n\t\treturn ret;\n\t}\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\n\t\tbtrfsic_dump_database(state);\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\n\t\tbtrfsic_dump_tree(state);\n\n\tmutex_unlock(&btrfsic_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE\t\t\t0x00000400",
            "#define BTRFSIC_PRINT_MASK_INITIAL_TREE\t\t\t\t0x00000100"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE\t\t\t0x00000400\n#define BTRFSIC_PRINT_MASK_INITIAL_TREE\t\t\t\t0x00000100\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nint btrfsic_mount(struct btrfs_root *root,\n\t\t  struct btrfs_fs_devices *fs_devices,\n\t\t  int including_extent_data, u32 print_mask)\n{\n\tint ret;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (root->nodesize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->nodesize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tif (root->sectorsize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->sectorsize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!state) {\n\t\tstate = vzalloc(sizeof(*state));\n\t\tif (!state) {\n\t\t\tprintk(KERN_INFO \"btrfs check-integrity: vzalloc() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!btrfsic_is_initialized) {\n\t\tmutex_init(&btrfsic_mutex);\n\t\tbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\n\t\tbtrfsic_is_initialized = 1;\n\t}\n\tmutex_lock(&btrfsic_mutex);\n\tstate->root = root;\n\tstate->print_mask = print_mask;\n\tstate->include_extent_data = including_extent_data;\n\tstate->csum_size = 0;\n\tstate->metablock_size = root->nodesize;\n\tstate->datablock_size = root->sectorsize;\n\tINIT_LIST_HEAD(&state->all_blocks_list);\n\tbtrfsic_block_hashtable_init(&state->block_hashtable);\n\tbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\n\tstate->max_superblock_generation = 0;\n\tstate->latest_superblock = NULL;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\t\tchar *p;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_alloc();\n\t\tif (NULL == ds) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfs check-integrity: kmalloc() failed!\\n\");\n\t\t\tmutex_unlock(&btrfsic_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tds->bdev = device->bdev;\n\t\tds->state = state;\n\t\tbdevname(ds->bdev, ds->name);\n\t\tds->name[BDEVNAME_SIZE - 1] = '\\0';\n\t\tfor (p = ds->name; *p != '\\0'; p++);\n\t\twhile (p > ds->name && *p != '/')\n\t\t\tp--;\n\t\tif (*p == '/')\n\t\t\tp++;\n\t\tstrlcpy(ds->name, p, sizeof(ds->name));\n\t\tbtrfsic_dev_state_hashtable_add(ds,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\t}\n\n\tret = btrfsic_process_superblock(state, fs_devices);\n\tif (0 != ret) {\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\tbtrfsic_unmount(root, fs_devices);\n\t\treturn ret;\n\t}\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\n\t\tbtrfsic_dump_database(state);\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\n\t\tbtrfsic_dump_tree(state);\n\n\tmutex_unlock(&btrfsic_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "CHECK_INTEGRITY_INCLUDING_EXTENT_DATA"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "CHECK_INTEGRITY"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_apply_pending_changes",
          "args": [
            "fs_info"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_apply_pending_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "2139-2166",
          "snippet": "void btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "fs_info->mount_opt",
            "SSD"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "NOSSD"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "tree_root",
            "SSD"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_info->transaction_kthread"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "transaction_kthread",
            "tree_root",
            "\"btrfs-transaction\""
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_info->cleaner_kthread"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "cleaner_kthread",
            "tree_root",
            "\"btrfs-cleaner\""
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "args": [
            "fs_info"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_num_tolerated_disk_barrier_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3348-3424",
          "snippet": "int btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_calc_num_tolerated_disk_barrier_failures(\n\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_space_info *sinfo;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint i;\n\tint c;\n\tint num_tolerated_disk_barrier_failures =\n\t\t(int)fs_info->fs_devices->num_devices;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tsinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &fs_info->space_info, list) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tsinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!sinfo)\n\t\t\tcontinue;\n\n\t\tdown_read(&sinfo->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&sinfo->block_groups[c])) {\n\t\t\t\tu64 flags;\n\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&sinfo->block_groups[c], &space);\n\t\t\t\tif (space.total_bytes == 0 ||\n\t\t\t\t    space.used_bytes == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = space.flags;\n\t\t\t\t/*\n\t\t\t\t * return\n\t\t\t\t * 0: if dup, single or RAID0 is configured for\n\t\t\t\t *    any of metadata, system or data, else\n\t\t\t\t * 1: if RAID5 is configured, or if RAID1 or\n\t\t\t\t *    RAID10 is configured and only two mirrors\n\t\t\t\t *    are used, else\n\t\t\t\t * 2: if RAID6 is configured, else\n\t\t\t\t * num_mirrors - 1: if RAID1 or RAID10 is\n\t\t\t\t *                  configured and more than\n\t\t\t\t *                  2 mirrors are used.\n\t\t\t\t */\n\t\t\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t\t\t    ((flags & (BTRFS_BLOCK_GROUP_DUP |\n\t\t\t\t\t       BTRFS_BLOCK_GROUP_RAID0)) ||\n\t\t\t\t     ((flags & BTRFS_BLOCK_GROUP_PROFILE_MASK)\n\t\t\t\t      == 0)))\n\t\t\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\t\t\telse if (num_tolerated_disk_barrier_failures > 1) {\n\t\t\t\t\tif (flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID5 |\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_RAID10)) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\t\t\t\t\t} else if (flags &\n\t\t\t\t\t\t   BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t\t\t\tnum_tolerated_disk_barrier_failures = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tup_read(&sinfo->groups_sem);\n\t}\n\n\treturn num_tolerated_disk_barrier_failures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_block_groups",
          "args": [
            "extent_root"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9001-9177",
          "snippet": "int btrfs_read_block_groups(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint need_clear = 0;\n\tu64 cache_gen;\n\n\troot = info->extent_root;\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (btrfs_test_opt(root, SPACE_CACHE) &&\n\t    btrfs_super_generation(root->fs_info->super_copy) != cache_gen)\n\t\tneed_clear = 1;\n\tif (btrfs_test_opt(root, CLEAR_CACHE))\n\t\tneed_clear = 1;\n\n\twhile (1) {\n\t\tret = find_first_block_group(root, path, &key);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tcache = btrfs_create_block_group_cache(root, found_key.objectid,\n\t\t\t\t\t\t       found_key.offset);\n\t\tif (!cache) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (need_clear) {\n\t\t\t/*\n\t\t\t * When we mount with old space cache, we need to\n\t\t\t * set BTRFS_DC_CLEAR and set dirty flag.\n\t\t\t *\n\t\t\t * a) Setting 'BTRFS_DC_CLEAR' makes sure that we\n\t\t\t *    truncate the old free space cache inode and\n\t\t\t *    setup a new one.\n\t\t\t * b) Setting 'dirty flag' makes sure that we flush\n\t\t\t *    the new space cache info onto disk.\n\t\t\t */\n\t\t\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\t\t}\n\n\t\tread_extent_buffer(leaf, &cache->item,\n\t\t\t\t   btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t\t   sizeof(cache->item));\n\t\tcache->flags = btrfs_block_group_flags(&cache->item);\n\n\t\tkey.objectid = found_key.objectid + found_key.offset;\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * We need to exclude the super stripes now so that the space\n\t\t * info has super bytes accounted for, otherwise we'll think\n\t\t * we have more space than we actually do.\n\t\t */\n\t\tret = exclude_super_stripes(root, cache);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We may have excluded something, so call this just in\n\t\t\t * case.\n\t\t\t */\n\t\t\tfree_excluded_extents(root, cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * check for two cases, either we are full, and therefore\n\t\t * don't need to bother with the caching work since we won't\n\t\t * find any space, or we are empty, and we can just add all\n\t\t * the space in and be done with it.  This saves us _alot_ of\n\t\t * time, particularly in the full case.\n\t\t */\n\t\tif (found_key.offset == btrfs_block_group_used(&cache->item)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\t\tfree_excluded_extents(root, cache);\n\t\t} else if (btrfs_block_group_used(&cache->item) == 0) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\t\tadd_new_free_space(cache, root->fs_info,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.objectid +\n\t\t\t\t\t   found_key.offset);\n\t\t\tfree_excluded_extents(root, cache);\n\t\t}\n\n\t\tret = btrfs_add_block_group_cache(root->fs_info, cache);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = update_space_info(info, cache->flags, found_key.offset,\n\t\t\t\t\tbtrfs_block_group_used(&cache->item),\n\t\t\t\t\t&space_info);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(cache);\n\t\t\tspin_lock(&info->block_group_cache_lock);\n\t\t\trb_erase(&cache->cache_node,\n\t\t\t\t &info->block_group_cache_tree);\n\t\t\tRB_CLEAR_NODE(&cache->cache_node);\n\t\t\tspin_unlock(&info->block_group_cache_lock);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\tcache->space_info = space_info;\n\t\tspin_lock(&cache->space_info->lock);\n\t\tcache->space_info->bytes_readonly += cache->bytes_super;\n\t\tspin_unlock(&cache->space_info->lock);\n\n\t\t__link_block_group(space_info, cache);\n\n\t\tset_avail_alloc_bits(root->fs_info, cache->flags);\n\t\tif (btrfs_chunk_readonly(root, cache->key.objectid)) {\n\t\t\tset_block_group_ro(cache, 1);\n\t\t} else if (btrfs_block_group_used(&cache->item) == 0) {\n\t\t\tspin_lock(&info->unused_bgs_lock);\n\t\t\t/* Should always be true but just in case. */\n\t\t\tif (list_empty(&cache->bg_list)) {\n\t\t\t\tbtrfs_get_block_group(cache);\n\t\t\t\tlist_add_tail(&cache->bg_list,\n\t\t\t\t\t      &info->unused_bgs);\n\t\t\t}\n\t\t\tspin_unlock(&info->unused_bgs_lock);\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(space_info, &root->fs_info->space_info, list) {\n\t\tif (!(get_alloc_profile(root, space_info->flags) &\n\t\t      (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t       BTRFS_BLOCK_GROUP_RAID1 |\n\t\t       BTRFS_BLOCK_GROUP_RAID5 |\n\t\t       BTRFS_BLOCK_GROUP_RAID6 |\n\t\t       BTRFS_BLOCK_GROUP_DUP)))\n\t\t\tcontinue;\n\t\t/*\n\t\t * avoid allocating from un-mirrored block group if there are\n\t\t * mirrored block groups.\n\t\t */\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_RAID0],\n\t\t\t\tlist)\n\t\t\tset_block_group_ro(cache, 1);\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_SINGLE],\n\t\t\t\tlist)\n\t\t\tset_block_group_ro(cache, 1);\n\t}\n\n\tinit_global_block_rsv(info);\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_read_block_groups(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint need_clear = 0;\n\tu64 cache_gen;\n\n\troot = info->extent_root;\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (btrfs_test_opt(root, SPACE_CACHE) &&\n\t    btrfs_super_generation(root->fs_info->super_copy) != cache_gen)\n\t\tneed_clear = 1;\n\tif (btrfs_test_opt(root, CLEAR_CACHE))\n\t\tneed_clear = 1;\n\n\twhile (1) {\n\t\tret = find_first_block_group(root, path, &key);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\tcache = btrfs_create_block_group_cache(root, found_key.objectid,\n\t\t\t\t\t\t       found_key.offset);\n\t\tif (!cache) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (need_clear) {\n\t\t\t/*\n\t\t\t * When we mount with old space cache, we need to\n\t\t\t * set BTRFS_DC_CLEAR and set dirty flag.\n\t\t\t *\n\t\t\t * a) Setting 'BTRFS_DC_CLEAR' makes sure that we\n\t\t\t *    truncate the old free space cache inode and\n\t\t\t *    setup a new one.\n\t\t\t * b) Setting 'dirty flag' makes sure that we flush\n\t\t\t *    the new space cache info onto disk.\n\t\t\t */\n\t\t\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\t\t}\n\n\t\tread_extent_buffer(leaf, &cache->item,\n\t\t\t\t   btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t\t   sizeof(cache->item));\n\t\tcache->flags = btrfs_block_group_flags(&cache->item);\n\n\t\tkey.objectid = found_key.objectid + found_key.offset;\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * We need to exclude the super stripes now so that the space\n\t\t * info has super bytes accounted for, otherwise we'll think\n\t\t * we have more space than we actually do.\n\t\t */\n\t\tret = exclude_super_stripes(root, cache);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We may have excluded something, so call this just in\n\t\t\t * case.\n\t\t\t */\n\t\t\tfree_excluded_extents(root, cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * check for two cases, either we are full, and therefore\n\t\t * don't need to bother with the caching work since we won't\n\t\t * find any space, or we are empty, and we can just add all\n\t\t * the space in and be done with it.  This saves us _alot_ of\n\t\t * time, particularly in the full case.\n\t\t */\n\t\tif (found_key.offset == btrfs_block_group_used(&cache->item)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\t\tfree_excluded_extents(root, cache);\n\t\t} else if (btrfs_block_group_used(&cache->item) == 0) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\t\tadd_new_free_space(cache, root->fs_info,\n\t\t\t\t\t   found_key.objectid,\n\t\t\t\t\t   found_key.objectid +\n\t\t\t\t\t   found_key.offset);\n\t\t\tfree_excluded_extents(root, cache);\n\t\t}\n\n\t\tret = btrfs_add_block_group_cache(root->fs_info, cache);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = update_space_info(info, cache->flags, found_key.offset,\n\t\t\t\t\tbtrfs_block_group_used(&cache->item),\n\t\t\t\t\t&space_info);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(cache);\n\t\t\tspin_lock(&info->block_group_cache_lock);\n\t\t\trb_erase(&cache->cache_node,\n\t\t\t\t &info->block_group_cache_tree);\n\t\t\tRB_CLEAR_NODE(&cache->cache_node);\n\t\t\tspin_unlock(&info->block_group_cache_lock);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto error;\n\t\t}\n\n\t\tcache->space_info = space_info;\n\t\tspin_lock(&cache->space_info->lock);\n\t\tcache->space_info->bytes_readonly += cache->bytes_super;\n\t\tspin_unlock(&cache->space_info->lock);\n\n\t\t__link_block_group(space_info, cache);\n\n\t\tset_avail_alloc_bits(root->fs_info, cache->flags);\n\t\tif (btrfs_chunk_readonly(root, cache->key.objectid)) {\n\t\t\tset_block_group_ro(cache, 1);\n\t\t} else if (btrfs_block_group_used(&cache->item) == 0) {\n\t\t\tspin_lock(&info->unused_bgs_lock);\n\t\t\t/* Should always be true but just in case. */\n\t\t\tif (list_empty(&cache->bg_list)) {\n\t\t\t\tbtrfs_get_block_group(cache);\n\t\t\t\tlist_add_tail(&cache->bg_list,\n\t\t\t\t\t      &info->unused_bgs);\n\t\t\t}\n\t\t\tspin_unlock(&info->unused_bgs_lock);\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(space_info, &root->fs_info->space_info, list) {\n\t\tif (!(get_alloc_profile(root, space_info->flags) &\n\t\t      (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t       BTRFS_BLOCK_GROUP_RAID1 |\n\t\t       BTRFS_BLOCK_GROUP_RAID5 |\n\t\t       BTRFS_BLOCK_GROUP_RAID6 |\n\t\t       BTRFS_BLOCK_GROUP_DUP)))\n\t\t\tcontinue;\n\t\t/*\n\t\t * avoid allocating from un-mirrored block group if there are\n\t\t * mirrored block groups.\n\t\t */\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_RAID0],\n\t\t\t\tlist)\n\t\t\tset_block_group_ro(cache, 1);\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_SINGLE],\n\t\t\t\tlist)\n\t\t\tset_block_group_ro(cache, 1);\n\t}\n\n\tinit_global_block_rsv(info);\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_space_info",
          "args": [
            "fs_info"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_space_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9667-9703",
          "snippet": "int btrfs_init_space_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\tu64 flags;\n\tint mixed = 0;\n\tint ret;\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\treturn 1;\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\tif (ret)\n\t\tgoto out;\n\n\tif (mixed) {\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t} else {\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_init_space_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\tu64 flags;\n\tint mixed = 0;\n\tint ret;\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\treturn 1;\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\tif (ret)\n\t\tgoto out;\n\n\tif (mixed) {\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t} else {\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\t\tret = update_space_info(fs_info, flags, 0, 0, &space_info);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BTRFS: failed to init sysfs interface: %d\\n\"",
            "ret"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sysfs_add_one",
          "args": [
            "fs_info"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sysfs_add_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "670-711",
          "snippet": "int btrfs_sysfs_add_one(struct btrfs_fs_info *fs_info)\n{\n\tint error;\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tfs_info->super_kobj.kset = btrfs_kset;\n\terror = kobject_init_and_add(&fs_info->super_kobj, &btrfs_ktype, NULL,\n\t\t\t\t     \"%pU\", fs_info->fsid);\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_group(&fs_info->super_kobj,\n\t\t\t\t   &btrfs_feature_attr_group);\n\tif (error) {\n\t\t__btrfs_sysfs_remove_one(fs_info);\n\t\treturn error;\n\t}\n\n\terror = addrm_unknown_feature_attrs(fs_info, true);\n\tif (error)\n\t\tgoto failure;\n\n\terror = btrfs_kobj_add_device(fs_info, NULL);\n\tif (error)\n\t\tgoto failure;\n\n\tfs_info->space_info_kobj = kobject_create_and_add(\"allocation\",\n\t\t\t\t\t\t  &fs_info->super_kobj);\n\tif (!fs_info->space_info_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\terror = sysfs_create_files(fs_info->space_info_kobj, allocation_attrs);\n\tif (error)\n\t\tgoto failure;\n\n\treturn 0;\nfailure:\n\tbtrfs_sysfs_remove_one(fs_info);\n\treturn error;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};",
            "static const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};",
            "static struct kobj_type btrfs_ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.release\t= btrfs_release_super_kobj,\n\t.default_attrs\t= btrfs_attrs,\n};",
            "static struct kset *btrfs_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\nstatic const struct attribute *allocation_attrs[] = {\n\tBTRFS_ATTR_PTR(global_rsv_reserved),\n\tBTRFS_ATTR_PTR(global_rsv_size),\n\tNULL,\n};\nstatic struct kobj_type btrfs_ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.release\t= btrfs_release_super_kobj,\n\t.default_attrs\t= btrfs_attrs,\n};\nstatic struct kset *btrfs_kset;\n\nint btrfs_sysfs_add_one(struct btrfs_fs_info *fs_info)\n{\n\tint error;\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tfs_info->super_kobj.kset = btrfs_kset;\n\terror = kobject_init_and_add(&fs_info->super_kobj, &btrfs_ktype, NULL,\n\t\t\t\t     \"%pU\", fs_info->fsid);\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_group(&fs_info->super_kobj,\n\t\t\t\t   &btrfs_feature_attr_group);\n\tif (error) {\n\t\t__btrfs_sysfs_remove_one(fs_info);\n\t\treturn error;\n\t}\n\n\terror = addrm_unknown_feature_attrs(fs_info, true);\n\tif (error)\n\t\tgoto failure;\n\n\terror = btrfs_kobj_add_device(fs_info, NULL);\n\tif (error)\n\t\tgoto failure;\n\n\tfs_info->space_info_kobj = kobject_create_and_add(\"allocation\",\n\t\t\t\t\t\t  &fs_info->super_kobj);\n\tif (!fs_info->space_info_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\terror = sysfs_create_files(fs_info->space_info_kobj, allocation_attrs);\n\tif (error)\n\t\tgoto failure;\n\n\treturn 0;\nfailure:\n\tbtrfs_sysfs_remove_one(fs_info);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_close_extra_devices",
          "args": [
            "fs_info",
            "fs_devices",
            "1"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_close_extra_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "612-671",
          "snippet": "void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_fs_devices *fs_devices, int step)\n{\n\tstruct btrfs_device *device, *next;\n\tstruct btrfs_device *latest_dev = NULL;\n\n\tmutex_lock(&uuid_mutex);\nagain:\n\t/* This is the initialized path, it is safe to release the devices. */\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->in_fs_metadata) {\n\t\t\tif (!device->is_tgtdev_for_dev_replace &&\n\t\t\t    (!latest_dev ||\n\t\t\t     device->generation > latest_dev->generation)) {\n\t\t\t\tlatest_dev = device;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (device->devid == BTRFS_DEV_REPLACE_DEVID) {\n\t\t\t/*\n\t\t\t * In the first step, keep the device which has\n\t\t\t * the correct fsid and the devid that is used\n\t\t\t * for the dev_replace procedure.\n\t\t\t * In the second step, the dev_replace state is\n\t\t\t * read from the device tree and it is known\n\t\t\t * whether the procedure is really active or\n\t\t\t * not, which means whether this device is\n\t\t\t * used or whether it should be removed.\n\t\t\t */\n\t\t\tif (step == 0 || device->is_tgtdev_for_dev_replace) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (device->bdev) {\n\t\t\tblkdev_put(device->bdev, device->mode);\n\t\t\tdevice->bdev = NULL;\n\t\t\tfs_devices->open_devices--;\n\t\t}\n\t\tif (device->writeable) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tdevice->writeable = 0;\n\t\t\tif (!device->is_tgtdev_for_dev_replace)\n\t\t\t\tfs_devices->rw_devices--;\n\t\t}\n\t\tlist_del_init(&device->dev_list);\n\t\tfs_devices->num_devices--;\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\n\tif (fs_devices->seed) {\n\t\tfs_devices = fs_devices->seed;\n\t\tgoto again;\n\t}\n\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\n\tmutex_unlock(&uuid_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_fs_devices *fs_devices, int step)\n{\n\tstruct btrfs_device *device, *next;\n\tstruct btrfs_device *latest_dev = NULL;\n\n\tmutex_lock(&uuid_mutex);\nagain:\n\t/* This is the initialized path, it is safe to release the devices. */\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->in_fs_metadata) {\n\t\t\tif (!device->is_tgtdev_for_dev_replace &&\n\t\t\t    (!latest_dev ||\n\t\t\t     device->generation > latest_dev->generation)) {\n\t\t\t\tlatest_dev = device;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (device->devid == BTRFS_DEV_REPLACE_DEVID) {\n\t\t\t/*\n\t\t\t * In the first step, keep the device which has\n\t\t\t * the correct fsid and the devid that is used\n\t\t\t * for the dev_replace procedure.\n\t\t\t * In the second step, the dev_replace state is\n\t\t\t * read from the device tree and it is known\n\t\t\t * whether the procedure is really active or\n\t\t\t * not, which means whether this device is\n\t\t\t * used or whether it should be removed.\n\t\t\t */\n\t\t\tif (step == 0 || device->is_tgtdev_for_dev_replace) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (device->bdev) {\n\t\t\tblkdev_put(device->bdev, device->mode);\n\t\t\tdevice->bdev = NULL;\n\t\t\tfs_devices->open_devices--;\n\t\t}\n\t\tif (device->writeable) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tdevice->writeable = 0;\n\t\t\tif (!device->is_tgtdev_for_dev_replace)\n\t\t\t\tfs_devices->rw_devices--;\n\t\t}\n\t\tlist_del_init(&device->dev_list);\n\t\tfs_devices->num_devices--;\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t}\n\n\tif (fs_devices->seed) {\n\t\tfs_devices = fs_devices->seed;\n\t\tgoto again;\n\t}\n\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\n\tmutex_unlock(&uuid_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BTRFS: failed to init dev_replace: %d\\n\"",
            "ret"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_dev_replace",
          "args": [
            "fs_info"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "55-189",
          "snippet": "int btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->replace_state = 0;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info, src_devid,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info,\n\t\t\t\t\t\t\tBTRFS_DEV_REPLACE_DEVID,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t/*\n\t\t * allow 'btrfs dev replace_cancel' if src/tgt device is\n\t\t * missing\n\t\t */\n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tdev_replace->tgtdev->is_tgtdev_for_dev_replace = 1;\n\t\t\tbtrfs_init_dev_replace_tgtdev_for_resume(fs_info,\n\t\t\t\tdev_replace->tgtdev);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->replace_state = 0;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info, src_devid,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info,\n\t\t\t\t\t\t\tBTRFS_DEV_REPLACE_DEVID,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t/*\n\t\t * allow 'btrfs dev replace_cancel' if src/tgt device is\n\t\t * missing\n\t\t */\n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tdev_replace->tgtdev->is_tgtdev_for_dev_replace = 1;\n\t\t\tbtrfs_init_dev_replace_tgtdev_for_resume(fs_info,\n\t\t\t\tdev_replace->tgtdev);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_dev_stats",
          "args": [
            "fs_info"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_dev_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6444-6503",
          "snippet": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\n\t\tkey.objectid = 0;\n\t\tkey.type = BTRFS_DEV_STATS_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\n\t\tkey.objectid = 0;\n\t\tkey.type = BTRFS_DEV_STATS_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_recover_balance",
          "args": [
            "fs_info"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recover_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3564-3622",
          "snippet": "int btrfs_recover_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) { /* ret = -ENOENT; */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tbctl->fs_info = fs_info;\n\tbctl->flags = btrfs_balance_flags(leaf, item);\n\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\n\tbtrfs_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->data, &disk_bargs);\n\tbtrfs_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->meta, &disk_bargs);\n\tbtrfs_balance_sys(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->sys, &disk_bargs);\n\n\tWARN_ON(atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1));\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tset_balance_control(bctl);\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_recover_balance(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_balance_control *bctl;\n\tstruct btrfs_balance_item *item;\n\tstruct btrfs_disk_balance_args disk_bargs;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_BALANCE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) { /* ret = -ENOENT; */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);\n\n\tbctl->fs_info = fs_info;\n\tbctl->flags = btrfs_balance_flags(leaf, item);\n\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\n\tbtrfs_balance_data(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->data, &disk_bargs);\n\tbtrfs_balance_meta(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->meta, &disk_bargs);\n\tbtrfs_balance_sys(leaf, item, &disk_bargs);\n\tbtrfs_disk_balance_args_to_cpu(&bctl->sys, &disk_bargs);\n\n\tWARN_ON(atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1));\n\n\tmutex_lock(&fs_info->volume_mutex);\n\tmutex_lock(&fs_info->balance_mutex);\n\n\tset_balance_control(bctl);\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_uuid_tree_generation",
          "args": [
            "disk_super"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_TRACK_DIRTY",
            "&uuid_root->state"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "uuid_root"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "uuid_root"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_tree_root",
          "args": [
            "tree_root",
            "&location"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_tree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1485-1537",
          "snippet": "static struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "quota_root"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "csum_root"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "csum_root"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_devices_late",
          "args": [
            "fs_info"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_devices_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6421-6434",
          "snippet": "void btrfs_init_devices_late(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\t\tdevice->dev_root = fs_info->dev_root;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_init_devices_late(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\t\tdevice->dev_root = fs_info->dev_root;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t\tfs_devices = fs_devices->seed;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dev_root"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dev_root"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "extent_root"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "extent_root"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&tree_root->root_item",
            "1"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "tree_root"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&tree_root->root_item",
            "tree_root->node"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&tree_root->node->bflags"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "disk_super"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_super"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_chunk_tree",
          "args": [
            "chunk_root"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_chunk_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6354-6419",
          "snippet": "int btrfs_read_chunk_tree(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\tint slot;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&uuid_mutex);\n\tlock_chunks(root);\n\n\t/*\n\t * Read all device items, and then all the chunk items. All\n\t * device items are found before any chunk item (their object id\n\t * is smaller than the lowest possible object id for a chunk\n\t * item - BTRFS_FIRST_CHUNK_TREE_OBJECTID).\n\t */\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.type == BTRFS_DEV_ITEM_KEY) {\n\t\t\tstruct btrfs_dev_item *dev_item;\n\t\t\tdev_item = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\t  struct btrfs_dev_item);\n\t\t\tret = read_one_dev(root, leaf, dev_item);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (found_key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tstruct btrfs_chunk *chunk;\n\t\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\t\tret = read_one_chunk(root, &found_key, leaf, chunk);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nerror:\n\tunlock_chunks(root);\n\tmutex_unlock(&uuid_mutex);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_read_chunk_tree(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint ret;\n\tint slot;\n\n\troot = root->fs_info->chunk_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&uuid_mutex);\n\tlock_chunks(root);\n\n\t/*\n\t * Read all device items, and then all the chunk items. All\n\t * device items are found before any chunk item (their object id\n\t * is smaller than the lowest possible object id for a chunk\n\t * item - BTRFS_FIRST_CHUNK_TREE_OBJECTID).\n\t */\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.type == BTRFS_DEV_ITEM_KEY) {\n\t\t\tstruct btrfs_dev_item *dev_item;\n\t\t\tdev_item = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\t  struct btrfs_dev_item);\n\t\t\tret = read_one_dev(root, leaf, dev_item);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else if (found_key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tstruct btrfs_chunk *chunk;\n\t\t\tchunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);\n\t\t\tret = read_one_chunk(root, &found_key, leaf, chunk);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nerror:\n\tunlock_chunks(root);\n\tmutex_unlock(&uuid_mutex);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "chunk_root->node",
            "fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(chunk_root->node)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "chunk_root->node"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "disk_super"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root_generation",
          "args": [
            "disk_super"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->chunk_mutex"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_sys_array",
          "args": [
            "tree_root"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_sys_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6258-6352",
          "snippet": "int btrfs_read_sys_array(struct btrfs_root *root)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct extent_buffer *sb;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *array_ptr;\n\tunsigned long sb_array_offset;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur_offset;\n\tstruct btrfs_key key;\n\n\tASSERT(BTRFS_SUPER_INFO_SIZE <= root->nodesize);\n\t/*\n\t * This will create extent buffer of nodesize, superblock size is\n\t * fixed to BTRFS_SUPER_INFO_SIZE. If nodesize > sb size, this will\n\t * overallocate but we can keep it as-is, only the first page is used.\n\t */\n\tsb = btrfs_find_create_tree_block(root, BTRFS_SUPER_INFO_OFFSET);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\tbtrfs_set_buffer_uptodate(sb);\n\tbtrfs_set_buffer_lockdep_class(root->root_key.objectid, sb, 0);\n\t/*\n\t * The sb extent buffer is artifical and just used to read the system array.\n\t * btrfs_set_buffer_uptodate() call does not properly mark all it's\n\t * pages up-to-date when the page is larger: extent does not cover the\n\t * whole page and consequently check_page_uptodate does not find all\n\t * the page's extents up-to-date (the hole beyond sb),\n\t * write_extent_buffer then triggers a WARN_ON.\n\t *\n\t * Regular short extents go through mark_extent_buffer_dirty/writeback cycle,\n\t * but sb spans only this function. Add an explicit SetPageUptodate call\n\t * to silence the warning eg. on PowerPC 64.\n\t */\n\tif (PAGE_CACHE_SIZE > BTRFS_SUPER_INFO_SIZE)\n\t\tSetPageUptodate(sb->pages[0]);\n\n\twrite_extent_buffer(sb, super_copy, 0, BTRFS_SUPER_INFO_SIZE);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tarray_ptr = super_copy->sys_chunk_array;\n\tsb_array_offset = offsetof(struct btrfs_super_block, sys_chunk_array);\n\tcur_offset = 0;\n\n\twhile (cur_offset < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)array_ptr;\n\t\tlen = sizeof(*disk_key);\n\t\tif (cur_offset + len > array_size)\n\t\t\tgoto out_short_read;\n\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)sb_array_offset;\n\t\t\t/*\n\t\t\t * At least one btrfs_chunk with one stripe must be\n\t\t\t * present, exact stripe count check comes afterwards\n\t\t\t */\n\t\t\tlen = btrfs_chunk_item_size(1);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tnum_stripes = btrfs_chunk_num_stripes(sb, chunk);\n\t\t\tlen = btrfs_chunk_item_size(num_stripes);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tret = read_one_chunk(root, &key, sb, chunk);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\t}\n\tfree_extent_buffer(sb);\n\treturn ret;\n\nout_short_read:\n\tprintk(KERN_ERR \"BTRFS: sys_array too short to read %u bytes at offset %u\\n\",\n\t\t\tlen, cur_offset);\n\tfree_extent_buffer(sb);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_read_sys_array(struct btrfs_root *root)\n{\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tstruct extent_buffer *sb;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *array_ptr;\n\tunsigned long sb_array_offset;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur_offset;\n\tstruct btrfs_key key;\n\n\tASSERT(BTRFS_SUPER_INFO_SIZE <= root->nodesize);\n\t/*\n\t * This will create extent buffer of nodesize, superblock size is\n\t * fixed to BTRFS_SUPER_INFO_SIZE. If nodesize > sb size, this will\n\t * overallocate but we can keep it as-is, only the first page is used.\n\t */\n\tsb = btrfs_find_create_tree_block(root, BTRFS_SUPER_INFO_OFFSET);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\tbtrfs_set_buffer_uptodate(sb);\n\tbtrfs_set_buffer_lockdep_class(root->root_key.objectid, sb, 0);\n\t/*\n\t * The sb extent buffer is artifical and just used to read the system array.\n\t * btrfs_set_buffer_uptodate() call does not properly mark all it's\n\t * pages up-to-date when the page is larger: extent does not cover the\n\t * whole page and consequently check_page_uptodate does not find all\n\t * the page's extents up-to-date (the hole beyond sb),\n\t * write_extent_buffer then triggers a WARN_ON.\n\t *\n\t * Regular short extents go through mark_extent_buffer_dirty/writeback cycle,\n\t * but sb spans only this function. Add an explicit SetPageUptodate call\n\t * to silence the warning eg. on PowerPC 64.\n\t */\n\tif (PAGE_CACHE_SIZE > BTRFS_SUPER_INFO_SIZE)\n\t\tSetPageUptodate(sb->pages[0]);\n\n\twrite_extent_buffer(sb, super_copy, 0, BTRFS_SUPER_INFO_SIZE);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\n\tarray_ptr = super_copy->sys_chunk_array;\n\tsb_array_offset = offsetof(struct btrfs_super_block, sys_chunk_array);\n\tcur_offset = 0;\n\n\twhile (cur_offset < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)array_ptr;\n\t\tlen = sizeof(*disk_key);\n\t\tif (cur_offset + len > array_size)\n\t\t\tgoto out_short_read;\n\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)sb_array_offset;\n\t\t\t/*\n\t\t\t * At least one btrfs_chunk with one stripe must be\n\t\t\t * present, exact stripe count check comes afterwards\n\t\t\t */\n\t\t\tlen = btrfs_chunk_item_size(1);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tnum_stripes = btrfs_chunk_num_stripes(sb, chunk);\n\t\t\tlen = btrfs_chunk_item_size(num_stripes);\n\t\t\tif (cur_offset + len > array_size)\n\t\t\t\tgoto out_short_read;\n\n\t\t\tret = read_one_chunk(root, &key, sb, chunk);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tarray_ptr += len;\n\t\tsb_array_offset += len;\n\t\tcur_offset += len;\n\t}\n\tfree_extent_buffer(sb);\n\treturn ret;\n\nout_short_read:\n\tprintk(KERN_ERR \"BTRFS: sys_array too short to read %u bytes at offset %u\\n\",\n\t\t\tlen, cur_offset);\n\tfree_extent_buffer(sb);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->chunk_mutex"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_magic",
          "args": [
            "disk_super"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "sectorsize"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "fs_info->bdi.ra_pages",
            "4 * 1024 * 1024 / PAGE_CACHE_SIZE"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "disk_super"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_workqueue",
          "args": [
            "\"extent-refs\"",
            "flags",
            "min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active)",
            "8"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "134-161",
          "snippet": "struct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstruct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "fs_devices->num_devices",
            "max_active"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "fs_devices->num_devices",
            "max_active"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_compat_ro_flags",
          "args": [
            "disk_super"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_incompat_flags",
          "args": [
            "disk_super",
            "features"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_stripesize",
          "args": [
            "disk_super"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_sectorsize",
          "args": [
            "disk_super"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_incompat_flags",
          "args": [
            "disk_super"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "disk_super->__unused_leafsize"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "disk_super"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_incompat_flags",
          "args": [
            "disk_super"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_parse_options",
          "args": [
            "tree_root",
            "options"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "388-759",
          "snippet": "int btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
            "static match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};\n\nint btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_oldest_super_backup",
          "args": [
            "fs_info",
            "generation"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "find_oldest_super_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1905-1917",
          "snippet": "static void find_oldest_super_backup(struct btrfs_fs_info *info,\n\t\t\t\t     u64 newest_gen)\n{\n\tint newest_index = -1;\n\n\tnewest_index = find_newest_super_backup(info, newest_gen);\n\t/* if there was garbage in there, just move along */\n\tif (newest_index == -1) {\n\t\tinfo->backup_root_index = 0;\n\t} else {\n\t\tinfo->backup_root_index = (newest_index + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void find_oldest_super_backup(struct btrfs_fs_info *info,\n\t\t\t\t     u64 newest_gen)\n{\n\tint newest_index = -1;\n\n\tnewest_index = find_newest_super_backup(info, newest_gen);\n\t/* if there was garbage in there, just move along */\n\tif (newest_index == -1) {\n\t\tinfo->backup_root_index = 0;\n\t} else {\n\t\tinfo->backup_root_index = (newest_index + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_super"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_flags",
          "args": [
            "disk_super"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "disk_super"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_super_valid",
          "args": [
            "fs_info",
            "sb->s_flags & MS_RDONLY"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_super_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3837-3946",
          "snippet": "static int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t      int read_only)\n{\n\tstruct btrfs_super_block *sb = fs_info->super_copy;\n\tint ret = 0;\n\n\tif (btrfs_super_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: tree_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_chunk_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: chunk_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_chunk_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_log_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: log_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_log_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The common minimum, we don't know if we can trust the nodesize/sectorsize\n\t * items yet, they'll be verified later. Issue just a warning.\n\t */\n\tif (!IS_ALIGNED(btrfs_super_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: tree_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_chunk_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: chunk_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_chunk_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_log_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: log_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_log_root(sb));\n\n\t/*\n\t * Check the lower bound, the alignment and other constraints are\n\t * checked later.\n\t */\n\tif (btrfs_super_nodesize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: nodesize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_nodesize(sb));\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sectorsize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: sectorsize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_sectorsize(sb));\n\t\tret = -EINVAL;\n\t}\n\n\tif (memcmp(fs_info->fsid, sb->dev_item.fsid, BTRFS_UUID_SIZE) != 0) {\n\t\tprintk(KERN_ERR \"BTRFS: dev_item UUID does not match fsid: %pU != %pU\\n\",\n\t\t\t\tfs_info->fsid, sb->dev_item.fsid);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Hint to catch really bogus numbers, bitflips or so, more exact checks are\n\t * done later\n\t */\n\tif (btrfs_super_num_devices(sb) > (1UL << 31))\n\t\tprintk(KERN_WARNING \"BTRFS: suspicious number of devices: %llu\\n\",\n\t\t\t\tbtrfs_super_num_devices(sb));\n\tif (btrfs_super_num_devices(sb) == 0) {\n\t\tprintk(KERN_ERR \"BTRFS: number of devices is 0\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (btrfs_super_bytenr(sb) != BTRFS_SUPER_INFO_OFFSET) {\n\t\tprintk(KERN_ERR \"BTRFS: super offset mismatch %llu != %u\\n\",\n\t\t\t\tbtrfs_super_bytenr(sb), BTRFS_SUPER_INFO_OFFSET);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Obvious sys_chunk_array corruptions, it must hold at least one key\n\t * and one chunk\n\t */\n\tif (btrfs_super_sys_array_size(sb) > BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too big %u > %u\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tBTRFS_SYSTEM_CHUNK_ARRAY_SIZE);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sys_array_size(sb) < sizeof(struct btrfs_disk_key)\n\t\t\t+ sizeof(struct btrfs_chunk)) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too small %u < %zu\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tsizeof(struct btrfs_disk_key)\n\t\t\t\t+ sizeof(struct btrfs_chunk));\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The generation is a global counter, we'll trust it more than the others\n\t * but it's still possible that it's the one that's wrong.\n\t */\n\tif (btrfs_super_generation(sb) < btrfs_super_chunk_root_generation(sb))\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < chunk_root_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_chunk_root_generation(sb));\n\tif (btrfs_super_generation(sb) < btrfs_super_cache_generation(sb)\n\t    && btrfs_super_cache_generation(sb) != (u64)-1)\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < cache_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_cache_generation(sb));\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    int read_only);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t\t    int read_only);\n\nstatic int btrfs_check_super_valid(struct btrfs_fs_info *fs_info,\n\t\t\t      int read_only)\n{\n\tstruct btrfs_super_block *sb = fs_info->super_copy;\n\tint ret = 0;\n\n\tif (btrfs_super_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: tree_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_chunk_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: chunk_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_chunk_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_log_root_level(sb) >= BTRFS_MAX_LEVEL) {\n\t\tprintk(KERN_ERR \"BTRFS: log_root level too big: %d >= %d\\n\",\n\t\t\t\tbtrfs_super_log_root_level(sb), BTRFS_MAX_LEVEL);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The common minimum, we don't know if we can trust the nodesize/sectorsize\n\t * items yet, they'll be verified later. Issue just a warning.\n\t */\n\tif (!IS_ALIGNED(btrfs_super_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: tree_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_chunk_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: chunk_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_chunk_root(sb));\n\tif (!IS_ALIGNED(btrfs_super_log_root(sb), 4096))\n\t\tprintk(KERN_WARNING \"BTRFS: log_root block unaligned: %llu\\n\",\n\t\t\t\tbtrfs_super_log_root(sb));\n\n\t/*\n\t * Check the lower bound, the alignment and other constraints are\n\t * checked later.\n\t */\n\tif (btrfs_super_nodesize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: nodesize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_nodesize(sb));\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sectorsize(sb) < 4096) {\n\t\tprintk(KERN_ERR \"BTRFS: sectorsize too small: %u < 4096\\n\",\n\t\t\t\tbtrfs_super_sectorsize(sb));\n\t\tret = -EINVAL;\n\t}\n\n\tif (memcmp(fs_info->fsid, sb->dev_item.fsid, BTRFS_UUID_SIZE) != 0) {\n\t\tprintk(KERN_ERR \"BTRFS: dev_item UUID does not match fsid: %pU != %pU\\n\",\n\t\t\t\tfs_info->fsid, sb->dev_item.fsid);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Hint to catch really bogus numbers, bitflips or so, more exact checks are\n\t * done later\n\t */\n\tif (btrfs_super_num_devices(sb) > (1UL << 31))\n\t\tprintk(KERN_WARNING \"BTRFS: suspicious number of devices: %llu\\n\",\n\t\t\t\tbtrfs_super_num_devices(sb));\n\tif (btrfs_super_num_devices(sb) == 0) {\n\t\tprintk(KERN_ERR \"BTRFS: number of devices is 0\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (btrfs_super_bytenr(sb) != BTRFS_SUPER_INFO_OFFSET) {\n\t\tprintk(KERN_ERR \"BTRFS: super offset mismatch %llu != %u\\n\",\n\t\t\t\tbtrfs_super_bytenr(sb), BTRFS_SUPER_INFO_OFFSET);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Obvious sys_chunk_array corruptions, it must hold at least one key\n\t * and one chunk\n\t */\n\tif (btrfs_super_sys_array_size(sb) > BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too big %u > %u\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tBTRFS_SYSTEM_CHUNK_ARRAY_SIZE);\n\t\tret = -EINVAL;\n\t}\n\tif (btrfs_super_sys_array_size(sb) < sizeof(struct btrfs_disk_key)\n\t\t\t+ sizeof(struct btrfs_chunk)) {\n\t\tprintk(KERN_ERR \"BTRFS: system chunk array too small %u < %zu\\n\",\n\t\t\t\tbtrfs_super_sys_array_size(sb),\n\t\t\t\tsizeof(struct btrfs_disk_key)\n\t\t\t\t+ sizeof(struct btrfs_chunk));\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * The generation is a global counter, we'll trust it more than the others\n\t * but it's still possible that it's the one that's wrong.\n\t */\n\tif (btrfs_super_generation(sb) < btrfs_super_chunk_root_generation(sb))\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < chunk_root_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_chunk_root_generation(sb));\n\tif (btrfs_super_generation(sb) < btrfs_super_cache_generation(sb)\n\t    && btrfs_super_cache_generation(sb) != (u64)-1)\n\t\tprintk(KERN_WARNING\n\t\t\t\"BTRFS: suspicious: generation < cache_generation: %llu < %llu\\n\",\n\t\t\tbtrfs_super_generation(sb), btrfs_super_cache_generation(sb));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fs_info->fsid",
            "fs_info->super_copy->fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fs_info->super_for_commit",
            "fs_info->super_copy",
            "sizeof(*fs_info->super_for_commit)"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fs_info->super_copy",
            "bh->b_data",
            "sizeof(*fs_info->super_copy)"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_super_csum",
          "args": [
            "bh->b_data"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_super_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "398-436",
          "snippet": "static int btrfs_check_super_csum(char *raw_disk_sb)\n{\n\tstruct btrfs_super_block *disk_sb =\n\t\t(struct btrfs_super_block *)raw_disk_sb;\n\tu16 csum_type = btrfs_super_csum_type(disk_sb);\n\tint ret = 0;\n\n\tif (csum_type == BTRFS_CSUM_TYPE_CRC32) {\n\t\tu32 crc = ~(u32)0;\n\t\tconst int csum_size = sizeof(crc);\n\t\tchar result[csum_size];\n\n\t\t/*\n\t\t * The super_block structure does not span the whole\n\t\t * BTRFS_SUPER_INFO_SIZE range, we expect that the unused space\n\t\t * is filled with zeros and is included in the checkum.\n\t\t */\n\t\tcrc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);\n\t\tbtrfs_csum_final(crc, result);\n\n\t\tif (memcmp(raw_disk_sb, result, csum_size))\n\t\t\tret = 1;\n\n\t\tif (ret && btrfs_super_generation(disk_sb) < 10) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: super block crcs don't match, older mkfs detected\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {\n\t\tprintk(KERN_ERR \"BTRFS: unsupported checksum algorithm %u\\n\",\n\t\t\t\tcsum_type);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_check_super_csum(char *raw_disk_sb)\n{\n\tstruct btrfs_super_block *disk_sb =\n\t\t(struct btrfs_super_block *)raw_disk_sb;\n\tu16 csum_type = btrfs_super_csum_type(disk_sb);\n\tint ret = 0;\n\n\tif (csum_type == BTRFS_CSUM_TYPE_CRC32) {\n\t\tu32 crc = ~(u32)0;\n\t\tconst int csum_size = sizeof(crc);\n\t\tchar result[csum_size];\n\n\t\t/*\n\t\t * The super_block structure does not span the whole\n\t\t * BTRFS_SUPER_INFO_SIZE range, we expect that the unused space\n\t\t * is filled with zeros and is included in the checkum.\n\t\t */\n\t\tcrc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);\n\t\tbtrfs_csum_final(crc, result);\n\n\t\tif (memcmp(raw_disk_sb, result, csum_size))\n\t\t\tret = 1;\n\n\t\tif (ret && btrfs_super_generation(disk_sb) < 10) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: super block crcs don't match, older mkfs detected\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {\n\t\tprintk(KERN_ERR \"BTRFS: unsupported checksum algorithm %u\\n\",\n\t\t\t\tcsum_type);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_dev_super",
          "args": [
            "fs_devices->latest_bdev"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_dev_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3084-3124",
          "snippet": "struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstruct buffer_head *btrfs_read_dev_super(struct block_device *bdev)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head *latest = NULL;\n\tstruct btrfs_super_block *super;\n\tint i;\n\tu64 transid = 0;\n\tu64 bytenr;\n\n\t/* we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tfor (i = 0; i < 1; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\tbreak;\n\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tsuper = (struct btrfs_super_block *)bh->b_data;\n\t\tif (btrfs_super_bytenr(super) != bytenr ||\n\t\t    btrfs_super_magic(super) != BTRFS_MAGIC) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!latest || btrfs_super_generation(super) > transid) {\n\t\t\tbrelse(latest);\n\t\t\tlatest = bh;\n\t\t\ttransid = btrfs_super_generation(super);\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n\treturn latest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "fs_devices->latest_bdev"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "77-91",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_stripe_hash_table",
          "args": [
            "fs_info"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_stripe_hash_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "199-247",
          "snippet": "int btrfs_alloc_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash_table *x;\n\tstruct btrfs_stripe_hash *cur;\n\tstruct btrfs_stripe_hash *h;\n\tint num_entries = 1 << BTRFS_STRIPE_HASH_TABLE_BITS;\n\tint i;\n\tint table_size;\n\n\tif (info->stripe_hash_table)\n\t\treturn 0;\n\n\t/*\n\t * The table is large, starting with order 4 and can go as high as\n\t * order 7 in case lock debugging is turned on.\n\t *\n\t * Try harder to allocate and fallback to vmalloc to lower the chance\n\t * of a failing mount.\n\t */\n\ttable_size = sizeof(*table) + sizeof(*h) * num_entries;\n\ttable = kzalloc(table_size, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!table) {\n\t\ttable = vzalloc(table_size);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&table->cache_lock);\n\tINIT_LIST_HEAD(&table->stripe_cache);\n\n\th = table->table;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tcur = h + i;\n\t\tINIT_LIST_HEAD(&cur->hash_list);\n\t\tspin_lock_init(&cur->lock);\n\t\tinit_waitqueue_head(&cur->wait);\n\t}\n\n\tx = cmpxchg(&info->stripe_hash_table, NULL, table);\n\tif (x) {\n\t\tif (is_vmalloc_addr(x))\n\t\t\tvfree(x);\n\t\telse\n\t\t\tkfree(x);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nint btrfs_alloc_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash_table *x;\n\tstruct btrfs_stripe_hash *cur;\n\tstruct btrfs_stripe_hash *h;\n\tint num_entries = 1 << BTRFS_STRIPE_HASH_TABLE_BITS;\n\tint i;\n\tint table_size;\n\n\tif (info->stripe_hash_table)\n\t\treturn 0;\n\n\t/*\n\t * The table is large, starting with order 4 and can go as high as\n\t * order 7 in case lock debugging is turned on.\n\t *\n\t * Try harder to allocate and fallback to vmalloc to lower the chance\n\t * of a failing mount.\n\t */\n\ttable_size = sizeof(*table) + sizeof(*h) * num_entries;\n\ttable = kzalloc(table_size, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!table) {\n\t\ttable = vzalloc(table_size);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&table->cache_lock);\n\tINIT_LIST_HEAD(&table->stripe_cache);\n\n\th = table->table;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tcur = h + i;\n\t\tINIT_LIST_HEAD(&cur->hash_list);\n\t\tspin_lock_init(&cur->lock);\n\t\tinit_waitqueue_head(&cur->wait);\n\t}\n\n\tx = cmpxchg(&info->stripe_hash_table, NULL, table);\n\tif (x) {\n\t\tif (is_vmalloc_addr(x))\n\t\t\tvfree(x);\n\t\telse\n\t\t\tkfree(x);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->pinned_chunks"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->async_submit_wait"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->transaction_blocked_wait"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->transaction_wait"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->transaction_throttle"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_free_cluster",
          "args": [
            "&fs_info->data_alloc_cluster"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2936-2944",
          "snippet": "void btrfs_init_free_cluster(struct btrfs_free_cluster *cluster)\n{\n\tspin_lock_init(&cluster->lock);\n\tspin_lock_init(&cluster->refill_lock);\n\tcluster->root = RB_ROOT;\n\tcluster->max_size = 0;\n\tINIT_LIST_HEAD(&cluster->block_group_list);\n\tcluster->block_group = NULL;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid btrfs_init_free_cluster(struct btrfs_free_cluster *cluster)\n{\n\tspin_lock_init(&cluster->lock);\n\tspin_lock_init(&cluster->refill_lock);\n\tcluster->root = RB_ROOT;\n\tcluster->max_size = 0;\n\tINIT_LIST_HEAD(&cluster->block_group_list);\n\tcluster->block_group = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->dirty_qgroups"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->dev_replace.lock"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->dev_replace.lock_management_lock"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->dev_replace.lock_finishing_cancel_unmount"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->dev_replace.nesting_level",
            "0"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&fs_info->uuid_tree_rescan_sem",
            "1"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&fs_info->subvol_sem"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&fs_info->cleanup_work_sem"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->transaction_kthread_mutex"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->chunk_mutex"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->tree_log_mutex"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->ordered_extent_flush_mutex"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->ordered_operations_mutex"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_io_tree_init",
          "args": [
            "&fs_info->freed_extents[1]",
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "198-206",
          "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->block_group_cache_lock"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_inode_hash",
          "args": [
            "fs_info->btree_inode"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "fs_info->btree_inode"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&BTRFS_I(fs_info->btree_inode)->location",
            "0",
            "sizeof(struct btrfs_key)"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_tree_init",
          "args": [
            "&BTRFS_I(fs_info->btree_inode)->extent_tree"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "34-39",
          "snippet": "void extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&BTRFS_I(fs_info->btree_inode)->rb_node"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "fs_info->btree_inode",
            "1"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "4096"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_async_reclaim_work",
          "args": [
            "&fs_info->async_reclaim_work"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_async_reclaim_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4363-4366",
          "snippet": "void btrfs_init_async_reclaim_work(struct work_struct *work)\n{\n\tINIT_WORK(work, btrfs_async_reclaim_metadata_space);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_init_async_reclaim_work(struct work_struct *work)\n{\n\tINIT_WORK(work, btrfs_async_reclaim_metadata_space);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->balance_wait_q"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->balance_cancel_req",
            "0"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->balance_pause_req",
            "0"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->balance_running",
            "0"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->scrub_pause_wait"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fs_info->replace_wait"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->scrub_cancel_req",
            "0"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->scrubs_paused",
            "0"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->scrub_pause_req",
            "0"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->scrubs_running",
            "0"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->scrub_lock"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_delayed_root",
          "args": [
            "fs_info->delayed_root"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_delayed_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.h",
          "lines": "89-99",
          "snippet": "static inline void btrfs_init_delayed_root(\n\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tatomic_set(&delayed_root->items, 0);\n\tatomic_set(&delayed_root->items_seq, 0);\n\tdelayed_root->nodes = 0;\n\tspin_lock_init(&delayed_root->lock);\n\tinit_waitqueue_head(&delayed_root->wait);\n\tINIT_LIST_HEAD(&delayed_root->node_list);\n\tINIT_LIST_HEAD(&delayed_root->prepare_list);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <linux/atomic.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n\nstatic inline void btrfs_init_delayed_root(\n\t\t\t\tstruct btrfs_delayed_root *delayed_root)\n{\n\tatomic_set(&delayed_root->items, 0);\n\tatomic_set(&delayed_root->items_seq, 0);\n\tdelayed_root->nodes = 0;\n\tspin_lock_init(&delayed_root->lock);\n\tinit_waitqueue_head(&delayed_root->wait);\n\tINIT_LIST_HEAD(&delayed_root->node_list);\n\tINIT_LIST_HEAD(&delayed_root->prepare_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct btrfs_delayed_root)",
            "GFP_NOFS"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->ordered_root_lock"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->ordered_roots"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "num_online_cpus() + 2",
            "8"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fs_info->reada_tree",
            "GFP_NOFS & ~__GFP_WAIT"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "NSEC_PER_SEC",
            "64"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&fs_info->tree_mod_seq",
            "0"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->qgroup_op_seq",
            "0"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->defrag_running",
            "0"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->nr_async_bios",
            "0"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->async_submit_draining",
            "0"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->async_delalloc_pages",
            "0"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->nr_async_submits",
            "0"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_block_rsv",
          "args": [
            "&fs_info->delayed_block_rsv",
            "BTRFS_BLOCK_RSV_DELOPS"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4671-4676",
          "snippet": "void btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mapping_init",
          "args": [
            "&fs_info->mapping_tree"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mapping_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4716-4719",
          "snippet": "void btrfs_mapping_init(struct btrfs_mapping_tree *tree)\n{\n\textent_map_tree_init(&tree->map_tree);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_mapping_init(struct btrfs_mapping_tree *tree)\n{\n\textent_map_tree_init(&tree->map_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->unused_bgs"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->space_info"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->dirty_cowonly_roots"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&fs_info->kobj_unregister"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seqlock_init",
          "args": [
            "&fs_info->profiles_lock"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->delalloc_root_mutex"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->reloc_mutex"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->unused_bg_unpin_mutex"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->unused_bgs_lock"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->super_lock"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->free_chunk_lock"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->defrag_inodes_lock"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->delayed_iput_lock"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->delalloc_root_lock"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->caching_block_groups"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->delalloc_roots"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->delayed_iputs"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->dead_roots"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->trans_list"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fs_info->buffer_radix",
            "GFP_ATOMIC"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fs_info->fs_roots_radix",
            "GFP_ATOMIC"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "fs_info->btree_inode->i_mapping",
            "GFP_NOFS"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&fs_info->bio_counter",
            "0",
            "GFP_KERNEL"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&fs_info->delalloc_bytes",
            "0",
            "GFP_KERNEL"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&fs_info->dirty_metadata_bytes",
            "0",
            "GFP_KERNEL"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_bdi",
          "args": [
            "fs_info",
            "&fs_info->bdi"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "setup_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1723-1735",
          "snippet": "static int setup_bdi(struct btrfs_fs_info *info, struct backing_dev_info *bdi)\n{\n\tint err;\n\n\terr = bdi_setup_and_register(bdi, \"btrfs\");\n\tif (err)\n\t\treturn err;\n\n\tbdi->ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\tbdi->congested_fn\t= btrfs_congested_fn;\n\tbdi->congested_data\t= info;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int setup_bdi(struct btrfs_fs_info *info, struct backing_dev_info *bdi)\n{\n\tint err;\n\n\terr = bdi_setup_and_register(bdi, \"btrfs\");\n\tif (err)\n\t\treturn err;\n\n\tbdi->ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\tbdi->congested_fn\t= btrfs_congested_fn;\n\tbdi->congested_data\t= info;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct extent_io_ops btree_extent_io_ops;\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\nstatic const struct address_space_operations btree_aops = {\n\t.readpage\t= btree_readpage,\n\t.writepages\t= btree_writepages,\n\t.releasepage\t= btree_releasepage,\n\t.invalidatepage = btree_invalidatepage,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= btree_migratepage,\n#endif\n\t.set_page_dirty = btree_set_page_dirty,\n};\nstatic struct extent_io_ops btree_extent_io_ops = {\n\t.readpage_end_io_hook = btree_readpage_end_io_hook,\n\t.readpage_io_failed_hook = btree_io_failed_hook,\n\t.submit_bio_hook = btree_submit_bio_hook,\n\t/* note we're sharing with inode.c for the merge bio hook */\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n};\n\nint open_ctree(struct super_block *sb,\n\t       struct btrfs_fs_devices *fs_devices,\n\t       char *options)\n{\n\tu32 sectorsize;\n\tu32 nodesize;\n\tu32 stripesize;\n\tu64 generation;\n\tu64 features;\n\tstruct btrfs_key location;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *tree_root;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_root *csum_root;\n\tstruct btrfs_root *chunk_root;\n\tstruct btrfs_root *dev_root;\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct btrfs_root *log_tree_root;\n\tint ret;\n\tint err = -EINVAL;\n\tint num_backups_tried = 0;\n\tint backup_index = 0;\n\tint max_active;\n\tint flags = WQ_MEM_RECLAIM | WQ_FREEZABLE | WQ_UNBOUND;\n\tbool create_uuid_tree;\n\tbool check_uuid_tree;\n\n\ttree_root = fs_info->tree_root = btrfs_alloc_root(fs_info);\n\tchunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);\n\tif (!tree_root || !chunk_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = init_srcu_struct(&fs_info->subvol_srcu);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail;\n\t}\n\n\tret = setup_bdi(fs_info, &fs_info->bdi);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_srcu;\n\t}\n\n\tret = percpu_counter_init(&fs_info->dirty_metadata_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_bdi;\n\t}\n\tfs_info->dirty_metadata_batch = PAGE_CACHE_SIZE *\n\t\t\t\t\t(1 + ilog2(nr_cpu_ids));\n\n\tret = percpu_counter_init(&fs_info->delalloc_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_dirty_metadata_bytes;\n\t}\n\n\tret = percpu_counter_init(&fs_info->bio_counter, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_delalloc_bytes;\n\t}\n\n\tfs_info->btree_inode = new_inode(sb);\n\tif (!fs_info->btree_inode) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_bio_counter;\n\t}\n\n\tmapping_set_gfp_mask(fs_info->btree_inode->i_mapping, GFP_NOFS);\n\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&fs_info->trans_list);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->delayed_iputs);\n\tINIT_LIST_HEAD(&fs_info->delalloc_roots);\n\tINIT_LIST_HEAD(&fs_info->caching_block_groups);\n\tspin_lock_init(&fs_info->delalloc_root_lock);\n\tspin_lock_init(&fs_info->trans_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->delayed_iput_lock);\n\tspin_lock_init(&fs_info->defrag_inodes_lock);\n\tspin_lock_init(&fs_info->free_chunk_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->unused_bgs_lock);\n\tmutex_init(&fs_info->unused_bg_unpin_mutex);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tmutex_init(&fs_info->reloc_mutex);\n\tmutex_init(&fs_info->delalloc_root_mutex);\n\tseqlock_init(&fs_info->profiles_lock);\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tINIT_LIST_HEAD(&fs_info->dirty_cowonly_roots);\n\tINIT_LIST_HEAD(&fs_info->space_info);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_LIST_HEAD(&fs_info->unused_bgs);\n\tbtrfs_mapping_init(&fs_info->mapping_tree);\n\tbtrfs_init_block_rsv(&fs_info->global_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_GLOBAL);\n\tbtrfs_init_block_rsv(&fs_info->delalloc_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELALLOC);\n\tbtrfs_init_block_rsv(&fs_info->trans_block_rsv, BTRFS_BLOCK_RSV_TRANS);\n\tbtrfs_init_block_rsv(&fs_info->chunk_block_rsv, BTRFS_BLOCK_RSV_CHUNK);\n\tbtrfs_init_block_rsv(&fs_info->empty_block_rsv, BTRFS_BLOCK_RSV_EMPTY);\n\tbtrfs_init_block_rsv(&fs_info->delayed_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELOPS);\n\tatomic_set(&fs_info->nr_async_submits, 0);\n\tatomic_set(&fs_info->async_delalloc_pages, 0);\n\tatomic_set(&fs_info->async_submit_draining, 0);\n\tatomic_set(&fs_info->nr_async_bios, 0);\n\tatomic_set(&fs_info->defrag_running, 0);\n\tatomic_set(&fs_info->qgroup_op_seq, 0);\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tfs_info->sb = sb;\n\tfs_info->max_inline = BTRFS_DEFAULT_MAX_INLINE;\n\tfs_info->metadata_ratio = 0;\n\tfs_info->defrag_inodes = RB_ROOT;\n\tfs_info->free_chunk_space = 0;\n\tfs_info->tree_mod_log = RB_ROOT;\n\tfs_info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\tfs_info->avg_delayed_ref_runtime = div64_u64(NSEC_PER_SEC, 64);\n\t/* readahead state */\n\tINIT_RADIX_TREE(&fs_info->reada_tree, GFP_NOFS & ~__GFP_WAIT);\n\tspin_lock_init(&fs_info->reada_lock);\n\n\tfs_info->thread_pool_size = min_t(unsigned long,\n\t\t\t\t\t  num_online_cpus() + 2, 8);\n\n\tINIT_LIST_HEAD(&fs_info->ordered_roots);\n\tspin_lock_init(&fs_info->ordered_root_lock);\n\tfs_info->delayed_root = kmalloc(sizeof(struct btrfs_delayed_root),\n\t\t\t\t\tGFP_NOFS);\n\tif (!fs_info->delayed_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_iput;\n\t}\n\tbtrfs_init_delayed_root(fs_info->delayed_root);\n\n\tmutex_init(&fs_info->scrub_lock);\n\tatomic_set(&fs_info->scrubs_running, 0);\n\tatomic_set(&fs_info->scrub_pause_req, 0);\n\tatomic_set(&fs_info->scrubs_paused, 0);\n\tatomic_set(&fs_info->scrub_cancel_req, 0);\n\tinit_waitqueue_head(&fs_info->replace_wait);\n\tinit_waitqueue_head(&fs_info->scrub_pause_wait);\n\tfs_info->scrub_workers_refcnt = 0;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tfs_info->check_integrity_print_mask = 0;\n#endif\n\n\tspin_lock_init(&fs_info->balance_lock);\n\tmutex_init(&fs_info->balance_mutex);\n\tatomic_set(&fs_info->balance_running, 0);\n\tatomic_set(&fs_info->balance_pause_req, 0);\n\tatomic_set(&fs_info->balance_cancel_req, 0);\n\tfs_info->balance_ctl = NULL;\n\tinit_waitqueue_head(&fs_info->balance_wait_q);\n\tbtrfs_init_async_reclaim_work(&fs_info->async_reclaim_work);\n\n\tsb->s_blocksize = 4096;\n\tsb->s_blocksize_bits = blksize_bits(4096);\n\tsb->s_bdi = &fs_info->bdi;\n\n\tfs_info->btree_inode->i_ino = BTRFS_BTREE_INODE_OBJECTID;\n\tset_nlink(fs_info->btree_inode, 1);\n\t/*\n\t * we set the i_size on the btree inode to the max possible int.\n\t * the real end of the address space is determined by all of\n\t * the devices in the system\n\t */\n\tfs_info->btree_inode->i_size = OFFSET_MAX;\n\tfs_info->btree_inode->i_mapping->a_ops = &btree_aops;\n\n\tRB_CLEAR_NODE(&BTRFS_I(fs_info->btree_inode)->rb_node);\n\textent_io_tree_init(&BTRFS_I(fs_info->btree_inode)->io_tree,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tBTRFS_I(fs_info->btree_inode)->io_tree.track_uptodate = 0;\n\textent_map_tree_init(&BTRFS_I(fs_info->btree_inode)->extent_tree);\n\n\tBTRFS_I(fs_info->btree_inode)->io_tree.ops = &btree_extent_io_ops;\n\n\tBTRFS_I(fs_info->btree_inode)->root = tree_root;\n\tmemset(&BTRFS_I(fs_info->btree_inode)->location, 0,\n\t       sizeof(struct btrfs_key));\n\tset_bit(BTRFS_INODE_DUMMY,\n\t\t&BTRFS_I(fs_info->btree_inode)->runtime_flags);\n\tbtrfs_insert_inode_hash(fs_info->btree_inode);\n\n\tspin_lock_init(&fs_info->block_group_cache_lock);\n\tfs_info->block_group_cache_tree = RB_ROOT;\n\tfs_info->first_logical_byte = (u64)-1;\n\n\textent_io_tree_init(&fs_info->freed_extents[0],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\textent_io_tree_init(&fs_info->freed_extents[1],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\tfs_info->do_barriers = 1;\n\n\n\tmutex_init(&fs_info->ordered_operations_mutex);\n\tmutex_init(&fs_info->ordered_extent_flush_mutex);\n\tmutex_init(&fs_info->tree_log_mutex);\n\tmutex_init(&fs_info->chunk_mutex);\n\tmutex_init(&fs_info->transaction_kthread_mutex);\n\tmutex_init(&fs_info->cleaner_mutex);\n\tmutex_init(&fs_info->volume_mutex);\n\tinit_rwsem(&fs_info->commit_root_sem);\n\tinit_rwsem(&fs_info->cleanup_work_sem);\n\tinit_rwsem(&fs_info->subvol_sem);\n\tsema_init(&fs_info->uuid_tree_rescan_sem, 1);\n\tfs_info->dev_replace.lock_owner = 0;\n\tatomic_set(&fs_info->dev_replace.nesting_level, 0);\n\tmutex_init(&fs_info->dev_replace.lock_finishing_cancel_unmount);\n\tmutex_init(&fs_info->dev_replace.lock_management_lock);\n\tmutex_init(&fs_info->dev_replace.lock);\n\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_op_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tfs_info->qgroup_seq = 1;\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tfs_info->qgroup_ulist = NULL;\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\n\tbtrfs_init_free_cluster(&fs_info->meta_alloc_cluster);\n\tbtrfs_init_free_cluster(&fs_info->data_alloc_cluster);\n\n\tinit_waitqueue_head(&fs_info->transaction_throttle);\n\tinit_waitqueue_head(&fs_info->transaction_wait);\n\tinit_waitqueue_head(&fs_info->transaction_blocked_wait);\n\tinit_waitqueue_head(&fs_info->async_submit_wait);\n\n\tINIT_LIST_HEAD(&fs_info->pinned_chunks);\n\n\tret = btrfs_alloc_stripe_hash_table(fs_info);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\t__setup_root(4096, 4096, 4096, tree_root,\n\t\t     fs_info, BTRFS_ROOT_TREE_OBJECTID);\n\n\tinvalidate_bdev(fs_devices->latest_bdev);\n\n\t/*\n\t * Read super block and check the signature bytes only\n\t */\n\tbh = btrfs_read_dev_super(fs_devices->latest_bdev);\n\tif (!bh) {\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * We want to check superblock checksum, the type is stored inside.\n\t * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).\n\t */\n\tif (btrfs_check_super_csum(bh->b_data)) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock checksum mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * super_copy is zeroed at allocation time and we never touch the\n\t * following bytes up to INFO_SIZE, the checksum is calculated from\n\t * the whole block of INFO_SIZE\n\t */\n\tmemcpy(fs_info->super_copy, bh->b_data, sizeof(*fs_info->super_copy));\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_for_commit));\n\tbrelse(bh);\n\n\tmemcpy(fs_info->fsid, fs_info->super_copy->fsid, BTRFS_FSID_SIZE);\n\n\tret = btrfs_check_super_valid(fs_info, sb->s_flags & MS_RDONLY);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock contains fatal errors\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\tgoto fail_alloc;\n\n\t/* check FS state, whether FS is broken. */\n\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_ERROR)\n\t\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n\n\t/*\n\t * run through our array of backup supers and setup\n\t * our ring pointer to the oldest one\n\t */\n\tgeneration = btrfs_super_generation(disk_super);\n\tfind_oldest_super_backup(fs_info, generation);\n\n\t/*\n\t * In the long term, we'll store the compression type in the super\n\t * block, and it'll be used for per file compression control.\n\t */\n\tfs_info->compress_type = BTRFS_COMPRESS_ZLIB;\n\n\tret = btrfs_parse_options(tree_root, options);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super) &\n\t\t~BTRFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because of \"\n\t\t       \"unsupported optional features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Leafsize and nodesize were always equal, this is only a sanity check.\n\t */\n\tif (le32_to_cpu(disk_super->__unused_leafsize) !=\n\t    btrfs_super_nodesize(disk_super)) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksizes don't match.  node %d leaf %d\\n\",\n\t\t       btrfs_super_nodesize(disk_super),\n\t\t       le32_to_cpu(disk_super->__unused_leafsize));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\tif (btrfs_super_nodesize(disk_super) > BTRFS_MAX_METADATA_BLOCKSIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksize (%d) was too large\\n\",\n\t\t       btrfs_super_nodesize(disk_super));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tfeatures |= BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF;\n\tif (tree_root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO;\n\n\tif (features & BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA)\n\t\tprintk(KERN_INFO \"BTRFS: has skinny extents\\n\");\n\n\t/*\n\t * flag our filesystem as having big metadata blocks if\n\t * they are bigger than the page size\n\t */\n\tif (btrfs_super_nodesize(disk_super) > PAGE_CACHE_SIZE) {\n\t\tif (!(features & BTRFS_FEATURE_INCOMPAT_BIG_METADATA))\n\t\t\tprintk(KERN_INFO \"BTRFS: flagging fs with big metadata feature\\n\");\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_BIG_METADATA;\n\t}\n\n\tnodesize = btrfs_super_nodesize(disk_super);\n\tsectorsize = btrfs_super_sectorsize(disk_super);\n\tstripesize = btrfs_super_stripesize(disk_super);\n\tfs_info->dirty_metadata_batch = nodesize * (1 + ilog2(nr_cpu_ids));\n\tfs_info->delalloc_batch = sectorsize * 512 * (1 + ilog2(nr_cpu_ids));\n\n\t/*\n\t * mixed block groups end up with duplicate but slightly offset\n\t * extent buffers for the same range.  It leads to corruptions\n\t */\n\tif ((features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS) &&\n\t    (sectorsize != nodesize)) {\n\t\tprintk(KERN_ERR \"BTRFS: unequal leaf/node/sector sizes \"\n\t\t\t\t\"are not allowed for mixed block groups on %s\\n\",\n\t\t\t\tsb->s_id);\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Needn't use the lock because there is no other task which will\n\t * update the flag.\n\t */\n\tbtrfs_set_super_incompat_flags(disk_super, features);\n\n\tfeatures = btrfs_super_compat_ro_flags(disk_super) &\n\t\t~BTRFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported option features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tmax_active = fs_info->thread_pool_size;\n\n\tfs_info->workers =\n\t\tbtrfs_alloc_workqueue(\"worker\", flags | WQ_HIGHPRI,\n\t\t\t\t      max_active, 16);\n\n\tfs_info->delalloc_workers =\n\t\tbtrfs_alloc_workqueue(\"delalloc\", flags, max_active, 2);\n\n\tfs_info->flush_workers =\n\t\tbtrfs_alloc_workqueue(\"flush_delalloc\", flags, max_active, 0);\n\n\tfs_info->caching_workers =\n\t\tbtrfs_alloc_workqueue(\"cache\", flags, max_active, 0);\n\n\t/*\n\t * a higher idle thresh on the submit workers makes it much more\n\t * likely that bios will be send down in a sane order to the\n\t * devices\n\t */\n\tfs_info->submit_workers =\n\t\tbtrfs_alloc_workqueue(\"submit\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 64);\n\n\tfs_info->fixup_workers =\n\t\tbtrfs_alloc_workqueue(\"fixup\", flags, 1, 0);\n\n\t/*\n\t * endios are largely parallel and should have a very\n\t * low idle thresh\n\t */\n\tfs_info->endio_workers =\n\t\tbtrfs_alloc_workqueue(\"endio\", flags, max_active, 4);\n\tfs_info->endio_meta_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta\", flags, max_active, 4);\n\tfs_info->endio_meta_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta-write\", flags, max_active, 2);\n\tfs_info->endio_raid56_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-raid56\", flags, max_active, 4);\n\tfs_info->endio_repair_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-repair\", flags, 1, 0);\n\tfs_info->rmw_workers =\n\t\tbtrfs_alloc_workqueue(\"rmw\", flags, max_active, 2);\n\tfs_info->endio_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-write\", flags, max_active, 2);\n\tfs_info->endio_freespace_worker =\n\t\tbtrfs_alloc_workqueue(\"freespace-write\", flags, max_active, 0);\n\tfs_info->delayed_workers =\n\t\tbtrfs_alloc_workqueue(\"delayed-meta\", flags, max_active, 0);\n\tfs_info->readahead_workers =\n\t\tbtrfs_alloc_workqueue(\"readahead\", flags, max_active, 2);\n\tfs_info->qgroup_rescan_workers =\n\t\tbtrfs_alloc_workqueue(\"qgroup-rescan\", flags, 1, 0);\n\tfs_info->extent_workers =\n\t\tbtrfs_alloc_workqueue(\"extent-refs\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 8);\n\n\tif (!(fs_info->workers && fs_info->delalloc_workers &&\n\t      fs_info->submit_workers && fs_info->flush_workers &&\n\t      fs_info->endio_workers && fs_info->endio_meta_workers &&\n\t      fs_info->endio_meta_write_workers &&\n\t      fs_info->endio_repair_workers &&\n\t      fs_info->endio_write_workers && fs_info->endio_raid56_workers &&\n\t      fs_info->endio_freespace_worker && fs_info->rmw_workers &&\n\t      fs_info->caching_workers && fs_info->readahead_workers &&\n\t      fs_info->fixup_workers && fs_info->delayed_workers &&\n\t      fs_info->extent_workers &&\n\t      fs_info->qgroup_rescan_workers)) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tfs_info->bdi.ra_pages *= btrfs_super_num_devices(disk_super);\n\tfs_info->bdi.ra_pages = max(fs_info->bdi.ra_pages,\n\t\t\t\t    4 * 1024 * 1024 / PAGE_CACHE_SIZE);\n\n\ttree_root->nodesize = nodesize;\n\ttree_root->sectorsize = sectorsize;\n\ttree_root->stripesize = stripesize;\n\n\tsb->s_blocksize = sectorsize;\n\tsb->s_blocksize_bits = blksize_bits(sectorsize);\n\n\tif (btrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\tprintk(KERN_ERR \"BTRFS: valid FS not found on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tif (sectorsize != PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: incompatible sector size (%lu) \"\n\t\t       \"found on %s\\n\", (unsigned long)sectorsize, sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\tret = btrfs_read_sys_array(tree_root);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read the system \"\n\t\t       \"array on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tgeneration = btrfs_super_chunk_root_generation(disk_super);\n\n\t__setup_root(nodesize, sectorsize, stripesize, chunk_root,\n\t\t     fs_info, BTRFS_CHUNK_TREE_OBJECTID);\n\n\tchunk_root->node = read_tree_block(chunk_root,\n\t\t\t\t\t   btrfs_super_chunk_root(disk_super),\n\t\t\t\t\t   generation);\n\tif (!chunk_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &chunk_root->node->bflags)) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk root on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\tbtrfs_set_root_node(&chunk_root->root_item, chunk_root->node);\n\tchunk_root->commit_root = btrfs_root_node(chunk_root);\n\n\tread_extent_buffer(chunk_root->node, fs_info->chunk_tree_uuid,\n\t   btrfs_header_chunk_tree_uuid(chunk_root->node), BTRFS_UUID_SIZE);\n\n\tret = btrfs_read_chunk_tree(chunk_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk tree on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\n\t/*\n\t * keep the device that is marked to be the target device for the\n\t * dev_replace procedure\n\t */\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 0);\n\n\tif (!fs_devices->latest_bdev) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read devices on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\nretry_root_backup:\n\tgeneration = btrfs_super_generation(disk_super);\n\n\ttree_root->node = read_tree_block(tree_root,\n\t\t\t\t\t  btrfs_super_root(disk_super),\n\t\t\t\t\t  generation);\n\tif (!tree_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &tree_root->node->bflags)) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to read tree root on %s\\n\",\n\t\t       sb->s_id);\n\n\t\tgoto recovery_tree_root;\n\t}\n\n\tbtrfs_set_root_node(&tree_root->root_item, tree_root->node);\n\ttree_root->commit_root = btrfs_root_node(tree_root);\n\tbtrfs_set_root_refs(&tree_root->root_item, 1);\n\n\tlocation.objectid = BTRFS_EXTENT_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\textent_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(extent_root)) {\n\t\tret = PTR_ERR(extent_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &extent_root->state);\n\tfs_info->extent_root = extent_root;\n\n\tlocation.objectid = BTRFS_DEV_TREE_OBJECTID;\n\tdev_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(dev_root)) {\n\t\tret = PTR_ERR(dev_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &dev_root->state);\n\tfs_info->dev_root = dev_root;\n\tbtrfs_init_devices_late(fs_info);\n\n\tlocation.objectid = BTRFS_CSUM_TREE_OBJECTID;\n\tcsum_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(csum_root)) {\n\t\tret = PTR_ERR(csum_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &csum_root->state);\n\tfs_info->csum_root = csum_root;\n\n\tlocation.objectid = BTRFS_QUOTA_TREE_OBJECTID;\n\tquota_root = btrfs_read_tree_root(tree_root, &location);\n\tif (!IS_ERR(quota_root)) {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &quota_root->state);\n\t\tfs_info->quota_enabled = 1;\n\t\tfs_info->pending_quota_state = 1;\n\t\tfs_info->quota_root = quota_root;\n\t}\n\n\tlocation.objectid = BTRFS_UUID_TREE_OBJECTID;\n\tuuid_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tif (ret != -ENOENT)\n\t\t\tgoto recovery_tree_root;\n\t\tcreate_uuid_tree = true;\n\t\tcheck_uuid_tree = false;\n\t} else {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &uuid_root->state);\n\t\tfs_info->uuid_root = uuid_root;\n\t\tcreate_uuid_tree = false;\n\t\tcheck_uuid_tree =\n\t\t    generation != btrfs_super_uuid_tree_generation(disk_super);\n\t}\n\n\tfs_info->generation = generation;\n\tfs_info->last_trans_committed = generation;\n\n\tret = btrfs_recover_balance(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to recover balance\\n\");\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_stats(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to init dev_stats: %d\\n\",\n\t\t       ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_replace(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init dev_replace: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 1);\n\n\tret = btrfs_sysfs_add_one(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init sysfs interface: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_space_info(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to initial space info: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\n\tret = btrfs_read_block_groups(extent_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to read block groups: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\tfs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\tif (fs_info->fs_devices->missing_devices >\n\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tprintk(KERN_WARNING \"BTRFS: \"\n\t\t\t\"too many missing devices, writeable mount is not allowed\\n\");\n\t\tgoto fail_sysfs;\n\t}\n\n\tfs_info->cleaner_kthread = kthread_run(cleaner_kthread, tree_root,\n\t\t\t\t\t       \"btrfs-cleaner\");\n\tif (IS_ERR(fs_info->cleaner_kthread))\n\t\tgoto fail_sysfs;\n\n\tfs_info->transaction_kthread = kthread_run(transaction_kthread,\n\t\t\t\t\t\t   tree_root,\n\t\t\t\t\t\t   \"btrfs-transaction\");\n\tif (IS_ERR(fs_info->transaction_kthread))\n\t\tgoto fail_cleaner;\n\n\tif (!btrfs_test_opt(tree_root, SSD) &&\n\t    !btrfs_test_opt(tree_root, NOSSD) &&\n\t    !fs_info->fs_devices->rotating) {\n\t\tprintk(KERN_INFO \"BTRFS: detected SSD devices, enabling SSD \"\n\t\t       \"mode\\n\");\n\t\tbtrfs_set_opt(fs_info->mount_opt, SSD);\n\t}\n\n\t/*\n\t * Mount does not set all options immediatelly, we can do it now and do\n\t * not have to wait for transaction commit\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(tree_root, CHECK_INTEGRITY)) {\n\t\tret = btrfsic_mount(tree_root, fs_devices,\n\t\t\t\t    btrfs_test_opt(tree_root,\n\t\t\t\t\tCHECK_INTEGRITY_INCLUDING_EXTENT_DATA) ?\n\t\t\t\t    1 : 0,\n\t\t\t\t    fs_info->check_integrity_print_mask);\n\t\tif (ret)\n\t\t\tprintk(KERN_WARNING \"BTRFS: failed to initialize\"\n\t\t\t       \" integrity check module %s\\n\", sb->s_id);\n\t}\n#endif\n\tret = btrfs_read_qgroup_config(fs_info);\n\tif (ret)\n\t\tgoto fail_trans_kthread;\n\n\t/* do not make disk changes in broken FS */\n\tif (btrfs_super_log_root(disk_super) != 0) {\n\t\tu64 bytenr = btrfs_super_log_root(disk_super);\n\n\t\tif (fs_devices->rw_devices == 0) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: log replay required \"\n\t\t\t       \"on RO media\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tlog_tree_root = btrfs_alloc_root(fs_info);\n\t\tif (!log_tree_root) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\t__setup_root(nodesize, sectorsize, stripesize,\n\t\t\t     log_tree_root, fs_info, BTRFS_TREE_LOG_OBJECTID);\n\n\t\tlog_tree_root->node = read_tree_block(tree_root, bytenr,\n\t\t\t\t\t\t      generation + 1);\n\t\tif (!log_tree_root->node ||\n\t\t    !extent_buffer_uptodate(log_tree_root->node)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: failed to read log tree\\n\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t\t/* returns with log_tree_root freed on success */\n\t\tret = btrfs_recover_log_trees(log_tree_root);\n\t\tif (ret) {\n\t\t\tbtrfs_error(tree_root->fs_info, ret,\n\t\t\t\t    \"Failed to recover log tree\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tret = btrfs_commit_super(tree_root);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tret = btrfs_find_orphan_roots(tree_root);\n\tif (ret)\n\t\tgoto fail_qgroup;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto fail_qgroup;\n\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(tree_root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"BTRFS: failed to recover relocation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tlocation.objectid = BTRFS_FS_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tfs_info->fs_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(fs_info->fs_root)) {\n\t\terr = PTR_ERR(fs_info->fs_root);\n\t\tgoto fail_qgroup;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_read(&fs_info->cleanup_work_sem);\n\tif ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||\n\t    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {\n\t\tup_read(&fs_info->cleanup_work_sem);\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\tup_read(&fs_info->cleanup_work_sem);\n\n\tret = btrfs_resume_balance_async(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to resume balance\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_resume_dev_replace_async(fs_info);\n\tif (ret) {\n\t\tpr_warn(\"BTRFS: failed to resume dev_replace\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_qgroup_rescan_resume(fs_info);\n\n\tif (create_uuid_tree) {\n\t\tpr_info(\"BTRFS: creating UUID tree\\n\");\n\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to create the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else if (check_uuid_tree ||\n\t\t   btrfs_test_opt(tree_root, RESCAN_UUID_TREE)) {\n\t\tpr_info(\"BTRFS: checking UUID tree\\n\");\n\t\tret = btrfs_check_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to check the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfs_info->update_uuid_tree_gen = 1;\n\t}\n\n\tfs_info->open = 1;\n\n\treturn 0;\n\nfail_qgroup:\n\tbtrfs_free_qgroup_config(fs_info);\nfail_trans_kthread:\n\tkthread_stop(fs_info->transaction_kthread);\n\tbtrfs_cleanup_transaction(fs_info->tree_root);\n\tbtrfs_free_fs_roots(fs_info);\nfail_cleaner:\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\t/*\n\t * make sure we're done with the btree inode before we stop our\n\t * kthreads\n\t */\n\tfilemap_write_and_wait(fs_info->btree_inode->i_mapping);\n\nfail_sysfs:\n\tbtrfs_sysfs_remove_one(fs_info);\n\nfail_block_groups:\n\tbtrfs_put_block_group_cache(fs_info);\n\tbtrfs_free_block_groups(fs_info);\n\nfail_tree_roots:\n\tfree_root_pointers(fs_info, 1);\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\nfail_sb_buffer:\n\tbtrfs_stop_all_workers(fs_info);\nfail_alloc:\nfail_iput:\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tiput(fs_info->btree_inode);\nfail_bio_counter:\n\tpercpu_counter_destroy(&fs_info->bio_counter);\nfail_delalloc_bytes:\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\nfail_dirty_metadata_bytes:\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\nfail_bdi:\n\tbdi_destroy(&fs_info->bdi);\nfail_srcu:\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\nfail:\n\tbtrfs_free_stripe_hash_table(fs_info);\n\tbtrfs_close_devices(fs_info->fs_devices);\n\treturn err;\n\nrecovery_tree_root:\n\tif (!btrfs_test_opt(tree_root, RECOVERY))\n\t\tgoto fail_tree_roots;\n\n\tfree_root_pointers(fs_info, 0);\n\n\t/* don't use the log in recovery mode, it won't be valid */\n\tbtrfs_set_super_log_root(disk_super, 0);\n\n\t/* we can't trust the free space cache either */\n\tbtrfs_set_opt(fs_info->mount_opt, CLEAR_CACHE);\n\n\tret = next_root_backup(fs_info, fs_info->super_copy,\n\t\t\t       &num_backups_tried, &backup_index);\n\tif (ret == -1)\n\t\tgoto fail_block_groups;\n\tgoto retry_root_backup;\n}"
  },
  {
    "function_name": "btrfs_free_fs_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2112-2147",
    "snippet": "void btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_destroy_pinned_extent",
          "args": [
            "fs_info->tree_root",
            "fs_info->pinned_extents"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_pinned_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4153-4185",
          "snippet": "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents)\n{\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\tbool loop = true;\n\n\tunpin = pinned_extents;\nagain:\n\twhile (1) {\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tbtrfs_error_unpin_extent_range(root, start, end);\n\t\tcond_resched();\n\t}\n\n\tif (loop) {\n\t\tif (unpin == &root->fs_info->freed_extents[0])\n\t\t\tunpin = &root->fs_info->freed_extents[1];\n\t\telse\n\t\t\tunpin = &root->fs_info->freed_extents[0];\n\t\tloop = false;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_log_root_tree",
          "args": [
            "NULL",
            "fs_info"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_log_root_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2811-2819",
          "snippet": "int btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_and_free_fs_root",
          "args": [
            "fs_info",
            "gang[i]"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_and_free_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3525-3544",
          "snippet": "void btrfs_drop_and_free_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_delete(&fs_info->fs_roots_radix,\n\t\t\t  (unsigned long)root->root_key.objectid);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\tsynchronize_srcu(&fs_info->subvol_srcu);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_free_log(NULL, root);\n\n\tif (root->free_ino_pinned)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_pinned);\n\tif (root->free_ino_ctl)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_ctl);\n\tfree_fs_root(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_drop_and_free_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_delete(&fs_info->fs_roots_radix,\n\t\t\t  (unsigned long)root->root_key.objectid);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\tsynchronize_srcu(&fs_info->subvol_srcu);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_free_log(NULL, root);\n\n\tif (root->free_ino_pinned)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_pinned);\n\tif (root->free_ino_ctl)\n\t\t__btrfs_remove_free_space_cache(root->free_ino_ctl);\n\tfree_fs_root(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&fs_info->fs_roots_radix",
            "(void **)gang",
            "0",
            "ARRAY_SIZE(gang)"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "gang"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_fs_root",
          "args": [
            "gang[0]"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "108-112",
          "snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "gang[0]->commit_root"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&gang[0]->root_list"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fs_info->dead_roots.next",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->dead_roots"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\n\nvoid btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}"
  },
  {
    "function_name": "free_root_pointers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2099-2110",
    "snippet": "static void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_root_extent_buffers",
          "args": [
            "info->chunk_root"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "free_root_extent_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2088-2096",
          "snippet": "static void free_root_extent_buffers(struct btrfs_root *root)\n{\n\tif (root) {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->node = NULL;\n\t\troot->commit_root = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void free_root_extent_buffers(struct btrfs_root *root)\n{\n\tif (root) {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->node = NULL;\n\t\troot->commit_root = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_root_pointers(struct btrfs_fs_info *info, int chunk_root)\n{\n\tfree_root_extent_buffers(info->tree_root);\n\n\tfree_root_extent_buffers(info->dev_root);\n\tfree_root_extent_buffers(info->extent_root);\n\tfree_root_extent_buffers(info->csum_root);\n\tfree_root_extent_buffers(info->quota_root);\n\tfree_root_extent_buffers(info->uuid_root);\n\tif (chunk_root)\n\t\tfree_root_extent_buffers(info->chunk_root);\n}"
  },
  {
    "function_name": "free_root_extent_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2088-2096",
    "snippet": "static void free_root_extent_buffers(struct btrfs_root *root)\n{\n\tif (root) {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->node = NULL;\n\t\troot->commit_root = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root->commit_root"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void free_root_extent_buffers(struct btrfs_root *root)\n{\n\tif (root) {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->node = NULL;\n\t\troot->commit_root = NULL;\n\t}\n}"
  },
  {
    "function_name": "btrfs_stop_all_workers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2066-2086",
    "snippet": "static void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_destroy_workqueue",
          "args": [
            "fs_info->extent_workers"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void btrfs_stop_all_workers(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_destroy_workqueue(fs_info->fixup_workers);\n\tbtrfs_destroy_workqueue(fs_info->delalloc_workers);\n\tbtrfs_destroy_workqueue(fs_info->workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_raid56_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_repair_workers);\n\tbtrfs_destroy_workqueue(fs_info->rmw_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_meta_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_write_workers);\n\tbtrfs_destroy_workqueue(fs_info->endio_freespace_worker);\n\tbtrfs_destroy_workqueue(fs_info->submit_workers);\n\tbtrfs_destroy_workqueue(fs_info->delayed_workers);\n\tbtrfs_destroy_workqueue(fs_info->caching_workers);\n\tbtrfs_destroy_workqueue(fs_info->readahead_workers);\n\tbtrfs_destroy_workqueue(fs_info->flush_workers);\n\tbtrfs_destroy_workqueue(fs_info->qgroup_rescan_workers);\n\tbtrfs_destroy_workqueue(fs_info->extent_workers);\n}"
  },
  {
    "function_name": "next_root_backup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "2021-2063",
    "snippet": "static noinline int next_root_backup(struct btrfs_fs_info *info,\n\t\t\t\t     struct btrfs_super_block *super,\n\t\t\t\t     int *num_backups_tried, int *backup_index)\n{\n\tstruct btrfs_root_backup *root_backup;\n\tint newest = *backup_index;\n\n\tif (*num_backups_tried == 0) {\n\t\tu64 gen = btrfs_super_generation(super);\n\n\t\tnewest = find_newest_super_backup(info, gen);\n\t\tif (newest == -1)\n\t\t\treturn -1;\n\n\t\t*backup_index = newest;\n\t\t*num_backups_tried = 1;\n\t} else if (*num_backups_tried == BTRFS_NUM_BACKUP_ROOTS) {\n\t\t/* we've tried all the backups, all done */\n\t\treturn -1;\n\t} else {\n\t\t/* jump to the next oldest backup */\n\t\tnewest = (*backup_index + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\t\tBTRFS_NUM_BACKUP_ROOTS;\n\t\t*backup_index = newest;\n\t\t*num_backups_tried += 1;\n\t}\n\troot_backup = super->super_roots + newest;\n\n\tbtrfs_set_super_generation(super,\n\t\t\t\t   btrfs_backup_tree_root_gen(root_backup));\n\tbtrfs_set_super_root(super, btrfs_backup_tree_root(root_backup));\n\tbtrfs_set_super_root_level(super,\n\t\t\t\t   btrfs_backup_tree_root_level(root_backup));\n\tbtrfs_set_super_bytes_used(super, btrfs_backup_bytes_used(root_backup));\n\n\t/*\n\t * fixme: the total bytes and num_devices need to match or we should\n\t * need a fsck\n\t */\n\tbtrfs_set_super_total_bytes(super, btrfs_backup_total_bytes(root_backup));\n\tbtrfs_set_super_num_devices(super, btrfs_backup_num_devices(root_backup));\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_super_num_devices",
          "args": [
            "super",
            "btrfs_backup_num_devices(root_backup)"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_num_devices",
          "args": [
            "root_backup"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_total_bytes",
          "args": [
            "super",
            "btrfs_backup_total_bytes(root_backup)"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_total_bytes",
          "args": [
            "root_backup"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_bytes_used",
          "args": [
            "super",
            "btrfs_backup_bytes_used(root_backup)"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_bytes_used",
          "args": [
            "root_backup"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_root_level",
          "args": [
            "super",
            "btrfs_backup_tree_root_level(root_backup)"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root_level",
          "args": [
            "root_backup"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_root",
          "args": [
            "super",
            "btrfs_backup_tree_root(root_backup)"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root",
          "args": [
            "root_backup"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_generation",
          "args": [
            "super",
            "btrfs_backup_tree_root_gen(root_backup)"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root_gen",
          "args": [
            "root_backup"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_newest_super_backup",
          "args": [
            "info",
            "gen"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "find_newest_super_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1875-1897",
          "snippet": "static int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic noinline int next_root_backup(struct btrfs_fs_info *info,\n\t\t\t\t     struct btrfs_super_block *super,\n\t\t\t\t     int *num_backups_tried, int *backup_index)\n{\n\tstruct btrfs_root_backup *root_backup;\n\tint newest = *backup_index;\n\n\tif (*num_backups_tried == 0) {\n\t\tu64 gen = btrfs_super_generation(super);\n\n\t\tnewest = find_newest_super_backup(info, gen);\n\t\tif (newest == -1)\n\t\t\treturn -1;\n\n\t\t*backup_index = newest;\n\t\t*num_backups_tried = 1;\n\t} else if (*num_backups_tried == BTRFS_NUM_BACKUP_ROOTS) {\n\t\t/* we've tried all the backups, all done */\n\t\treturn -1;\n\t} else {\n\t\t/* jump to the next oldest backup */\n\t\tnewest = (*backup_index + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\t\tBTRFS_NUM_BACKUP_ROOTS;\n\t\t*backup_index = newest;\n\t\t*num_backups_tried += 1;\n\t}\n\troot_backup = super->super_roots + newest;\n\n\tbtrfs_set_super_generation(super,\n\t\t\t\t   btrfs_backup_tree_root_gen(root_backup));\n\tbtrfs_set_super_root(super, btrfs_backup_tree_root(root_backup));\n\tbtrfs_set_super_root_level(super,\n\t\t\t\t   btrfs_backup_tree_root_level(root_backup));\n\tbtrfs_set_super_bytes_used(super, btrfs_backup_bytes_used(root_backup));\n\n\t/*\n\t * fixme: the total bytes and num_devices need to match or we should\n\t * need a fsck\n\t */\n\tbtrfs_set_super_total_bytes(super, btrfs_backup_total_bytes(root_backup));\n\tbtrfs_set_super_num_devices(super, btrfs_backup_num_devices(root_backup));\n\treturn 0;\n}"
  },
  {
    "function_name": "backup_super_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1924-2011",
    "snippet": "static void backup_super_roots(struct btrfs_fs_info *info)\n{\n\tint next_backup;\n\tstruct btrfs_root_backup *root_backup;\n\tint last_backup;\n\n\tnext_backup = info->backup_root_index;\n\tlast_backup = (next_backup + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\tBTRFS_NUM_BACKUP_ROOTS;\n\n\t/*\n\t * just overwrite the last backup if we're at the same generation\n\t * this happens only at umount\n\t */\n\troot_backup = info->super_for_commit->super_roots + last_backup;\n\tif (btrfs_backup_tree_root_gen(root_backup) ==\n\t    btrfs_header_generation(info->tree_root->node))\n\t\tnext_backup = last_backup;\n\n\troot_backup = info->super_for_commit->super_roots + next_backup;\n\n\t/*\n\t * make sure all of our padding and empty slots get zero filled\n\t * regardless of which ones we use today\n\t */\n\tmemset(root_backup, 0, sizeof(*root_backup));\n\n\tinfo->backup_root_index = (next_backup + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\n\tbtrfs_set_backup_tree_root(root_backup, info->tree_root->node->start);\n\tbtrfs_set_backup_tree_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->tree_root->node));\n\n\tbtrfs_set_backup_tree_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->tree_root->node));\n\n\tbtrfs_set_backup_chunk_root(root_backup, info->chunk_root->node->start);\n\tbtrfs_set_backup_chunk_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->chunk_root->node));\n\tbtrfs_set_backup_chunk_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->chunk_root->node));\n\n\tbtrfs_set_backup_extent_root(root_backup, info->extent_root->node->start);\n\tbtrfs_set_backup_extent_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->extent_root->node));\n\tbtrfs_set_backup_extent_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->extent_root->node));\n\n\t/*\n\t * we might commit during log recovery, which happens before we set\n\t * the fs_root.  Make sure it is valid before we fill it in.\n\t */\n\tif (info->fs_root && info->fs_root->node) {\n\t\tbtrfs_set_backup_fs_root(root_backup,\n\t\t\t\t\t info->fs_root->node->start);\n\t\tbtrfs_set_backup_fs_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->fs_root->node));\n\t\tbtrfs_set_backup_fs_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->fs_root->node));\n\t}\n\n\tbtrfs_set_backup_dev_root(root_backup, info->dev_root->node->start);\n\tbtrfs_set_backup_dev_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->dev_root->node));\n\tbtrfs_set_backup_dev_root_level(root_backup,\n\t\t\t\t       btrfs_header_level(info->dev_root->node));\n\n\tbtrfs_set_backup_csum_root(root_backup, info->csum_root->node->start);\n\tbtrfs_set_backup_csum_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->csum_root->node));\n\tbtrfs_set_backup_csum_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->csum_root->node));\n\n\tbtrfs_set_backup_total_bytes(root_backup,\n\t\t\t     btrfs_super_total_bytes(info->super_copy));\n\tbtrfs_set_backup_bytes_used(root_backup,\n\t\t\t     btrfs_super_bytes_used(info->super_copy));\n\tbtrfs_set_backup_num_devices(root_backup,\n\t\t\t     btrfs_super_num_devices(info->super_copy));\n\n\t/*\n\t * if we don't copy this out to the super_copy, it won't get remembered\n\t * for the next commit\n\t */\n\tmemcpy(&info->super_copy->super_roots,\n\t       &info->super_for_commit->super_roots,\n\t       sizeof(*root_backup) * BTRFS_NUM_BACKUP_ROOTS);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&info->super_copy->super_roots",
            "&info->super_for_commit->super_roots",
            "sizeof(*root_backup) * BTRFS_NUM_BACKUP_ROOTS"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_num_devices",
          "args": [
            "root_backup",
            "btrfs_super_num_devices(info->super_copy)"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_num_devices",
          "args": [
            "info->super_copy"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_bytes_used",
          "args": [
            "root_backup",
            "btrfs_super_bytes_used(info->super_copy)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytes_used",
          "args": [
            "info->super_copy"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_total_bytes",
          "args": [
            "root_backup",
            "btrfs_super_total_bytes(info->super_copy)"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "info->super_copy"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_csum_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->csum_root->node)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->csum_root->node"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_csum_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->csum_root->node)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->csum_root->node"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_csum_root",
          "args": [
            "root_backup",
            "info->csum_root->node->start"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_dev_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->dev_root->node)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->dev_root->node"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_dev_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->dev_root->node)"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->dev_root->node"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_dev_root",
          "args": [
            "root_backup",
            "info->dev_root->node->start"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_fs_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->fs_root->node)"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->fs_root->node"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_fs_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->fs_root->node)"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->fs_root->node"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_fs_root",
          "args": [
            "root_backup",
            "info->fs_root->node->start"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_extent_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->extent_root->node)"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->extent_root->node"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_extent_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->extent_root->node)"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->extent_root->node"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_extent_root",
          "args": [
            "root_backup",
            "info->extent_root->node->start"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_chunk_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->chunk_root->node)"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->chunk_root->node"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_chunk_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->chunk_root->node)"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->chunk_root->node"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_chunk_root",
          "args": [
            "root_backup",
            "info->chunk_root->node->start"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_tree_root_level",
          "args": [
            "root_backup",
            "btrfs_header_level(info->tree_root->node)"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "info->tree_root->node"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_tree_root_gen",
          "args": [
            "root_backup",
            "btrfs_header_generation(info->tree_root->node)"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->tree_root->node"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_backup_tree_root",
          "args": [
            "root_backup",
            "info->tree_root->node->start"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "root_backup",
            "0",
            "sizeof(*root_backup)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "info->tree_root->node"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root_gen",
          "args": [
            "root_backup"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void backup_super_roots(struct btrfs_fs_info *info)\n{\n\tint next_backup;\n\tstruct btrfs_root_backup *root_backup;\n\tint last_backup;\n\n\tnext_backup = info->backup_root_index;\n\tlast_backup = (next_backup + BTRFS_NUM_BACKUP_ROOTS - 1) %\n\t\tBTRFS_NUM_BACKUP_ROOTS;\n\n\t/*\n\t * just overwrite the last backup if we're at the same generation\n\t * this happens only at umount\n\t */\n\troot_backup = info->super_for_commit->super_roots + last_backup;\n\tif (btrfs_backup_tree_root_gen(root_backup) ==\n\t    btrfs_header_generation(info->tree_root->node))\n\t\tnext_backup = last_backup;\n\n\troot_backup = info->super_for_commit->super_roots + next_backup;\n\n\t/*\n\t * make sure all of our padding and empty slots get zero filled\n\t * regardless of which ones we use today\n\t */\n\tmemset(root_backup, 0, sizeof(*root_backup));\n\n\tinfo->backup_root_index = (next_backup + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\n\tbtrfs_set_backup_tree_root(root_backup, info->tree_root->node->start);\n\tbtrfs_set_backup_tree_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->tree_root->node));\n\n\tbtrfs_set_backup_tree_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->tree_root->node));\n\n\tbtrfs_set_backup_chunk_root(root_backup, info->chunk_root->node->start);\n\tbtrfs_set_backup_chunk_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->chunk_root->node));\n\tbtrfs_set_backup_chunk_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->chunk_root->node));\n\n\tbtrfs_set_backup_extent_root(root_backup, info->extent_root->node->start);\n\tbtrfs_set_backup_extent_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->extent_root->node));\n\tbtrfs_set_backup_extent_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->extent_root->node));\n\n\t/*\n\t * we might commit during log recovery, which happens before we set\n\t * the fs_root.  Make sure it is valid before we fill it in.\n\t */\n\tif (info->fs_root && info->fs_root->node) {\n\t\tbtrfs_set_backup_fs_root(root_backup,\n\t\t\t\t\t info->fs_root->node->start);\n\t\tbtrfs_set_backup_fs_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->fs_root->node));\n\t\tbtrfs_set_backup_fs_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->fs_root->node));\n\t}\n\n\tbtrfs_set_backup_dev_root(root_backup, info->dev_root->node->start);\n\tbtrfs_set_backup_dev_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->dev_root->node));\n\tbtrfs_set_backup_dev_root_level(root_backup,\n\t\t\t\t       btrfs_header_level(info->dev_root->node));\n\n\tbtrfs_set_backup_csum_root(root_backup, info->csum_root->node->start);\n\tbtrfs_set_backup_csum_root_gen(root_backup,\n\t\t\t       btrfs_header_generation(info->csum_root->node));\n\tbtrfs_set_backup_csum_root_level(root_backup,\n\t\t\t       btrfs_header_level(info->csum_root->node));\n\n\tbtrfs_set_backup_total_bytes(root_backup,\n\t\t\t     btrfs_super_total_bytes(info->super_copy));\n\tbtrfs_set_backup_bytes_used(root_backup,\n\t\t\t     btrfs_super_bytes_used(info->super_copy));\n\tbtrfs_set_backup_num_devices(root_backup,\n\t\t\t     btrfs_super_num_devices(info->super_copy));\n\n\t/*\n\t * if we don't copy this out to the super_copy, it won't get remembered\n\t * for the next commit\n\t */\n\tmemcpy(&info->super_copy->super_roots,\n\t       &info->super_for_commit->super_roots,\n\t       sizeof(*root_backup) * BTRFS_NUM_BACKUP_ROOTS);\n}"
  },
  {
    "function_name": "find_oldest_super_backup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1905-1917",
    "snippet": "static void find_oldest_super_backup(struct btrfs_fs_info *info,\n\t\t\t\t     u64 newest_gen)\n{\n\tint newest_index = -1;\n\n\tnewest_index = find_newest_super_backup(info, newest_gen);\n\t/* if there was garbage in there, just move along */\n\tif (newest_index == -1) {\n\t\tinfo->backup_root_index = 0;\n\t} else {\n\t\tinfo->backup_root_index = (newest_index + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_newest_super_backup",
          "args": [
            "info",
            "newest_gen"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "find_newest_super_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1875-1897",
          "snippet": "static int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void find_oldest_super_backup(struct btrfs_fs_info *info,\n\t\t\t\t     u64 newest_gen)\n{\n\tint newest_index = -1;\n\n\tnewest_index = find_newest_super_backup(info, newest_gen);\n\t/* if there was garbage in there, just move along */\n\tif (newest_index == -1) {\n\t\tinfo->backup_root_index = 0;\n\t} else {\n\t\tinfo->backup_root_index = (newest_index + 1) % BTRFS_NUM_BACKUP_ROOTS;\n\t}\n}"
  },
  {
    "function_name": "find_newest_super_backup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1875-1897",
    "snippet": "static int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root_gen",
          "args": [
            "root_backup"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_backup_tree_root_gen",
          "args": [
            "root_backup"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int find_newest_super_backup(struct btrfs_fs_info *info, u64 newest_gen)\n{\n\tu64 cur;\n\tint newest_index = -1;\n\tstruct btrfs_root_backup *root_backup;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_NUM_BACKUP_ROOTS; i++) {\n\t\troot_backup = info->super_copy->super_roots + i;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = i;\n\t}\n\n\t/* check to see if we actually wrapped around */\n\tif (newest_index == BTRFS_NUM_BACKUP_ROOTS - 1) {\n\t\troot_backup = info->super_copy->super_roots;\n\t\tcur = btrfs_backup_tree_root_gen(root_backup);\n\t\tif (cur == newest_gen)\n\t\t\tnewest_index = 0;\n\t}\n\treturn newest_index;\n}"
  },
  {
    "function_name": "transaction_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1802-1864",
    "snippet": "static int transaction_kthread(void *arg)\n{\n\tstruct btrfs_root *root = arg;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_transaction *cur;\n\tu64 transid;\n\tunsigned long now;\n\tunsigned long delay;\n\tbool cannot_commit;\n\n\tdo {\n\t\tcannot_commit = false;\n\t\tdelay = HZ * root->fs_info->commit_interval;\n\t\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tcur = root->fs_info->running_transaction;\n\t\tif (!cur) {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tgoto sleep;\n\t\t}\n\n\t\tnow = get_seconds();\n\t\tif (cur->state < TRANS_STATE_BLOCKED &&\n\t\t    (now < cur->start_time ||\n\t\t     now - cur->start_time < root->fs_info->commit_interval)) {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tdelay = HZ * 5;\n\t\t\tgoto sleep;\n\t\t}\n\t\ttransid = cur->transid;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/* If the file system is aborted, this will always fail. */\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\t\tcannot_commit = true;\n\t\t\tgoto sleep;\n\t\t}\n\t\tif (transid == trans->transid) {\n\t\t\tbtrfs_commit_transaction(trans, root);\n\t\t} else {\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t}\nsleep:\n\t\twake_up_process(root->fs_info->cleaner_kthread);\n\t\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\t\tif (unlikely(test_bit(BTRFS_FS_STATE_ERROR,\n\t\t\t\t      &root->fs_info->fs_state)))\n\t\t\tbtrfs_cleanup_transaction(root);\n\t\tif (!try_to_freeze()) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!kthread_should_stop() &&\n\t\t\t    (!btrfs_transaction_blocked(root->fs_info) ||\n\t\t\t     cannot_commit))\n\t\t\t\tschedule_timeout(delay);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\t} while (!kthread_should_stop());\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "delay"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_transaction_blocked",
          "args": [
            "root->fs_info"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_transaction_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1560-1571",
          "snippet": "int btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_transaction",
          "args": [
            "root"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4235-4286",
          "snippet": "static int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *t;\n\n\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\twhile (!list_empty(&root->fs_info->trans_list)) {\n\t\tt = list_first_entry(&root->fs_info->trans_list,\n\t\t\t\t     struct btrfs_transaction, list);\n\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\tatomic_inc(&t->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tbtrfs_wait_for_commit(root, t->transid);\n\t\t\tbtrfs_put_transaction(t);\n\t\t\tspin_lock(&root->fs_info->trans_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == root->fs_info->running_transaction) {\n\t\t\tt->state = TRANS_STATE_COMMIT_DOING;\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\t/*\n\t\t\t * We wait for 0 num_writers since we don't hold a trans\n\t\t\t * handle open currently for this transaction.\n\t\t\t */\n\t\t\twait_event(t->writer_wait,\n\t\t\t\t   atomic_read(&t->num_writers) == 0);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t\tbtrfs_cleanup_one_transaction(t, root);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tif (t == root->fs_info->running_transaction)\n\t\t\troot->fs_info->running_transaction = NULL;\n\t\tlist_del_init(&t->list);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\tbtrfs_put_transaction(t);\n\t\ttrace_btrfs_transaction_commit(root);\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\tbtrfs_destroy_all_ordered_extents(root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\tbtrfs_destroy_pinned_extent(root, root->fs_info->pinned_extents);\n\tbtrfs_destroy_all_delalloc_inodes(root->fs_info);\n\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(BTRFS_FS_STATE_ERROR,\n\t\t\t\t      &root->fs_info->fs_state)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->transaction_kthread_mutex"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "root->fs_info->cleaner_kthread"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction",
          "args": [
            "root"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->transaction_kthread_mutex"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int transaction_kthread(void *arg)\n{\n\tstruct btrfs_root *root = arg;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_transaction *cur;\n\tu64 transid;\n\tunsigned long now;\n\tunsigned long delay;\n\tbool cannot_commit;\n\n\tdo {\n\t\tcannot_commit = false;\n\t\tdelay = HZ * root->fs_info->commit_interval;\n\t\tmutex_lock(&root->fs_info->transaction_kthread_mutex);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tcur = root->fs_info->running_transaction;\n\t\tif (!cur) {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tgoto sleep;\n\t\t}\n\n\t\tnow = get_seconds();\n\t\tif (cur->state < TRANS_STATE_BLOCKED &&\n\t\t    (now < cur->start_time ||\n\t\t     now - cur->start_time < root->fs_info->commit_interval)) {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t\tdelay = HZ * 5;\n\t\t\tgoto sleep;\n\t\t}\n\t\ttransid = cur->transid;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/* If the file system is aborted, this will always fail. */\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\t\tcannot_commit = true;\n\t\t\tgoto sleep;\n\t\t}\n\t\tif (transid == trans->transid) {\n\t\t\tbtrfs_commit_transaction(trans, root);\n\t\t} else {\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t}\nsleep:\n\t\twake_up_process(root->fs_info->cleaner_kthread);\n\t\tmutex_unlock(&root->fs_info->transaction_kthread_mutex);\n\n\t\tif (unlikely(test_bit(BTRFS_FS_STATE_ERROR,\n\t\t\t\t      &root->fs_info->fs_state)))\n\t\t\tbtrfs_cleanup_transaction(root);\n\t\tif (!try_to_freeze()) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!kthread_should_stop() &&\n\t\t\t    (!btrfs_transaction_blocked(root->fs_info) ||\n\t\t\t     cannot_commit))\n\t\t\t\tschedule_timeout(delay);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\t} while (!kthread_should_stop());\n\treturn 0;\n}"
  },
  {
    "function_name": "cleaner_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1757-1800",
    "snippet": "static int cleaner_kthread(void *arg)\n{\n\tstruct btrfs_root *root = arg;\n\tint again;\n\n\tdo {\n\t\tagain = 0;\n\n\t\t/* Make the cleaner go to sleep early. */\n\t\tif (btrfs_need_cleaner_sleep(root))\n\t\t\tgoto sleep;\n\n\t\tif (!mutex_trylock(&root->fs_info->cleaner_mutex))\n\t\t\tgoto sleep;\n\n\t\t/*\n\t\t * Avoid the problem that we change the status of the fs\n\t\t * during the above check and trylock.\n\t\t */\n\t\tif (btrfs_need_cleaner_sleep(root)) {\n\t\t\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\t\t\tgoto sleep;\n\t\t}\n\n\t\tbtrfs_run_delayed_iputs(root);\n\t\tbtrfs_delete_unused_bgs(root->fs_info);\n\t\tagain = btrfs_clean_one_deleted_snapshot(root);\n\t\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\t\t/*\n\t\t * The defragger has dealt with the R/O remount and umount,\n\t\t * needn't do anything special here.\n\t\t */\n\t\tbtrfs_run_defrag_inodes(root->fs_info);\nsleep:\n\t\tif (!try_to_freeze() && !again) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!kthread_should_stop())\n\t\t\t\tschedule();\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\t} while (!kthread_should_stop());\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_defrag_inodes",
          "args": [
            "root->fs_info"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_defrag_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "366-408",
          "snippet": "int btrfs_run_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tu64 first_ino = 0;\n\tu64 root_objectid = 0;\n\n\tatomic_inc(&fs_info->defrag_running);\n\twhile (1) {\n\t\t/* Pause the auto defragger. */\n\t\tif (test_bit(BTRFS_FS_STATE_REMOUNTING,\n\t\t\t     &fs_info->fs_state))\n\t\t\tbreak;\n\n\t\tif (!__need_auto_defrag(fs_info->tree_root))\n\t\t\tbreak;\n\n\t\t/* find an inode to defrag */\n\t\tdefrag = btrfs_pick_defrag_inode(fs_info, root_objectid,\n\t\t\t\t\t\t first_ino);\n\t\tif (!defrag) {\n\t\t\tif (root_objectid || first_ino) {\n\t\t\t\troot_objectid = 0;\n\t\t\t\tfirst_ino = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfirst_ino = defrag->ino + 1;\n\t\troot_objectid = defrag->root;\n\n\t\t__btrfs_run_defrag_inode(fs_info, defrag);\n\t}\n\tatomic_dec(&fs_info->defrag_running);\n\n\t/*\n\t * during unmount, we use the transaction_wait queue to\n\t * wait for the defragger to stop\n\t */\n\twake_up(&fs_info->transaction_wait);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_run_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tu64 first_ino = 0;\n\tu64 root_objectid = 0;\n\n\tatomic_inc(&fs_info->defrag_running);\n\twhile (1) {\n\t\t/* Pause the auto defragger. */\n\t\tif (test_bit(BTRFS_FS_STATE_REMOUNTING,\n\t\t\t     &fs_info->fs_state))\n\t\t\tbreak;\n\n\t\tif (!__need_auto_defrag(fs_info->tree_root))\n\t\t\tbreak;\n\n\t\t/* find an inode to defrag */\n\t\tdefrag = btrfs_pick_defrag_inode(fs_info, root_objectid,\n\t\t\t\t\t\t first_ino);\n\t\tif (!defrag) {\n\t\t\tif (root_objectid || first_ino) {\n\t\t\t\troot_objectid = 0;\n\t\t\t\tfirst_ino = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfirst_ino = defrag->ino + 1;\n\t\troot_objectid = defrag->root;\n\n\t\t__btrfs_run_defrag_inode(fs_info, defrag);\n\t}\n\tatomic_dec(&fs_info->defrag_running);\n\n\t/*\n\t * during unmount, we use the transaction_wait queue to\n\t * wait for the defragger to stop\n\t */\n\twake_up(&fs_info->transaction_wait);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clean_one_deleted_snapshot",
          "args": [
            "root"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clean_one_deleted_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "2111-2137",
          "snippet": "int btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tpr_debug(\"BTRFS: cleaner removing %llu\\n\", root->objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, NULL, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, NULL, 1, 0);\n\n\treturn (ret < 0) ? 0 : 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tpr_debug(\"BTRFS: cleaner removing %llu\\n\", root->objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, NULL, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, NULL, 1, 0);\n\n\treturn (ret < 0) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delete_unused_bgs",
          "args": [
            "root->fs_info"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delete_unused_bgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9551-9665",
          "snippet": "void btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (!fs_info->open)\n\t\treturn;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->unused_bgs)) {\n\t\tu64 start, end;\n\n\t\tblock_group = list_first_entry(&fs_info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tspace_info = block_group->space_info;\n\t\tlist_del_init(&block_group->bg_list);\n\t\tif (ret || btrfs_mixed_space_info(space_info)) {\n\t\t\tbtrfs_put_block_group(block_group);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\t/* Don't want to race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->reserved ||\n\t\t    btrfs_block_group_used(&block_group->item) ||\n\t\t    block_group->ro) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\n\t\t/* We don't want to force the issue, only flip if it's ok. */\n\t\tret = set_block_group_ro(block_group, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0) {\n\t\t\tret = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Want to do this before we do anything else so we can recover\n\t\t * properly if we fail to join the transaction.\n\t\t */\n\t\t/* 1 for btrfs_orphan_reserve_metadata() */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * We could have pending pinned extents for this block group,\n\t\t * just delete them, we don't care about them anymore.\n\t\t */\n\t\tstart = block_group->key.objectid;\n\t\tend = start + block_group->key.offset - 1;\n\t\t/*\n\t\t * Hold the unused_bg_unpin_mutex lock to avoid racing with\n\t\t * btrfs_finish_extent_commit(). If we are at transaction N,\n\t\t * another task might be running finish_extent_commit() for the\n\t\t * previous transaction N - 1, and have seen a range belonging\n\t\t * to the block group in freed_extents[] before we were able to\n\t\t * clear the whole block group range from freed_extents[]. This\n\t\t * means that task can lookup for the block group after we\n\t\t * unpinned it from freed_extents[] and removed it, leading to\n\t\t * a BUG_ON() at btrfs_unpin_extent_range().\n\t\t */\n\t\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\t\tret = clear_extent_bits(&fs_info->freed_extents[0], start, end,\n\t\t\t\t  EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tret = clear_extent_bits(&fs_info->freed_extents[1], start, end,\n\t\t\t\t  EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\n\t\t/* Reset pinned so btrfs_put_block_group doesn't complain */\n\t\tblock_group->pinned = 0;\n\n\t\t/*\n\t\t * Btrfs_remove_chunk will abort the transaction if things go\n\t\t * horribly wrong.\n\t\t */\n\t\tret = btrfs_remove_chunk(trans, root,\n\t\t\t\t\t block_group->key.objectid);\nend_trans:\n\t\tbtrfs_end_transaction(trans, root);\nnext:\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *extent_root, u64 flags,\n\t\t\t  int force);",
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int do_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *extent_root, u64 flags,\n\t\t\t  int force);\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nvoid btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (!fs_info->open)\n\t\treturn;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->unused_bgs)) {\n\t\tu64 start, end;\n\n\t\tblock_group = list_first_entry(&fs_info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group_cache,\n\t\t\t\t\t       bg_list);\n\t\tspace_info = block_group->space_info;\n\t\tlist_del_init(&block_group->bg_list);\n\t\tif (ret || btrfs_mixed_space_info(space_info)) {\n\t\t\tbtrfs_put_block_group(block_group);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\t/* Don't want to race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->reserved ||\n\t\t    btrfs_block_group_used(&block_group->item) ||\n\t\t    block_group->ro) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\n\t\t/* We don't want to force the issue, only flip if it's ok. */\n\t\tret = set_block_group_ro(block_group, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0) {\n\t\t\tret = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Want to do this before we do anything else so we can recover\n\t\t * properly if we fail to join the transaction.\n\t\t */\n\t\t/* 1 for btrfs_orphan_reserve_metadata() */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * We could have pending pinned extents for this block group,\n\t\t * just delete them, we don't care about them anymore.\n\t\t */\n\t\tstart = block_group->key.objectid;\n\t\tend = start + block_group->key.offset - 1;\n\t\t/*\n\t\t * Hold the unused_bg_unpin_mutex lock to avoid racing with\n\t\t * btrfs_finish_extent_commit(). If we are at transaction N,\n\t\t * another task might be running finish_extent_commit() for the\n\t\t * previous transaction N - 1, and have seen a range belonging\n\t\t * to the block group in freed_extents[] before we were able to\n\t\t * clear the whole block group range from freed_extents[]. This\n\t\t * means that task can lookup for the block group after we\n\t\t * unpinned it from freed_extents[] and removed it, leading to\n\t\t * a BUG_ON() at btrfs_unpin_extent_range().\n\t\t */\n\t\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\t\tret = clear_extent_bits(&fs_info->freed_extents[0], start, end,\n\t\t\t\t  EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tret = clear_extent_bits(&fs_info->freed_extents[1], start, end,\n\t\t\t\t  EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbtrfs_set_block_group_rw(root, block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\n\t\t/* Reset pinned so btrfs_put_block_group doesn't complain */\n\t\tblock_group->pinned = 0;\n\n\t\t/*\n\t\t * Btrfs_remove_chunk will abort the transaction if things go\n\t\t * horribly wrong.\n\t\t */\n\t\tret = btrfs_remove_chunk(trans, root,\n\t\t\t\t\t block_group->key.objectid);\nend_trans:\n\t\tbtrfs_end_transaction(trans, root);\nnext:\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_iputs",
          "args": [
            "root"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_need_cleaner_sleep",
          "args": [
            "root"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_need_cleaner_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3626-3630",
          "snippet": "static inline int btrfs_need_cleaner_sleep(struct btrfs_root *root)\n{\n\treturn (root->fs_info->sb->s_flags & MS_RDONLY ||\n\t\tbtrfs_fs_closing(root->fs_info));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_need_cleaner_sleep(struct btrfs_root *root)\n{\n\treturn (root->fs_info->sb->s_flags & MS_RDONLY ||\n\t\tbtrfs_fs_closing(root->fs_info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&root->fs_info->cleaner_mutex"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int cleaner_kthread(void *arg)\n{\n\tstruct btrfs_root *root = arg;\n\tint again;\n\n\tdo {\n\t\tagain = 0;\n\n\t\t/* Make the cleaner go to sleep early. */\n\t\tif (btrfs_need_cleaner_sleep(root))\n\t\t\tgoto sleep;\n\n\t\tif (!mutex_trylock(&root->fs_info->cleaner_mutex))\n\t\t\tgoto sleep;\n\n\t\t/*\n\t\t * Avoid the problem that we change the status of the fs\n\t\t * during the above check and trylock.\n\t\t */\n\t\tif (btrfs_need_cleaner_sleep(root)) {\n\t\t\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\t\t\tgoto sleep;\n\t\t}\n\n\t\tbtrfs_run_delayed_iputs(root);\n\t\tbtrfs_delete_unused_bgs(root->fs_info);\n\t\tagain = btrfs_clean_one_deleted_snapshot(root);\n\t\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\n\t\t/*\n\t\t * The defragger has dealt with the R/O remount and umount,\n\t\t * needn't do anything special here.\n\t\t */\n\t\tbtrfs_run_defrag_inodes(root->fs_info);\nsleep:\n\t\tif (!try_to_freeze() && !again) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!kthread_should_stop())\n\t\t\t\tschedule();\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\t} while (!kthread_should_stop());\n\treturn 0;\n}"
  },
  {
    "function_name": "end_workqueue_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1741-1755",
    "snippet": "static void end_workqueue_fn(struct btrfs_work *work)\n{\n\tstruct bio *bio;\n\tstruct btrfs_end_io_wq *end_io_wq;\n\tint error;\n\n\tend_io_wq = container_of(work, struct btrfs_end_io_wq, work);\n\tbio = end_io_wq->bio;\n\n\terror = end_io_wq->error;\n\tbio->bi_private = end_io_wq->private;\n\tbio->bi_end_io = end_io_wq->end_io;\n\tkmem_cache_free(btrfs_end_io_wq_cache, end_io_wq);\n\tbio_endio_nodec(bio, error);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);",
      "static struct kmem_cache *btrfs_end_io_wq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_endio_nodec",
          "args": [
            "bio",
            "error"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_end_io_wq_cache",
            "end_io_wq"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_end_io_wq",
            "work"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nstatic void end_workqueue_fn(struct btrfs_work *work)\n{\n\tstruct bio *bio;\n\tstruct btrfs_end_io_wq *end_io_wq;\n\tint error;\n\n\tend_io_wq = container_of(work, struct btrfs_end_io_wq, work);\n\tbio = end_io_wq->bio;\n\n\terror = end_io_wq->error;\n\tbio->bi_private = end_io_wq->private;\n\tbio->bi_end_io = end_io_wq->end_io;\n\tkmem_cache_free(btrfs_end_io_wq_cache, end_io_wq);\n\tbio_endio_nodec(bio, error);\n}"
  },
  {
    "function_name": "setup_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1723-1735",
    "snippet": "static int setup_bdi(struct btrfs_fs_info *info, struct backing_dev_info *bdi)\n{\n\tint err;\n\n\terr = bdi_setup_and_register(bdi, \"btrfs\");\n\tif (err)\n\t\treturn err;\n\n\tbdi->ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\tbdi->congested_fn\t= btrfs_congested_fn;\n\tbdi->congested_data\t= info;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "bdi",
            "\"btrfs\""
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int setup_bdi(struct btrfs_fs_info *info, struct backing_dev_info *bdi)\n{\n\tint err;\n\n\terr = bdi_setup_and_register(bdi, \"btrfs\");\n\tif (err)\n\t\treturn err;\n\n\tbdi->ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\tbdi->congested_fn\t= btrfs_congested_fn;\n\tbdi->congested_data\t= info;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_congested_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1702-1721",
    "snippet": "static int btrfs_congested_fn(void *congested_data, int bdi_bits)\n{\n\tstruct btrfs_fs_info *info = (struct btrfs_fs_info *)congested_data;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &info->fs_devices->devices, dev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tbdi = blk_get_backing_dev_info(device->bdev);\n\t\tif (bdi_congested(bdi, bdi_bits)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_congested",
          "args": [
            "bdi",
            "bdi_bits"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_get_backing_dev_info",
          "args": [
            "device->bdev"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "device",
            "&info->fs_devices->devices",
            "dev_list"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_congested_fn(void *congested_data, int bdi_bits)\n{\n\tstruct btrfs_fs_info *info = (struct btrfs_fs_info *)congested_data;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &info->fs_devices->devices, dev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tbdi = blk_get_backing_dev_info(device->bdev);\n\t\tif (bdi_congested(bdi, bdi_bits)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_get_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1626-1700",
    "snippet": "struct btrfs_root *btrfs_get_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_key *location,\n\t\t\t\t     bool check_ref)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (location->objectid == BTRFS_ROOT_TREE_OBJECTID)\n\t\treturn fs_info->tree_root;\n\tif (location->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\treturn fs_info->extent_root;\n\tif (location->objectid == BTRFS_CHUNK_TREE_OBJECTID)\n\t\treturn fs_info->chunk_root;\n\tif (location->objectid == BTRFS_DEV_TREE_OBJECTID)\n\t\treturn fs_info->dev_root;\n\tif (location->objectid == BTRFS_CSUM_TREE_OBJECTID)\n\t\treturn fs_info->csum_root;\n\tif (location->objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn fs_info->quota_root ? fs_info->quota_root :\n\t\t\t\t\t     ERR_PTR(-ENOENT);\n\tif (location->objectid == BTRFS_UUID_TREE_OBJECTID)\n\t\treturn fs_info->uuid_root ? fs_info->uuid_root :\n\t\t\t\t\t    ERR_PTR(-ENOENT);\nagain:\n\troot = btrfs_lookup_fs_root(fs_info, location->objectid);\n\tif (root) {\n\t\tif (check_ref && btrfs_root_refs(&root->root_item) == 0)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn root;\n\t}\n\n\troot = btrfs_read_fs_root(fs_info->tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (check_ref && btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_init_fs_root(root);\n\tif (ret)\n\t\tgoto fail;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = location->objectid;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tbtrfs_free_path(path);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\tret = btrfs_insert_fs_root(fs_info, root);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\tfree_fs_root(root);\n\t\t\tgoto again;\n\t\t}\n\t\tgoto fail;\n\t}\n\treturn root;\nfail:\n\tfree_fs_root(root);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fs_root",
          "args": [
            "root"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3564-3567",
          "snippet": "void btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_free_fs_root(struct btrfs_root *root)\n{\n\tfree_fs_root(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_fs_root",
          "args": [
            "fs_info",
            "root"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1605-1624",
          "snippet": "int btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_ORPHAN_ITEM_INSERTED",
            "&root->state"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "fs_info->tree_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_fs_root",
          "args": [
            "root"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1556-1591",
          "snippet": "int btrfs_init_fs_root(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_subvolume_writers *writers;\n\n\troot->free_ino_ctl = kzalloc(sizeof(*root->free_ino_ctl), GFP_NOFS);\n\troot->free_ino_pinned = kzalloc(sizeof(*root->free_ino_pinned),\n\t\t\t\t\tGFP_NOFS);\n\tif (!root->free_ino_pinned || !root->free_ino_ctl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twriters = btrfs_alloc_subvolume_writers();\n\tif (IS_ERR(writers)) {\n\t\tret = PTR_ERR(writers);\n\t\tgoto fail;\n\t}\n\troot->subv_writers = writers;\n\n\tbtrfs_init_free_ino_ctl(root);\n\tspin_lock_init(&root->ino_cache_lock);\n\tinit_waitqueue_head(&root->ino_cache_wait);\n\n\tret = get_anon_bdev(&root->anon_dev);\n\tif (ret)\n\t\tgoto free_writers;\n\treturn 0;\n\nfree_writers:\n\tbtrfs_free_subvolume_writers(root->subv_writers);\nfail:\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_init_fs_root(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_subvolume_writers *writers;\n\n\troot->free_ino_ctl = kzalloc(sizeof(*root->free_ino_ctl), GFP_NOFS);\n\troot->free_ino_pinned = kzalloc(sizeof(*root->free_ino_pinned),\n\t\t\t\t\tGFP_NOFS);\n\tif (!root->free_ino_pinned || !root->free_ino_ctl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twriters = btrfs_alloc_subvolume_writers();\n\tif (IS_ERR(writers)) {\n\t\tret = PTR_ERR(writers);\n\t\tgoto fail;\n\t}\n\troot->subv_writers = writers;\n\n\tbtrfs_init_free_ino_ctl(root);\n\tspin_lock_init(&root->ino_cache_lock);\n\tinit_waitqueue_head(&root->ino_cache_wait);\n\n\tret = get_anon_bdev(&root->anon_dev);\n\tif (ret)\n\t\tgoto free_writers;\n\treturn 0;\n\nfree_writers:\n\tbtrfs_free_subvolume_writers(root->subv_writers);\nfail:\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root",
          "args": [
            "fs_info->tree_root",
            "location"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1539-1554",
          "snippet": "struct btrfs_root *btrfs_read_fs_root(struct btrfs_root *tree_root,\n\t\t\t\t      struct btrfs_key *location)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_read_tree_root(tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tset_bit(BTRFS_ROOT_REF_COWS, &root->state);\n\t\tbtrfs_check_and_init_root_item(&root->root_item);\n\t}\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_read_fs_root(struct btrfs_root *tree_root,\n\t\t\t\t      struct btrfs_key *location)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_read_tree_root(tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tset_bit(BTRFS_ROOT_REF_COWS, &root->state);\n\t\tbtrfs_check_and_init_root_item(&root->root_item);\n\t}\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_fs_root",
          "args": [
            "fs_info",
            "location->objectid"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1593-1603",
          "snippet": "static struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 root_id)\n{\n\tstruct btrfs_root *root;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\troot = radix_tree_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t (unsigned long)root_id);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 root_id)\n{\n\tstruct btrfs_root *root;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\troot = radix_tree_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t (unsigned long)root_id);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_get_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_key *location,\n\t\t\t\t     bool check_ref)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (location->objectid == BTRFS_ROOT_TREE_OBJECTID)\n\t\treturn fs_info->tree_root;\n\tif (location->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\treturn fs_info->extent_root;\n\tif (location->objectid == BTRFS_CHUNK_TREE_OBJECTID)\n\t\treturn fs_info->chunk_root;\n\tif (location->objectid == BTRFS_DEV_TREE_OBJECTID)\n\t\treturn fs_info->dev_root;\n\tif (location->objectid == BTRFS_CSUM_TREE_OBJECTID)\n\t\treturn fs_info->csum_root;\n\tif (location->objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn fs_info->quota_root ? fs_info->quota_root :\n\t\t\t\t\t     ERR_PTR(-ENOENT);\n\tif (location->objectid == BTRFS_UUID_TREE_OBJECTID)\n\t\treturn fs_info->uuid_root ? fs_info->uuid_root :\n\t\t\t\t\t    ERR_PTR(-ENOENT);\nagain:\n\troot = btrfs_lookup_fs_root(fs_info, location->objectid);\n\tif (root) {\n\t\tif (check_ref && btrfs_root_refs(&root->root_item) == 0)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn root;\n\t}\n\n\troot = btrfs_read_fs_root(fs_info->tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (check_ref && btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_init_fs_root(root);\n\tif (ret)\n\t\tgoto fail;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = location->objectid;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tbtrfs_free_path(path);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\tret = btrfs_insert_fs_root(fs_info, root);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\tfree_fs_root(root);\n\t\t\tgoto again;\n\t\t}\n\t\tgoto fail;\n\t}\n\treturn root;\nfail:\n\tfree_fs_root(root);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "btrfs_insert_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1605-1624",
    "snippet": "int btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_IN_RADIX",
            "&root->state"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&fs_info->fs_roots_radix",
            "(unsigned long)root->root_key.objectid",
            "root"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS & ~__GFP_HIGHMEM"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tret = radix_tree_insert(&fs_info->fs_roots_radix,\n\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\troot);\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_IN_RADIX, &root->state);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_lookup_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1593-1603",
    "snippet": "static struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 root_id)\n{\n\tstruct btrfs_root *root;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\troot = radix_tree_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t (unsigned long)root_id);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn root;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&fs_info->fs_roots_radix",
            "(unsigned long)root_id"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 root_id)\n{\n\tstruct btrfs_root *root;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\troot = radix_tree_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t (unsigned long)root_id);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn root;\n}"
  },
  {
    "function_name": "btrfs_init_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1556-1591",
    "snippet": "int btrfs_init_fs_root(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_subvolume_writers *writers;\n\n\troot->free_ino_ctl = kzalloc(sizeof(*root->free_ino_ctl), GFP_NOFS);\n\troot->free_ino_pinned = kzalloc(sizeof(*root->free_ino_pinned),\n\t\t\t\t\tGFP_NOFS);\n\tif (!root->free_ino_pinned || !root->free_ino_ctl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twriters = btrfs_alloc_subvolume_writers();\n\tif (IS_ERR(writers)) {\n\t\tret = PTR_ERR(writers);\n\t\tgoto fail;\n\t}\n\troot->subv_writers = writers;\n\n\tbtrfs_init_free_ino_ctl(root);\n\tspin_lock_init(&root->ino_cache_lock);\n\tinit_waitqueue_head(&root->ino_cache_wait);\n\n\tret = get_anon_bdev(&root->anon_dev);\n\tif (ret)\n\t\tgoto free_writers;\n\treturn 0;\n\nfree_writers:\n\tbtrfs_free_subvolume_writers(root->subv_writers);\nfail:\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root->free_ino_pinned"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root->free_ino_ctl"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_subvolume_writers",
          "args": [
            "root->subv_writers"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_subvolume_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1207-1212",
          "snippet": "static void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_anon_bdev",
          "args": [
            "&root->anon_dev"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&root->ino_cache_wait"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_free_ino_ctl",
          "args": [
            "root"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_free_ino_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "357-383",
          "snippet": "void btrfs_init_free_ino_ctl(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = 1;\n\tctl->start = 0;\n\tctl->private = NULL;\n\tctl->op = &free_ino_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * Initially we allow to use 16K of ram to cache chunks of\n\t * inode numbers before we resort to bitmaps. This is somewhat\n\t * arbitrary, but it will be adjusted in runtime.\n\t */\n\tctl->extents_thresh = INIT_THRESHOLD;\n\n\tspin_lock_init(&pinned->tree_lock);\n\tpinned->unit = 1;\n\tpinned->start = 0;\n\tpinned->private = NULL;\n\tpinned->extents_thresh = 0;\n\tpinned->op = &pinned_free_ino_op;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))"
          ],
          "globals_used": [
            "static struct btrfs_free_space_op free_ino_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};",
            "static struct btrfs_free_space_op pinned_free_ino_op = {\n\t.recalc_thresholds\t= pinned_recalc_thresholds,\n\t.use_bitmap\t\t= pinned_use_bitmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))\n\nstatic struct btrfs_free_space_op free_ino_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\nstatic struct btrfs_free_space_op pinned_free_ino_op = {\n\t.recalc_thresholds\t= pinned_recalc_thresholds,\n\t.use_bitmap\t\t= pinned_use_bitmap,\n};\n\nvoid btrfs_init_free_ino_ctl(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = 1;\n\tctl->start = 0;\n\tctl->private = NULL;\n\tctl->op = &free_ino_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * Initially we allow to use 16K of ram to cache chunks of\n\t * inode numbers before we resort to bitmaps. This is somewhat\n\t * arbitrary, but it will be adjusted in runtime.\n\t */\n\tctl->extents_thresh = INIT_THRESHOLD;\n\n\tspin_lock_init(&pinned->tree_lock);\n\tpinned->unit = 1;\n\tpinned->start = 0;\n\tpinned->private = NULL;\n\tpinned->extents_thresh = 0;\n\tpinned->op = &pinned_free_ino_op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "writers"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "writers"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_subvolume_writers",
          "args": [],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_subvolume_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1188-1205",
          "snippet": "static struct btrfs_subvolume_writers *btrfs_alloc_subvolume_writers(void)\n{\n\tstruct btrfs_subvolume_writers *writers;\n\tint ret;\n\n\twriters = kmalloc(sizeof(*writers), GFP_NOFS);\n\tif (!writers)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_counter_init(&writers->counter, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(writers);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinit_waitqueue_head(&writers->wait);\n\treturn writers;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_subvolume_writers *btrfs_alloc_subvolume_writers(void)\n{\n\tstruct btrfs_subvolume_writers *writers;\n\tint ret;\n\n\twriters = kmalloc(sizeof(*writers), GFP_NOFS);\n\tif (!writers)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_counter_init(&writers->counter, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(writers);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinit_waitqueue_head(&writers->wait);\n\treturn writers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*root->free_ino_pinned)",
            "GFP_NOFS"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*root->free_ino_ctl)",
            "GFP_NOFS"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_init_fs_root(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_subvolume_writers *writers;\n\n\troot->free_ino_ctl = kzalloc(sizeof(*root->free_ino_ctl), GFP_NOFS);\n\troot->free_ino_pinned = kzalloc(sizeof(*root->free_ino_pinned),\n\t\t\t\t\tGFP_NOFS);\n\tif (!root->free_ino_pinned || !root->free_ino_ctl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twriters = btrfs_alloc_subvolume_writers();\n\tif (IS_ERR(writers)) {\n\t\tret = PTR_ERR(writers);\n\t\tgoto fail;\n\t}\n\troot->subv_writers = writers;\n\n\tbtrfs_init_free_ino_ctl(root);\n\tspin_lock_init(&root->ino_cache_lock);\n\tinit_waitqueue_head(&root->ino_cache_wait);\n\n\tret = get_anon_bdev(&root->anon_dev);\n\tif (ret)\n\t\tgoto free_writers;\n\treturn 0;\n\nfree_writers:\n\tbtrfs_free_subvolume_writers(root->subv_writers);\nfail:\n\tkfree(root->free_ino_ctl);\n\tkfree(root->free_ino_pinned);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_read_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1539-1554",
    "snippet": "struct btrfs_root *btrfs_read_fs_root(struct btrfs_root *tree_root,\n\t\t\t\t      struct btrfs_key *location)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_read_tree_root(tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tset_bit(BTRFS_ROOT_REF_COWS, &root->state);\n\t\tbtrfs_check_and_init_root_item(&root->root_item);\n\t}\n\n\treturn root;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_check_and_init_root_item",
          "args": [
            "&root->root_item"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_and_init_root_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "474-484",
          "snippet": "void btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\n{\n\tu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\n\n\tif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\n\t\tinode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\n\t\tbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\n\t\tbtrfs_set_root_flags(root_item, 0);\n\t\tbtrfs_set_root_limit(root_item, 0);\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\n{\n\tu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\n\n\tif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\n\t\tinode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\n\t\tbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\n\t\tbtrfs_set_root_flags(root_item, 0);\n\t\tbtrfs_set_root_limit(root_item, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_tree_root",
          "args": [
            "tree_root",
            "location"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_tree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1485-1537",
          "snippet": "static struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_read_fs_root(struct btrfs_root *tree_root,\n\t\t\t\t      struct btrfs_key *location)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_read_tree_root(tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tset_bit(BTRFS_ROOT_REF_COWS, &root->state);\n\t\tbtrfs_check_and_init_root_item(&root->root_item);\n\t}\n\n\treturn root;\n}"
  },
  {
    "function_name": "btrfs_read_tree_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1485-1537",
    "snippet": "static struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root->node"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_buffer_uptodate",
          "args": [
            "root->node",
            "generation",
            "0"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3741-3756",
          "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "btrfs_root_bytenr(&root->root_item)",
            "generation"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_bytenr",
          "args": [
            "&root->root_item"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_generation",
          "args": [
            "&root->root_item"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_root",
          "args": [
            "tree_root",
            "key",
            "path",
            "&root->root_item",
            "&root->root_key"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "81-122",
          "snippet": "int btrfs_find_root(struct btrfs_root *root, struct btrfs_key *search_key,\n\t\t    struct btrfs_path *path, struct btrfs_root_item *root_item,\n\t\t    struct btrfs_key *root_key)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, search_key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (search_key->offset != -1ULL) {\t/* the search key is exact */\n\t\tif (ret > 0)\n\t\t\tgoto out;\n\t} else {\n\t\tBUG_ON(ret == 0);\t\t/* Logical error */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t\tret = 0;\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\n\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\tif (found_key.objectid != search_key->objectid ||\n\t    found_key.type != BTRFS_ROOT_ITEM_KEY) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (root_item)\n\t\tbtrfs_read_root_item(l, slot, root_item);\n\tif (root_key)\n\t\tmemcpy(root_key, &found_key, sizeof(found_key));\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_find_root(struct btrfs_root *root, struct btrfs_key *search_key,\n\t\t    struct btrfs_path *path, struct btrfs_root_item *root_item,\n\t\t    struct btrfs_key *root_key)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, search_key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (search_key->offset != -1ULL) {\t/* the search key is exact */\n\t\tif (ret > 0)\n\t\t\tgoto out;\n\t} else {\n\t\tBUG_ON(ret == 0);\t\t/* Logical error */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t\tret = 0;\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\n\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\tif (found_key.objectid != search_key->objectid ||\n\t    found_key.type != BTRFS_ROOT_ITEM_KEY) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (root_item)\n\t\tbtrfs_read_root_item(l, slot, root_item);\n\tif (root_key)\n\t\tmemcpy(root_key, &found_key, sizeof(found_key));\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_root",
          "args": [
            "tree_root->nodesize",
            "tree_root->sectorsize",
            "tree_root->stripesize",
            "root",
            "fs_info",
            "key->objectid"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1214-1286",
          "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_root",
          "args": [
            "fs_info"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1288-1294",
          "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_read_tree_root(struct btrfs_root *tree_root,\n\t\t\t\t\t       struct btrfs_key *key)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info = tree_root->fs_info;\n\tstruct btrfs_path *path;\n\tu64 generation;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, key->objectid);\n\n\tret = btrfs_find_root(tree_root, key, path,\n\t\t\t      &root->root_item, &root->root_key);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto find_fail;\n\t}\n\n\tgeneration = btrfs_root_generation(&root->root_item);\n\troot->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),\n\t\t\t\t     generation);\n\tif (!root->node) {\n\t\tret = -ENOMEM;\n\t\tgoto find_fail;\n\t} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {\n\t\tret = -EIO;\n\t\tgoto read_fail;\n\t}\n\troot->commit_root = btrfs_root_node(root);\nout:\n\tbtrfs_free_path(path);\n\treturn root;\n\nread_fail:\n\tfree_extent_buffer(root->node);\nfind_fail:\n\tkfree(root);\nalloc_fail:\n\troot = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "btrfs_add_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1455-1483",
    "snippet": "int btrfs_add_log_tree(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_root *log_root;\n\tstruct btrfs_inode_item *inode_item;\n\n\tlog_root = alloc_log_tree(trans, root->fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\n\tlog_root->last_trans = trans->transid;\n\tlog_root->root_key.offset = root->root_key.objectid;\n\n\tinode_item = &log_root->root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_node(&log_root->root_item, log_root->node);\n\n\tWARN_ON(root->log_root);\n\troot->log_root = log_root;\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root->log_root"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&log_root->root_item",
            "log_root->node"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_mode",
          "args": [
            "inode_item",
            "S_IFDIR | 0755"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nbytes",
          "args": [
            "inode_item",
            "root->nodesize"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nlink",
          "args": [
            "inode_item",
            "1"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_size",
          "args": [
            "inode_item",
            "3"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_generation",
          "args": [
            "inode_item",
            "1"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "log_root"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log_root"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_log_tree",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1393-1440",
          "snippet": "static struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_add_log_tree(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_root *log_root;\n\tstruct btrfs_inode_item *inode_item;\n\n\tlog_root = alloc_log_tree(trans, root->fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\n\tlog_root->last_trans = trans->transid;\n\tlog_root->root_key.offset = root->root_key.objectid;\n\n\tinode_item = &log_root->root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_node(&log_root->root_item, log_root->node);\n\n\tWARN_ON(root->log_root);\n\troot->log_root = log_root;\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_init_log_root_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1442-1453",
    "snippet": "int btrfs_init_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *log_root;\n\n\tlog_root = alloc_log_tree(trans, fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\tWARN_ON(fs_info->log_root_tree);\n\tfs_info->log_root_tree = log_root;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "fs_info->log_root_tree"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "log_root"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log_root"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_log_tree",
          "args": [
            "trans",
            "fs_info"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1393-1440",
          "snippet": "static struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_init_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *log_root;\n\n\tlog_root = alloc_log_tree(trans, fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\tWARN_ON(fs_info->log_root_tree);\n\tfs_info->log_root_tree = log_root;\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1393-1440",
    "snippet": "static struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "root->node"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "root->node"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "root->node",
            "root->fs_info->fsid",
            "btrfs_header_fsid()",
            "BTRFS_FSID_SIZE"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "leaf",
            "BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "leaf",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "leaf",
            "trans->transid"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "leaf",
            "leaf->start"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "leaf"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "leaf"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "BTRFS_TREE_LOG_OBJECTID",
            "NULL",
            "0",
            "0",
            "0"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_root",
          "args": [
            "tree_root->nodesize",
            "tree_root->sectorsize",
            "tree_root->stripesize",
            "root",
            "fs_info",
            "BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1214-1286",
          "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_root",
          "args": [
            "fs_info"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1288-1294",
          "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct extent_buffer *leaf;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\t     tree_root->stripesize, root, fs_info,\n\t\t     BTRFS_TREE_LOG_OBJECTID);\n\n\troot->root_key.objectid = BTRFS_TREE_LOG_OBJECTID;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = BTRFS_TREE_LOG_OBJECTID;\n\n\t/*\n\t * DON'T set REF_COWS for log trees\n\t *\n\t * log trees do not get reference counted because they go away\n\t * before a real commit is actually done.  They do store pointers\n\t * to file data extents, and those reference counts still get\n\t * updated (along with back refs to the log tree).\n\t */\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, BTRFS_TREE_LOG_OBJECTID,\n\t\t\tNULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tkfree(root);\n\t\treturn ERR_CAST(leaf);\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, BTRFS_TREE_LOG_OBJECTID);\n\troot->node = leaf;\n\n\twrite_extent_buffer(root->node, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\tbtrfs_mark_buffer_dirty(root->node);\n\tbtrfs_tree_unlock(root->node);\n\treturn root;\n}"
  },
  {
    "function_name": "btrfs_create_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1313-1391",
    "snippet": "struct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "leaf"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "leaf"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_root",
          "args": [
            "trans",
            "tree_root",
            "&key",
            "&root->root_item"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "212-220",
          "snippet": "int btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root->root_item.uuid",
            "uuid.b",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_le_gen",
          "args": [
            "&uuid"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_dirid",
          "args": [
            "&root->root_item",
            "0"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_last_snapshot",
          "args": [
            "&root->root_item",
            "0"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_used",
          "args": [
            "&root->root_item",
            "leaf->len"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&root->root_item",
            "1"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_level",
          "args": [
            "&root->root_item",
            "0"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_generation",
          "args": [
            "&root->root_item",
            "trans->transid"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_bytenr",
          "args": [
            "&root->root_item",
            "leaf->start"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_TRACK_DIRTY",
            "&root->state"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(leaf)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "leaf"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "leaf",
            "objectid"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "leaf",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "leaf",
            "trans->transid"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "leaf",
            "leaf->start"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "leaf"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "leaf"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "objectid",
            "NULL",
            "0",
            "0",
            "0"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_root",
          "args": [
            "tree_root->nodesize",
            "tree_root->sectorsize",
            "tree_root->stripesize",
            "root",
            "fs_info",
            "objectid"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1214-1286",
          "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_root",
          "args": [
            "fs_info"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1288-1294",
          "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "btrfs_alloc_dummy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1298-1310",
    "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_DUMMY_ROOT",
            "&root->state"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_root",
          "args": [
            "4096",
            "4096",
            "4096",
            "root",
            "NULL",
            "1"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1214-1286",
          "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_root",
          "args": [
            "NULL"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1288-1294",
          "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
  },
  {
    "function_name": "btrfs_alloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1288-1294",
    "snippet": "static struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*root)",
            "GFP_NOFS"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);\n\tif (root)\n\t\troot->fs_info = fs_info;\n\treturn root;\n}"
  },
  {
    "function_name": "__setup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1214-1286",
    "snippet": "static void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->root_item_lock"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->defrag_progress",
            "0",
            "sizeof(root->defrag_progress)"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->root_item",
            "0",
            "sizeof(root->root_item)"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->root_key",
            "0",
            "sizeof(root->root_key)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_io_tree_init",
          "args": [
            "&root->dirty_log_pages",
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "198-206",
          "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->will_be_snapshoted",
            "0"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->refs",
            "1"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->orphan_inodes",
            "0"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_batch",
            "0"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_writers",
            "0"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_commit[1]",
            "0"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_commit[0]",
            "0"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->log_ctxs[1]"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->log_ctxs[0]"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&root->log_commit_wait[1]"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&root->log_commit_wait[0]"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&root->log_writer_wait"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&root->delalloc_mutex"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&root->ordered_extent_mutex"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&root->log_mutex"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&root->objectid_mutex"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->log_extents_lock[1]"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->log_extents_lock[0]"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->accounting_lock"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->delalloc_lock"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&root->orphan_lock"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->logged_list[1]"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->logged_list[0]"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->ordered_root"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->ordered_extents"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->delalloc_root"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->delalloc_inodes"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->root_list"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->dirty_list"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&root->delayed_nodes_tree",
            "GFP_ATOMIC"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void __setup_root(u32 nodesize, u32 sectorsize, u32 stripesize,\n\t\t\t struct btrfs_root *root, struct btrfs_fs_info *fs_info,\n\t\t\t u64 objectid)\n{\n\troot->node = NULL;\n\troot->commit_root = NULL;\n\troot->sectorsize = sectorsize;\n\troot->nodesize = nodesize;\n\troot->stripesize = stripesize;\n\troot->state = 0;\n\troot->orphan_cleanup_state = 0;\n\n\troot->objectid = objectid;\n\troot->last_trans = 0;\n\troot->highest_objectid = 0;\n\troot->nr_delalloc_inodes = 0;\n\troot->nr_ordered_extents = 0;\n\troot->name = NULL;\n\troot->inode_tree = RB_ROOT;\n\tINIT_RADIX_TREE(&root->delayed_nodes_tree, GFP_ATOMIC);\n\troot->block_rsv = NULL;\n\troot->orphan_block_rsv = NULL;\n\n\tINIT_LIST_HEAD(&root->dirty_list);\n\tINIT_LIST_HEAD(&root->root_list);\n\tINIT_LIST_HEAD(&root->delalloc_inodes);\n\tINIT_LIST_HEAD(&root->delalloc_root);\n\tINIT_LIST_HEAD(&root->ordered_extents);\n\tINIT_LIST_HEAD(&root->ordered_root);\n\tINIT_LIST_HEAD(&root->logged_list[0]);\n\tINIT_LIST_HEAD(&root->logged_list[1]);\n\tspin_lock_init(&root->orphan_lock);\n\tspin_lock_init(&root->inode_lock);\n\tspin_lock_init(&root->delalloc_lock);\n\tspin_lock_init(&root->ordered_extent_lock);\n\tspin_lock_init(&root->accounting_lock);\n\tspin_lock_init(&root->log_extents_lock[0]);\n\tspin_lock_init(&root->log_extents_lock[1]);\n\tmutex_init(&root->objectid_mutex);\n\tmutex_init(&root->log_mutex);\n\tmutex_init(&root->ordered_extent_mutex);\n\tmutex_init(&root->delalloc_mutex);\n\tinit_waitqueue_head(&root->log_writer_wait);\n\tinit_waitqueue_head(&root->log_commit_wait[0]);\n\tinit_waitqueue_head(&root->log_commit_wait[1]);\n\tINIT_LIST_HEAD(&root->log_ctxs[0]);\n\tINIT_LIST_HEAD(&root->log_ctxs[1]);\n\tatomic_set(&root->log_commit[0], 0);\n\tatomic_set(&root->log_commit[1], 0);\n\tatomic_set(&root->log_writers, 0);\n\tatomic_set(&root->log_batch, 0);\n\tatomic_set(&root->orphan_inodes, 0);\n\tatomic_set(&root->refs, 1);\n\tatomic_set(&root->will_be_snapshoted, 0);\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\tif (fs_info)\n\t\textent_io_tree_init(&root->dirty_log_pages,\n\t\t\t\t     fs_info->btree_inode->i_mapping);\n\n\tmemset(&root->root_key, 0, sizeof(root->root_key));\n\tmemset(&root->root_item, 0, sizeof(root->root_item));\n\tmemset(&root->defrag_progress, 0, sizeof(root->defrag_progress));\n\tif (fs_info)\n\t\troot->defrag_trans_start = fs_info->generation;\n\telse\n\t\troot->defrag_trans_start = 0;\n\troot->root_key.objectid = objectid;\n\troot->anon_dev = 0;\n\n\tspin_lock_init(&root->root_item_lock);\n}"
  },
  {
    "function_name": "btrfs_free_subvolume_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1207-1212",
    "snippet": "static void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "writers"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&writers->counter"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void\nbtrfs_free_subvolume_writers(struct btrfs_subvolume_writers *writers)\n{\n\tpercpu_counter_destroy(&writers->counter);\n\tkfree(writers);\n}"
  },
  {
    "function_name": "btrfs_alloc_subvolume_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1188-1205",
    "snippet": "static struct btrfs_subvolume_writers *btrfs_alloc_subvolume_writers(void)\n{\n\tstruct btrfs_subvolume_writers *writers;\n\tint ret;\n\n\twriters = kmalloc(sizeof(*writers), GFP_NOFS);\n\tif (!writers)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_counter_init(&writers->counter, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(writers);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinit_waitqueue_head(&writers->wait);\n\treturn writers;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&writers->wait"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "writers"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&writers->counter",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*writers)",
            "GFP_NOFS"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_subvolume_writers *btrfs_alloc_subvolume_writers(void)\n{\n\tstruct btrfs_subvolume_writers *writers;\n\tint ret;\n\n\twriters = kmalloc(sizeof(*writers), GFP_NOFS);\n\tif (!writers)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_counter_init(&writers->counter, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(writers);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinit_waitqueue_head(&writers->wait);\n\treturn writers;\n}"
  },
  {
    "function_name": "clean_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1168-1186",
    "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_buffer_dirty",
          "args": [
            "buf"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5033-5061",
          "snippet": "void clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "buf"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__percpu_counter_add",
          "args": [
            "&fs_info->dirty_metadata_bytes",
            "-buf->len",
            "fs_info->dirty_metadata_batch"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&buf->bflags"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "buf"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "read_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1149-1166",
    "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "buf"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_read_extent_buffer_pages",
          "args": [
            "root",
            "buf",
            "0",
            "parent_transid"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_create_tree_block",
          "args": [
            "root",
            "bytenr"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_create_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1128-1134",
          "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
  },
  {
    "function_name": "btrfs_wait_tree_block_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1143-1147",
    "snippet": "int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "buf->pages[0]->mapping",
            "buf->start",
            "buf->start + buf->len - 1"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}"
  },
  {
    "function_name": "btrfs_write_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1137-1141",
    "snippet": "int btrfs_write_tree_block(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawrite_range(buf->pages[0]->mapping, buf->start,\n\t\t\t\t\tbuf->start + buf->len - 1);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "buf->pages[0]->mapping",
            "buf->start",
            "buf->start + buf->len - 1"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_write_tree_block(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawrite_range(buf->pages[0]->mapping, buf->start,\n\t\t\t\t\tbuf->start + buf->len - 1);\n}"
  },
  {
    "function_name": "btrfs_find_create_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1128-1134",
    "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_extent_buffer",
          "args": [
            "root->fs_info",
            "bytenr"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4826-4941",
          "snippet": "struct extent_buffer *alloc_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 start)\n{\n\tunsigned long len = fs_info->tree_root->nodesize;\n\tunsigned long num_pages = num_extent_pages(start, len);\n\tunsigned long i;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *exists = NULL;\n\tstruct page *p;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tint uptodate = 1;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++, index++) {\n\t\tp = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!p)\n\t\t\tgoto free_eb;\n\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (PagePrivate(p)) {\n\t\t\t/*\n\t\t\t * We could have already allocated an eb for this page\n\t\t\t * and attached one so lets see if we can get a ref on\n\t\t\t * the existing eb, and if we can we know it's good and\n\t\t\t * we can just return that one, else we know we can just\n\t\t\t * overwrite page->private.\n\t\t\t */\n\t\t\texists = (struct extent_buffer *)p->private;\n\t\t\tif (atomic_inc_not_zero(&exists->refs)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tunlock_page(p);\n\t\t\t\tpage_cache_release(p);\n\t\t\t\tmark_extent_buffer_accessed(exists, p);\n\t\t\t\tgoto free_eb;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do this so attach doesn't complain and we need to\n\t\t\t * drop the ref the old guy had.\n\t\t\t */\n\t\t\tClearPagePrivate(p);\n\t\t\tWARN_ON(PageDirty(p));\n\t\t\tpage_cache_release(p);\n\t\t}\n\t\tattach_extent_buffer_page(eb, p);\n\t\tspin_unlock(&mapping->private_lock);\n\t\tWARN_ON(PageDirty(p));\n\t\teb->pages[i] = p;\n\t\tif (!PageUptodate(p))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * see below about how we avoid a nasty race with release page\n\t\t * and why we unlock later\n\t\t */\n\t}\n\tif (uptodate)\n\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\t/* add one reference for the tree */\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * there is a race where release page may have\n\t * tried to find this extent buffer in the radix\n\t * but failed.  It will tell the VM it is safe to\n\t * reclaim the, and it will clear the page private bit.\n\t * We must make sure to set the page private bit properly\n\t * after the extent buffer is in the radix tree so\n\t * it doesn't get lost\n\t */\n\tSetPageChecked(eb->pages[0]);\n\tfor (i = 1; i < num_pages; i++) {\n\t\tp = eb->pages[i];\n\t\tClearPageChecked(p);\n\t\tunlock_page(p);\n\t}\n\tunlock_page(eb->pages[0]);\n\treturn eb;\n\nfree_eb:\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (eb->pages[i])\n\t\t\tunlock_page(eb->pages[i]);\n\t}\n\n\tWARN_ON(!atomic_dec_and_test(&eb->refs));\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 start)\n{\n\tunsigned long len = fs_info->tree_root->nodesize;\n\tunsigned long num_pages = num_extent_pages(start, len);\n\tunsigned long i;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *exists = NULL;\n\tstruct page *p;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tint uptodate = 1;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++, index++) {\n\t\tp = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!p)\n\t\t\tgoto free_eb;\n\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (PagePrivate(p)) {\n\t\t\t/*\n\t\t\t * We could have already allocated an eb for this page\n\t\t\t * and attached one so lets see if we can get a ref on\n\t\t\t * the existing eb, and if we can we know it's good and\n\t\t\t * we can just return that one, else we know we can just\n\t\t\t * overwrite page->private.\n\t\t\t */\n\t\t\texists = (struct extent_buffer *)p->private;\n\t\t\tif (atomic_inc_not_zero(&exists->refs)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tunlock_page(p);\n\t\t\t\tpage_cache_release(p);\n\t\t\t\tmark_extent_buffer_accessed(exists, p);\n\t\t\t\tgoto free_eb;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do this so attach doesn't complain and we need to\n\t\t\t * drop the ref the old guy had.\n\t\t\t */\n\t\t\tClearPagePrivate(p);\n\t\t\tWARN_ON(PageDirty(p));\n\t\t\tpage_cache_release(p);\n\t\t}\n\t\tattach_extent_buffer_page(eb, p);\n\t\tspin_unlock(&mapping->private_lock);\n\t\tWARN_ON(PageDirty(p));\n\t\teb->pages[i] = p;\n\t\tif (!PageUptodate(p))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * see below about how we avoid a nasty race with release page\n\t\t * and why we unlock later\n\t\t */\n\t}\n\tif (uptodate)\n\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\t/* add one reference for the tree */\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * there is a race where release page may have\n\t * tried to find this extent buffer in the radix\n\t * but failed.  It will tell the VM it is safe to\n\t * reclaim the, and it will clear the page private bit.\n\t * We must make sure to set the page private bit properly\n\t * after the extent buffer is in the radix tree so\n\t * it doesn't get lost\n\t */\n\tSetPageChecked(eb->pages[0]);\n\tfor (i = 1; i < num_pages; i++) {\n\t\tp = eb->pages[i];\n\t\tClearPageChecked(p);\n\t\tunlock_page(p);\n\t}\n\tunlock_page(eb->pages[0]);\n\treturn eb;\n\nfree_eb:\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (eb->pages[i])\n\t\t\tunlock_page(eb->pages[i]);\n\t}\n\n\tWARN_ON(!atomic_dec_and_test(&eb->refs));\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_test_extent_buffer",
          "args": [
            "root->fs_info",
            "bytenr"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_test_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4780-4823",
          "snippet": "struct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_is_dummy_root",
          "args": [
            "root"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_is_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4198-4205",
          "snippet": "static inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_DUMMY_ROOT\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_DUMMY_ROOT\t\t4\n\nstatic inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
  },
  {
    "function_name": "btrfs_find_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1122-1126",
    "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_extent_buffer",
          "args": [
            "root->fs_info",
            "bytenr"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "find_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4761-4777",
          "snippet": "struct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
  },
  {
    "function_name": "reada_tree_block_flagged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1090-1120",
    "snippet": "int reada_tree_block_flagged(struct btrfs_root *root, u64 bytenr,\n\t\t\t int mirror_num, struct extent_buffer **eb)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(btree_inode)->io_tree;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn 0;\n\n\tset_bit(EXTENT_BUFFER_READAHEAD, &buf->bflags);\n\n\tret = read_extent_buffer_pages(io_tree, buf, 0, WAIT_PAGE_LOCK,\n\t\t\t\t       btree_get_extent, mirror_num);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags)) {\n\t\tfree_extent_buffer(buf);\n\t\treturn -EIO;\n\t} else if (extent_buffer_uptodate(buf)) {\n\t\t*eb = buf;\n\t} else {\n\t\tfree_extent_buffer(buf);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "buf"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "buf"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_CORRUPT",
            "&buf->bflags"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer_pages",
          "args": [
            "io_tree",
            "buf",
            "0",
            "WAIT_PAGE_LOCK",
            "btree_get_extent",
            "mirror_num"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5118-5212",
          "snippet": "int read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_READAHEAD",
            "&buf->bflags"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_create_tree_block",
          "args": [
            "root",
            "bytenr"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_create_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1128-1134",
          "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "btree_inode"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint reada_tree_block_flagged(struct btrfs_root *root, u64 bytenr,\n\t\t\t int mirror_num, struct extent_buffer **eb)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(btree_inode)->io_tree;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn 0;\n\n\tset_bit(EXTENT_BUFFER_READAHEAD, &buf->bflags);\n\n\tret = read_extent_buffer_pages(io_tree, buf, 0, WAIT_PAGE_LOCK,\n\t\t\t\t       btree_get_extent, mirror_num);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags)) {\n\t\tfree_extent_buffer(buf);\n\t\treturn -EIO;\n\t} else if (extent_buffer_uptodate(buf)) {\n\t\t*eb = buf;\n\t} else {\n\t\tfree_extent_buffer(buf);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "readahead_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1077-1088",
    "snippet": "void readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "buf"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer_pages",
          "args": [
            "&BTRFS_I(btree_inode)->io_tree",
            "buf",
            "0",
            "WAIT_NONE",
            "btree_get_extent",
            "0"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5118-5212",
          "snippet": "int read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "btree_inode"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_create_tree_block",
          "args": [
            "root",
            "bytenr"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_create_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1128-1134",
          "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}"
  },
  {
    "function_name": "btree_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1051-1064",
    "snippet": "static int btree_set_page_dirty(struct page *page)\n{\n#ifdef DEBUG\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(!PagePrivate(page));\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\tBUG_ON(!test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\tBUG_ON(!atomic_read(&eb->refs));\n\tbtrfs_assert_tree_locked(eb);\n#endif\n\treturn __set_page_dirty_nobuffers(page);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "eb"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&eb->refs)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!eb"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PagePrivate(page)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btree_set_page_dirty(struct page *page)\n{\n#ifdef DEBUG\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(!PagePrivate(page));\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\tBUG_ON(!test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\tBUG_ON(!atomic_read(&eb->refs));\n\tbtrfs_assert_tree_locked(eb);\n#endif\n\treturn __set_page_dirty_nobuffers(page);\n}"
  },
  {
    "function_name": "btree_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1034-1049",
    "snippet": "static void btree_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\textent_invalidatepage(tree, page, offset);\n\tbtree_releasepage(page, GFP_NOFS);\n\tif (PagePrivate(page)) {\n\t\tbtrfs_warn(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t   \"page private not zero on page %llu\",\n\t\t\t   (unsigned long long)page_offset(page));\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "BTRFS_I(page->mapping->host)->root->fs_info",
            "\"page private not zero on page %llu\"",
            "(unsigned long long)page_offset(page)"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_releasepage",
          "args": [
            "page",
            "GFP_NOFS"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "btree_releasepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1026-1032",
          "snippet": "static int btree_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tif (PageWriteback(page) || PageDirty(page))\n\t\treturn 0;\n\n\treturn try_release_extent_buffer(page);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btree_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tif (PageWriteback(page) || PageDirty(page))\n\t\treturn 0;\n\n\treturn try_release_extent_buffer(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_invalidatepage",
          "args": [
            "tree",
            "page",
            "offset"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "extent_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4193-4212",
          "snippet": "int extent_invalidatepage(struct extent_io_tree *tree,\n\t\t\t  struct page *page, unsigned long offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tsize_t blocksize = page->mapping->host->i_sb->s_blocksize;\n\n\tstart += ALIGN(offset, blocksize);\n\tif (start > end)\n\t\treturn 0;\n\n\tlock_extent_bits(tree, start, end, 0, &cached_state);\n\twait_on_page_writeback(page);\n\tclear_extent_bit(tree, start, end,\n\t\t\t EXTENT_LOCKED | EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t EXTENT_DO_ACCOUNTING,\n\t\t\t 1, 1, &cached_state, GFP_NOFS);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_invalidatepage(struct extent_io_tree *tree,\n\t\t\t  struct page *page, unsigned long offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tsize_t blocksize = page->mapping->host->i_sb->s_blocksize;\n\n\tstart += ALIGN(offset, blocksize);\n\tif (start > end)\n\t\treturn 0;\n\n\tlock_extent_bits(tree, start, end, 0, &cached_state);\n\twait_on_page_writeback(page);\n\tclear_extent_bit(tree, start, end,\n\t\t\t EXTENT_LOCKED | EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t EXTENT_DO_ACCOUNTING,\n\t\t\t 1, 1, &cached_state, GFP_NOFS);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void btree_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\textent_invalidatepage(tree, page, offset);\n\tbtree_releasepage(page, GFP_NOFS);\n\tif (PagePrivate(page)) {\n\t\tbtrfs_warn(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t   \"page private not zero on page %llu\",\n\t\t\t   (unsigned long long)page_offset(page));\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "btree_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1026-1032",
    "snippet": "static int btree_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tif (PageWriteback(page) || PageDirty(page))\n\t\treturn 0;\n\n\treturn try_release_extent_buffer(page);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_release_extent_buffer",
          "args": [
            "page"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "try_release_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5568-5608",
          "snippet": "int try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btree_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tif (PageWriteback(page) || PageDirty(page))\n\t\treturn 0;\n\n\treturn try_release_extent_buffer(page);\n}"
  },
  {
    "function_name": "btree_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "1019-1024",
    "snippet": "static int btree_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btree_get_extent, 0);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extent_read_full_page",
          "args": [
            "tree",
            "page",
            "btree_get_extent",
            "0"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "extent_read_full_page_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3189-3201",
          "snippet": "int extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btree_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btree_get_extent, 0);\n}"
  },
  {
    "function_name": "btree_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "998-1017",
    "snippet": "static int btree_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tint ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\n\t\tif (wbc->for_kupdate)\n\t\t\treturn 0;\n\n\t\tfs_info = BTRFS_I(mapping->host)->root->fs_info;\n\t\t/* this is a bit racy, but that's ok */\n\t\tret = percpu_counter_compare(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t}\n\treturn btree_write_cache_pages(mapping, wbc);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_write_cache_pages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "btree_write_cache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3778-3898",
          "snippet": "int btree_write_cache_pages(struct address_space *mapping,\n\t\t\t\t   struct writeback_control *wbc)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(mapping->host)->io_tree;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(mapping->host)->root->fs_info;\n\tstruct extent_buffer *eb, *prev_eb = NULL;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_lock(&mapping->private_lock);\n\t\t\tif (!PagePrivate(page)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teb = (struct extent_buffer *)page->private;\n\n\t\t\t/*\n\t\t\t * Shouldn't happen and normally this would be a BUG_ON\n\t\t\t * but no sense in crashing the users box for something\n\t\t\t * we can survive anyway.\n\t\t\t */\n\t\t\tif (WARN_ON(!eb)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eb == prev_eb) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = atomic_inc_not_zero(&eb->refs);\n\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tprev_eb = eb;\n\t\t\tret = lock_extent_buffer_for_io(eb, fs_info, &epd);\n\t\t\tif (!ret) {\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = write_one_eb(eb, fs_info, wbc, &epd);\n\t\t\tif (ret) {\n\t\t\t\tdone = 1;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree_extent_buffer(eb);\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tflush_write_bio(&epd);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint btree_write_cache_pages(struct address_space *mapping,\n\t\t\t\t   struct writeback_control *wbc)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(mapping->host)->io_tree;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(mapping->host)->root->fs_info;\n\tstruct extent_buffer *eb, *prev_eb = NULL;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_lock(&mapping->private_lock);\n\t\t\tif (!PagePrivate(page)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teb = (struct extent_buffer *)page->private;\n\n\t\t\t/*\n\t\t\t * Shouldn't happen and normally this would be a BUG_ON\n\t\t\t * but no sense in crashing the users box for something\n\t\t\t * we can survive anyway.\n\t\t\t */\n\t\t\tif (WARN_ON(!eb)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eb == prev_eb) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = atomic_inc_not_zero(&eb->refs);\n\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tprev_eb = eb;\n\t\t\tret = lock_extent_buffer_for_io(eb, fs_info, &epd);\n\t\t\tif (!ret) {\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = write_one_eb(eb, fs_info, wbc, &epd);\n\t\t\tif (ret) {\n\t\t\t\tdone = 1;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree_extent_buffer(eb);\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tflush_write_bio(&epd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_compare",
          "args": [
            "&fs_info->dirty_metadata_bytes",
            "BTRFS_DIRTY_METADATA_THRESH"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tint ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\n\t\tif (wbc->for_kupdate)\n\t\t\treturn 0;\n\n\t\tfs_info = BTRFS_I(mapping->host)->root->fs_info;\n\t\t/* this is a bit racy, but that's ok */\n\t\tret = percpu_counter_compare(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     BTRFS_DIRTY_METADATA_THRESH);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t}\n\treturn btree_write_cache_pages(mapping, wbc);\n}"
  },
  {
    "function_name": "btree_migratepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "976-994",
    "snippet": "static int btree_migratepage(struct address_space *mapping,\n\t\t\tstruct page *newpage, struct page *page,\n\t\t\tenum migrate_mode mode)\n{\n\t/*\n\t * we can't safely write a btree page from here,\n\t * we haven't done the locking hook\n\t */\n\tif (PageDirty(page))\n\t\treturn -EAGAIN;\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1928-1946",
          "snippet": "int nfs_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\t/*\n\t * If PagePrivate is set, then the page is currently associated with\n\t * an in-progress read or write request. Don't try to migrate it.\n\t *\n\t * FIXME: we could do this in principle, but we'll need a way to ensure\n\t *        that we can safely release the inode reference while holding\n\t *        the page lock.\n\t */\n\tif (PagePrivate(page))\n\t\treturn -EBUSY;\n\n\tif (!nfs_fscache_release_page(page, GFP_KERNEL))\n\t\treturn -EBUSY;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\t/*\n\t * If PagePrivate is set, then the page is currently associated with\n\t * an in-progress read or write request. Don't try to migrate it.\n\t *\n\t * FIXME: we could do this in principle, but we'll need a way to ensure\n\t *        that we can safely release the inode reference while holding\n\t *        the page lock.\n\t */\n\tif (PagePrivate(page))\n\t\treturn -EBUSY;\n\n\tif (!nfs_fscache_release_page(page, GFP_KERNEL))\n\t\treturn -EBUSY;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btree_migratepage(struct address_space *mapping,\n\t\t\tstruct page *newpage, struct page *page,\n\t\t\tenum migrate_mode mode)\n{\n\t/*\n\t * we can't safely write a btree page from here,\n\t * we haven't done the locking hook\n\t */\n\tif (PageDirty(page))\n\t\treturn -EAGAIN;\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
  },
  {
    "function_name": "btree_submit_bio_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "932-973",
    "snippet": "static int btree_submit_bio_hook(struct inode *inode, int rw, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags,\n\t\t\t\t u64 bio_offset)\n{\n\tint async = check_async_write(inode, bio_flags);\n\tint ret;\n\n\tif (!(rw & REQ_WRITE)) {\n\t\t/*\n\t\t * called for a read, do the setup so that checksum validation\n\t\t * can happen in the async kernel threads\n\t\t */\n\t\tret = btrfs_bio_wq_end_io(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t  bio, BTRFS_WQ_ENDIO_METADATA);\n\t\tif (ret)\n\t\t\tgoto out_w_error;\n\t\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio,\n\t\t\t\t    mirror_num, 0);\n\t} else if (!async) {\n\t\tret = btree_csum_one_bio(bio);\n\t\tif (ret)\n\t\t\tgoto out_w_error;\n\t\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio,\n\t\t\t\t    mirror_num, 0);\n\t} else {\n\t\t/*\n\t\t * kthread helpers are used to submit writes so that\n\t\t * checksumming can happen in parallel across all CPUs\n\t\t */\n\t\tret = btrfs_wq_submit_bio(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t  inode, rw, bio, mirror_num, 0,\n\t\t\t\t\t  bio_offset,\n\t\t\t\t\t  __btree_submit_bio_start,\n\t\t\t\t\t  __btree_submit_bio_done);\n\t}\n\n\tif (ret) {\nout_w_error:\n\t\tbio_endio(bio, ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "bio",
            "ret"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wq_submit_bio",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "inode",
            "rw",
            "bio",
            "mirror_num",
            "0",
            "bio_offset",
            "__btree_submit_bio_start",
            "__btree_submit_bio_done"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wq_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "833-875",
          "snippet": "int btrfs_wq_submit_bio(struct btrfs_fs_info *fs_info, struct inode *inode,\n\t\t\tint rw, struct bio *bio, int mirror_num,\n\t\t\tunsigned long bio_flags,\n\t\t\tu64 bio_offset,\n\t\t\textent_submit_bio_hook_t *submit_bio_start,\n\t\t\textent_submit_bio_hook_t *submit_bio_done)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->inode = inode;\n\tasync->rw = rw;\n\tasync->bio = bio;\n\tasync->mirror_num = mirror_num;\n\tasync->submit_bio_start = submit_bio_start;\n\tasync->submit_bio_done = submit_bio_done;\n\n\tbtrfs_init_work(&async->work, btrfs_worker_helper, run_one_async_start,\n\t\t\trun_one_async_done, run_one_async_free);\n\n\tasync->bio_flags = bio_flags;\n\tasync->bio_offset = bio_offset;\n\n\tasync->error = 0;\n\n\tatomic_inc(&fs_info->nr_async_submits);\n\n\tif (rw & REQ_SYNC)\n\t\tbtrfs_set_work_high_priority(&async->work);\n\n\tbtrfs_queue_work(fs_info->workers, &async->work);\n\n\twhile (atomic_read(&fs_info->async_submit_draining) &&\n\t      atomic_read(&fs_info->nr_async_submits)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&fs_info->nr_async_submits) == 0));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void end_workqueue_fn(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\n\nint btrfs_wq_submit_bio(struct btrfs_fs_info *fs_info, struct inode *inode,\n\t\t\tint rw, struct bio *bio, int mirror_num,\n\t\t\tunsigned long bio_flags,\n\t\t\tu64 bio_offset,\n\t\t\textent_submit_bio_hook_t *submit_bio_start,\n\t\t\textent_submit_bio_hook_t *submit_bio_done)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->inode = inode;\n\tasync->rw = rw;\n\tasync->bio = bio;\n\tasync->mirror_num = mirror_num;\n\tasync->submit_bio_start = submit_bio_start;\n\tasync->submit_bio_done = submit_bio_done;\n\n\tbtrfs_init_work(&async->work, btrfs_worker_helper, run_one_async_start,\n\t\t\trun_one_async_done, run_one_async_free);\n\n\tasync->bio_flags = bio_flags;\n\tasync->bio_offset = bio_offset;\n\n\tasync->error = 0;\n\n\tatomic_inc(&fs_info->nr_async_submits);\n\n\tif (rw & REQ_SYNC)\n\t\tbtrfs_set_work_high_priority(&async->work);\n\n\tbtrfs_queue_work(fs_info->workers, &async->work);\n\n\twhile (atomic_read(&fs_info->async_submit_draining) &&\n\t      atomic_read(&fs_info->nr_async_submits)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&fs_info->nr_async_submits) == 0));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_bio",
          "args": [
            "BTRFS_I(inode)->root",
            "rw",
            "bio",
            "mirror_num",
            "0"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5829-5916",
          "snippet": "int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_csum_one_bio",
          "args": [
            "bio"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "btree_csum_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "877-891",
          "snippet": "static int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "bio",
            "BTRFS_WQ_ENDIO_METADATA"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_async_write",
          "args": [
            "inode",
            "bio_flags"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "check_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "921-930",
          "snippet": "static int check_async_write(struct inode *inode, unsigned long bio_flags)\n{\n\tif (bio_flags & EXTENT_BIO_TREE_LOG)\n\t\treturn 0;\n#ifdef CONFIG_X86\n\tif (cpu_has_xmm4_2)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int check_async_write(struct inode *inode, unsigned long bio_flags)\n{\n\tif (bio_flags & EXTENT_BIO_TREE_LOG)\n\t\treturn 0;\n#ifdef CONFIG_X86\n\tif (cpu_has_xmm4_2)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_submit_bio_hook(struct inode *inode, int rw, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags,\n\t\t\t\t u64 bio_offset)\n{\n\tint async = check_async_write(inode, bio_flags);\n\tint ret;\n\n\tif (!(rw & REQ_WRITE)) {\n\t\t/*\n\t\t * called for a read, do the setup so that checksum validation\n\t\t * can happen in the async kernel threads\n\t\t */\n\t\tret = btrfs_bio_wq_end_io(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t  bio, BTRFS_WQ_ENDIO_METADATA);\n\t\tif (ret)\n\t\t\tgoto out_w_error;\n\t\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio,\n\t\t\t\t    mirror_num, 0);\n\t} else if (!async) {\n\t\tret = btree_csum_one_bio(bio);\n\t\tif (ret)\n\t\t\tgoto out_w_error;\n\t\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio,\n\t\t\t\t    mirror_num, 0);\n\t} else {\n\t\t/*\n\t\t * kthread helpers are used to submit writes so that\n\t\t * checksumming can happen in parallel across all CPUs\n\t\t */\n\t\tret = btrfs_wq_submit_bio(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t  inode, rw, bio, mirror_num, 0,\n\t\t\t\t\t  bio_offset,\n\t\t\t\t\t  __btree_submit_bio_start,\n\t\t\t\t\t  __btree_submit_bio_done);\n\t}\n\n\tif (ret) {\nout_w_error:\n\t\tbio_endio(bio, ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "check_async_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "921-930",
    "snippet": "static int check_async_write(struct inode *inode, unsigned long bio_flags)\n{\n\tif (bio_flags & EXTENT_BIO_TREE_LOG)\n\t\treturn 0;\n#ifdef CONFIG_X86\n\tif (cpu_has_xmm4_2)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int check_async_write(struct inode *inode, unsigned long bio_flags)\n{\n\tif (bio_flags & EXTENT_BIO_TREE_LOG)\n\t\treturn 0;\n#ifdef CONFIG_X86\n\tif (cpu_has_xmm4_2)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "__btree_submit_bio_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "905-919",
    "snippet": "static int __btree_submit_bio_done(struct inode *inode, int rw, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags,\n\t\t\t\t u64 bio_offset)\n{\n\tint ret;\n\n\t/*\n\t * when we're called for a write, we're already in the async\n\t * submission context.  Just jump into btrfs_map_bio\n\t */\n\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio, mirror_num, 1);\n\tif (ret)\n\t\tbio_endio(bio, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "bio",
            "ret"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_bio",
          "args": [
            "BTRFS_I(inode)->root",
            "rw",
            "bio",
            "mirror_num",
            "1"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5829-5916",
          "snippet": "int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int __btree_submit_bio_done(struct inode *inode, int rw, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags,\n\t\t\t\t u64 bio_offset)\n{\n\tint ret;\n\n\t/*\n\t * when we're called for a write, we're already in the async\n\t * submission context.  Just jump into btrfs_map_bio\n\t */\n\tret = btrfs_map_bio(BTRFS_I(inode)->root, rw, bio, mirror_num, 1);\n\tif (ret)\n\t\tbio_endio(bio, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btree_submit_bio_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "893-903",
    "snippet": "static int __btree_submit_bio_start(struct inode *inode, int rw,\n\t\t\t\t    struct bio *bio, int mirror_num,\n\t\t\t\t    unsigned long bio_flags,\n\t\t\t\t    u64 bio_offset)\n{\n\t/*\n\t * when we're called for a write, we're already in the async\n\t * submission context.  Just jump into btrfs_map_bio\n\t */\n\treturn btree_csum_one_bio(bio);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_csum_one_bio",
          "args": [
            "bio"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "btree_csum_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "877-891",
          "snippet": "static int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int __btree_submit_bio_start(struct inode *inode, int rw,\n\t\t\t\t    struct bio *bio, int mirror_num,\n\t\t\t\t    unsigned long bio_flags,\n\t\t\t\t    u64 bio_offset)\n{\n\t/*\n\t * when we're called for a write, we're already in the async\n\t * submission context.  Just jump into btrfs_map_bio\n\t */\n\treturn btree_csum_one_bio(bio);\n}"
  },
  {
    "function_name": "btree_csum_one_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "877-891",
    "snippet": "static int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csum_dirty_buffer",
          "args": [
            "root",
            "bvec->bv_page"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "csum_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "504-518",
          "snippet": "static int csum_dirty_buffer(struct btrfs_root *root, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 found_start;\n\tstruct extent_buffer *eb;\n\n\teb = (struct extent_buffer *)page->private;\n\tif (page != eb->pages[0])\n\t\treturn 0;\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (WARN_ON(found_start != start || !PageUptodate(page)))\n\t\treturn 0;\n\tcsum_tree_block(root, eb, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int csum_dirty_buffer(struct btrfs_root *root, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 found_start;\n\tstruct extent_buffer *eb;\n\n\teb = (struct extent_buffer *)page->private;\n\tif (page != eb->pages[0])\n\t\treturn 0;\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (WARN_ON(found_start != start || !PageUptodate(page)))\n\t\treturn 0;\n\tcsum_tree_block(root, eb, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "bvec->bv_page->mapping->host"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_csum_one_bio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct btrfs_root *root;\n\tint i, ret = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\troot = BTRFS_I(bvec->bv_page->mapping->host)->root;\n\t\tret = csum_dirty_buffer(root, bvec->bv_page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_wq_submit_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "833-875",
    "snippet": "int btrfs_wq_submit_bio(struct btrfs_fs_info *fs_info, struct inode *inode,\n\t\t\tint rw, struct bio *bio, int mirror_num,\n\t\t\tunsigned long bio_flags,\n\t\t\tu64 bio_offset,\n\t\t\textent_submit_bio_hook_t *submit_bio_start,\n\t\t\textent_submit_bio_hook_t *submit_bio_done)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->inode = inode;\n\tasync->rw = rw;\n\tasync->bio = bio;\n\tasync->mirror_num = mirror_num;\n\tasync->submit_bio_start = submit_bio_start;\n\tasync->submit_bio_done = submit_bio_done;\n\n\tbtrfs_init_work(&async->work, btrfs_worker_helper, run_one_async_start,\n\t\t\trun_one_async_done, run_one_async_free);\n\n\tasync->bio_flags = bio_flags;\n\tasync->bio_offset = bio_offset;\n\n\tasync->error = 0;\n\n\tatomic_inc(&fs_info->nr_async_submits);\n\n\tif (rw & REQ_SYNC)\n\t\tbtrfs_set_work_high_priority(&async->work);\n\n\tbtrfs_queue_work(fs_info->workers, &async->work);\n\n\twhile (atomic_read(&fs_info->async_submit_draining) &&\n\t      atomic_read(&fs_info->nr_async_submits)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&fs_info->nr_async_submits) == 0));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->async_submit_wait",
            "(atomic_read(&fs_info->nr_async_submits) == 0)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->nr_async_submits"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->nr_async_submits"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->async_submit_draining"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->workers",
            "&async->work"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_work_high_priority",
          "args": [
            "&async->work"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_work_high_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "362-365",
          "snippet": "void btrfs_set_work_high_priority(struct btrfs_work *work)\n{\n\tset_bit(WORK_HIGH_PRIO_BIT, &work->flags);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_set_work_high_priority(struct btrfs_work *work)\n{\n\tset_bit(WORK_HIGH_PRIO_BIT, &work->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->nr_async_submits"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&async->work",
            "btrfs_worker_helper",
            "run_one_async_start",
            "run_one_async_done",
            "run_one_async_free"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*async)",
            "GFP_NOFS"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\n\nint btrfs_wq_submit_bio(struct btrfs_fs_info *fs_info, struct inode *inode,\n\t\t\tint rw, struct bio *bio, int mirror_num,\n\t\t\tunsigned long bio_flags,\n\t\t\tu64 bio_offset,\n\t\t\textent_submit_bio_hook_t *submit_bio_start,\n\t\t\textent_submit_bio_hook_t *submit_bio_done)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->inode = inode;\n\tasync->rw = rw;\n\tasync->bio = bio;\n\tasync->mirror_num = mirror_num;\n\tasync->submit_bio_start = submit_bio_start;\n\tasync->submit_bio_done = submit_bio_done;\n\n\tbtrfs_init_work(&async->work, btrfs_worker_helper, run_one_async_start,\n\t\t\trun_one_async_done, run_one_async_free);\n\n\tasync->bio_flags = bio_flags;\n\tasync->bio_offset = bio_offset;\n\n\tasync->error = 0;\n\n\tatomic_inc(&fs_info->nr_async_submits);\n\n\tif (rw & REQ_SYNC)\n\t\tbtrfs_set_work_high_priority(&async->work);\n\n\tbtrfs_queue_work(fs_info->workers, &async->work);\n\n\twhile (atomic_read(&fs_info->async_submit_draining) &&\n\t      atomic_read(&fs_info->nr_async_submits)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&fs_info->nr_async_submits) == 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "run_one_async_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "825-831",
    "snippet": "static void run_one_async_free(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tkfree(async);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "async"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structasync_submit_bio",
            "work"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\n\nstatic void run_one_async_free(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tkfree(async);\n}"
  },
  {
    "function_name": "run_one_async_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "798-823",
    "snippet": "static void run_one_async_done(struct btrfs_work *work)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tstruct async_submit_bio *async;\n\tint limit;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tfs_info = BTRFS_I(async->inode)->root->fs_info;\n\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\n\tif (atomic_dec_return(&fs_info->nr_async_submits) < limit &&\n\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\twake_up(&fs_info->async_submit_wait);\n\n\t/* If an error occured we just want to clean up the bio and move on */\n\tif (async->error) {\n\t\tbio_endio(async->bio, async->error);\n\t\treturn;\n\t}\n\n\tasync->submit_bio_done(async->inode, async->rw, async->bio,\n\t\t\t       async->mirror_num, async->bio_flags,\n\t\t\t       async->bio_offset);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);",
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async->submit_bio_done",
          "args": [
            "async->inode",
            "async->rw",
            "async->bio",
            "async->mirror_num",
            "async->bio_flags",
            "async->bio_offset"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "async->bio",
            "async->error"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->async_submit_wait"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fs_info->async_submit_wait"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&fs_info->nr_async_submits"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_async_submit_limit",
          "args": [
            "fs_info"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_async_submit_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "777-783",
          "snippet": "unsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nunsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "async->inode"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structasync_submit_bio",
            "work"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic void run_one_async_done(struct btrfs_work *work)\n{\n\tstruct btrfs_fs_info *fs_info;\n\tstruct async_submit_bio *async;\n\tint limit;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tfs_info = BTRFS_I(async->inode)->root->fs_info;\n\n\tlimit = btrfs_async_submit_limit(fs_info);\n\tlimit = limit * 2 / 3;\n\n\tif (atomic_dec_return(&fs_info->nr_async_submits) < limit &&\n\t    waitqueue_active(&fs_info->async_submit_wait))\n\t\twake_up(&fs_info->async_submit_wait);\n\n\t/* If an error occured we just want to clean up the bio and move on */\n\tif (async->error) {\n\t\tbio_endio(async->bio, async->error);\n\t\treturn;\n\t}\n\n\tasync->submit_bio_done(async->inode, async->rw, async->bio,\n\t\t\t       async->mirror_num, async->bio_flags,\n\t\t\t       async->bio_offset);\n}"
  },
  {
    "function_name": "run_one_async_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "785-796",
    "snippet": "static void run_one_async_start(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async;\n\tint ret;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tret = async->submit_bio_start(async->inode, async->rw, async->bio,\n\t\t\t\t      async->mirror_num, async->bio_flags,\n\t\t\t\t      async->bio_offset);\n\tif (ret)\n\t\tasync->error = ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async->submit_bio_start",
          "args": [
            "async->inode",
            "async->rw",
            "async->bio",
            "async->mirror_num",
            "async->bio_flags",
            "async->bio_offset"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structasync_submit_bio",
            "work"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\n\nstatic void run_one_async_start(struct btrfs_work *work)\n{\n\tstruct async_submit_bio *async;\n\tint ret;\n\n\tasync = container_of(work, struct  async_submit_bio, work);\n\tret = async->submit_bio_start(async->inode, async->rw, async->bio,\n\t\t\t\t      async->mirror_num, async->bio_flags,\n\t\t\t\t      async->bio_offset);\n\tif (ret)\n\t\tasync->error = ret;\n}"
  },
  {
    "function_name": "btrfs_async_submit_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "777-783",
    "snippet": "unsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "info->thread_pool_size",
            "info->fs_devices->open_devices"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nunsigned long btrfs_async_submit_limit(struct btrfs_fs_info *info)\n{\n\tunsigned long limit = min_t(unsigned long,\n\t\t\t\t    info->thread_pool_size,\n\t\t\t\t    info->fs_devices->open_devices);\n\treturn 256 * limit;\n}"
  },
  {
    "function_name": "btrfs_bio_wq_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "756-775",
    "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_end_io_wq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_end_io_wq_cache",
            "GFP_NOFS"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
  },
  {
    "function_name": "end_workqueue_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "711-754",
    "snippet": "static void end_workqueue_bio(struct bio *bio, int err)\n{\n\tstruct btrfs_end_io_wq *end_io_wq = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_workqueue *wq;\n\tbtrfs_work_func_t func;\n\n\tfs_info = end_io_wq->info;\n\tend_io_wq->error = err;\n\n\tif (bio->bi_rw & REQ_WRITE) {\n\t\tif (end_io_wq->metadata == BTRFS_WQ_ENDIO_METADATA) {\n\t\t\twq = fs_info->endio_meta_write_workers;\n\t\t\tfunc = btrfs_endio_meta_write_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_FREE_SPACE) {\n\t\t\twq = fs_info->endio_freespace_worker;\n\t\t\tfunc = btrfs_freespace_write_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_RAID56) {\n\t\t\twq = fs_info->endio_raid56_workers;\n\t\t\tfunc = btrfs_endio_raid56_helper;\n\t\t} else {\n\t\t\twq = fs_info->endio_write_workers;\n\t\t\tfunc = btrfs_endio_write_helper;\n\t\t}\n\t} else {\n\t\tif (unlikely(end_io_wq->metadata ==\n\t\t\t     BTRFS_WQ_ENDIO_DIO_REPAIR)) {\n\t\t\twq = fs_info->endio_repair_workers;\n\t\t\tfunc = btrfs_endio_repair_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_RAID56) {\n\t\t\twq = fs_info->endio_raid56_workers;\n\t\t\tfunc = btrfs_endio_raid56_helper;\n\t\t} else if (end_io_wq->metadata) {\n\t\t\twq = fs_info->endio_meta_workers;\n\t\t\tfunc = btrfs_endio_meta_helper;\n\t\t} else {\n\t\t\twq = fs_info->endio_workers;\n\t\t\tfunc = btrfs_endio_helper;\n\t\t}\n\t}\n\n\tbtrfs_init_work(&end_io_wq->work, func, end_workqueue_fn, NULL, NULL);\n\tbtrfs_queue_work(wq, &end_io_wq->work);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void end_workqueue_fn(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "wq",
            "&end_io_wq->work"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&end_io_wq->work",
            "func",
            "end_workqueue_fn",
            "NULL",
            "NULL"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "end_io_wq->metadata ==\n\t\t\t     BTRFS_WQ_ENDIO_DIO_REPAIR"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\n\nstatic void end_workqueue_bio(struct bio *bio, int err)\n{\n\tstruct btrfs_end_io_wq *end_io_wq = bio->bi_private;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_workqueue *wq;\n\tbtrfs_work_func_t func;\n\n\tfs_info = end_io_wq->info;\n\tend_io_wq->error = err;\n\n\tif (bio->bi_rw & REQ_WRITE) {\n\t\tif (end_io_wq->metadata == BTRFS_WQ_ENDIO_METADATA) {\n\t\t\twq = fs_info->endio_meta_write_workers;\n\t\t\tfunc = btrfs_endio_meta_write_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_FREE_SPACE) {\n\t\t\twq = fs_info->endio_freespace_worker;\n\t\t\tfunc = btrfs_freespace_write_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_RAID56) {\n\t\t\twq = fs_info->endio_raid56_workers;\n\t\t\tfunc = btrfs_endio_raid56_helper;\n\t\t} else {\n\t\t\twq = fs_info->endio_write_workers;\n\t\t\tfunc = btrfs_endio_write_helper;\n\t\t}\n\t} else {\n\t\tif (unlikely(end_io_wq->metadata ==\n\t\t\t     BTRFS_WQ_ENDIO_DIO_REPAIR)) {\n\t\t\twq = fs_info->endio_repair_workers;\n\t\t\tfunc = btrfs_endio_repair_helper;\n\t\t} else if (end_io_wq->metadata == BTRFS_WQ_ENDIO_RAID56) {\n\t\t\twq = fs_info->endio_raid56_workers;\n\t\t\tfunc = btrfs_endio_raid56_helper;\n\t\t} else if (end_io_wq->metadata) {\n\t\t\twq = fs_info->endio_meta_workers;\n\t\t\tfunc = btrfs_endio_meta_helper;\n\t\t} else {\n\t\t\twq = fs_info->endio_workers;\n\t\t\tfunc = btrfs_endio_helper;\n\t\t}\n\t}\n\n\tbtrfs_init_work(&end_io_wq->work, func, end_workqueue_fn, NULL, NULL);\n\tbtrfs_queue_work(wq, &end_io_wq->work);\n}"
  },
  {
    "function_name": "btree_io_failed_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "697-709",
    "snippet": "static int btree_io_failed_hook(struct page *page, int failed_mirror)\n{\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root *root = BTRFS_I(page->mapping->host)->root;\n\n\teb = (struct extent_buffer *)page->private;\n\tset_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = failed_mirror;\n\tatomic_dec(&eb->io_pages);\n\tif (test_and_clear_bit(EXTENT_BUFFER_READAHEAD, &eb->bflags))\n\t\tbtree_readahead_hook(root, eb, eb->start, -EIO);\n\treturn -EIO;\t/* we fixed nothing */\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_readahead_hook",
          "args": [
            "root",
            "eb",
            "eb->start",
            "-EIO"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "btree_readahead_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "236-246",
          "snippet": "int btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nint btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_READAHEAD",
            "&eb->bflags"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->io_pages"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_READ_ERR",
            "&eb->bflags"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_io_failed_hook(struct page *page, int failed_mirror)\n{\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root *root = BTRFS_I(page->mapping->host)->root;\n\n\teb = (struct extent_buffer *)page->private;\n\tset_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = failed_mirror;\n\tatomic_dec(&eb->io_pages);\n\tif (test_and_clear_bit(EXTENT_BUFFER_READAHEAD, &eb->bflags))\n\t\tbtree_readahead_hook(root, eb, eb->start, -EIO);\n\treturn -EIO;\t/* we fixed nothing */\n}"
  },
  {
    "function_name": "btree_readpage_end_io_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "604-695",
    "snippet": "static int btree_readpage_end_io_hook(struct btrfs_io_bio *io_bio,\n\t\t\t\t      u64 phy_offset, struct page *page,\n\t\t\t\t      u64 start, u64 end, int mirror)\n{\n\tu64 found_start;\n\tint found_level;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root *root = BTRFS_I(page->mapping->host)->root;\n\tint ret = 0;\n\tint reads_done;\n\n\tif (!page->private)\n\t\tgoto out;\n\n\teb = (struct extent_buffer *)page->private;\n\n\t/* the pending IO might have been the only thing that kept this buffer\n\t * in memory.  Make sure we have a ref for all this other checks\n\t */\n\textent_buffer_get(eb);\n\n\treads_done = atomic_dec_and_test(&eb->io_pages);\n\tif (!reads_done)\n\t\tgoto err;\n\n\teb->read_mirror = mirror;\n\tif (test_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (found_start != eb->start) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS (device %s): bad tree block start \"\n\t\t\t       \"%llu %llu\\n\",\n\t\t\t       eb->fs_info->sb->s_id, found_start, eb->start);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tif (check_tree_block_fsid(root, eb)) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS (device %s): bad fsid on block %llu\\n\",\n\t\t\t       eb->fs_info->sb->s_id, eb->start);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tfound_level = btrfs_header_level(eb);\n\tif (found_level >= BTRFS_MAX_LEVEL) {\n\t\tbtrfs_err(root->fs_info, \"bad tree block level %d\",\n\t\t\t   (int)btrfs_header_level(eb));\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tbtrfs_set_buffer_lockdep_class(btrfs_header_owner(eb),\n\t\t\t\t       eb, found_level);\n\n\tret = csum_tree_block(root, eb, 1);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * If this is a leaf block and it is corrupt, set the corrupt bit so\n\t * that we don't try and read the other copies of this block, just\n\t * return -EIO.\n\t */\n\tif (found_level == 0 && check_leaf(root, eb)) {\n\t\tset_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret)\n\t\tset_extent_buffer_uptodate(eb);\nerr:\n\tif (reads_done &&\n\t    test_and_clear_bit(EXTENT_BUFFER_READAHEAD, &eb->bflags))\n\t\tbtree_readahead_hook(root, eb, eb->start, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * our io error hook is going to dec the io pages\n\t\t * again, we have to make sure it has something\n\t\t * to decrement\n\t\t */\n\t\tatomic_inc(&eb->io_pages);\n\t\tclear_extent_buffer_uptodate(eb);\n\t}\n\tfree_extent_buffer(eb);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5082-5096",
          "snippet": "int clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->io_pages"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_readahead_hook",
          "args": [
            "root",
            "eb",
            "eb->start",
            "ret"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "btree_readahead_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "236-246",
          "snippet": "int btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nint btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_READAHEAD",
            "&eb->bflags"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5098-5111",
          "snippet": "int set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_CORRUPT",
            "&eb->bflags"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_leaf",
          "args": [
            "root",
            "eb"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "check_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "543-602",
          "snippet": "static noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csum_tree_block",
          "args": [
            "root",
            "eb",
            "1"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "csum_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "277-336",
          "snippet": "static int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_buffer_lockdep_class",
          "args": [
            "btrfs_header_owner(eb)",
            "eb",
            "found_level"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_lockdep_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "195-209",
          "snippet": "void btrfs_set_buffer_lockdep_class(u64 objectid, struct extent_buffer *eb,\n\t\t\t\t    int level)\n{\n\tstruct btrfs_lockdep_keyset *ks;\n\n\tBUG_ON(level >= ARRAY_SIZE(ks->keys));\n\n\t/* find the matching keyset, id 0 is the default entry */\n\tfor (ks = btrfs_lockdep_keysets; ks->id; ks++)\n\t\tif (ks->id == objectid)\n\t\t\tbreak;\n\n\tlockdep_set_class_and_name(&eb->lock,\n\t\t\t\t   &ks->keys[level], ks->names[level]);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_set_buffer_lockdep_class(u64 objectid, struct extent_buffer *eb,\n\t\t\t\t    int level)\n{\n\tstruct btrfs_lockdep_keyset *ks;\n\n\tBUG_ON(level >= ARRAY_SIZE(ks->keys));\n\n\t/* find the matching keyset, id 0 is the default entry */\n\tfor (ks = btrfs_lockdep_keysets; ks->id; ks++)\n\t\tif (ks->id == objectid)\n\t\t\tbreak;\n\n\tlockdep_set_class_and_name(&eb->lock,\n\t\t\t\t   &ks->keys[level], ks->names[level]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "eb"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"bad tree block level %d\"",
            "(int)btrfs_header_level(eb)"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"BTRFS (device %s): bad fsid on block %llu\\n\"",
            "eb->fs_info->sb->s_id",
            "eb->start"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_tree_block_fsid",
          "args": [
            "root",
            "eb"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "check_tree_block_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "520-536",
          "snippet": "static int check_tree_block_fsid(struct btrfs_root *root,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tu8 fsid[BTRFS_UUID_SIZE];\n\tint ret = 1;\n\n\tread_extent_buffer(eb, fsid, btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twhile (fs_devices) {\n\t\tif (!memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int check_tree_block_fsid(struct btrfs_root *root,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tu8 fsid[BTRFS_UUID_SIZE];\n\tint ret = 1;\n\n\tread_extent_buffer(eb, fsid, btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twhile (fs_devices) {\n\t\tif (!memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"BTRFS (device %s): bad tree block start \"\n\t\t\t       \"%llu %llu\\n\"",
            "eb->fs_info->sb->s_id",
            "found_start",
            "eb->start"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_bytenr",
          "args": [
            "eb"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_READ_ERR",
            "&eb->bflags"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->io_pages"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "eb"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_readpage_end_io_hook(struct btrfs_io_bio *io_bio,\n\t\t\t\t      u64 phy_offset, struct page *page,\n\t\t\t\t      u64 start, u64 end, int mirror)\n{\n\tu64 found_start;\n\tint found_level;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root *root = BTRFS_I(page->mapping->host)->root;\n\tint ret = 0;\n\tint reads_done;\n\n\tif (!page->private)\n\t\tgoto out;\n\n\teb = (struct extent_buffer *)page->private;\n\n\t/* the pending IO might have been the only thing that kept this buffer\n\t * in memory.  Make sure we have a ref for all this other checks\n\t */\n\textent_buffer_get(eb);\n\n\treads_done = atomic_dec_and_test(&eb->io_pages);\n\tif (!reads_done)\n\t\tgoto err;\n\n\teb->read_mirror = mirror;\n\tif (test_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (found_start != eb->start) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS (device %s): bad tree block start \"\n\t\t\t       \"%llu %llu\\n\",\n\t\t\t       eb->fs_info->sb->s_id, found_start, eb->start);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tif (check_tree_block_fsid(root, eb)) {\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS (device %s): bad fsid on block %llu\\n\",\n\t\t\t       eb->fs_info->sb->s_id, eb->start);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tfound_level = btrfs_header_level(eb);\n\tif (found_level >= BTRFS_MAX_LEVEL) {\n\t\tbtrfs_err(root->fs_info, \"bad tree block level %d\",\n\t\t\t   (int)btrfs_header_level(eb));\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tbtrfs_set_buffer_lockdep_class(btrfs_header_owner(eb),\n\t\t\t\t       eb, found_level);\n\n\tret = csum_tree_block(root, eb, 1);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * If this is a leaf block and it is corrupt, set the corrupt bit so\n\t * that we don't try and read the other copies of this block, just\n\t * return -EIO.\n\t */\n\tif (found_level == 0 && check_leaf(root, eb)) {\n\t\tset_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret)\n\t\tset_extent_buffer_uptodate(eb);\nerr:\n\tif (reads_done &&\n\t    test_and_clear_bit(EXTENT_BUFFER_READAHEAD, &eb->bflags))\n\t\tbtree_readahead_hook(root, eb, eb->start, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * our io error hook is going to dec the io pages\n\t\t * again, we have to make sure it has something\n\t\t * to decrement\n\t\t */\n\t\tatomic_inc(&eb->io_pages);\n\t\tclear_extent_buffer_uptodate(eb);\n\t}\n\tfree_extent_buffer(eb);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "check_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "543-602",
    "snippet": "static noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CORRUPT",
          "args": [
            "\"slot end outside of leaf\"",
            "leaf",
            "root",
            "slot"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_end_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_end_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2639-2642",
          "snippet": "static inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CORRUPT",
          "args": [
            "\"slot offset bad\"",
            "leaf",
            "root",
            "slot"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_offset_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CORRUPT",
          "args": [
            "\"bad key order\"",
            "leaf",
            "root",
            "slot"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&leaf_key",
            "&key"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot + 1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CORRUPT",
          "args": [
            "\"invalid item offset size pair\"",
            "leaf",
            "root",
            "0"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "0"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic noinline int check_leaf(struct btrfs_root *root,\n\t\t\t       struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key leaf_key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/* Check the 0 item */\n\tif (btrfs_item_offset_nr(leaf, 0) + btrfs_item_size_nr(leaf, 0) !=\n\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tCORRUPT(\"invalid item offset size pair\", leaf, root, 0);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Check to make sure each items keys are in the correct order and their\n\t * offsets make sense.  We only have to loop through nritems-1 because\n\t * we check the current slot against the next slot, which verifies the\n\t * next slot's offset+size makes sense and that the current's slot\n\t * offset is correct.\n\t */\n\tfor (slot = 0; slot < nritems - 1; slot++) {\n\t\tbtrfs_item_key_to_cpu(leaf, &leaf_key, slot);\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot + 1);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&leaf_key, &key) >= 0) {\n\t\t\tCORRUPT(\"bad key order\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (btrfs_item_offset_nr(leaf, slot) !=\n\t\t\tbtrfs_item_end_nr(leaf, slot + 1)) {\n\t\t\tCORRUPT(\"slot offset bad\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just incase all the items are consistent to eachother, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tCORRUPT(\"slot end outside of leaf\", leaf, root, slot);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_tree_block_fsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "520-536",
    "snippet": "static int check_tree_block_fsid(struct btrfs_root *root,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tu8 fsid[BTRFS_UUID_SIZE];\n\tint ret = 1;\n\n\tread_extent_buffer(eb, fsid, btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twhile (fs_devices) {\n\t\tif (!memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fsid",
            "fs_devices->fsid",
            "BTRFS_FSID_SIZE"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "fsid",
            "btrfs_header_fsid()",
            "BTRFS_FSID_SIZE"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int check_tree_block_fsid(struct btrfs_root *root,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tu8 fsid[BTRFS_UUID_SIZE];\n\tint ret = 1;\n\n\tread_extent_buffer(eb, fsid, btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twhile (fs_devices) {\n\t\tif (!memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "csum_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "504-518",
    "snippet": "static int csum_dirty_buffer(struct btrfs_root *root, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 found_start;\n\tstruct extent_buffer *eb;\n\n\teb = (struct extent_buffer *)page->private;\n\tif (page != eb->pages[0])\n\t\treturn 0;\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (WARN_ON(found_start != start || !PageUptodate(page)))\n\t\treturn 0;\n\tcsum_tree_block(root, eb, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csum_tree_block",
          "args": [
            "root",
            "eb",
            "0"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "csum_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "277-336",
          "snippet": "static int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "found_start != start || !PageUptodate(page)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_bytenr",
          "args": [
            "eb"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int csum_dirty_buffer(struct btrfs_root *root, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 found_start;\n\tstruct extent_buffer *eb;\n\n\teb = (struct extent_buffer *)page->private;\n\tif (page != eb->pages[0])\n\t\treturn 0;\n\tfound_start = btrfs_header_bytenr(eb);\n\tif (WARN_ON(found_start != start || !PageUptodate(page)))\n\t\treturn 0;\n\tcsum_tree_block(root, eb, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "btree_read_extent_buffer_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "442-497",
    "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repair_eb_io_failure",
          "args": [
            "root",
            "eb",
            "failed_mirror"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "repair_eb_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2084-2106",
          "snippet": "int repair_eb_io_failure(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t int mirror_num)\n{\n\tu64 start = eb->start;\n\tunsigned long i, num_pages = num_extent_pages(eb->start, eb->len);\n\tint ret = 0;\n\n\tif (root->fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tret = repair_io_failure(root->fs_info->btree_inode, start,\n\t\t\t\t\tPAGE_CACHE_SIZE, start, p,\n\t\t\t\t\tstart - page_offset(p), mirror_num);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_eb_io_failure(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t int mirror_num)\n{\n\tu64 start = eb->start;\n\tunsigned long i, num_pages = num_extent_pages(eb->start, eb->len);\n\tint ret = 0;\n\n\tif (root->fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tret = repair_io_failure(root->fs_info->btree_inode, start,\n\t\t\t\t\tPAGE_CACHE_SIZE, start, p,\n\t\t\t\t\tstart - page_offset(p), mirror_num);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "root->fs_info",
            "eb->start",
            "eb->len"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_CORRUPT",
            "&eb->bflags"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_parent_transid",
          "args": [
            "io_tree",
            "eb",
            "parent_transid",
            "0"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "verify_parent_transid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "344-392",
          "snippet": "static int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer_pages",
          "args": [
            "io_tree",
            "eb",
            "start",
            "WAIT_COMPLETE",
            "btree_get_extent",
            "mirror_num"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5118-5212",
          "snippet": "int read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "root->fs_info->btree_inode"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_BUFFER_CORRUPT",
            "&eb->bflags"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_check_super_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "398-436",
    "snippet": "static int btrfs_check_super_csum(char *raw_disk_sb)\n{\n\tstruct btrfs_super_block *disk_sb =\n\t\t(struct btrfs_super_block *)raw_disk_sb;\n\tu16 csum_type = btrfs_super_csum_type(disk_sb);\n\tint ret = 0;\n\n\tif (csum_type == BTRFS_CSUM_TYPE_CRC32) {\n\t\tu32 crc = ~(u32)0;\n\t\tconst int csum_size = sizeof(crc);\n\t\tchar result[csum_size];\n\n\t\t/*\n\t\t * The super_block structure does not span the whole\n\t\t * BTRFS_SUPER_INFO_SIZE range, we expect that the unused space\n\t\t * is filled with zeros and is included in the checkum.\n\t\t */\n\t\tcrc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);\n\t\tbtrfs_csum_final(crc, result);\n\n\t\tif (memcmp(raw_disk_sb, result, csum_size))\n\t\t\tret = 1;\n\n\t\tif (ret && btrfs_super_generation(disk_sb) < 10) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: super block crcs don't match, older mkfs detected\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {\n\t\tprintk(KERN_ERR \"BTRFS: unsupported checksum algorithm %u\\n\",\n\t\t\t\tcsum_type);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: unsupported checksum algorithm %u\\n\"",
            "csum_type"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btrfs_csum_sizes"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"BTRFS: super block crcs don't match, older mkfs detected\\n\""
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "disk_sb"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "raw_disk_sb",
            "result",
            "csum_size"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "result"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "raw_disk_sb + BTRFS_CSUM_SIZE",
            "crc",
            "BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_type",
          "args": [
            "disk_sb"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_check_super_csum(char *raw_disk_sb)\n{\n\tstruct btrfs_super_block *disk_sb =\n\t\t(struct btrfs_super_block *)raw_disk_sb;\n\tu16 csum_type = btrfs_super_csum_type(disk_sb);\n\tint ret = 0;\n\n\tif (csum_type == BTRFS_CSUM_TYPE_CRC32) {\n\t\tu32 crc = ~(u32)0;\n\t\tconst int csum_size = sizeof(crc);\n\t\tchar result[csum_size];\n\n\t\t/*\n\t\t * The super_block structure does not span the whole\n\t\t * BTRFS_SUPER_INFO_SIZE range, we expect that the unused space\n\t\t * is filled with zeros and is included in the checkum.\n\t\t */\n\t\tcrc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,\n\t\t\t\tcrc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);\n\t\tbtrfs_csum_final(crc, result);\n\n\t\tif (memcmp(raw_disk_sb, result, csum_size))\n\t\t\tret = 1;\n\n\t\tif (ret && btrfs_super_generation(disk_sb) < 10) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: super block crcs don't match, older mkfs detected\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {\n\t\tprintk(KERN_ERR \"BTRFS: unsupported checksum algorithm %u\\n\",\n\t\t\t\tcsum_type);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "verify_parent_transid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "344-392",
    "snippet": "static int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "io_tree",
            "eb->start",
            "eb->start + eb->len - 1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5082-5096",
          "snippet": "int clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_under_io",
          "args": [
            "eb"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_under_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4535-4540",
          "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\"",
            "eb->fs_info->sb->s_id",
            "eb->start",
            "parent_transid",
            "btrfs_header_generation(eb)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "eb"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "eb"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "io_tree",
            "eb->start",
            "eb->start + eb->len - 1",
            "0",
            "&cached_state"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb",
            "BTRFS_READ_LOCK"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "eb"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int verify_parent_transid(struct extent_io_tree *io_tree,\n\t\t\t\t struct extent_buffer *eb, u64 parent_transid,\n\t\t\t\t int atomic)\n{\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tbool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);\n\n\tif (!parent_transid || btrfs_header_generation(eb) == parent_transid)\n\t\treturn 0;\n\n\tif (atomic)\n\t\treturn -EAGAIN;\n\n\tif (need_lock) {\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t}\n\n\tlock_extent_bits(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t 0, &cached_state);\n\tif (extent_buffer_uptodate(eb) &&\n\t    btrfs_header_generation(eb) == parent_transid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tprintk_ratelimited(KERN_ERR\n\t    \"BTRFS (device %s): parent transid verify failed on %llu wanted %llu found %llu\\n\",\n\t\t\teb->fs_info->sb->s_id, eb->start,\n\t\t\tparent_transid, btrfs_header_generation(eb));\n\tret = 1;\n\n\t/*\n\t * Things reading via commit roots that don't have normal protection,\n\t * like send, can have a really old block in cache that may point at a\n\t * block that has been free'd and re-allocated.  So don't clear uptodate\n\t * if we find an eb that is under IO (dirty/writeback) because we could\n\t * end up reading in the stale data and then writing it back out and\n\t * making everybody very sad.\n\t */\n\tif (!extent_buffer_under_io(eb))\n\t\tclear_extent_buffer_uptodate(eb);\nout:\n\tunlock_extent_cached(io_tree, eb->start, eb->start + eb->len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\tif (need_lock)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\treturn ret;\n}"
  },
  {
    "function_name": "csum_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "277-336",
    "snippet": "static int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "buf",
            "result",
            "0",
            "csum_size"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\"",
            "root->fs_info->sb->s_id",
            "buf->start",
            "val",
            "found",
            "btrfs_header_level(buf)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "buf",
            "&val",
            "0",
            "csum_size"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&found",
            "result",
            "csum_size"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "buf",
            "result",
            "0",
            "csum_size"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5320-5354",
          "snippet": "int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "result"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "csum_size * sizeof(char)",
            "GFP_NOFS"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "kaddr + offset - map_start",
            "crc",
            "cur_len"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "map_len - (offset - map_start)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_private_extent_buffer",
          "args": [
            "buf",
            "offset",
            "32",
            "&kaddr",
            "&map_start",
            "&map_len"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "map_private_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5282-5318",
          "snippet": "int map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int csum_tree_block(struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t   int verify)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tchar *result = NULL;\n\tunsigned long len;\n\tunsigned long cur_len;\n\tunsigned long offset = BTRFS_CSUM_SIZE;\n\tchar *kaddr;\n\tunsigned long map_start;\n\tunsigned long map_len;\n\tint err;\n\tu32 crc = ~(u32)0;\n\tunsigned long inline_result;\n\n\tlen = buf->len - offset;\n\twhile (len > 0) {\n\t\terr = map_private_extent_buffer(buf, offset, 32,\n\t\t\t\t\t&kaddr, &map_start, &map_len);\n\t\tif (err)\n\t\t\treturn 1;\n\t\tcur_len = min(len, map_len - (offset - map_start));\n\t\tcrc = btrfs_csum_data(kaddr + offset - map_start,\n\t\t\t\t      crc, cur_len);\n\t\tlen -= cur_len;\n\t\toffset += cur_len;\n\t}\n\tif (csum_size > sizeof(inline_result)) {\n\t\tresult = kzalloc(csum_size * sizeof(char), GFP_NOFS);\n\t\tif (!result)\n\t\t\treturn 1;\n\t} else {\n\t\tresult = (char *)&inline_result;\n\t}\n\n\tbtrfs_csum_final(crc, result);\n\n\tif (verify) {\n\t\tif (memcmp_extent_buffer(buf, result, 0, csum_size)) {\n\t\t\tu32 val;\n\t\t\tu32 found = 0;\n\t\t\tmemcpy(&found, result, csum_size);\n\n\t\t\tread_extent_buffer(buf, &val, 0, csum_size);\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\"BTRFS: %s checksum verify failed on %llu wanted %X found %X \"\n\t\t\t\t\"level %d\\n\",\n\t\t\t\troot->fs_info->sb->s_id, buf->start,\n\t\t\t\tval, found, btrfs_header_level(buf));\n\t\t\tif (result != (char *)&inline_result)\n\t\t\t\tkfree(result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\twrite_extent_buffer(buf, result, 0, csum_size);\n\t}\n\tif (result != (char *)&inline_result)\n\t\tkfree(result);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_csum_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "268-271",
    "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_le32",
          "args": [
            "~crc",
            "result"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
  },
  {
    "function_name": "btrfs_csum_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "263-266",
    "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_crc32c",
          "args": [
            "seed",
            "data",
            "len"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_crc32c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "32-46",
          "snippet": "u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nu32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
  },
  {
    "function_name": "btree_get_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "217-261",
    "snippet": "static struct extent_map *btree_get_extent(struct inode *inode,\n\t\tstruct page *page, size_t pg_offset, u64 start, u64 len,\n\t\tint create)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tif (em) {\n\t\tem->bdev =\n\t\t\tBTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\t\tread_unlock(&em_tree->lock);\n\t\tgoto out;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tem = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tem->start = 0;\n\tem->len = (u64)-1;\n\tem->block_len = (u64)-1;\n\tem->block_start = 0;\n\tem->bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (ret == -EEXIST) {\n\t\tfree_extent_map(em);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em)\n\t\t\tem = ERR_PTR(-EIO);\n\t} else if (ret) {\n\t\tfree_extent_map(em);\n\t\tem = ERR_PTR(ret);\n\t}\n\twrite_unlock(&em_tree->lock);\n\nout:\n\treturn em;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_fs_root(struct btrfs_root *root);",
      "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
      "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
      "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
      "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
      "static void btrfs_error_commit_super(struct btrfs_root *root);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "start",
            "len"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "em",
            "0"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic struct extent_map *btree_get_extent(struct inode *inode,\n\t\tstruct page *page, size_t pg_offset, u64 start, u64 len,\n\t\tint create)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tif (em) {\n\t\tem->bdev =\n\t\t\tBTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\t\tread_unlock(&em_tree->lock);\n\t\tgoto out;\n\t}\n\tread_unlock(&em_tree->lock);\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tem = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tem->start = 0;\n\tem->len = (u64)-1;\n\tem->block_len = (u64)-1;\n\tem->block_start = 0;\n\tem->bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\twrite_lock(&em_tree->lock);\n\tret = add_extent_mapping(em_tree, em, 0);\n\tif (ret == -EEXIST) {\n\t\tfree_extent_map(em);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em)\n\t\t\tem = ERR_PTR(-EIO);\n\t} else if (ret) {\n\t\tfree_extent_map(em);\n\t\tem = ERR_PTR(ret);\n\t}\n\twrite_unlock(&em_tree->lock);\n\nout:\n\treturn em;\n}"
  },
  {
    "function_name": "btrfs_set_buffer_lockdep_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "195-209",
    "snippet": "void btrfs_set_buffer_lockdep_class(u64 objectid, struct extent_buffer *eb,\n\t\t\t\t    int level)\n{\n\tstruct btrfs_lockdep_keyset *ks;\n\n\tBUG_ON(level >= ARRAY_SIZE(ks->keys));\n\n\t/* find the matching keyset, id 0 is the default entry */\n\tfor (ks = btrfs_lockdep_keysets; ks->id; ks++)\n\t\tif (ks->id == objectid)\n\t\t\tbreak;\n\n\tlockdep_set_class_and_name(&eb->lock,\n\t\t\t\t   &ks->keys[level], ks->names[level]);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&eb->lock",
            "&ks->keys[level]",
            "ks->names[level]"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level >= ARRAY_SIZE(ks->keys)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ks->keys"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_set_buffer_lockdep_class(u64 objectid, struct extent_buffer *eb,\n\t\t\t\t    int level)\n{\n\tstruct btrfs_lockdep_keyset *ks;\n\n\tBUG_ON(level >= ARRAY_SIZE(ks->keys));\n\n\t/* find the matching keyset, id 0 is the default entry */\n\tfor (ks = btrfs_lockdep_keysets; ks->id; ks++)\n\t\tif (ks->id == objectid)\n\t\t\tbreak;\n\n\tlockdep_set_class_and_name(&eb->lock,\n\t\t\t\t   &ks->keys[level], ks->names[level]);\n}"
  },
  {
    "function_name": "btrfs_init_lockdep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "181-193",
    "snippet": "void __init btrfs_init_lockdep(void)\n{\n\tint i, j;\n\n\t/* initialize lockdep class names */\n\tfor (i = 0; i < ARRAY_SIZE(btrfs_lockdep_keysets); i++) {\n\t\tstruct btrfs_lockdep_keyset *ks = &btrfs_lockdep_keysets[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(ks->names); j++)\n\t\t\tsnprintf(ks->names[j], sizeof(ks->names[j]),\n\t\t\t\t \"btrfs-%s-%02d\", ks->name_stem, j);\n\t}\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ks->names[j]",
            "sizeof(ks->names[j])",
            "\"btrfs-%s-%02d\"",
            "ks->name_stem",
            "j"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ks->names"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btrfs_lockdep_keysets"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid __init btrfs_init_lockdep(void)\n{\n\tint i, j;\n\n\t/* initialize lockdep class names */\n\tfor (i = 0; i < ARRAY_SIZE(btrfs_lockdep_keysets); i++) {\n\t\tstruct btrfs_lockdep_keyset *ks = &btrfs_lockdep_keysets[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(ks->names); j++)\n\t\t\tsnprintf(ks->names[j], sizeof(ks->names[j]),\n\t\t\t\t \"btrfs-%s-%02d\", ks->name_stem, j);\n\t}\n}"
  },
  {
    "function_name": "btrfs_end_io_wq_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "104-108",
    "snippet": "void btrfs_end_io_wq_exit(void)\n{\n\tif (btrfs_end_io_wq_cache)\n\t\tkmem_cache_destroy(btrfs_end_io_wq_cache);\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_end_io_wq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_end_io_wq_cache"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nvoid btrfs_end_io_wq_exit(void)\n{\n\tif (btrfs_end_io_wq_cache)\n\t\tkmem_cache_destroy(btrfs_end_io_wq_cache);\n}"
  },
  {
    "function_name": "btrfs_end_io_wq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
    "lines": "92-102",
    "snippet": "int __init btrfs_end_io_wq_init(void)\n{\n\tbtrfs_end_io_wq_cache = kmem_cache_create(\"btrfs_end_io_wq\",\n\t\t\t\t\tsizeof(struct btrfs_end_io_wq),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_end_io_wq_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpufeature.h>",
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"raid56.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/uuid.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/migrate.h>",
      "#include <linux/slab.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/swap.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_end_io_wq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_end_io_wq\"",
            "sizeof(struct btrfs_end_io_wq)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint __init btrfs_end_io_wq_init(void)\n{\n\tbtrfs_end_io_wq_cache = kmem_cache_create(\"btrfs_end_io_wq\",\n\t\t\t\t\tsizeof(struct btrfs_end_io_wq),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_end_io_wq_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]