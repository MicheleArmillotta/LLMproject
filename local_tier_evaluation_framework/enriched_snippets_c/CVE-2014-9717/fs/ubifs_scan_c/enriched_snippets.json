[
  {
    "function_name": "stroy(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "367-379",
    "snippet": "an_destroy(struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *node;\n\tstruct list_head *head;\n\n\thead = &sleb->nodes;\n\twhile (!list_empty(head)) {\n\t\tnode = list_entry(head->next, struct ubifs_scan_node, list);\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\tkfree(sleb);\n}",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tk",
          "args": [
            "ree("
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->list)",
          "args": [
            "kfree(no"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad->next,",
          "args": [
            "truct ubif",
            "scan_nde, list);\n\t\tli",
            "_del"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad)) {\n\t\tn",
          "args": [
            "de ="
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nan_destroy(struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *node;\n\tstruct list_head *head;\n\n\thead = &sleb->nodes;\n\twhile (!list_empty(head)) {\n\t\tnode = list_entry(head->next, struct ubifs_scan_node, list);\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\tkfree(sleb);\n}"
  },
  {
    "function_name": "nst struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "267-361",
    "snippet": "scan_leb *ubifs_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t  int offs, void *sbuf, int quiet)\n{\n\tvoid *buf = sbuf + offs;\n\tint err, len = c->leb_size - offs;\n\tstruct ubifs_scan_leb *sleb;\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\twhile (len >= 8) {\n\t\tstruct ubifs_ch *ch = buf;\n\t\tint node_len, ret;\n\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\t\tif (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE)\n\t\t\t/* Empty space is checked later */\n\t\t\tbreak;\n\n\t\tswitch (ret) {\n\t\tcase SCANNED_GARBAGE:\n\t\t\tubifs_err(\"garbage\");\n\t\t\tgoto corrupted;\n\t\tcase SCANNED_A_NODE:\n\t\t\tbreak;\n\t\tcase SCANNED_A_CORRUPT_NODE:\n\t\tcase SCANNED_A_BAD_PAD_NODE:\n\t\t\tubifs_err(\"bad node\");\n\t\t\tgoto corrupted;\n\t\tdefault:\n\t\t\tubifs_err(\"unknown\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\toffs += node_len;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tif (offs % c->min_io_size) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"empty space starts at non-aligned offset %d\",\n\t\t\t\t  offs);\n\t\tgoto corrupted;\n\t}\n\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\tfor (; len > 4; offs += 4, buf = buf + 4, len -= 4)\n\t\tif (*(uint32_t *)buf != 0xffffffff)\n\t\t\tbreak;\n\tfor (; len; offs++, buf++, len--)\n\t\tif (*(uint8_t *)buf != 0xff) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(\"corrupt empty space at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\tgoto corrupted;\n\t\t}\n\n\treturn sleb;\n\ncorrupted:\n\tif (!quiet) {\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\tubifs_err(\"LEB %d scanning failed\", lnum);\n\t}\n\terr = -EUCLEAN;\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n\nerror:\n\tubifs_err(\"LEB %d scanning failed, error %d\", lnum, err);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/**",
          "args": [
            "*"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n ER"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d scan",
          "args": [
            "ing failed, error %d\", lnum, err);",
            "ubif",
            "sca"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "u"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n ER"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d scan",
          "args": [
            "ing failed\", lnum);\n\t}",
            "r ="
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_corruption(c, lnum, off",
          "args": [
            ",",
            "uf);",
            "ubi",
            "_er"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrupt emp",
          "args": [
            "y space at LEB %d:%d\",\n\t\t\t\t\t  lnum",
            "g",
            "o co"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c, sleb, lnu",
          "args": [
            ",",
            "ffs)",
            "fo",
            "(; l"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pty space",
          "args": [
            "starts at non-aligned offset %d\",\n\t\t\t\t  offs)",
            "cor"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu(",
          "args": [
            "h->len), 8);\n\t\toffs"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len), 8)",
          "args": [
            "offs"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, sleb, buf",
          "args": [
            "fs);",
            "if",
            "err)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known\");",
          "args": [
            "err = -"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node\");",
          "args": [
            "goto co"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbage\");",
          "args": [
            "goto co"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            "uiet",
            "i",
            "(ret"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tret =",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k at LEB",
          "args": [
            "%d:%d (%d bytes left)\",\n\t\t\t lnum, o",
            "en);",
            "co",
            "_re"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn s"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "can(c, lnum, off",
          "args": [
            ",",
            "buf)",
            "if",
            "S_ER"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nscan_leb *ubifs_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t  int offs, void *sbuf, int quiet)\n{\n\tvoid *buf = sbuf + offs;\n\tint err, len = c->leb_size - offs;\n\tstruct ubifs_scan_leb *sleb;\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\twhile (len >= 8) {\n\t\tstruct ubifs_ch *ch = buf;\n\t\tint node_len, ret;\n\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\t\tif (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE)\n\t\t\t/* Empty space is checked later */\n\t\t\tbreak;\n\n\t\tswitch (ret) {\n\t\tcase SCANNED_GARBAGE:\n\t\t\tubifs_err(\"garbage\");\n\t\t\tgoto corrupted;\n\t\tcase SCANNED_A_NODE:\n\t\t\tbreak;\n\t\tcase SCANNED_A_CORRUPT_NODE:\n\t\tcase SCANNED_A_BAD_PAD_NODE:\n\t\t\tubifs_err(\"bad node\");\n\t\t\tgoto corrupted;\n\t\tdefault:\n\t\t\tubifs_err(\"unknown\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\toffs += node_len;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tif (offs % c->min_io_size) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"empty space starts at non-aligned offset %d\",\n\t\t\t\t  offs);\n\t\tgoto corrupted;\n\t}\n\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\tfor (; len > 4; offs += 4, buf = buf + 4, len -= 4)\n\t\tif (*(uint32_t *)buf != 0xffffffff)\n\t\t\tbreak;\n\tfor (; len; offs++, buf++, len--)\n\t\tif (*(uint8_t *)buf != 0xff) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(\"corrupt empty space at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\tgoto corrupted;\n\t\t}\n\n\treturn sleb;\n\ncorrupted:\n\tif (!quiet) {\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\tubifs_err(\"LEB %d scanning failed\", lnum);\n\t}\n\terr = -EUCLEAN;\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n\nerror:\n\tubifs_err(\"LEB %d scanning failed, error %d\", lnum, err);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_corruption(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "238-249",
    "snippet": "anned_corruption(const struct ubifs_info *c, int lnum, int offs,\n\t\t\t      void *buf)\n{\n\tint len;\n\n\tubifs_err(\"corruption at LEB %d:%d\", lnum, offs);\n\tlen = c->leb_size - offs;\n\tif (len > 8192)\n\t\tlen = 8192;\n\tubifs_err(\"first %d bytes from LEB %d:%d\", len, lnum, offs);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 4, buf, len, 1);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p(KERN_DEBUG,",
          "args": [
            "\", DUMP_PR",
            "IX",
            "FFSET, 32, 4, buf,",
            "en",
            "1",
            "}",
            "**"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst %d by",
          "args": [
            "es from LEB %d:%d\", len, lnum,",
            "fs)",
            "pri",
            "_hex"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rruption",
          "args": [
            "t LEB %d:%d\", lnum, offs)",
            "len",
            "c->"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nanned_corruption(const struct ubifs_info *c, int lnum, int offs,\n\t\t\t      void *buf)\n{\n\tint len;\n\n\tubifs_err(\"corruption at LEB %d:%d\", lnum, offs);\n\tlen = c->leb_size - offs;\n\tif (len > 8192)\n\t\tlen = 8192;\n\tubifs_err(\"first %d bytes from LEB %d:%d\", len, lnum, offs);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 4, buf, len, 1);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "d(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "194-229",
    "snippet": "_snod(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t   void *buf, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tstruct ubifs_ino_node *ino = buf;\n\tstruct ubifs_scan_node *snod;\n\n\tsnod = kmalloc(sizeof(struct ubifs_scan_node), GFP_NOFS);\n\tif (!snod)\n\t\treturn -ENOMEM;\n\n\tsnod->sqnum = le64_to_cpu(ch->sqnum);\n\tsnod->type = ch->node_type;\n\tsnod->offs = offs;\n\tsnod->len = le32_to_cpu(ch->len);\n\tsnod->node = buf;\n\n\tswitch (ch->node_type) {\n\tcase UBIFS_INO_NODE:\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\tcase UBIFS_DATA_NODE:\n\t\t/*\n\t\t * The key is in the same place in all keyed\n\t\t * nodes.\n\t\t */\n\t\tkey_read(c, &ino->key, &snod->key);\n\t\tbreak;\n\tdefault:\n\t\tinvalid_key_init(c, &snod->key);\n\t\tbreak;\n\t}\n\tlist_add_tail(&snod->list, &sleb->nodes);\n\tsleb->nodes_cnt += 1;\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(&snod->list,",
          "args": [
            "&sleb->node",
            ";\n\tsleb->nod"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit(c, &snod->ke",
          "args": [
            ")",
            "break;"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino->key",
          "args": [
            "nod->key)",
            "break;"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ts",
          "args": [
            "od->nod"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->sqnum);",
          "args": [
            "snod->typ"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_scan_node), GFP_NOFS);",
            "f (!snod"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\n_snod(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t   void *buf, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tstruct ubifs_ino_node *ino = buf;\n\tstruct ubifs_scan_node *snod;\n\n\tsnod = kmalloc(sizeof(struct ubifs_scan_node), GFP_NOFS);\n\tif (!snod)\n\t\treturn -ENOMEM;\n\n\tsnod->sqnum = le64_to_cpu(ch->sqnum);\n\tsnod->type = ch->node_type;\n\tsnod->offs = offs;\n\tsnod->len = le32_to_cpu(ch->len);\n\tsnod->node = buf;\n\n\tswitch (ch->node_type) {\n\tcase UBIFS_INO_NODE:\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\tcase UBIFS_DATA_NODE:\n\t\t/*\n\t\t * The key is in the same place in all keyed\n\t\t * nodes.\n\t\t */\n\t\tkey_read(c, &ino->key, &snod->key);\n\t\tbreak;\n\tdefault:\n\t\tinvalid_key_init(c, &snod->key);\n\t\tbreak;\n\t}\n\tlist_add_tail(&snod->list, &sleb->nodes);\n\tsleb->nodes_cnt += 1;\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "n(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "175-183",
    "snippet": "d_scan(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t    int lnum, int offs)\n{\n\tlnum = lnum;\n\tdbg_scan(\"stop scanning LEB %d at offset %d\", lnum, offs);\n\tubifs_assert(offs % c->min_io_size == 0);\n\n\tsleb->endpt = ALIGN(offs, c->min_io_size);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n}\n\n/**\n *"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offs % c->mi",
          "args": [
            "_io_size == 0);\n\n\tsleb->en"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p scanni",
          "args": [
            "g LEB %d at offset %d\", lnum, offs)",
            "ubi",
            "_ass"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nd_scan(const struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t    int lnum, int offs)\n{\n\tlnum = lnum;\n\tdbg_scan(\"stop scanning LEB %d at offset %d\", lnum, offs);\n\tubifs_assert(offs % c->min_io_size == 0);\n\n\tsleb->endpt = ALIGN(offs, c->min_io_size);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "can(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "137-166",
    "snippet": "scan_leb *ubifs_start_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t\tint offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint err;\n\n\tdbg_scan(\"scan LEB %d:%d\", lnum, offs);\n\n\tsleb = kzalloc(sizeof(struct ubifs_scan_leb), GFP_NOFS);\n\tif (!sleb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsleb->lnum = lnum;\n\tINIT_LIST_HEAD(&sleb->nodes);\n\tsleb->buf = sbuf;\n\n\terr = ubifs_leb_read(c, lnum, sbuf + offs, offs, c->leb_size - offs, 0);\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"cannot read %d bytes from LEB %d:%d, error %d\",\n\t\t\t  c->leb_size - offs, lnum, offs, err);\n\t\tkfree(sleb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/*\n\t * Note, we ignore integrity errors (EBASMSG) because all the nodes are\n\t * protected by CRC checksums.\n\t */\n\treturn sleb;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n\t/",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn E"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "%d bytes from LEB %d:%d, error %d\",\n\t\t\t  c->leb",
            "offs, lnum, offs,",
            "rr);",
            "kfr",
            "(sl"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, sbu",
          "args": [
            "offs",
            "offs, c->le",
            "size",
            "offs, 0);\n\tif (er",
            "&"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(&sleb->nodes",
          "args": [
            ";\n\tsleb->buf"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "leb->ln"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_scan_leb), GFP_NOFS);",
            "f (!sleb"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "n LEB %d",
          "args": [
            "%d\", lnum, offs)",
            "sl",
            "= k"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nscan_leb *ubifs_start_scan(const struct ubifs_info *c, int lnum,\n\t\t\t\t\tint offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint err;\n\n\tdbg_scan(\"scan LEB %d:%d\", lnum, offs);\n\n\tsleb = kzalloc(sizeof(struct ubifs_scan_leb), GFP_NOFS);\n\tif (!sleb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsleb->lnum = lnum;\n\tINIT_LIST_HEAD(&sleb->nodes);\n\tsleb->buf = sbuf;\n\n\terr = ubifs_leb_read(c, lnum, sbuf + offs, offs, c->leb_size - offs, 0);\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"cannot read %d bytes from LEB %d:%d, error %d\",\n\t\t\t  c->leb_size - offs, lnum, offs, err);\n\t\tkfree(sleb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/*\n\t * Note, we ignore integrity errors (EBASMSG) because all the nodes are\n\t * protected by CRC checksums.\n\t */\n\treturn sleb;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "node(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "69-125",
    "snippet": "n_a_node(const struct ubifs_info *c, void *buf, int len, int lnum,\n\t\t      int offs, int quiet)\n{\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t magic;\n\n\tmagic = le32_to_cpu(ch->magic);\n\n\tif (magic == 0xFFFFFFFF) {\n\t\tdbg_scan(\"hit empty space at LEB %d:%d\", lnum, offs);\n\t\treturn SCANNED_EMPTY_SPACE;\n\t}\n\n\tif (magic != UBIFS_NODE_MAGIC)\n\t\treturn scan_padding_bytes(buf, len);\n\n\tif (len < UBIFS_CH_SZ)\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"scanning %s at LEB %d:%d\",\n\t\t dbg_ntype(ch->node_type), lnum, offs);\n\n\tif (ubifs_check_node(c, buf, lnum, offs, quiet, 1))\n\t\treturn SCANNED_A_CORRUPT_NODE;\n\n\tif (ch->node_type == UBIFS_PAD_NODE) {\n\t\tstruct ubifs_pad_node *pad = buf;\n\t\tint pad_len = le32_to_cpu(pad->pad_len);\n\t\tint node_len = le32_to_cpu(ch->len);\n\n\t\t/* Validate the padding node */\n\t\tif (pad_len < 0 ||\n\t\t    offs + node_len + pad_len > c->leb_size) {\n\t\t\tif (!quiet) {\n\t\t\t\tubifs_err(\"bad pad node at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\t\tubifs_dump_node(c, pad);\n\t\t\t}\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\t/* Make the node pads to 8-byte boundary */\n\t\tif ((node_len + pad_len) & 7) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(\"bad padding length %d - %d\",\n\t\t\t\t\t  offs, offs + node_len + pad_len);\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\tdbg_scan(\"%d bytes padded at LEB %d:%d, offset now %d\", pad_len,\n\t\t\t lnum, offs, ALIGN(offs + node_len + pad_len, 8));\n\n\t\treturn node_len + pad_len;\n\t}\n\n\treturn SCANNED_A_NODE;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bytes pa",
          "args": [
            "ded at LEB %d:%d, offset now %d\", pad_len,",
            "lnum, o",
            "LIGN",
            "ffs",
            "node_len + pad_len, 8));\n\n\t\treturn"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_",
          "args": [
            "en + pad_len, 8));\n\n\t\tret",
            "n"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "_dirty_inode_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
          "lines": "606-615",
          "snippet": "lease_dirty_inode_budget(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_inode *ui)\n{\n\tstruct ubifs_budget_req req;\n\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\t/* The \"no space\" flags will be cleared because dd_growth is > 0 */\n\treq.dd_growth = c->bi.inode_budget + ALIGN(ui->data_len, 8);\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * ubif",
          "includes": [
            "ux/math64.h>\n\n/*\n * When p",
            "ux/writeback.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlease_dirty_inode_budget(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_inode *ui)\n{\n\tstruct ubifs_budget_req req;\n\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\t/* The \"no space\" flags will be cleared because dd_growth is > 0 */\n\treq.dd_growth = c->bi.inode_budget + ALIGN(ui->data_len, 8);\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "d padding",
          "args": [
            "length %d - %d\",\n\t\t\t\t\t  offs",
            "node",
            "en + pad_len);\n\t\t\treturn"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, pad);",
          "args": [
            "re"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d pad nod",
          "args": [
            "at LEB %d:%d\",\n\t\t\t\t\t  lnum",
            "ifs_"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);",
          "args": [
            "/* Vali"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad->pad_len",
          "args": [
            ";\n\t\tint node"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf, lnum",
          "args": [
            "fs,",
            "uiet",
            "1))",
            "retur",
            "S"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nning %s",
          "args": [
            "at LEB %d:%d\",\n\t\t dbg_ntyp",
            ">node_type), lnum, offs)",
            "if",
            "ubif"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">node_typ",
          "args": [
            "), lnum, offs"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes(buf, len);",
          "args": [
            "if",
            "en"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty s",
          "args": [
            "ace at LEB %d:%d\", lnum, offs)",
            "re",
            "rn S"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->magic);",
          "args": [
            "if (magi"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nn_a_node(const struct ubifs_info *c, void *buf, int len, int lnum,\n\t\t      int offs, int quiet)\n{\n\tstruct ubifs_ch *ch = buf;\n\tuint32_t magic;\n\n\tmagic = le32_to_cpu(ch->magic);\n\n\tif (magic == 0xFFFFFFFF) {\n\t\tdbg_scan(\"hit empty space at LEB %d:%d\", lnum, offs);\n\t\treturn SCANNED_EMPTY_SPACE;\n\t}\n\n\tif (magic != UBIFS_NODE_MAGIC)\n\t\treturn scan_padding_bytes(buf, len);\n\n\tif (len < UBIFS_CH_SZ)\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"scanning %s at LEB %d:%d\",\n\t\t dbg_ntype(ch->node_type), lnum, offs);\n\n\tif (ubifs_check_node(c, buf, lnum, offs, quiet, 1))\n\t\treturn SCANNED_A_CORRUPT_NODE;\n\n\tif (ch->node_type == UBIFS_PAD_NODE) {\n\t\tstruct ubifs_pad_node *pad = buf;\n\t\tint pad_len = le32_to_cpu(pad->pad_len);\n\t\tint node_len = le32_to_cpu(ch->len);\n\n\t\t/* Validate the padding node */\n\t\tif (pad_len < 0 ||\n\t\t    offs + node_len + pad_len > c->leb_size) {\n\t\t\tif (!quiet) {\n\t\t\t\tubifs_err(\"bad pad node at LEB %d:%d\",\n\t\t\t\t\t  lnum, offs);\n\t\t\t\tubifs_dump_node(c, pad);\n\t\t\t}\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\t/* Make the node pads to 8-byte boundary */\n\t\tif ((node_len + pad_len) & 7) {\n\t\t\tif (!quiet)\n\t\t\t\tubifs_err(\"bad padding length %d - %d\",\n\t\t\t\t\t  offs, offs + node_len + pad_len);\n\t\t\treturn SCANNED_A_BAD_PAD_NODE;\n\t\t}\n\n\t\tdbg_scan(\"%d bytes padded at LEB %d:%d, offset now %d\", pad_len,\n\t\t\t lnum, offs, ALIGN(offs + node_len + pad_len, 8));\n\n\t\treturn node_len + pad_len;\n\t}\n\n\treturn SCANNED_A_NODE;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "bytes(void *buf, i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/scan.c",
    "lines": "40-56",
    "snippet": "an_padding_bytes(void *buf, int len)\n{\n\tint pad_len = 0, max_pad_len = min_t(int, UBIFS_PAD_NODE_SZ, len);\n\tuint8_t *p = buf;\n\n\tdbg_scan(\"not a node\");\n\n\twhile (pad_len < max_pad_len && *p++ == UBIFS_PADDING_BYTE)\n\t\tpad_len += 1;\n\n\tif (!pad_len || (pad_len & 7))\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"%d padding bytes\", pad_len);\n\n\treturn pad_len;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * scan_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padding",
          "args": [
            "ytes\", pad_len);",
            "eturn p"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_padding_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "108-113",
          "snippet": "nt jffs2_sum_add_padding_mem(struct jffs2_summary *s, uint32_t size)\n{\n\tdbg_summary(\"called with %u\\n\", size);\n\ts->sum_padded += size;\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_padding_mem(struct jffs2_summary *s, uint32_t size)\n{\n\tdbg_summary(\"called with %u\\n\", size);\n\ts->sum_padded += size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "a node\"",
          "args": [
            ";\n\n\twhile (p"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFS_P",
          "args": [
            "D_N",
            "E_SZ, len);\n\tuint",
            "t *"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * scan_\n\nan_padding_bytes(void *buf, int len)\n{\n\tint pad_len = 0, max_pad_len = min_t(int, UBIFS_PAD_NODE_SZ, len);\n\tuint8_t *p = buf;\n\n\tdbg_scan(\"not a node\");\n\n\twhile (pad_len < max_pad_len && *p++ == UBIFS_PADDING_BYTE)\n\t\tpad_len += 1;\n\n\tif (!pad_len || (pad_len & 7))\n\t\treturn SCANNED_GARBAGE;\n\n\tdbg_scan(\"%d padding bytes\", pad_len);\n\n\treturn pad_len;\n}\n\n/**\n * ubif"
  }
]