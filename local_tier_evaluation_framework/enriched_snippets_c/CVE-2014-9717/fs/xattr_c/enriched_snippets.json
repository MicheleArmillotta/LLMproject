[
  {
    "function_name": "simple_xattr_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "966-972",
    "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_xattr->list",
            "&xattrs->head"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
  },
  {
    "function_name": "simple_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "932-961",
    "snippet": "ssize_t simple_xattr_list(struct simple_xattrs *xattrs, char *buffer,\n\t\t\t  size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tsize_t used = 0;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tsize_t len;\n\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\tlen = strlen(xattr->name) + 1;\n\t\tused += len;\n\t\tif (buffer) {\n\t\t\tif (size < used) {\n\t\t\t\tused = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buffer, xattr->name, len);\n\t\t\tbuffer += len;\n\t\t}\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn used;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "xattr->name",
            "len"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xattr->name"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_is_trusted",
          "args": [
            "xattr->name"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_is_trusted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "924-927",
          "snippet": "static bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t simple_xattr_list(struct simple_xattrs *xattrs, char *buffer,\n\t\t\t  size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tsize_t used = 0;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tsize_t len;\n\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\tlen = strlen(xattr->name) + 1;\n\t\tused += len;\n\t\tif (buffer) {\n\t\t\tif (size < used) {\n\t\t\t\tused = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buffer, xattr->name, len);\n\t\t\tbuffer += len;\n\t\t}\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn used;\n}"
  },
  {
    "function_name": "xattr_is_trusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "924-927",
    "snippet": "static bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}"
  },
  {
    "function_name": "simple_xattr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "919-922",
    "snippet": "int simple_xattr_remove(struct simple_xattrs *xattrs, const char *name)\n{\n\treturn __simple_xattr_set(xattrs, name, NULL, 0, XATTR_REPLACE);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__simple_xattr_set",
          "args": [
            "xattrs",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "__simple_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "843-892",
          "snippet": "static int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_remove(struct simple_xattrs *xattrs, const char *name)\n{\n\treturn __simple_xattr_set(xattrs, name, NULL, 0, XATTR_REPLACE);\n}"
  },
  {
    "function_name": "simple_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "908-914",
    "snippet": "int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tif (size == 0)\n\t\tvalue = \"\"; /* empty EA, do not remove */\n\treturn __simple_xattr_set(xattrs, name, value, size, flags);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__simple_xattr_set",
          "args": [
            "xattrs",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "__simple_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "843-892",
          "snippet": "static int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tif (size == 0)\n\t\tvalue = \"\"; /* empty EA, do not remove */\n\treturn __simple_xattr_set(xattrs, name, value, size, flags);\n}"
  },
  {
    "function_name": "__simple_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "843-892",
    "snippet": "static int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr->name"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_xattr->list",
            "&xattrs->head"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&xattr->list"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&xattr->list",
            "&new_xattr->list"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_list_replace_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1472-1479",
          "snippet": "static void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "xattr->name"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_xattr"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_xattr_alloc",
          "args": [
            "value",
            "size"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "797-814",
          "snippet": "struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}"
  },
  {
    "function_name": "simple_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "819-841",
    "snippet": "int simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "xattr->value",
            "xattr->size"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "xattr->name"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "simple_xattr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "797-814",
    "snippet": "struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_xattr->value",
            "value",
            "size"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}"
  },
  {
    "function_name": "generic_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "777-787",
    "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "dentry",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE",
            "handler->flags"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "dentry->d_sb->s_xattr",
            "&name"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "694-710",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
  },
  {
    "function_name": "generic_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "760-771",
    "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags",
            "handler->flags"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "dentry->d_sb->s_xattr",
            "&name"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "694-710",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
  },
  {
    "function_name": "generic_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "730-755",
    "snippet": "ssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize += handler->list(dentry, NULL, 0, NULL, 0,\n\t\t\t\t\t      handler->flags);\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize = handler->list(dentry, buf, buffer_size,\n\t\t\t\t\t     NULL, 0, handler->flags);\n\t\t\tif (size > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tbuf += size;\n\t\t\tbuffer_size -= size;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "buf",
            "buffer_size",
            "NULL",
            "0",
            "handler->flags"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "NULL",
            "0",
            "NULL",
            "0",
            "handler->flags"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize += handler->list(dentry, NULL, 0, NULL, 0,\n\t\t\t\t\t      handler->flags);\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize = handler->list(dentry, buf, buffer_size,\n\t\t\t\t\t     NULL, 0, handler->flags);\n\t\t\tif (size > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tbuf += size;\n\t\t\tbuffer_size -= size;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}"
  },
  {
    "function_name": "generic_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "715-724",
    "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->get",
          "args": [
            "dentry",
            "name",
            "buffer",
            "size",
            "handler->flags"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "dentry->d_sb->s_xattr",
            "&name"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "694-710",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
  },
  {
    "function_name": "xattr_resolve_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "694-710",
    "snippet": "static const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp_prefix",
          "args": [
            "*name",
            "handler->prefix"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(const struct xattr_handler **handlers, const char **name)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n = strcmp_prefix(*name, handler->prefix);\n\t\tif (n) {\n\t\t\t*name = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handler;\n}"
  },
  {
    "function_name": "strcmp_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "667-675",
    "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
  },
  {
    "function_name": "path_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "615-635",
    "snippet": "static int path_removexattr(const char __user *pathname,\n\t\t\t    const char __user *name, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = removexattr(path.dentry, name);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path.mnt"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "removexattr",
          "args": [
            "path.dentry",
            "name"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "generic_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "777-787",
          "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path.mnt"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int path_removexattr(const char __user *pathname,\n\t\t\t    const char __user *name, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = removexattr(path.dentry, name);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "600-613",
    "snippet": "static long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_removexattr",
          "args": [
            "d",
            "kname"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "286-314",
          "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}"
  },
  {
    "function_name": "path_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "554-570",
    "snippet": "static ssize_t path_listxattr(const char __user *pathname, char __user *list,\n\t\t\t      size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = listxattr(path.dentry, list, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listxattr",
          "args": [
            "path.dentry",
            "list",
            "size"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "generic_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "730-755",
          "snippet": "ssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize += handler->list(dentry, NULL, 0, NULL, 0,\n\t\t\t\t\t      handler->flags);\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize = handler->list(dentry, buf, buffer_size,\n\t\t\t\t\t     NULL, 0, handler->flags);\n\t\t\tif (size > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tbuf += size;\n\t\t\tbuffer_size -= size;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize += handler->list(dentry, NULL, 0, NULL, 0,\n\t\t\t\t\t      handler->flags);\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tsize = handler->list(dentry, buf, buffer_size,\n\t\t\t\t\t     NULL, 0, handler->flags);\n\t\t\tif (size > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tbuf += size;\n\t\t\tbuffer_size -= size;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t path_listxattr(const char __user *pathname, char __user *list,\n\t\t\t      size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = listxattr(path.dentry, list, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "519-552",
    "snippet": "static ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "klist"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "vlist"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "list",
            "klist",
            "error"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_listxattr",
          "args": [
            "d",
            "klist",
            "size"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "266-283",
          "snippet": "ssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "__GFP_NOWARN | GFP_KERNEL"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}"
  },
  {
    "function_name": "path_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "471-488",
    "snippet": "static ssize_t path_getxattr(const char __user *pathname,\n\t\t\t     const char __user *name, void __user *value,\n\t\t\t     size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = getxattr(path.dentry, name, value, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getxattr",
          "args": [
            "path.dentry",
            "name",
            "value",
            "size"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "generic_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "715-724",
          "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t path_getxattr(const char __user *pathname,\n\t\t\t     const char __user *name, void __user *value,\n\t\t\t     size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = getxattr(path.dentry, name, value, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "425-469",
    "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kvalue"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "vvalue"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "value",
            "kvalue",
            "error"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_to_user",
          "args": [
            "kvalue",
            "size"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "651-657",
          "snippet": "void posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kname",
            "XATTR_NAME_POSIX_ACL_DEFAULT"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "d",
            "kname",
            "kvalue",
            "size"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
  },
  {
    "function_name": "path_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "367-388",
    "snippet": "static int path_setxattr(const char __user *pathname,\n\t\t\t const char __user *name, const void __user *value,\n\t\t\t size_t size, int flags, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = setxattr(path.dentry, name, value, size, flags);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path.mnt"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setxattr",
          "args": [
            "path.dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "760-771",
          "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path.mnt"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int path_setxattr(const char __user *pathname,\n\t\t\t const char __user *name, const void __user *value,\n\t\t\t size_t size, int flags, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = setxattr(path.dentry, name, value, size, flags);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "321-365",
    "snippet": "static long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kvalue"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "vvalue"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "d",
            "kname",
            "kvalue",
            "size",
            "flags"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_from_user",
          "args": [
            "kvalue",
            "size"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "643-649",
          "snippet": "void posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kname",
            "XATTR_NAME_POSIX_ACL_DEFAULT"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kvalue",
            "value",
            "size"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "286-314",
    "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_inode_post_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "600-613",
          "snippet": "static long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_WRITE"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "31-74",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "266-283",
    "snippet": "ssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_listsecurity",
          "args": [
            "d->d_inode",
            "list",
            "size"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->d_inode->i_op->listxattr",
          "args": [
            "d",
            "list",
            "size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "519-552",
          "snippet": "static ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_listxattr",
          "args": [
            "d"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "230-263",
    "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_op->getxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "425-469",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_getsecurity",
          "args": [
            "inode",
            "suffix",
            "value",
            "size"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_getsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "145-169",
          "snippet": "ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tsecurity_release_secctx(buffer, len);\nout_noalloc:\n\treturn len;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tsecurity_release_secctx(buffer, len);\nout_noalloc:\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getxattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_READ"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "31-74",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_xattr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "212-228",
    "snippet": "int vfs_xattr_cmp(struct dentry *dentry, const char *xattr_name,\n\t\t  const char *value, size_t size, gfp_t flags)\n{\n\tchar *xattr_value = NULL;\n\tint rc;\n\n\trc = vfs_getxattr_alloc(dentry, xattr_name, &xattr_value, 0, flags);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif ((rc != size) || (memcmp(xattr_value, value, rc) != 0))\n\t\trc = -EINVAL;\n\telse\n\t\trc = 0;\n\tkfree(xattr_value);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_value"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "xattr_value",
            "value",
            "rc"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getxattr_alloc",
          "args": [
            "dentry",
            "xattr_name",
            "&xattr_value",
            "0",
            "flags"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "180-209",
          "snippet": "ssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = inode->i_op->getxattr(dentry, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = inode->i_op->getxattr(dentry, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = inode->i_op->getxattr(dentry, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = inode->i_op->getxattr(dentry, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint vfs_xattr_cmp(struct dentry *dentry, const char *xattr_name,\n\t\t  const char *value, size_t size, gfp_t flags)\n{\n\tchar *xattr_value = NULL;\n\tint rc;\n\n\trc = vfs_getxattr_alloc(dentry, xattr_name, &xattr_value, 0, flags);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif ((rc != size) || (memcmp(xattr_value, value, rc) != 0))\n\t\trc = -EINVAL;\n\telse\n\t\trc = 0;\n\tkfree(xattr_value);\n\treturn rc;\n}"
  },
  {
    "function_name": "vfs_getxattr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "180-209",
    "snippet": "ssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = inode->i_op->getxattr(dentry, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = inode->i_op->getxattr(dentry, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_op->getxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "error"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "425-469",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "error + 1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "*xattr_value",
            "error + 1",
            "flags"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_READ"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "31-74",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = inode->i_op->getxattr(dentry, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = inode->i_op->getxattr(dentry, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}"
  },
  {
    "function_name": "xattr_getsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "145-169",
    "snippet": "ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tsecurity_release_secctx(buffer, len);\nout_noalloc:\n\treturn len;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "buffer",
            "len"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "buffer",
            "len"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecurity",
          "args": [
            "inode",
            "name",
            "&buffer",
            "true"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecurity",
          "args": [
            "inode",
            "name",
            "&buffer",
            "false"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tsecurity_release_secctx(buffer, len);\nout_noalloc:\n\treturn len;\n}"
  },
  {
    "function_name": "vfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "121-142",
    "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_setxattr_noperm",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_setxattr_noperm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "92-118",
          "snippet": "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EOPNOTSUPP;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_op->setxattr) {\n\t\terror = inode->i_op->setxattr(dentry, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else if (issec) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t   size, flags);\n\t\tif (!error)\n\t\t\tfsnotify_xattr(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EOPNOTSUPP;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_op->setxattr) {\n\t\terror = inode->i_op->setxattr(dentry, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else if (issec) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t   size, flags);\n\t\tif (!error)\n\t\t\tfsnotify_xattr(dentry);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_WRITE"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "31-74",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "__vfs_setxattr_noperm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "92-118",
    "snippet": "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EOPNOTSUPP;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_op->setxattr) {\n\t\terror = inode->i_op->setxattr(dentry, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else if (issec) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t   size, flags);\n\t\tif (!error)\n\t\t\tfsnotify_xattr(dentry);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_setsecurity",
          "args": [
            "inode",
            "suffix",
            "value",
            "size",
            "flags"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_post_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "321-365",
          "snippet": "static long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EOPNOTSUPP;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_op->setxattr) {\n\t\terror = inode->i_op->setxattr(dentry, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else if (issec) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t   size, flags);\n\t\tif (!error)\n\t\t\tfsnotify_xattr(dentry);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xattr_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
    "lines": "31-74",
    "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
  }
]