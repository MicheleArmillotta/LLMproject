[
  {
    "function_name": "ufs_load_cylinder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
    "lines": "126-201",
    "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_read_cylinder",
          "args": [
            "sb",
            "cgno",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_read_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "28-76",
          "snippet": "static void ufs_read_cylinder (struct super_block * sb,\n\tunsigned cgno, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i, j;\n\n\tUFSD(\"ENTER, cgno %u, bitmap_nr %u\\n\", cgno, bitmap_nr);\n\tuspi = sbi->s_uspi;\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\n\n\tUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\n\tUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\n\t/*\n\t * We have already the first fragment of cylinder group block in buffer\n\t */\n\tUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\n\t\tif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\n\t\t\tgoto failed;\n\tsbi->s_cgno[bitmap_nr] = cgno;\n\t\t\t\n\tucpi->c_cgx\t= fs32_to_cpu(sb, ucg->cg_cgx);\n\tucpi->c_ncyl\t= fs16_to_cpu(sb, ucg->cg_ncyl);\n\tucpi->c_niblk\t= fs16_to_cpu(sb, ucg->cg_niblk);\n\tucpi->c_ndblk\t= fs32_to_cpu(sb, ucg->cg_ndblk);\n\tucpi->c_rotor\t= fs32_to_cpu(sb, ucg->cg_rotor);\n\tucpi->c_frotor\t= fs32_to_cpu(sb, ucg->cg_frotor);\n\tucpi->c_irotor\t= fs32_to_cpu(sb, ucg->cg_irotor);\n\tucpi->c_btotoff\t= fs32_to_cpu(sb, ucg->cg_btotoff);\n\tucpi->c_boff\t= fs32_to_cpu(sb, ucg->cg_boff);\n\tucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\n\tucpi->c_freeoff\t= fs32_to_cpu(sb, ucg->cg_freeoff);\n\tucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\n\tucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\n\tucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\n\tucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\n\tUFSD(\"EXIT\\n\");\n\treturn;\t\n\t\nfailed:\n\tfor (j = 1; j < i; j++)\n\t\tbrelse (sbi->s_ucg[j]);\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tufs_error (sb, \"ufs_read_cylinder\", \"can't read cylinder group block %u\", cgno);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ufs_read_cylinder (struct super_block * sb,\n\tunsigned cgno, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i, j;\n\n\tUFSD(\"ENTER, cgno %u, bitmap_nr %u\\n\", cgno, bitmap_nr);\n\tuspi = sbi->s_uspi;\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\n\n\tUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\n\tUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\n\t/*\n\t * We have already the first fragment of cylinder group block in buffer\n\t */\n\tUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\n\t\tif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\n\t\t\tgoto failed;\n\tsbi->s_cgno[bitmap_nr] = cgno;\n\t\t\t\n\tucpi->c_cgx\t= fs32_to_cpu(sb, ucg->cg_cgx);\n\tucpi->c_ncyl\t= fs16_to_cpu(sb, ucg->cg_ncyl);\n\tucpi->c_niblk\t= fs16_to_cpu(sb, ucg->cg_niblk);\n\tucpi->c_ndblk\t= fs32_to_cpu(sb, ucg->cg_ndblk);\n\tucpi->c_rotor\t= fs32_to_cpu(sb, ucg->cg_rotor);\n\tucpi->c_frotor\t= fs32_to_cpu(sb, ucg->cg_frotor);\n\tucpi->c_irotor\t= fs32_to_cpu(sb, ucg->cg_irotor);\n\tucpi->c_btotoff\t= fs32_to_cpu(sb, ucg->cg_btotoff);\n\tucpi->c_boff\t= fs32_to_cpu(sb, ucg->cg_boff);\n\tucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\n\tucpi->c_freeoff\t= fs32_to_cpu(sb, ucg->cg_freeoff);\n\tucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\n\tucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\n\tucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\n\tucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\n\tUFSD(\"EXIT\\n\");\n\treturn;\t\n\t\nfailed:\n\tfor (j = 1; j < i; j++)\n\t\tbrelse (sbi->s_ucg[j]);\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tufs_error (sb, \"ufs_read_cylinder\", \"can't read cylinder group block %u\", cgno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_put_cylinder",
          "args": [
            "sb",
            "UFS_MAX_GROUP_LOADED-1"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "82-118",
          "snippet": "void ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_load_cylinder\"",
            "\"internal error, wrong number of cg in cache\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, cgno %u\\n\"",
            "cgno"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
  },
  {
    "function_name": "ufs_put_cylinder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
    "lines": "82-118",
    "snippet": "void ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "UCPI_UBH(ucpi)->bh[i]"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "ucpi->c_irotor"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_put_cylinder\"",
            "\"internal error\""
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, bitmap_nr %u\\n\"",
            "bitmap_nr"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_read_cylinder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
    "lines": "28-76",
    "snippet": "static void ufs_read_cylinder (struct super_block * sb,\n\tunsigned cgno, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i, j;\n\n\tUFSD(\"ENTER, cgno %u, bitmap_nr %u\\n\", cgno, bitmap_nr);\n\tuspi = sbi->s_uspi;\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\n\n\tUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\n\tUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\n\t/*\n\t * We have already the first fragment of cylinder group block in buffer\n\t */\n\tUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\n\t\tif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\n\t\t\tgoto failed;\n\tsbi->s_cgno[bitmap_nr] = cgno;\n\t\t\t\n\tucpi->c_cgx\t= fs32_to_cpu(sb, ucg->cg_cgx);\n\tucpi->c_ncyl\t= fs16_to_cpu(sb, ucg->cg_ncyl);\n\tucpi->c_niblk\t= fs16_to_cpu(sb, ucg->cg_niblk);\n\tucpi->c_ndblk\t= fs32_to_cpu(sb, ucg->cg_ndblk);\n\tucpi->c_rotor\t= fs32_to_cpu(sb, ucg->cg_rotor);\n\tucpi->c_frotor\t= fs32_to_cpu(sb, ucg->cg_frotor);\n\tucpi->c_irotor\t= fs32_to_cpu(sb, ucg->cg_irotor);\n\tucpi->c_btotoff\t= fs32_to_cpu(sb, ucg->cg_btotoff);\n\tucpi->c_boff\t= fs32_to_cpu(sb, ucg->cg_boff);\n\tucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\n\tucpi->c_freeoff\t= fs32_to_cpu(sb, ucg->cg_freeoff);\n\tucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\n\tucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\n\tucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\n\tucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\n\tUFSD(\"EXIT\\n\");\n\treturn;\t\n\t\nfailed:\n\tfor (j = 1; j < i; j++)\n\t\tbrelse (sbi->s_ucg[j]);\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tufs_error (sb, \"ufs_read_cylinder\", \"can't read cylinder group block %u\", cgno);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_read_cylinder\"",
            "\"can't read cylinder group block %u\"",
            "cgno"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_ucg[j]"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ucg->cg_u.cg_44.cg_nclusterblks"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "ucg->cg_niblk"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "UCPI_UBH(ucpi)->fragment + i"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cgcmin",
          "args": [
            "cgno"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, cgno %u, bitmap_nr %u\\n\"",
            "cgno",
            "bitmap_nr"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ufs_read_cylinder (struct super_block * sb,\n\tunsigned cgno, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i, j;\n\n\tUFSD(\"ENTER, cgno %u, bitmap_nr %u\\n\", cgno, bitmap_nr);\n\tuspi = sbi->s_uspi;\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\n\n\tUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\n\tUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\n\t/*\n\t * We have already the first fragment of cylinder group block in buffer\n\t */\n\tUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\n\t\tif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\n\t\t\tgoto failed;\n\tsbi->s_cgno[bitmap_nr] = cgno;\n\t\t\t\n\tucpi->c_cgx\t= fs32_to_cpu(sb, ucg->cg_cgx);\n\tucpi->c_ncyl\t= fs16_to_cpu(sb, ucg->cg_ncyl);\n\tucpi->c_niblk\t= fs16_to_cpu(sb, ucg->cg_niblk);\n\tucpi->c_ndblk\t= fs32_to_cpu(sb, ucg->cg_ndblk);\n\tucpi->c_rotor\t= fs32_to_cpu(sb, ucg->cg_rotor);\n\tucpi->c_frotor\t= fs32_to_cpu(sb, ucg->cg_frotor);\n\tucpi->c_irotor\t= fs32_to_cpu(sb, ucg->cg_irotor);\n\tucpi->c_btotoff\t= fs32_to_cpu(sb, ucg->cg_btotoff);\n\tucpi->c_boff\t= fs32_to_cpu(sb, ucg->cg_boff);\n\tucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\n\tucpi->c_freeoff\t= fs32_to_cpu(sb, ucg->cg_freeoff);\n\tucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\n\tucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\n\tucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\n\tucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\n\tUFSD(\"EXIT\\n\");\n\treturn;\t\n\t\nfailed:\n\tfor (j = 1; j < i; j++)\n\t\tbrelse (sbi->s_ucg[j]);\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tufs_error (sb, \"ufs_read_cylinder\", \"can't read cylinder group block %u\", cgno);\n}"
  }
]