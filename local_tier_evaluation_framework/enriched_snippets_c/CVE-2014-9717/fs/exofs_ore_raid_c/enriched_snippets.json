[
  {
    "function_name": "_ore_free_raid_stuff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "698-721",
    "snippet": "void _ore_free_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->sp2d) { /* writing and raid */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->cur_par_page; i++) {\n\t\t\tstruct page *page = ios->parity_pages[i];\n\n\t\t\tif (page)\n\t\t\t\t_raid_page_free(page);\n\t\t}\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->parity_pages);\n\t\t/* If IO returned an error pages might need unlocking */\n\t\t_sp2d_reset(ios->sp2d, ios->r4w, ios->private);\n\t\t_sp2d_free(ios->sp2d);\n\t} else {\n\t\t/* Will only be set if raid reading && sglist is big */\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->per_dev[0].sglist);\n\t}\n\tif (ios->ios_read_4_write)\n\t\tore_put_io_state(ios->ios_read_4_write);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios->ios_read_4_write"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ios->per_dev[0].sglist"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sp2d_free",
          "args": [
            "ios->sp2d"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "175-188",
          "snippet": "static void _sp2d_free(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned i;\n\n\tif (!sp2d)\n\t\treturn;\n\n\tfor (i = 0; i < sp2d->pages_in_unit; ++i) {\n\t\tif (sp2d->_1p_stripes[i].alloc)\n\t\t\tkfree(sp2d->_1p_stripes[i].pages);\n\t}\n\n\tkfree(sp2d);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _sp2d_free(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned i;\n\n\tif (!sp2d)\n\t\treturn;\n\n\tfor (i = 0; i < sp2d->pages_in_unit; ++i) {\n\t\tif (sp2d->_1p_stripes[i].alloc)\n\t\t\tkfree(sp2d->_1p_stripes[i].pages);\n\t}\n\n\tkfree(sp2d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sp2d_reset",
          "args": [
            "ios->sp2d",
            "ios->r4w",
            "ios->private"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "142-173",
          "snippet": "static void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ios->parity_pages"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_raid_page_free",
          "args": [
            "page"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "_raid_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "29-32",
          "snippet": "static void _raid_page_free(struct page *p)\n{\n\t__free_page(p);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _raid_page_free(struct page *p)\n{\n\t__free_page(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_free_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->sp2d) { /* writing and raid */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->cur_par_page; i++) {\n\t\t\tstruct page *page = ios->parity_pages[i];\n\n\t\t\tif (page)\n\t\t\t\t_raid_page_free(page);\n\t\t}\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->parity_pages);\n\t\t/* If IO returned an error pages might need unlocking */\n\t\t_sp2d_reset(ios->sp2d, ios->r4w, ios->private);\n\t\t_sp2d_free(ios->sp2d);\n\t} else {\n\t\t/* Will only be set if raid reading && sglist is big */\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->per_dev[0].sglist);\n\t}\n\tif (ios->ios_read_4_write)\n\t\tore_put_io_state(ios->ios_read_4_write);\n}"
  },
  {
    "function_name": "_ore_post_alloc_raid_stuff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "684-696",
    "snippet": "int _ore_post_alloc_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->parity_pages) {\n\t\tstruct ore_layout *layout = ios->layout;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\n\t\tif (_sp2d_alloc(pages_in_unit, layout->group_width,\n\t\t\t\tlayout->parity, &ios->sp2d)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_sp2d_alloc",
          "args": [
            "pages_in_unit",
            "layout->group_width",
            "layout->parity",
            "&ios->sp2d"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "69-140",
          "snippet": "static int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width,\n\t\t       unsigned parity, struct __stripe_pages_2d **psp2d)\n{\n\tstruct __stripe_pages_2d *sp2d;\n\tunsigned data_devs = group_width - parity;\n\tstruct _alloc_all_bytes {\n\t\tstruct __alloc_stripe_pages_2d {\n\t\t\tstruct __stripe_pages_2d sp2d;\n\t\t\tstruct __1_page_stripe _1p_stripes[pages_in_unit];\n\t\t} __asp2d;\n\t\tstruct __alloc_1p_arrays {\n\t\t\tstruct page *pages[group_width];\n\t\t\tstruct page *scribble[group_width];\n\t\t\tchar page_is_read[data_devs];\n\t\t} __a1pa[pages_in_unit];\n\t} *_aab;\n\tstruct __alloc_1p_arrays *__a1pa;\n\tstruct __alloc_1p_arrays *__a1pa_end;\n\tconst unsigned sizeof__a1pa = sizeof(_aab->__a1pa[0]);\n\tunsigned num_a1pa, alloc_size, i;\n\n\t/* FIXME: check these numbers in ore_verify_layout */\n\tBUG_ON(sizeof(_aab->__asp2d) > PAGE_SIZE);\n\tBUG_ON(sizeof__a1pa > PAGE_SIZE);\n\n\tif (sizeof(*_aab) > PAGE_SIZE) {\n\t\tnum_a1pa = (PAGE_SIZE - sizeof(_aab->__asp2d)) / sizeof__a1pa;\n\t\talloc_size = sizeof(_aab->__asp2d) + sizeof__a1pa * num_a1pa;\n\t} else {\n\t\tnum_a1pa = pages_in_unit;\n\t\talloc_size = sizeof(*_aab);\n\t}\n\n\t_aab = kzalloc(alloc_size, GFP_KERNEL);\n\tif (unlikely(!_aab)) {\n\t\tORE_DBGMSG(\"!! Failed to alloc sp2d size=%d\\n\", alloc_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tsp2d = &_aab->__asp2d.sp2d;\n\t*psp2d = sp2d; /* From here Just call _sp2d_free */\n\n\t__a1pa = _aab->__a1pa;\n\t__a1pa_end = __a1pa + num_a1pa;\n\n\tfor (i = 0; i < pages_in_unit; ++i) {\n\t\tif (unlikely(__a1pa >= __a1pa_end)) {\n\t\t\tnum_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa,\n\t\t\t\t\t\t\tpages_in_unit - i);\n\n\t\t\t__a1pa = kcalloc(num_a1pa, sizeof__a1pa, GFP_KERNEL);\n\t\t\tif (unlikely(!__a1pa)) {\n\t\t\t\tORE_DBGMSG(\"!! Failed to _alloc_1p_arrays=%d\\n\",\n\t\t\t\t\t   num_a1pa);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t__a1pa_end = __a1pa + num_a1pa;\n\t\t\t/* First *pages is marked for kfree of the buffer */\n\t\t\tsp2d->_1p_stripes[i].alloc = true;\n\t\t}\n\n\t\tsp2d->_1p_stripes[i].pages = __a1pa->pages;\n\t\tsp2d->_1p_stripes[i].scribble = __a1pa->scribble ;\n\t\tsp2d->_1p_stripes[i].page_is_read = __a1pa->page_is_read;\n\t\t++__a1pa;\n\t}\n\n\tsp2d->parity = parity;\n\tsp2d->data_devs = data_devs;\n\tsp2d->pages_in_unit = pages_in_unit;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width,\n\t\t       unsigned parity, struct __stripe_pages_2d **psp2d)\n{\n\tstruct __stripe_pages_2d *sp2d;\n\tunsigned data_devs = group_width - parity;\n\tstruct _alloc_all_bytes {\n\t\tstruct __alloc_stripe_pages_2d {\n\t\t\tstruct __stripe_pages_2d sp2d;\n\t\t\tstruct __1_page_stripe _1p_stripes[pages_in_unit];\n\t\t} __asp2d;\n\t\tstruct __alloc_1p_arrays {\n\t\t\tstruct page *pages[group_width];\n\t\t\tstruct page *scribble[group_width];\n\t\t\tchar page_is_read[data_devs];\n\t\t} __a1pa[pages_in_unit];\n\t} *_aab;\n\tstruct __alloc_1p_arrays *__a1pa;\n\tstruct __alloc_1p_arrays *__a1pa_end;\n\tconst unsigned sizeof__a1pa = sizeof(_aab->__a1pa[0]);\n\tunsigned num_a1pa, alloc_size, i;\n\n\t/* FIXME: check these numbers in ore_verify_layout */\n\tBUG_ON(sizeof(_aab->__asp2d) > PAGE_SIZE);\n\tBUG_ON(sizeof__a1pa > PAGE_SIZE);\n\n\tif (sizeof(*_aab) > PAGE_SIZE) {\n\t\tnum_a1pa = (PAGE_SIZE - sizeof(_aab->__asp2d)) / sizeof__a1pa;\n\t\talloc_size = sizeof(_aab->__asp2d) + sizeof__a1pa * num_a1pa;\n\t} else {\n\t\tnum_a1pa = pages_in_unit;\n\t\talloc_size = sizeof(*_aab);\n\t}\n\n\t_aab = kzalloc(alloc_size, GFP_KERNEL);\n\tif (unlikely(!_aab)) {\n\t\tORE_DBGMSG(\"!! Failed to alloc sp2d size=%d\\n\", alloc_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tsp2d = &_aab->__asp2d.sp2d;\n\t*psp2d = sp2d; /* From here Just call _sp2d_free */\n\n\t__a1pa = _aab->__a1pa;\n\t__a1pa_end = __a1pa + num_a1pa;\n\n\tfor (i = 0; i < pages_in_unit; ++i) {\n\t\tif (unlikely(__a1pa >= __a1pa_end)) {\n\t\t\tnum_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa,\n\t\t\t\t\t\t\tpages_in_unit - i);\n\n\t\t\t__a1pa = kcalloc(num_a1pa, sizeof__a1pa, GFP_KERNEL);\n\t\t\tif (unlikely(!__a1pa)) {\n\t\t\t\tORE_DBGMSG(\"!! Failed to _alloc_1p_arrays=%d\\n\",\n\t\t\t\t\t   num_a1pa);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t__a1pa_end = __a1pa + num_a1pa;\n\t\t\t/* First *pages is marked for kfree of the buffer */\n\t\t\tsp2d->_1p_stripes[i].alloc = true;\n\t\t}\n\n\t\tsp2d->_1p_stripes[i].pages = __a1pa->pages;\n\t\tsp2d->_1p_stripes[i].scribble = __a1pa->scribble ;\n\t\tsp2d->_1p_stripes[i].page_is_read = __a1pa->page_is_read;\n\t\t++__a1pa;\n\t}\n\n\tsp2d->parity = parity;\n\tsp2d->data_devs = data_devs;\n\tsp2d->pages_in_unit = pages_in_unit;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nint _ore_post_alloc_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->parity_pages) {\n\t\tstruct ore_layout *layout = ios->layout;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\n\t\tif (_sp2d_alloc(pages_in_unit, layout->group_width,\n\t\t\t\tlayout->parity, &ios->sp2d)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "_ore_add_parity_unit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "624-682",
    "snippet": "int _ore_add_parity_unit(struct ore_io_state *ios,\n\t\t\t    struct ore_striping_info *si,\n\t\t\t    struct ore_per_dev_state *per_dev,\n\t\t\t    unsigned cur_len, bool do_xor)\n{\n\tif (ios->reading) {\n\t\tif (per_dev->cur_sg >= ios->sgs_per_dev) {\n\t\t\tORE_DBGMSG(\"cur_sg(%d) >= sgs_per_dev(%d)\\n\" ,\n\t\t\t\tper_dev->cur_sg, ios->sgs_per_dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t_ore_add_sg_seg(per_dev, cur_len, true);\n\t} else {\n\t\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\t\tstruct page **pages = ios->parity_pages + ios->cur_par_page;\n\t\tunsigned num_pages;\n\t\tunsigned array_start = 0;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\tsi->cur_pg = _sp2d_min_pg(sp2d);\n\t\tnum_pages  = _sp2d_max_pg(sp2d) + 1 - si->cur_pg;\n\n\t\tif (!per_dev->length) {\n\t\t\tper_dev->offset += si->cur_pg * PAGE_SIZE;\n\t\t\t/* If first stripe, Read in all read4write pages\n\t\t\t * (if needed) before we calculate the first parity.\n\t\t\t */\n\t\t\tif (do_xor)\n\t\t\t\t_read_4_write_first_stripe(ios);\n\t\t}\n\t\tif (!cur_len && do_xor)\n\t\t\t/* If last stripe r4w pages of last stripe */\n\t\t\t_read_4_write_last_stripe(ios);\n\t\t_read_4_write_execute(ios);\n\n\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\tpages[i] = _raid_page_alloc();\n\t\t\tif (unlikely(!pages[i]))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t++(ios->cur_par_page);\n\t\t}\n\n\t\tBUG_ON(si->cur_comp < sp2d->data_devs);\n\t\tBUG_ON(si->cur_pg + num_pages > sp2d->pages_in_unit);\n\n\t\tret = _ore_add_stripe_unit(ios,  &array_start, 0, pages,\n\t\t\t\t\t   per_dev, num_pages * PAGE_SIZE);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tif (do_xor) {\n\t\t\t_gen_xor_unit(sp2d);\n\t\t\t_sp2d_reset(sp2d, ios->r4w, ios->private);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_sp2d_reset",
          "args": [
            "sp2d",
            "ios->r4w",
            "ios->private"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "142-173",
          "snippet": "static void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_gen_xor_unit",
          "args": [
            "sp2d"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "_gen_xor_unit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "218-253",
          "snippet": "static void _gen_xor_unit(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\tunsigned tx_flags = ASYNC_TX_ACK;\n\n\tif (sp2d->parity == 1)\n\t\ttx_flags |= ASYNC_TX_XOR_ZERO_DST;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (!_1ps->write_count)\n\t\t\tcontinue;\n\n\t\tinit_async_submit(&_1ps->submit, tx_flags,\n\t\t\tNULL, NULL, NULL, (addr_conv_t *)_1ps->scribble);\n\n\t\tif (sp2d->parity == 1)\n\t\t\t_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs],\n\t\t\t\t\t\t_1ps->pages, 0, sp2d->data_devs,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t\telse /* parity == 2 */\n\t\t\t_1ps->tx = async_gen_syndrome(_1ps->pages, 0,\n\t\t\t\t\t\tsp2d->data_devs + sp2d->parity,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t/* NOTE: We wait for HW synchronously (I don't have such HW\n\t\t * to test with.) Is parallelism needed with today's multi\n\t\t * cores?\n\t\t */\n\t\tasync_tx_issue_pending(_1ps->tx);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _gen_xor_unit(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\tunsigned tx_flags = ASYNC_TX_ACK;\n\n\tif (sp2d->parity == 1)\n\t\ttx_flags |= ASYNC_TX_XOR_ZERO_DST;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (!_1ps->write_count)\n\t\t\tcontinue;\n\n\t\tinit_async_submit(&_1ps->submit, tx_flags,\n\t\t\tNULL, NULL, NULL, (addr_conv_t *)_1ps->scribble);\n\n\t\tif (sp2d->parity == 1)\n\t\t\t_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs],\n\t\t\t\t\t\t_1ps->pages, 0, sp2d->data_devs,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t\telse /* parity == 2 */\n\t\t\t_1ps->tx = async_gen_syndrome(_1ps->pages, 0,\n\t\t\t\t\t\tsp2d->data_devs + sp2d->parity,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t/* NOTE: We wait for HW synchronously (I don't have such HW\n\t\t * to test with.) Is parallelism needed with today's multi\n\t\t * cores?\n\t\t */\n\t\tasync_tx_issue_pending(_1ps->tx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ore_add_stripe_unit",
          "args": [
            "ios",
            "&array_start",
            "0",
            "pages",
            "per_dev",
            "num_pages * PAGE_SIZE"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "si->cur_pg + num_pages > sp2d->pages_in_unit"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "si->cur_comp < sp2d->data_devs"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pages[i]"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_raid_page_alloc",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "_raid_page_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "24-27",
          "snippet": "static struct page *_raid_page_alloc(void)\n{\n\treturn alloc_page(GFP_KERNEL);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic struct page *_raid_page_alloc(void)\n{\n\treturn alloc_page(GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_read_4_write_execute",
          "args": [
            "ios"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "_read_4_write_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "589-621",
          "snippet": "static int _read_4_write_execute(struct ore_io_state *ios)\n{\n\tstruct ore_io_state *ios_read;\n\tunsigned i;\n\tint ret;\n\n\tios_read = ios->ios_read_4_write;\n\tif (!ios_read)\n\t\treturn 0;\n\n\t/* FIXME: Ugly to signal _sbi_read_mirror that we have bio(s). Change\n\t * to check for per_dev->bio\n\t */\n\tios_read->pages = ios->pages;\n\n\t/* Now read these devices */\n\tfor (i = 0; i < ios_read->numdevs; i += ios_read->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios_read, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios_read); /* Synchronus execution */\n\tif (unlikely(ret)) {\n\t\tORE_DBGMSG(\"!! ore_io_execute => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t_mark_read4write_pages_uptodate(ios_read, ret);\n\tore_put_io_state(ios_read);\n\tios->ios_read_4_write = NULL; /* Might need a reuse at last stripe */\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_execute(struct ore_io_state *ios)\n{\n\tstruct ore_io_state *ios_read;\n\tunsigned i;\n\tint ret;\n\n\tios_read = ios->ios_read_4_write;\n\tif (!ios_read)\n\t\treturn 0;\n\n\t/* FIXME: Ugly to signal _sbi_read_mirror that we have bio(s). Change\n\t * to check for per_dev->bio\n\t */\n\tios_read->pages = ios->pages;\n\n\t/* Now read these devices */\n\tfor (i = 0; i < ios_read->numdevs; i += ios_read->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios_read, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios_read); /* Synchronus execution */\n\tif (unlikely(ret)) {\n\t\tORE_DBGMSG(\"!! ore_io_execute => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t_mark_read4write_pages_uptodate(ios_read, ret);\n\tore_put_io_state(ios_read);\n\tios->ios_read_4_write = NULL; /* Might need a reuse at last stripe */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_read_4_write_last_stripe",
          "args": [
            "ios"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "_read_4_write_last_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "522-587",
          "snippet": "static int _read_4_write_last_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset;\n\tu64 last_stripe_end;\n\tunsigned bytes_in_stripe = ios->si.bytes_in_stripe;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\toffset = ios->offset + ios->length;\n\tif (offset % PAGE_SIZE)\n\t\t_add_to_r4w_last_page(ios, &offset);\n\t\t/* offset will be aligned to next page */\n\n\tlast_stripe_end = div_u64(offset + bytes_in_stripe - 1, bytes_in_stripe)\n\t\t\t\t * bytes_in_stripe;\n\tif (offset == last_stripe_end) /* Optimize for the aligned case */\n\t\tgoto read_it;\n\n\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\tp = read_si.cur_pg;\n\tc = read_si.cur_comp;\n\n\tif (min_p == sp2d->pages_in_unit) {\n\t\t/* Didn't do it yet */\n\t\tmin_p = _sp2d_min_pg(sp2d);\n\t\tmax_p = _sp2d_max_pg(sp2d);\n\t}\n\n\tORE_DBGMSG(\"offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, last_stripe_end, min_p, max_p);\n\n\twhile (offset < last_stripe_end) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif ((min_p <= p) && (p <= max_p)) {\n\t\t\tstruct page *page;\n\t\t\tbool uptodate;\n\n\t\t\tBUG_ON(_1ps->pages[c]);\n\t\t\tpage = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t  &uptodate);\n\t\t\tif (unlikely(!page))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t_1ps->pages[c] = page;\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, page, PAGE_SIZE);\n\t\t}\n\n\t\toffset += PAGE_SIZE;\n\t\tif (p == (sp2d->pages_in_unit - 1)) {\n\t\t\t++c;\n\t\t\tp = 0;\n\t\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\t} else {\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\t++p;\n\t\t}\n\t}\n\nread_it:\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_last_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset;\n\tu64 last_stripe_end;\n\tunsigned bytes_in_stripe = ios->si.bytes_in_stripe;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\toffset = ios->offset + ios->length;\n\tif (offset % PAGE_SIZE)\n\t\t_add_to_r4w_last_page(ios, &offset);\n\t\t/* offset will be aligned to next page */\n\n\tlast_stripe_end = div_u64(offset + bytes_in_stripe - 1, bytes_in_stripe)\n\t\t\t\t * bytes_in_stripe;\n\tif (offset == last_stripe_end) /* Optimize for the aligned case */\n\t\tgoto read_it;\n\n\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\tp = read_si.cur_pg;\n\tc = read_si.cur_comp;\n\n\tif (min_p == sp2d->pages_in_unit) {\n\t\t/* Didn't do it yet */\n\t\tmin_p = _sp2d_min_pg(sp2d);\n\t\tmax_p = _sp2d_max_pg(sp2d);\n\t}\n\n\tORE_DBGMSG(\"offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, last_stripe_end, min_p, max_p);\n\n\twhile (offset < last_stripe_end) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif ((min_p <= p) && (p <= max_p)) {\n\t\t\tstruct page *page;\n\t\t\tbool uptodate;\n\n\t\t\tBUG_ON(_1ps->pages[c]);\n\t\t\tpage = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t  &uptodate);\n\t\t\tif (unlikely(!page))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t_1ps->pages[c] = page;\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, page, PAGE_SIZE);\n\t\t}\n\n\t\toffset += PAGE_SIZE;\n\t\tif (p == (sp2d->pages_in_unit - 1)) {\n\t\t\t++c;\n\t\t\tp = 0;\n\t\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\t} else {\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\t++p;\n\t\t}\n\t}\n\nread_it:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_read_4_write_first_stripe",
          "args": [
            "ios"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "_read_4_write_first_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "469-520",
          "snippet": "static int _read_4_write_first_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset = ios->si.first_stripe_start;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\tif (offset == ios->offset) /* Go to start collect $200 */\n\t\tgoto read_last_stripe;\n\n\tmin_p = _sp2d_min_pg(sp2d);\n\tmax_p = _sp2d_max_pg(sp2d);\n\n\tORE_DBGMSG(\"stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, ios->offset, min_p, max_p);\n\n\tfor (c = 0; ; c++) {\n\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\tread_si.obj_offset += min_p * PAGE_SIZE;\n\t\toffset += min_p * PAGE_SIZE;\n\t\tfor (p = min_p; p <= max_p; p++) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t\tstruct page **pp = &_1ps->pages[c];\n\t\t\tbool uptodate;\n\n\t\t\tif (*pp) {\n\t\t\t\tif (ios->offset % PAGE_SIZE)\n\t\t\t\t\t/* Read the remainder of the page */\n\t\t\t\t\t_add_to_r4w_first_page(ios, *pp);\n\t\t\t\t/* to-be-written pages start here */\n\t\t\t\tgoto read_last_stripe;\n\t\t\t}\n\n\t\t\t*pp = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t &uptodate);\n\t\t\tif (unlikely(!*pp))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, *pp, PAGE_SIZE);\n\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\toffset += PAGE_SIZE;\n\t\t}\n\t\toffset += (sp2d->pages_in_unit - p) * PAGE_SIZE;\n\t}\n\nread_last_stripe:\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_first_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset = ios->si.first_stripe_start;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\tif (offset == ios->offset) /* Go to start collect $200 */\n\t\tgoto read_last_stripe;\n\n\tmin_p = _sp2d_min_pg(sp2d);\n\tmax_p = _sp2d_max_pg(sp2d);\n\n\tORE_DBGMSG(\"stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, ios->offset, min_p, max_p);\n\n\tfor (c = 0; ; c++) {\n\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\tread_si.obj_offset += min_p * PAGE_SIZE;\n\t\toffset += min_p * PAGE_SIZE;\n\t\tfor (p = min_p; p <= max_p; p++) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t\tstruct page **pp = &_1ps->pages[c];\n\t\t\tbool uptodate;\n\n\t\t\tif (*pp) {\n\t\t\t\tif (ios->offset % PAGE_SIZE)\n\t\t\t\t\t/* Read the remainder of the page */\n\t\t\t\t\t_add_to_r4w_first_page(ios, *pp);\n\t\t\t\t/* to-be-written pages start here */\n\t\t\t\tgoto read_last_stripe;\n\t\t\t}\n\n\t\t\t*pp = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t &uptodate);\n\t\t\tif (unlikely(!*pp))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, *pp, PAGE_SIZE);\n\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\toffset += PAGE_SIZE;\n\t\t}\n\t\toffset += (sp2d->pages_in_unit - p) * PAGE_SIZE;\n\t}\n\nread_last_stripe:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sp2d_max_pg",
          "args": [
            "sp2d"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_max_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "204-216",
          "snippet": "static unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sp2d_min_pg",
          "args": [
            "sp2d"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_min_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "190-202",
          "snippet": "static unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ore_add_sg_seg",
          "args": [
            "per_dev",
            "cur_len",
            "true"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_add_sg_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "270-317",
          "snippet": "void _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"cur_sg(%d) >= sgs_per_dev(%d)\\n\"",
            "per_dev->cur_sg",
            "ios->sgs_per_dev"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nint _ore_add_parity_unit(struct ore_io_state *ios,\n\t\t\t    struct ore_striping_info *si,\n\t\t\t    struct ore_per_dev_state *per_dev,\n\t\t\t    unsigned cur_len, bool do_xor)\n{\n\tif (ios->reading) {\n\t\tif (per_dev->cur_sg >= ios->sgs_per_dev) {\n\t\t\tORE_DBGMSG(\"cur_sg(%d) >= sgs_per_dev(%d)\\n\" ,\n\t\t\t\tper_dev->cur_sg, ios->sgs_per_dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t_ore_add_sg_seg(per_dev, cur_len, true);\n\t} else {\n\t\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\t\tstruct page **pages = ios->parity_pages + ios->cur_par_page;\n\t\tunsigned num_pages;\n\t\tunsigned array_start = 0;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\tsi->cur_pg = _sp2d_min_pg(sp2d);\n\t\tnum_pages  = _sp2d_max_pg(sp2d) + 1 - si->cur_pg;\n\n\t\tif (!per_dev->length) {\n\t\t\tper_dev->offset += si->cur_pg * PAGE_SIZE;\n\t\t\t/* If first stripe, Read in all read4write pages\n\t\t\t * (if needed) before we calculate the first parity.\n\t\t\t */\n\t\t\tif (do_xor)\n\t\t\t\t_read_4_write_first_stripe(ios);\n\t\t}\n\t\tif (!cur_len && do_xor)\n\t\t\t/* If last stripe r4w pages of last stripe */\n\t\t\t_read_4_write_last_stripe(ios);\n\t\t_read_4_write_execute(ios);\n\n\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\tpages[i] = _raid_page_alloc();\n\t\t\tif (unlikely(!pages[i]))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t++(ios->cur_par_page);\n\t\t}\n\n\t\tBUG_ON(si->cur_comp < sp2d->data_devs);\n\t\tBUG_ON(si->cur_pg + num_pages > sp2d->pages_in_unit);\n\n\t\tret = _ore_add_stripe_unit(ios,  &array_start, 0, pages,\n\t\t\t\t\t   per_dev, num_pages * PAGE_SIZE);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tif (do_xor) {\n\t\t\t_gen_xor_unit(sp2d);\n\t\t\t_sp2d_reset(sp2d, ios->r4w, ios->private);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "_read_4_write_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "589-621",
    "snippet": "static int _read_4_write_execute(struct ore_io_state *ios)\n{\n\tstruct ore_io_state *ios_read;\n\tunsigned i;\n\tint ret;\n\n\tios_read = ios->ios_read_4_write;\n\tif (!ios_read)\n\t\treturn 0;\n\n\t/* FIXME: Ugly to signal _sbi_read_mirror that we have bio(s). Change\n\t * to check for per_dev->bio\n\t */\n\tios_read->pages = ios->pages;\n\n\t/* Now read these devices */\n\tfor (i = 0; i < ios_read->numdevs; i += ios_read->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios_read, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios_read); /* Synchronus execution */\n\tif (unlikely(ret)) {\n\t\tORE_DBGMSG(\"!! ore_io_execute => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t_mark_read4write_pages_uptodate(ios_read, ret);\n\tore_put_io_state(ios_read);\n\tios->ios_read_4_write = NULL; /* Might need a reuse at last stripe */\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios_read"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mark_read4write_pages_uptodate",
          "args": [
            "ios_read",
            "ret"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "_mark_read4write_pages_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "428-448",
          "snippet": "static void _mark_read4write_pages_uptodate(struct ore_io_state *ios, int ret)\n{\n\tstruct bio_vec *bv;\n\tunsigned i, d;\n\n\t/* loop on all devices all pages */\n\tfor (d = 0; d < ios->numdevs; d++) {\n\t\tstruct bio *bio = ios->per_dev[d].bio;\n\n\t\tif (!bio)\n\t\t\tcontinue;\n\n\t\tbio_for_each_segment_all(bv, bio, i) {\n\t\t\tstruct page *page = bv->bv_page;\n\n\t\t\tSetPageUptodate(page);\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _mark_read4write_pages_uptodate(struct ore_io_state *ios, int ret)\n{\n\tstruct bio_vec *bv;\n\tunsigned i, d;\n\n\t/* loop on all devices all pages */\n\tfor (d = 0; d < ios->numdevs; d++) {\n\t\tstruct bio *bio = ios->per_dev[d].bio;\n\n\t\tif (!bio)\n\t\t\tcontinue;\n\n\t\tbio_for_each_segment_all(bv, bio, i) {\n\t\t\tstruct page *page = bv->bv_page;\n\n\t\t\tSetPageUptodate(page);\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"!! ore_io_execute => %d\\n\"",
            "ret"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_io_execute",
          "args": [
            "ios_read"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ore_io_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "360-403",
          "snippet": "int ore_io_execute(struct ore_io_state *ios)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tbool sync = (ios->done == NULL);\n\tint i, ret;\n\n\tif (sync) {\n\t\tios->done = _sync_done;\n\t\tios->private = &wait;\n\t}\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_finalize_request(or, 0, _ios_cred(ios, i), NULL);\n\t\tif (unlikely(ret)) {\n\t\t\tORE_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\",\n\t\t\t\t     ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tkref_init(&ios->kref);\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tkref_get(&ios->kref);\n\t\tosd_execute_request_async(or, _done_io, ios);\n\t}\n\n\tkref_put(&ios->kref, _last_io);\n\tret = 0;\n\n\tif (sync) {\n\t\twait_for_completion(&wait);\n\t\tret = ore_check_io(ios, NULL);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_io_execute(struct ore_io_state *ios)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tbool sync = (ios->done == NULL);\n\tint i, ret;\n\n\tif (sync) {\n\t\tios->done = _sync_done;\n\t\tios->private = &wait;\n\t}\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_finalize_request(or, 0, _ios_cred(ios, i), NULL);\n\t\tif (unlikely(ret)) {\n\t\t\tORE_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\",\n\t\t\t\t     ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tkref_init(&ios->kref);\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tkref_get(&ios->kref);\n\t\tosd_execute_request_async(or, _done_io, ios);\n\t}\n\n\tkref_put(&ios->kref, _last_io);\n\tret = 0;\n\n\tif (sync) {\n\t\twait_for_completion(&wait);\n\t\tret = ore_check_io(ios, NULL);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ore_read_mirror",
          "args": [
            "ios_read",
            "i"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_execute(struct ore_io_state *ios)\n{\n\tstruct ore_io_state *ios_read;\n\tunsigned i;\n\tint ret;\n\n\tios_read = ios->ios_read_4_write;\n\tif (!ios_read)\n\t\treturn 0;\n\n\t/* FIXME: Ugly to signal _sbi_read_mirror that we have bio(s). Change\n\t * to check for per_dev->bio\n\t */\n\tios_read->pages = ios->pages;\n\n\t/* Now read these devices */\n\tfor (i = 0; i < ios_read->numdevs; i += ios_read->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios_read, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios_read); /* Synchronus execution */\n\tif (unlikely(ret)) {\n\t\tORE_DBGMSG(\"!! ore_io_execute => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t_mark_read4write_pages_uptodate(ios_read, ret);\n\tore_put_io_state(ios_read);\n\tios->ios_read_4_write = NULL; /* Might need a reuse at last stripe */\n\treturn 0;\n}"
  },
  {
    "function_name": "_read_4_write_last_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "522-587",
    "snippet": "static int _read_4_write_last_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset;\n\tu64 last_stripe_end;\n\tunsigned bytes_in_stripe = ios->si.bytes_in_stripe;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\toffset = ios->offset + ios->length;\n\tif (offset % PAGE_SIZE)\n\t\t_add_to_r4w_last_page(ios, &offset);\n\t\t/* offset will be aligned to next page */\n\n\tlast_stripe_end = div_u64(offset + bytes_in_stripe - 1, bytes_in_stripe)\n\t\t\t\t * bytes_in_stripe;\n\tif (offset == last_stripe_end) /* Optimize for the aligned case */\n\t\tgoto read_it;\n\n\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\tp = read_si.cur_pg;\n\tc = read_si.cur_comp;\n\n\tif (min_p == sp2d->pages_in_unit) {\n\t\t/* Didn't do it yet */\n\t\tmin_p = _sp2d_min_pg(sp2d);\n\t\tmax_p = _sp2d_max_pg(sp2d);\n\t}\n\n\tORE_DBGMSG(\"offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, last_stripe_end, min_p, max_p);\n\n\twhile (offset < last_stripe_end) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif ((min_p <= p) && (p <= max_p)) {\n\t\t\tstruct page *page;\n\t\t\tbool uptodate;\n\n\t\t\tBUG_ON(_1ps->pages[c]);\n\t\t\tpage = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t  &uptodate);\n\t\t\tif (unlikely(!page))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t_1ps->pages[c] = page;\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, page, PAGE_SIZE);\n\t\t}\n\n\t\toffset += PAGE_SIZE;\n\t\tif (p == (sp2d->pages_in_unit - 1)) {\n\t\t\t++c;\n\t\t\tp = 0;\n\t\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\t} else {\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\t++p;\n\t\t}\n\t}\n\nread_it:\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "ios->layout",
            "offset",
            "0",
            "&read_si"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_add_to_r4w",
          "args": [
            "ios",
            "&read_si",
            "page",
            "PAGE_SIZE"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "337-385",
          "snippet": "static int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ios->r4w->get_page",
          "args": [
            "ios->private",
            "offset",
            "&uptodate"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "_1ps->pages[c]"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\\n\"",
            "offset",
            "last_stripe_end",
            "min_p",
            "max_p"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sp2d_max_pg",
          "args": [
            "sp2d"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_max_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "204-216",
          "snippet": "static unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sp2d_min_pg",
          "args": [
            "sp2d"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_min_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "190-202",
          "snippet": "static unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "ios->layout",
            "offset",
            "0",
            "&read_si"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "offset + bytes_in_stripe - 1",
            "bytes_in_stripe"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_add_to_r4w_last_page",
          "args": [
            "ios",
            "&offset"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w_last_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "405-426",
          "snippet": "static int _add_to_r4w_last_page(struct ore_io_state *ios, u64 *offset)\n{\n\tstruct ore_striping_info si;\n\tstruct page *page;\n\tunsigned pg_len, p, c;\n\n\tore_calc_stripe_info(ios->layout, *offset, 0, &si);\n\n\tp = si.cur_pg;\n\tc = si.cur_comp;\n\tpage = ios->sp2d->_1p_stripes[p].pages[c];\n\n\tpg_len = PAGE_SIZE - (si.unit_off % PAGE_SIZE);\n\t*offset += pg_len;\n\n\tORE_DBGMSG(\"p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\\n\",\n\t\t   p, c, _LLU(*offset), pg_len, si.dev, si.par_dev);\n\n\tBUG_ON(!page);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w_last_page(struct ore_io_state *ios, u64 *offset)\n{\n\tstruct ore_striping_info si;\n\tstruct page *page;\n\tunsigned pg_len, p, c;\n\n\tore_calc_stripe_info(ios->layout, *offset, 0, &si);\n\n\tp = si.cur_pg;\n\tc = si.cur_comp;\n\tpage = ios->sp2d->_1p_stripes[p].pages[c];\n\n\tpg_len = PAGE_SIZE - (si.unit_off % PAGE_SIZE);\n\t*offset += pg_len;\n\n\tORE_DBGMSG(\"p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\\n\",\n\t\t   p, c, _LLU(*offset), pg_len, si.dev, si.par_dev);\n\n\tBUG_ON(!page);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_last_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset;\n\tu64 last_stripe_end;\n\tunsigned bytes_in_stripe = ios->si.bytes_in_stripe;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\toffset = ios->offset + ios->length;\n\tif (offset % PAGE_SIZE)\n\t\t_add_to_r4w_last_page(ios, &offset);\n\t\t/* offset will be aligned to next page */\n\n\tlast_stripe_end = div_u64(offset + bytes_in_stripe - 1, bytes_in_stripe)\n\t\t\t\t * bytes_in_stripe;\n\tif (offset == last_stripe_end) /* Optimize for the aligned case */\n\t\tgoto read_it;\n\n\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\tp = read_si.cur_pg;\n\tc = read_si.cur_comp;\n\n\tif (min_p == sp2d->pages_in_unit) {\n\t\t/* Didn't do it yet */\n\t\tmin_p = _sp2d_min_pg(sp2d);\n\t\tmax_p = _sp2d_max_pg(sp2d);\n\t}\n\n\tORE_DBGMSG(\"offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, last_stripe_end, min_p, max_p);\n\n\twhile (offset < last_stripe_end) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif ((min_p <= p) && (p <= max_p)) {\n\t\t\tstruct page *page;\n\t\t\tbool uptodate;\n\n\t\t\tBUG_ON(_1ps->pages[c]);\n\t\t\tpage = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t  &uptodate);\n\t\t\tif (unlikely(!page))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t_1ps->pages[c] = page;\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, page, PAGE_SIZE);\n\t\t}\n\n\t\toffset += PAGE_SIZE;\n\t\tif (p == (sp2d->pages_in_unit - 1)) {\n\t\t\t++c;\n\t\t\tp = 0;\n\t\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\t} else {\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\t++p;\n\t\t}\n\t}\n\nread_it:\n\treturn 0;\n}"
  },
  {
    "function_name": "_read_4_write_first_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "469-520",
    "snippet": "static int _read_4_write_first_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset = ios->si.first_stripe_start;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\tif (offset == ios->offset) /* Go to start collect $200 */\n\t\tgoto read_last_stripe;\n\n\tmin_p = _sp2d_min_pg(sp2d);\n\tmax_p = _sp2d_max_pg(sp2d);\n\n\tORE_DBGMSG(\"stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, ios->offset, min_p, max_p);\n\n\tfor (c = 0; ; c++) {\n\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\tread_si.obj_offset += min_p * PAGE_SIZE;\n\t\toffset += min_p * PAGE_SIZE;\n\t\tfor (p = min_p; p <= max_p; p++) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t\tstruct page **pp = &_1ps->pages[c];\n\t\t\tbool uptodate;\n\n\t\t\tif (*pp) {\n\t\t\t\tif (ios->offset % PAGE_SIZE)\n\t\t\t\t\t/* Read the remainder of the page */\n\t\t\t\t\t_add_to_r4w_first_page(ios, *pp);\n\t\t\t\t/* to-be-written pages start here */\n\t\t\t\tgoto read_last_stripe;\n\t\t\t}\n\n\t\t\t*pp = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t &uptodate);\n\t\t\tif (unlikely(!*pp))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, *pp, PAGE_SIZE);\n\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\toffset += PAGE_SIZE;\n\t\t}\n\t\toffset += (sp2d->pages_in_unit - p) * PAGE_SIZE;\n\t}\n\nread_last_stripe:\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_add_to_r4w",
          "args": [
            "ios",
            "&read_si",
            "*pp",
            "PAGE_SIZE"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "337-385",
          "snippet": "static int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*pp"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ios->r4w->get_page",
          "args": [
            "ios->private",
            "offset",
            "&uptodate"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_add_to_r4w_first_page",
          "args": [
            "ios",
            "*pp"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w_first_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "388-402",
          "snippet": "static int _add_to_r4w_first_page(struct ore_io_state *ios, struct page *page)\n{\n\tstruct ore_striping_info si;\n\tunsigned pg_len;\n\n\tore_calc_stripe_info(ios->layout, ios->offset, 0, &si);\n\n\tpg_len = si.obj_offset % PAGE_SIZE;\n\tsi.obj_offset -= pg_len;\n\n\tORE_DBGMSG(\"offset=0x%llx len=0x%x index=0x%lx dev=%x\\n\",\n\t\t   _LLU(si.obj_offset), pg_len, page->index, si.dev);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w_first_page(struct ore_io_state *ios, struct page *page)\n{\n\tstruct ore_striping_info si;\n\tunsigned pg_len;\n\n\tore_calc_stripe_info(ios->layout, ios->offset, 0, &si);\n\n\tpg_len = si.obj_offset % PAGE_SIZE;\n\tsi.obj_offset -= pg_len;\n\n\tORE_DBGMSG(\"offset=0x%llx len=0x%x index=0x%lx dev=%x\\n\",\n\t\t   _LLU(si.obj_offset), pg_len, page->index, si.dev);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "ios->layout",
            "offset",
            "0",
            "&read_si"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\\n\"",
            "offset",
            "ios->offset",
            "min_p",
            "max_p"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sp2d_max_pg",
          "args": [
            "sp2d"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_max_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "204-216",
          "snippet": "static unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sp2d_min_pg",
          "args": [
            "sp2d"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "_sp2d_min_pg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "190-202",
          "snippet": "static unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _read_4_write_first_stripe(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info read_si;\n\tstruct __stripe_pages_2d *sp2d = ios->sp2d;\n\tu64 offset = ios->si.first_stripe_start;\n\tunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\n\n\tif (offset == ios->offset) /* Go to start collect $200 */\n\t\tgoto read_last_stripe;\n\n\tmin_p = _sp2d_min_pg(sp2d);\n\tmax_p = _sp2d_max_pg(sp2d);\n\n\tORE_DBGMSG(\"stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\\n\",\n\t\t   offset, ios->offset, min_p, max_p);\n\n\tfor (c = 0; ; c++) {\n\t\tore_calc_stripe_info(ios->layout, offset, 0, &read_si);\n\t\tread_si.obj_offset += min_p * PAGE_SIZE;\n\t\toffset += min_p * PAGE_SIZE;\n\t\tfor (p = min_p; p <= max_p; p++) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t\tstruct page **pp = &_1ps->pages[c];\n\t\t\tbool uptodate;\n\n\t\t\tif (*pp) {\n\t\t\t\tif (ios->offset % PAGE_SIZE)\n\t\t\t\t\t/* Read the remainder of the page */\n\t\t\t\t\t_add_to_r4w_first_page(ios, *pp);\n\t\t\t\t/* to-be-written pages start here */\n\t\t\t\tgoto read_last_stripe;\n\t\t\t}\n\n\t\t\t*pp = ios->r4w->get_page(ios->private, offset,\n\t\t\t\t\t\t &uptodate);\n\t\t\tif (unlikely(!*pp))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (!uptodate)\n\t\t\t\t_add_to_r4w(ios, &read_si, *pp, PAGE_SIZE);\n\n\t\t\t/* Mark read-pages to be cache_released */\n\t\t\t_1ps->page_is_read[c] = true;\n\t\t\tread_si.obj_offset += PAGE_SIZE;\n\t\t\toffset += PAGE_SIZE;\n\t\t}\n\t\toffset += (sp2d->pages_in_unit - p) * PAGE_SIZE;\n\t}\n\nread_last_stripe:\n\treturn 0;\n}"
  },
  {
    "function_name": "_mark_read4write_pages_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "428-448",
    "snippet": "static void _mark_read4write_pages_uptodate(struct ore_io_state *ios, int ret)\n{\n\tstruct bio_vec *bv;\n\tunsigned i, d;\n\n\t/* loop on all devices all pages */\n\tfor (d = 0; d < ios->numdevs; d++) {\n\t\tstruct bio *bio = ios->per_dev[d].bio;\n\n\t\tif (!bio)\n\t\t\tcontinue;\n\n\t\tbio_for_each_segment_all(bv, bio, i) {\n\t\t\tstruct page *page = bv->bv_page;\n\n\t\t\tSetPageUptodate(page);\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bv",
            "bio",
            "i"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _mark_read4write_pages_uptodate(struct ore_io_state *ios, int ret)\n{\n\tstruct bio_vec *bv;\n\tunsigned i, d;\n\n\t/* loop on all devices all pages */\n\tfor (d = 0; d < ios->numdevs; d++) {\n\t\tstruct bio *bio = ios->per_dev[d].bio;\n\n\t\tif (!bio)\n\t\t\tcontinue;\n\n\t\tbio_for_each_segment_all(bv, bio, i) {\n\t\t\tstruct page *page = bv->bv_page;\n\n\t\t\tSetPageUptodate(page);\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "_add_to_r4w_last_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "405-426",
    "snippet": "static int _add_to_r4w_last_page(struct ore_io_state *ios, u64 *offset)\n{\n\tstruct ore_striping_info si;\n\tstruct page *page;\n\tunsigned pg_len, p, c;\n\n\tore_calc_stripe_info(ios->layout, *offset, 0, &si);\n\n\tp = si.cur_pg;\n\tc = si.cur_comp;\n\tpage = ios->sp2d->_1p_stripes[p].pages[c];\n\n\tpg_len = PAGE_SIZE - (si.unit_off % PAGE_SIZE);\n\t*offset += pg_len;\n\n\tORE_DBGMSG(\"p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\\n\",\n\t\t   p, c, _LLU(*offset), pg_len, si.dev, si.par_dev);\n\n\tBUG_ON(!page);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_add_to_r4w",
          "args": [
            "ios",
            "&si",
            "page",
            "pg_len"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "337-385",
          "snippet": "static int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\\n\"",
            "p",
            "c",
            "_LLU(*offset)",
            "pg_len",
            "si.dev",
            "si.par_dev"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "*offset"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "ios->layout",
            "*offset",
            "0",
            "&si"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w_last_page(struct ore_io_state *ios, u64 *offset)\n{\n\tstruct ore_striping_info si;\n\tstruct page *page;\n\tunsigned pg_len, p, c;\n\n\tore_calc_stripe_info(ios->layout, *offset, 0, &si);\n\n\tp = si.cur_pg;\n\tc = si.cur_comp;\n\tpage = ios->sp2d->_1p_stripes[p].pages[c];\n\n\tpg_len = PAGE_SIZE - (si.unit_off % PAGE_SIZE);\n\t*offset += pg_len;\n\n\tORE_DBGMSG(\"p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\\n\",\n\t\t   p, c, _LLU(*offset), pg_len, si.dev, si.par_dev);\n\n\tBUG_ON(!page);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}"
  },
  {
    "function_name": "_add_to_r4w_first_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "388-402",
    "snippet": "static int _add_to_r4w_first_page(struct ore_io_state *ios, struct page *page)\n{\n\tstruct ore_striping_info si;\n\tunsigned pg_len;\n\n\tore_calc_stripe_info(ios->layout, ios->offset, 0, &si);\n\n\tpg_len = si.obj_offset % PAGE_SIZE;\n\tsi.obj_offset -= pg_len;\n\n\tORE_DBGMSG(\"offset=0x%llx len=0x%x index=0x%lx dev=%x\\n\",\n\t\t   _LLU(si.obj_offset), pg_len, page->index, si.dev);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_add_to_r4w",
          "args": [
            "ios",
            "&si",
            "page",
            "pg_len"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "_add_to_r4w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "337-385",
          "snippet": "static int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"offset=0x%llx len=0x%x index=0x%lx dev=%x\\n\"",
            "_LLU(si.obj_offset)",
            "pg_len",
            "page->index",
            "si.dev"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "si.obj_offset"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "ios->layout",
            "ios->offset",
            "0",
            "&si"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w_first_page(struct ore_io_state *ios, struct page *page)\n{\n\tstruct ore_striping_info si;\n\tunsigned pg_len;\n\n\tore_calc_stripe_info(ios->layout, ios->offset, 0, &si);\n\n\tpg_len = si.obj_offset % PAGE_SIZE;\n\tsi.obj_offset -= pg_len;\n\n\tORE_DBGMSG(\"offset=0x%llx len=0x%x index=0x%lx dev=%x\\n\",\n\t\t   _LLU(si.obj_offset), pg_len, page->index, si.dev);\n\n\treturn _add_to_r4w(ios, &si, page, pg_len);\n}"
  },
  {
    "function_name": "_add_to_r4w",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "337-385",
    "snippet": "static int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed to bio_add_pc_page bi_vcnt=%d\\n\"",
            "per_dev->bio->bi_vcnt"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "added_len != pg_len"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_pc_page",
          "args": [
            "q",
            "per_dev->bio",
            "page",
            "pg_len",
            "si->obj_offset % PAGE_SIZE"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_request_queue",
          "args": [
            "ore_comp_dev(read_ios->oc, per_dev->dev)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_comp_dev",
          "args": [
            "read_ios->oc",
            "per_dev->dev"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ore_add_sg_seg",
          "args": [
            "per_dev",
            "gap",
            "true"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_add_sg_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "270-317",
          "snippet": "void _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed to allocate BIO size=%u\\n\"",
            "ios->sp2d->pages_in_unit"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!per_dev->bio"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_kmalloc",
          "args": [
            "GFP_KERNEL",
            "ios->sp2d->pages_in_unit"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_alloc_read_4_write",
          "args": [
            "ios"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "_alloc_read_4_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "319-332",
          "snippet": "static int _alloc_read_4_write(struct ore_io_state *ios)\n{\n\tstruct ore_layout *layout = ios->layout;\n\tint ret;\n\t/* We want to only read those pages not in cache so worst case\n\t * is a stripe populated with every other page\n\t */\n\tunsigned sgs_per_dev = ios->sp2d->pages_in_unit + 2;\n\n\tret = _ore_get_io_state(layout, ios->oc,\n\t\t\t\tlayout->group_width * layout->mirrors_p1,\n\t\t\t\tsgs_per_dev, 0, &ios->ios_read_4_write);\n\treturn ret;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _alloc_read_4_write(struct ore_io_state *ios)\n{\n\tstruct ore_layout *layout = ios->layout;\n\tint ret;\n\t/* We want to only read those pages not in cache so worst case\n\t * is a stripe populated with every other page\n\t */\n\tunsigned sgs_per_dev = ios->sp2d->pages_in_unit + 2;\n\n\tret = _ore_get_io_state(layout, ios->oc,\n\t\t\t\tlayout->group_width * layout->mirrors_p1,\n\t\t\t\tsgs_per_dev, 0, &ios->ios_read_4_write);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\n\t\t       struct page *page, unsigned pg_len)\n{\n\tstruct request_queue *q;\n\tstruct ore_per_dev_state *per_dev;\n\tstruct ore_io_state *read_ios;\n\tunsigned first_dev = si->dev - (si->dev %\n\t\t\t  (ios->layout->group_width * ios->layout->mirrors_p1));\n\tunsigned comp = si->dev - first_dev;\n\tunsigned added_len;\n\n\tif (!ios->ios_read_4_write) {\n\t\tint ret = _alloc_read_4_write(ios);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tread_ios = ios->ios_read_4_write;\n\tread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\n\n\tper_dev = &read_ios->per_dev[comp];\n\tif (!per_dev->length) {\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL,\n\t\t\t\t\t   ios->sp2d->pages_in_unit);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     ios->sp2d->pages_in_unit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->offset = si->obj_offset;\n\t\tper_dev->dev = si->dev;\n\t} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\n\t\tu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\n\n\t\t_ore_add_sg_seg(per_dev, gap, true);\n\t}\n\tq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\n\tadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\n\t\t\t\t    si->obj_offset % PAGE_SIZE);\n\tif (unlikely(added_len != pg_len)) {\n\t\tORE_DBGMSG(\"Failed to bio_add_pc_page bi_vcnt=%d\\n\",\n\t\t\t      per_dev->bio->bi_vcnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tper_dev->length += pg_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "_alloc_read_4_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "319-332",
    "snippet": "static int _alloc_read_4_write(struct ore_io_state *ios)\n{\n\tstruct ore_layout *layout = ios->layout;\n\tint ret;\n\t/* We want to only read those pages not in cache so worst case\n\t * is a stripe populated with every other page\n\t */\n\tunsigned sgs_per_dev = ios->sp2d->pages_in_unit + 2;\n\n\tret = _ore_get_io_state(layout, ios->oc,\n\t\t\t\tlayout->group_width * layout->mirrors_p1,\n\t\t\t\tsgs_per_dev, 0, &ios->ios_read_4_write);\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ore_get_io_state",
          "args": [
            "layout",
            "ios->oc",
            "layout->group_width * layout->mirrors_p1",
            "sgs_per_dev",
            "0",
            "&ios->ios_read_4_write"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "143-224",
          "snippet": "int  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _alloc_read_4_write(struct ore_io_state *ios)\n{\n\tstruct ore_layout *layout = ios->layout;\n\tint ret;\n\t/* We want to only read those pages not in cache so worst case\n\t * is a stripe populated with every other page\n\t */\n\tunsigned sgs_per_dev = ios->sp2d->pages_in_unit + 2;\n\n\tret = _ore_get_io_state(layout, ios->oc,\n\t\t\t\tlayout->group_width * layout->mirrors_p1,\n\t\t\t\tsgs_per_dev, 0, &ios->ios_read_4_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "_ore_add_sg_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "270-317",
    "snippet": "void _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\"",
            "per_dev->dev",
            "cur_len",
            "not_last",
            "per_dev->cur_sg",
            "_LLU(per_dev->offset)",
            "per_dev->length",
            "per_dev->last_sgs_total"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "per_dev->offset"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\n\t\t     bool not_last)\n{\n\tstruct osd_sg_entry *sge;\n\n\tORE_DBGMSG(\"dev=%d cur_len=0x%x not_last=%d cur_sg=%d \"\n\t\t     \"offset=0x%llx length=0x%x last_sgs_total=0x%x\\n\",\n\t\t     per_dev->dev, cur_len, not_last, per_dev->cur_sg,\n\t\t     _LLU(per_dev->offset), per_dev->length,\n\t\t     per_dev->last_sgs_total);\n\n\tif (!per_dev->cur_sg) {\n\t\tsge = per_dev->sglist;\n\n\t\t/* First time we prepare two entries */\n\t\tif (per_dev->length) {\n\t\t\t++per_dev->cur_sg;\n\t\t\tsge->offset = per_dev->offset;\n\t\t\tsge->len = per_dev->length;\n\t\t} else {\n\t\t\t/* Here the parity is the first unit of this object.\n\t\t\t * This happens every time we reach a parity device on\n\t\t\t * the same stripe as the per_dev->offset. We need to\n\t\t\t * just skip this unit.\n\t\t\t */\n\t\t\tper_dev->offset += cur_len;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* finalize the last one */\n\t\tsge = &per_dev->sglist[per_dev->cur_sg - 1];\n\t\tsge->len = per_dev->length - per_dev->last_sgs_total;\n\t}\n\n\tif (not_last) {\n\t\t/* Partly prepare the next one */\n\t\tstruct osd_sg_entry *next_sge = sge + 1;\n\n\t\t++per_dev->cur_sg;\n\t\tnext_sge->offset = sge->offset + sge->len + cur_len;\n\t\t/* Save cur len so we know how mutch was added next time */\n\t\tper_dev->last_sgs_total = per_dev->length;\n\t\tnext_sge->len = 0;\n\t} else if (!sge->len) {\n\t\t/* Optimize for when the last unit is a parity */\n\t\t--per_dev->cur_sg;\n\t}\n}"
  },
  {
    "function_name": "_ore_add_stripe_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "255-268",
    "snippet": "void _ore_add_stripe_page(struct __stripe_pages_2d *sp2d,\n\t\t       struct ore_striping_info *si, struct page *page)\n{\n\tstruct __1_page_stripe *_1ps;\n\n\tsp2d->needed = true;\n\n\t_1ps = &sp2d->_1p_stripes[si->cur_pg];\n\t_1ps->pages[si->cur_comp] = page;\n\t++_1ps->write_count;\n\n\tsi->cur_pg = (si->cur_pg + 1) % sp2d->pages_in_unit;\n\t/* si->cur_comp is advanced outside at main loop */\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_add_stripe_page(struct __stripe_pages_2d *sp2d,\n\t\t       struct ore_striping_info *si, struct page *page)\n{\n\tstruct __1_page_stripe *_1ps;\n\n\tsp2d->needed = true;\n\n\t_1ps = &sp2d->_1p_stripes[si->cur_pg];\n\t_1ps->pages[si->cur_comp] = page;\n\t++_1ps->write_count;\n\n\tsi->cur_pg = (si->cur_pg + 1) % sp2d->pages_in_unit;\n\t/* si->cur_comp is advanced outside at main loop */\n}"
  },
  {
    "function_name": "_gen_xor_unit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "218-253",
    "snippet": "static void _gen_xor_unit(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\tunsigned tx_flags = ASYNC_TX_ACK;\n\n\tif (sp2d->parity == 1)\n\t\ttx_flags |= ASYNC_TX_XOR_ZERO_DST;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (!_1ps->write_count)\n\t\t\tcontinue;\n\n\t\tinit_async_submit(&_1ps->submit, tx_flags,\n\t\t\tNULL, NULL, NULL, (addr_conv_t *)_1ps->scribble);\n\n\t\tif (sp2d->parity == 1)\n\t\t\t_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs],\n\t\t\t\t\t\t_1ps->pages, 0, sp2d->data_devs,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t\telse /* parity == 2 */\n\t\t\t_1ps->tx = async_gen_syndrome(_1ps->pages, 0,\n\t\t\t\t\t\tsp2d->data_devs + sp2d->parity,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t/* NOTE: We wait for HW synchronously (I don't have such HW\n\t\t * to test with.) Is parallelism needed with today's multi\n\t\t * cores?\n\t\t */\n\t\tasync_tx_issue_pending(_1ps->tx);\n\t}\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_tx_issue_pending",
          "args": [
            "_1ps->tx"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "async_gen_syndrome",
          "args": [
            "_1ps->pages",
            "0",
            "sp2d->data_devs + sp2d->parity",
            "PAGE_SIZE",
            "&_1ps->submit"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "async_xor",
          "args": [
            "_1ps->pages[sp2d->data_devs]",
            "_1ps->pages",
            "0",
            "sp2d->data_devs",
            "PAGE_SIZE",
            "&_1ps->submit"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_async_submit",
          "args": [
            "&_1ps->submit",
            "tx_flags",
            "NULL",
            "NULL",
            "NULL",
            "(addr_conv_t *)_1ps->scribble"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _gen_xor_unit(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\tunsigned tx_flags = ASYNC_TX_ACK;\n\n\tif (sp2d->parity == 1)\n\t\ttx_flags |= ASYNC_TX_XOR_ZERO_DST;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (!_1ps->write_count)\n\t\t\tcontinue;\n\n\t\tinit_async_submit(&_1ps->submit, tx_flags,\n\t\t\tNULL, NULL, NULL, (addr_conv_t *)_1ps->scribble);\n\n\t\tif (sp2d->parity == 1)\n\t\t\t_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs],\n\t\t\t\t\t\t_1ps->pages, 0, sp2d->data_devs,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t\telse /* parity == 2 */\n\t\t\t_1ps->tx = async_gen_syndrome(_1ps->pages, 0,\n\t\t\t\t\t\tsp2d->data_devs + sp2d->parity,\n\t\t\t\t\t\tPAGE_SIZE, &_1ps->submit);\n\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\t\t/* NOTE: We wait for HW synchronously (I don't have such HW\n\t\t * to test with.) Is parallelism needed with today's multi\n\t\t * cores?\n\t\t */\n\t\tasync_tx_issue_pending(_1ps->tx);\n\t}\n}"
  },
  {
    "function_name": "_sp2d_max_pg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "204-216",
    "snippet": "static unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\n{\n\tint p;\n\n\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
  },
  {
    "function_name": "_sp2d_min_pg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "190-202",
    "snippet": "static unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned p;\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tif (_1ps->write_count)\n\t\t\treturn p;\n\t}\n\n\treturn ~0;\n}"
  },
  {
    "function_name": "_sp2d_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "175-188",
    "snippet": "static void _sp2d_free(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned i;\n\n\tif (!sp2d)\n\t\treturn;\n\n\tfor (i = 0; i < sp2d->pages_in_unit; ++i) {\n\t\tif (sp2d->_1p_stripes[i].alloc)\n\t\t\tkfree(sp2d->_1p_stripes[i].pages);\n\t}\n\n\tkfree(sp2d);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sp2d"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sp2d->_1p_stripes[i].pages"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _sp2d_free(struct __stripe_pages_2d *sp2d)\n{\n\tunsigned i;\n\n\tif (!sp2d)\n\t\treturn;\n\n\tfor (i = 0; i < sp2d->pages_in_unit; ++i) {\n\t\tif (sp2d->_1p_stripes[i].alloc)\n\t\t\tkfree(sp2d->_1p_stripes[i].pages);\n\t}\n\n\tkfree(sp2d);\n}"
  },
  {
    "function_name": "_sp2d_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "142-173",
    "snippet": "static void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "_1ps->pages",
            "0",
            "group_width * sizeof(*_1ps->pages)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r4w->put_page",
          "args": [
            "priv",
            "page"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _sp2d_reset(struct __stripe_pages_2d *sp2d,\n\t\t\tconst struct _ore_r4w_op *r4w, void *priv)\n{\n\tunsigned data_devs = sp2d->data_devs;\n\tunsigned group_width = data_devs + sp2d->parity;\n\tint p, c;\n\n\tif (!sp2d->needed)\n\t\treturn;\n\n\tfor (c = data_devs - 1; c >= 0; --c)\n\t\tfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\n\t\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\t\tif (_1ps->page_is_read[c]) {\n\t\t\t\tstruct page *page = _1ps->pages[c];\n\n\t\t\t\tr4w->put_page(priv, page);\n\t\t\t\t_1ps->page_is_read[c] = false;\n\t\t\t}\n\t\t}\n\n\tfor (p = 0; p < sp2d->pages_in_unit; p++) {\n\t\tstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\n\n\t\tmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\n\t\t_1ps->write_count = 0;\n\t\t_1ps->tx = NULL;\n\t}\n\n\tsp2d->needed = false;\n}"
  },
  {
    "function_name": "_sp2d_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "69-140",
    "snippet": "static int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width,\n\t\t       unsigned parity, struct __stripe_pages_2d **psp2d)\n{\n\tstruct __stripe_pages_2d *sp2d;\n\tunsigned data_devs = group_width - parity;\n\tstruct _alloc_all_bytes {\n\t\tstruct __alloc_stripe_pages_2d {\n\t\t\tstruct __stripe_pages_2d sp2d;\n\t\t\tstruct __1_page_stripe _1p_stripes[pages_in_unit];\n\t\t} __asp2d;\n\t\tstruct __alloc_1p_arrays {\n\t\t\tstruct page *pages[group_width];\n\t\t\tstruct page *scribble[group_width];\n\t\t\tchar page_is_read[data_devs];\n\t\t} __a1pa[pages_in_unit];\n\t} *_aab;\n\tstruct __alloc_1p_arrays *__a1pa;\n\tstruct __alloc_1p_arrays *__a1pa_end;\n\tconst unsigned sizeof__a1pa = sizeof(_aab->__a1pa[0]);\n\tunsigned num_a1pa, alloc_size, i;\n\n\t/* FIXME: check these numbers in ore_verify_layout */\n\tBUG_ON(sizeof(_aab->__asp2d) > PAGE_SIZE);\n\tBUG_ON(sizeof__a1pa > PAGE_SIZE);\n\n\tif (sizeof(*_aab) > PAGE_SIZE) {\n\t\tnum_a1pa = (PAGE_SIZE - sizeof(_aab->__asp2d)) / sizeof__a1pa;\n\t\talloc_size = sizeof(_aab->__asp2d) + sizeof__a1pa * num_a1pa;\n\t} else {\n\t\tnum_a1pa = pages_in_unit;\n\t\talloc_size = sizeof(*_aab);\n\t}\n\n\t_aab = kzalloc(alloc_size, GFP_KERNEL);\n\tif (unlikely(!_aab)) {\n\t\tORE_DBGMSG(\"!! Failed to alloc sp2d size=%d\\n\", alloc_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tsp2d = &_aab->__asp2d.sp2d;\n\t*psp2d = sp2d; /* From here Just call _sp2d_free */\n\n\t__a1pa = _aab->__a1pa;\n\t__a1pa_end = __a1pa + num_a1pa;\n\n\tfor (i = 0; i < pages_in_unit; ++i) {\n\t\tif (unlikely(__a1pa >= __a1pa_end)) {\n\t\t\tnum_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa,\n\t\t\t\t\t\t\tpages_in_unit - i);\n\n\t\t\t__a1pa = kcalloc(num_a1pa, sizeof__a1pa, GFP_KERNEL);\n\t\t\tif (unlikely(!__a1pa)) {\n\t\t\t\tORE_DBGMSG(\"!! Failed to _alloc_1p_arrays=%d\\n\",\n\t\t\t\t\t   num_a1pa);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t__a1pa_end = __a1pa + num_a1pa;\n\t\t\t/* First *pages is marked for kfree of the buffer */\n\t\t\tsp2d->_1p_stripes[i].alloc = true;\n\t\t}\n\n\t\tsp2d->_1p_stripes[i].pages = __a1pa->pages;\n\t\tsp2d->_1p_stripes[i].scribble = __a1pa->scribble ;\n\t\tsp2d->_1p_stripes[i].page_is_read = __a1pa->page_is_read;\n\t\t++__a1pa;\n\t}\n\n\tsp2d->parity = parity;\n\tsp2d->data_devs = data_devs;\n\tsp2d->pages_in_unit = pages_in_unit;\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"!! Failed to _alloc_1p_arrays=%d\\n\"",
            "num_a1pa"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!__a1pa"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num_a1pa",
            "sizeof__a1pa",
            "GFP_KERNEL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "PAGE_SIZE / sizeof__a1pa",
            "pages_in_unit - i"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__a1pa >= __a1pa_end"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"!! Failed to alloc sp2d size=%d\\n\"",
            "alloc_size"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!_aab"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc_size",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sizeof__a1pa > PAGE_SIZE"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sizeof(_aab->__asp2d) > PAGE_SIZE"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width,\n\t\t       unsigned parity, struct __stripe_pages_2d **psp2d)\n{\n\tstruct __stripe_pages_2d *sp2d;\n\tunsigned data_devs = group_width - parity;\n\tstruct _alloc_all_bytes {\n\t\tstruct __alloc_stripe_pages_2d {\n\t\t\tstruct __stripe_pages_2d sp2d;\n\t\t\tstruct __1_page_stripe _1p_stripes[pages_in_unit];\n\t\t} __asp2d;\n\t\tstruct __alloc_1p_arrays {\n\t\t\tstruct page *pages[group_width];\n\t\t\tstruct page *scribble[group_width];\n\t\t\tchar page_is_read[data_devs];\n\t\t} __a1pa[pages_in_unit];\n\t} *_aab;\n\tstruct __alloc_1p_arrays *__a1pa;\n\tstruct __alloc_1p_arrays *__a1pa_end;\n\tconst unsigned sizeof__a1pa = sizeof(_aab->__a1pa[0]);\n\tunsigned num_a1pa, alloc_size, i;\n\n\t/* FIXME: check these numbers in ore_verify_layout */\n\tBUG_ON(sizeof(_aab->__asp2d) > PAGE_SIZE);\n\tBUG_ON(sizeof__a1pa > PAGE_SIZE);\n\n\tif (sizeof(*_aab) > PAGE_SIZE) {\n\t\tnum_a1pa = (PAGE_SIZE - sizeof(_aab->__asp2d)) / sizeof__a1pa;\n\t\talloc_size = sizeof(_aab->__asp2d) + sizeof__a1pa * num_a1pa;\n\t} else {\n\t\tnum_a1pa = pages_in_unit;\n\t\talloc_size = sizeof(*_aab);\n\t}\n\n\t_aab = kzalloc(alloc_size, GFP_KERNEL);\n\tif (unlikely(!_aab)) {\n\t\tORE_DBGMSG(\"!! Failed to alloc sp2d size=%d\\n\", alloc_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tsp2d = &_aab->__asp2d.sp2d;\n\t*psp2d = sp2d; /* From here Just call _sp2d_free */\n\n\t__a1pa = _aab->__a1pa;\n\t__a1pa_end = __a1pa + num_a1pa;\n\n\tfor (i = 0; i < pages_in_unit; ++i) {\n\t\tif (unlikely(__a1pa >= __a1pa_end)) {\n\t\t\tnum_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa,\n\t\t\t\t\t\t\tpages_in_unit - i);\n\n\t\t\t__a1pa = kcalloc(num_a1pa, sizeof__a1pa, GFP_KERNEL);\n\t\t\tif (unlikely(!__a1pa)) {\n\t\t\t\tORE_DBGMSG(\"!! Failed to _alloc_1p_arrays=%d\\n\",\n\t\t\t\t\t   num_a1pa);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t__a1pa_end = __a1pa + num_a1pa;\n\t\t\t/* First *pages is marked for kfree of the buffer */\n\t\t\tsp2d->_1p_stripes[i].alloc = true;\n\t\t}\n\n\t\tsp2d->_1p_stripes[i].pages = __a1pa->pages;\n\t\tsp2d->_1p_stripes[i].scribble = __a1pa->scribble ;\n\t\tsp2d->_1p_stripes[i].page_is_read = __a1pa->page_is_read;\n\t\t++__a1pa;\n\t}\n\n\tsp2d->parity = parity;\n\tsp2d->data_devs = data_devs;\n\tsp2d->pages_in_unit = pages_in_unit;\n\treturn 0;\n}"
  },
  {
    "function_name": "_raid_page_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "29-32",
    "snippet": "static void _raid_page_free(struct page *p)\n{\n\t__free_page(p);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "p"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic void _raid_page_free(struct page *p)\n{\n\t__free_page(p);\n}"
  },
  {
    "function_name": "_raid_page_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
    "lines": "24-27",
    "snippet": "static struct page *_raid_page_alloc(void)\n{\n\treturn alloc_page(GFP_KERNEL);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/async_tx.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nstatic struct page *_raid_page_alloc(void)\n{\n\treturn alloc_page(GFP_KERNEL);\n}"
  }
]