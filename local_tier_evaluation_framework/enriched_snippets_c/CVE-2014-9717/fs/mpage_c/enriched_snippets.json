[
  {
    "function_name": "mpage_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "703-716",
    "snippet": "int mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio)\n\t\tmpage_bio_submit(WRITE, mpd.bio);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "WRITE",
            "mpd.bio"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mpage_writepage",
          "args": [
            "page",
            "wbc",
            "&mpd"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__mpage_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "462-654",
          "snippet": "static int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tunmap_underlying_metadata(map_bh.b_bdev,\n\t\t\t\t\t\tmap_bh.b_blocknr);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc)) {\n\t\t\t\tclean_buffers(page, first_unmapped);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tbio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tunmap_underlying_metadata(map_bh.b_bdev,\n\t\t\t\t\t\tmap_bh.b_blocknr);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc)) {\n\t\t\t\tclean_buffers(page, first_unmapped);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tbio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio)\n\t\tmpage_bio_submit(WRITE, mpd.bio);\n\treturn ret;\n}"
  },
  {
    "function_name": "mpage_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "675-700",
    "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "WRITE",
            "mpd.bio"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "__mpage_writepage",
            "&mpd"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
  },
  {
    "function_name": "__mpage_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "462-654",
    "snippet": "static int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tunmap_underlying_metadata(map_bh.b_bdev,\n\t\t\t\t\t\tmap_bh.b_blocknr);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc)) {\n\t\t\t\tclean_buffers(page, first_unmapped);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tbio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_boundary_block",
          "args": [
            "boundary_bdev",
            "boundary_block",
            "1 << blkbits"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "write_boundary_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "588-597",
          "snippet": "void write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_buffers",
          "args": [
            "page",
            "first_unmapped"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "clean_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "437-460",
          "snippet": "static void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "length",
            "0"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_alloc",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "bio_get_nr_vecs(bdev)",
            "GFP_NOFS|__GFP_HIGH"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "66-85",
          "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "bdev"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_write_page",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "page",
            "wbc"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "406-421",
          "snippet": "int bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tint rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);\n\tif (result)\n\t\tend_page_writeback(page);\n\telse\n\t\tunlock_page(page);\n\treturn result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tint rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);\n\tif (result)\n\t\tend_page_writeback(page);\n\telse\n\t\tunlock_page(page);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_block == 0"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "&map_bh"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "&map_bh"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "map_bh.b_bdev",
            "map_bh.b_blocknr"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&map_bh"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpd->get_block",
          "args": [
            "inode",
            "block_in_file",
            "&map_bh",
            "1"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_common.c",
          "lines": "145-206",
          "snippet": "static inline int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "bh"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_locked(bh)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tunmap_underlying_metadata(map_bh.b_bdev,\n\t\t\t\t\t\tmap_bh.b_blocknr);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_CACHE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc)) {\n\t\t\t\tclean_buffers(page, first_unmapped);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tbio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(WRITE, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}"
  },
  {
    "function_name": "clean_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "437-460",
    "snippet": "static void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}"
  },
  {
    "function_name": "mpage_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "392-406",
    "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "READ",
            "bio"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mpage_readpage",
          "args": [
            "bio",
            "page",
            "1",
            "&last_block_in_bio",
            "&map_bh",
            "&first_logical_block",
            "get_block"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "do_mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "139-310",
          "snippet": "static struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "mpage_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "355-386",
    "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "READ",
            "bio"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mpage_readpage",
          "args": [
            "bio",
            "page",
            "nr_pages - page_idx",
            "&last_block_in_bio",
            "&map_bh",
            "&first_logical_block",
            "get_block"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "do_mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "139-310",
          "snippet": "static struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "page->index",
            "GFP_KERNEL"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "&page->flags"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pages->prev",
            "structpage",
            "lru"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_mpage_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "139-310",
    "snippet": "static struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "get_block"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "READ",
            "bio"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "58-64",
          "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "map_bh"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "length",
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_alloc",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "min_t(int, nr_pages, bio_get_nr_vecs(bdev))",
            "GFP_KERNEL"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "66-85",
          "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "nr_pages",
            "bio_get_nr_vecs(bdev)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "bdev"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_page",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "page"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "377-384",
          "snippet": "int bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_page",
          "args": [
            "page"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "first_hole << blkbits",
            "PAGE_CACHE_SIZE"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_buffer_to_page",
          "args": [
            "page",
            "map_bh",
            "page_block"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "map_buffer_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "97-128",
          "snippet": "static void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_CACHE_SHIFT && \n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_CACHE_SHIFT && \n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "map_bh"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block_in_file",
            "map_bh",
            "0"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\n\t\tsector_t *last_block_in_bio, struct buffer_head *map_bh,\n\t\tunsigned long *first_logical_block, get_block_t get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\tlast_block = block_in_file + nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\n\t\t\tblock_in_file < (*first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - *first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\t*first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != blocks[0] - 1))\n\t\tbio = mpage_bio_submit(READ, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t  \tmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\n\t\t\t\tGFP_KERNEL);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(READ, bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - *first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\tbio = mpage_bio_submit(READ, bio);\n\telse\n\t\t*last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn bio;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(READ, bio);\n\tif (!PageUptodate(page))\n\t        block_read_full_page(page, get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
  },
  {
    "function_name": "map_buffer_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "97-128",
    "snippet": "static void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_CACHE_SHIFT && \n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << inode->i_blkbits",
            "0"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_CACHE_SHIFT && \n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}"
  },
  {
    "function_name": "mpage_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "66-85",
    "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "gfp_flags",
            "nr_vecs"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "mpage_bio_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "58-64",
    "snippet": "static struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guard_bio_eod",
          "args": [
            "rw",
            "bio"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "guard_bio_eod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2964-2998",
          "snippet": "void guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tguard_bio_eod(rw, bio);\n\tsubmit_bio(rw, bio);\n\treturn NULL;\n}"
  },
  {
    "function_name": "mpage_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
    "lines": "45-56",
    "snippet": "static void mpage_end_io(struct bio *bio, int err)\n{\n\tstruct bio_vec *bv;\n\tint i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tstruct page *page = bv->bv_page;\n\t\tpage_endio(page, bio_data_dir(bio), err);\n\t}\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_endio",
          "args": [
            "page",
            "bio_data_dir(bio)",
            "err"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_data_dir",
          "args": [
            "bio"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bv",
            "bio",
            "i"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void mpage_end_io(struct bio *bio, int err)\n{\n\tstruct bio_vec *bv;\n\tint i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tstruct page *page = bv->bv_page;\n\t\tpage_endio(page, bio_data_dir(bio), err);\n\t}\n\n\tbio_put(bio);\n}"
  }
]