[
  {
    "function_name": "xlog_iclogs_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3990-4006",
    "snippet": "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\t/* endianness does not matter here, zero is zero in\n\t\t * any language.\n\t\t */\n\t\tif (iclog->ic_header.h_num_logops)\n\t\t\treturn 0;\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\t/* endianness does not matter here, zero is zero in\n\t\t * any language.\n\t\t */\n\t\tif (iclog->ic_header.h_num_logops)\n\t\t\treturn 0;\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_log_force_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3896-3988",
    "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_callback == 0"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_do_callback",
          "args": [
            "log",
            "XFS_LI_ABORTED",
            "NULL"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_do_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2583-2799",
          "snippet": "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&log->l_cilp->xc_commit_wait"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_wake_all",
          "args": [
            "&log->l_write_head"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_wake_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "202-212",
          "snippet": "STATIC void\nxlog_grant_head_wake_all(\n\tstruct xlog_grant_head\t*head)\n{\n\tstruct xlog_ticket\t*tic;\n\n\tspin_lock(&head->lock);\n\tlist_for_each_entry(tic, &head->waiters, t_queue)\n\t\twake_up_process(tic->t_task);\n\tspin_unlock(&head->lock);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_head_wake_all(\n\tstruct xlog_grant_head\t*head)\n{\n\tstruct xlog_ticket\t*tic;\n\n\tspin_lock(&head->lock);\n\tlist_for_each_entry(tic, &head->waiters, t_queue)\n\t\twake_up_process(tic->t_task);\n\tspin_unlock(&head->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_ioerror",
          "args": [
            "log"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_ioerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3855-3878",
          "snippet": "STATIC int\nxlog_state_ioerror(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *ic;\n\n\ticlog = log->l_iclog;\n\tif (! (iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t/*\n\t\t * Mark all the incore logs IOERROR.\n\t\t * From now on, no log flushes will result.\n\t\t */\n\t\tic = iclog;\n\t\tdo {\n\t\t\tic->ic_state = XLOG_STATE_IOERROR;\n\t\t\tic = ic->ic_next;\n\t\t} while (ic != iclog);\n\t\treturn 0;\n\t}\n\t/*\n\t * Return non-zero, if state transition has already happened.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_ioerror(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *ic;\n\n\ticlog = log->l_iclog;\n\tif (! (iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t/*\n\t\t * Mark all the incore logs IOERROR.\n\t\t * From now on, no log flushes will result.\n\t\t */\n\t\tic = iclog;\n\t\tdo {\n\t\t\tic->ic_state = XLOG_STATE_IOERROR;\n\t\t\tic = ic->ic_next;\n\t\t} while (ic != iclog);\n\t\treturn 0;\n\t}\n\t/*\n\t * Return non-zero, if state transition has already happened.\n\t */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "mp->m_sb_bp"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC",
            "NULL"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3185-3297",
          "snippet": "int\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XLOG_FORCED_SHUTDOWN(log)"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "mp->m_sb_bp"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
  },
  {
    "function_name": "xlog_state_ioerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3855-3878",
    "snippet": "STATIC int\nxlog_state_ioerror(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *ic;\n\n\ticlog = log->l_iclog;\n\tif (! (iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t/*\n\t\t * Mark all the incore logs IOERROR.\n\t\t * From now on, no log flushes will result.\n\t\t */\n\t\tic = iclog;\n\t\tdo {\n\t\t\tic->ic_state = XLOG_STATE_IOERROR;\n\t\t\tic = ic->ic_next;\n\t\t} while (ic != iclog);\n\t\treturn 0;\n\t}\n\t/*\n\t * Return non-zero, if state transition has already happened.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_ioerror(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *ic;\n\n\ticlog = log->l_iclog;\n\tif (! (iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t/*\n\t\t * Mark all the incore logs IOERROR.\n\t\t * From now on, no log flushes will result.\n\t\t */\n\t\tic = iclog;\n\t\tdo {\n\t\t\tic->ic_state = XLOG_STATE_IOERROR;\n\t\t\tic = ic->ic_next;\n\t\t} while (ic != iclog);\n\t\treturn 0;\n\t}\n\t/*\n\t * Return non-zero, if state transition has already happened.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "xlog_verify_iclog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3760-3849",
    "snippet": "STATIC void\nxlog_verify_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\tcount,\n\tbool                    syncing)\n{\n\txlog_op_header_t\t*ophead;\n\txlog_in_core_t\t\t*icptr;\n\txlog_in_core_2_t\t*xhdr;\n\txfs_caddr_t\t\tptr;\n\txfs_caddr_t\t\tbase_ptr;\n\t__psint_t\t\tfield_offset;\n\t__uint8_t\t\tclientid;\n\tint\t\t\tlen, i, j, k, op_len;\n\tint\t\t\tidx;\n\n\t/* check validity of iclog pointers */\n\tspin_lock(&log->l_icloglock);\n\ticptr = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++, icptr = icptr->ic_next)\n\t\tASSERT(icptr);\n\n\tif (icptr != log->l_iclog)\n\t\txfs_emerg(log->l_mp, \"%s: corrupt iclog ring\", __func__);\n\tspin_unlock(&log->l_icloglock);\n\n\t/* check log magic numbers */\n\tif (iclog->ic_header.h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\txfs_emerg(log->l_mp, \"%s: invalid magic num\", __func__);\n\n\tptr = (xfs_caddr_t) &iclog->ic_header;\n\tfor (ptr += BBSIZE; ptr < ((xfs_caddr_t)&iclog->ic_header) + count;\n\t     ptr += BBSIZE) {\n\t\tif (*(__be32 *)ptr == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\txfs_emerg(log->l_mp, \"%s: unexpected magic num\",\n\t\t\t\t__func__);\n\t}\n\n\t/* check fields */\n\tlen = be32_to_cpu(iclog->ic_header.h_num_logops);\n\tptr = iclog->ic_datap;\n\tbase_ptr = ptr;\n\tophead = (xlog_op_header_t *)ptr;\n\txhdr = iclog->ic_data;\n\tfor (i = 0; i < len; i++) {\n\t\tophead = (xlog_op_header_t *)ptr;\n\n\t\t/* clientid is only 1 byte */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_clientid) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\tclientid = ophead->oh_clientid;\n\t\t} else {\n\t\t\tidx = BTOBBT((xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\txhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\ticlog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tif (clientid != XFS_TRANSACTION && clientid != XFS_LOG)\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: invalid clientid %d op 0x%p offset 0x%lx\",\n\t\t\t\t__func__, clientid, ophead,\n\t\t\t\t(unsigned long)field_offset);\n\n\t\t/* check length */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_len) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\top_len = be32_to_cpu(ophead->oh_len);\n\t\t} else {\n\t\t\tidx = BTOBBT((__psint_t)&ophead->oh_len -\n\t\t\t\t    (__psint_t)iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\top_len = be32_to_cpu(xhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\top_len = be32_to_cpu(iclog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tptr += sizeof(xlog_op_header_t) + op_len;\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "iclog->ic_header.h_cycle_data[idx]"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "xhdr[j].hic_xheader.xh_cycle_data[k]"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBBT",
          "args": [
            "(__psint_t)&ophead->oh_len -\n\t\t\t\t    (__psint_t)iclog->ic_datap"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ophead->oh_len"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(xfs_caddr_t)&(ophead->oh_len) - base_ptr"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: invalid clientid %d op 0x%p offset 0x%lx\"",
            "__func__",
            "clientid",
            "ophead",
            "(unsigned long)field_offset"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_client_id",
          "args": [
            "iclog->ic_header.h_cycle_data[idx]"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_client_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "48-51",
          "snippet": "static inline uint xlog_get_client_id(__be32 i)\n{\n\treturn be32_to_cpu(i) >> 24;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline uint xlog_get_client_id(__be32 i)\n{\n\treturn be32_to_cpu(i) >> 24;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBBT",
          "args": [
            "(xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(xfs_caddr_t)&(ophead->oh_clientid) - base_ptr"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "iclog->ic_header.h_num_logops"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: unexpected magic num\"",
            "__func__"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: invalid magic num\"",
            "__func__"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: corrupt iclog ring\"",
            "__func__"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "icptr"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\tcount,\n\tbool                    syncing)\n{\n\txlog_op_header_t\t*ophead;\n\txlog_in_core_t\t\t*icptr;\n\txlog_in_core_2_t\t*xhdr;\n\txfs_caddr_t\t\tptr;\n\txfs_caddr_t\t\tbase_ptr;\n\t__psint_t\t\tfield_offset;\n\t__uint8_t\t\tclientid;\n\tint\t\t\tlen, i, j, k, op_len;\n\tint\t\t\tidx;\n\n\t/* check validity of iclog pointers */\n\tspin_lock(&log->l_icloglock);\n\ticptr = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++, icptr = icptr->ic_next)\n\t\tASSERT(icptr);\n\n\tif (icptr != log->l_iclog)\n\t\txfs_emerg(log->l_mp, \"%s: corrupt iclog ring\", __func__);\n\tspin_unlock(&log->l_icloglock);\n\n\t/* check log magic numbers */\n\tif (iclog->ic_header.h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\txfs_emerg(log->l_mp, \"%s: invalid magic num\", __func__);\n\n\tptr = (xfs_caddr_t) &iclog->ic_header;\n\tfor (ptr += BBSIZE; ptr < ((xfs_caddr_t)&iclog->ic_header) + count;\n\t     ptr += BBSIZE) {\n\t\tif (*(__be32 *)ptr == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\txfs_emerg(log->l_mp, \"%s: unexpected magic num\",\n\t\t\t\t__func__);\n\t}\n\n\t/* check fields */\n\tlen = be32_to_cpu(iclog->ic_header.h_num_logops);\n\tptr = iclog->ic_datap;\n\tbase_ptr = ptr;\n\tophead = (xlog_op_header_t *)ptr;\n\txhdr = iclog->ic_data;\n\tfor (i = 0; i < len; i++) {\n\t\tophead = (xlog_op_header_t *)ptr;\n\n\t\t/* clientid is only 1 byte */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_clientid) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\tclientid = ophead->oh_clientid;\n\t\t} else {\n\t\t\tidx = BTOBBT((xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\txhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\ticlog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tif (clientid != XFS_TRANSACTION && clientid != XFS_LOG)\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: invalid clientid %d op 0x%p offset 0x%lx\",\n\t\t\t\t__func__, clientid, ophead,\n\t\t\t\t(unsigned long)field_offset);\n\n\t\t/* check length */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_len) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\top_len = be32_to_cpu(ophead->oh_len);\n\t\t} else {\n\t\t\tidx = BTOBBT((__psint_t)&ophead->oh_len -\n\t\t\t\t    (__psint_t)iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\top_len = be32_to_cpu(xhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\top_len = be32_to_cpu(iclog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tptr += sizeof(xlog_op_header_t) + op_len;\n\t}\n}"
  },
  {
    "function_name": "xlog_verify_tail_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3720-3743",
    "snippet": "STATIC void\nxlog_verify_tail_lsn(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\txfs_lsn_t\t\ttail_lsn)\n{\n    int blocks;\n\n    if (CYCLE_LSN(tail_lsn) == log->l_prev_cycle) {\n\tblocks =\n\t    log->l_logBBsize - (log->l_prev_block - BLOCK_LSN(tail_lsn));\n\tif (blocks < BTOBB(iclog->ic_offset)+BTOBB(log->l_iclog_hsize))\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    } else {\n\tASSERT(CYCLE_LSN(tail_lsn)+1 == log->l_prev_cycle);\n\n\tif (BLOCK_LSN(tail_lsn) == log->l_prev_block)\n\t\txfs_emerg(log->l_mp, \"%s: tail wrapped\", __func__);\n\n\tblocks = BLOCK_LSN(tail_lsn) - log->l_prev_block;\n\tif (blocks < BTOBB(iclog->ic_offset) + 1)\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    }\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: ran out of log space\"",
            "__func__"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "iclog->ic_offset"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: tail wrapped\"",
            "__func__"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "CYCLE_LSN(tail_lsn)+1 == log->l_prev_cycle"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: ran out of log space\"",
            "__func__"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_iclog_hsize"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "iclog->ic_offset"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "tail_lsn"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_tail_lsn(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\txfs_lsn_t\t\ttail_lsn)\n{\n    int blocks;\n\n    if (CYCLE_LSN(tail_lsn) == log->l_prev_cycle) {\n\tblocks =\n\t    log->l_logBBsize - (log->l_prev_block - BLOCK_LSN(tail_lsn));\n\tif (blocks < BTOBB(iclog->ic_offset)+BTOBB(log->l_iclog_hsize))\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    } else {\n\tASSERT(CYCLE_LSN(tail_lsn)+1 == log->l_prev_cycle);\n\n\tif (BLOCK_LSN(tail_lsn) == log->l_prev_block)\n\t\txfs_emerg(log->l_mp, \"%s: tail wrapped\", __func__);\n\n\tblocks = BLOCK_LSN(tail_lsn) - log->l_prev_block;\n\tif (blocks < BTOBB(iclog->ic_offset) + 1)\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    }\n}"
  },
  {
    "function_name": "xlog_verify_grant_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3693-3717",
    "snippet": "STATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "log->l_mp",
            "XFS_PTAG_LOGRES",
            "\"%s: space > BBTOB(tail_blocks)\"",
            "__func__"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "tail_blocks"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_crack_atomic_lsn",
          "args": [
            "&log->l_tail_lsn",
            "&tail_cycle",
            "&tail_blocks"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_atomic_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "469-476",
          "snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_crack_grant_head",
          "args": [
            "&log->l_write_head.grant",
            "&cycle",
            "&space"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_grant_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "499-503",
          "snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xlog_verify_dest_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3664-3680",
    "snippet": "void\nxlog_verify_dest_ptr(\n\tstruct xlog\t*log,\n\tchar\t\t*ptr)\n{\n\tint i;\n\tint good_ptr = 0;\n\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\tif (ptr >= log->l_iclog_bak[i] &&\n\t\t    ptr <= log->l_iclog_bak[i] + log->l_iclog_size)\n\t\t\tgood_ptr++;\n\t}\n\n\tif (!good_ptr)\n\t\txfs_emerg(log->l_mp, \"%s: invalid ptr\", __func__);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_emerg",
          "args": [
            "log->l_mp",
            "\"%s: invalid ptr\"",
            "__func__"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxlog_verify_dest_ptr(\n\tstruct xlog\t*log,\n\tchar\t\t*ptr)\n{\n\tint i;\n\tint good_ptr = 0;\n\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\tif (ptr >= log->l_iclog_bak[i] &&\n\t\t    ptr <= log->l_iclog_bak[i] + log->l_iclog_size)\n\t\t\tgood_ptr++;\n\t}\n\n\tif (!good_ptr)\n\t\txfs_emerg(log->l_mp, \"%s: invalid ptr\", __func__);\n}"
  },
  {
    "function_name": "xlog_ticket_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3614-3649",
    "snippet": "struct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_log_ticket_zone;",
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_tic_reset_res",
          "args": [
            "tic"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_tic_reset_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "343-349",
          "snippet": "static void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tic->t_queue"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tic->t_ref",
            "1"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_calc_unit_res",
          "args": [
            "log->l_mp",
            "unit_bytes"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_calc_unit_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3518-3609",
          "snippet": "int\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_log_ticket_zone",
            "alloc_flags"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstruct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}"
  },
  {
    "function_name": "xfs_log_calc_unit_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3518-3609",
    "snippet": "int\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "unit_bytes",
            "iclog_space"
          ],
          "line": 3590
        },
        "resolved": true,
        "details": {
          "function_name": "howmany_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "340-345",
          "snippet": "static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_calc_unit_res(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tunit_bytes)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\ticlog_space;\n\tuint\t\t\tnum_headers;\n\n\t/*\n\t * Permanent reservations have up to 'cnt'-1 active log operations\n\t * in the log.  A unit in this case is the amount of space for one\n\t * of these log operations.  Normal reservations have a cnt of 1\n\t * and their unit amount is the total amount of space required.\n\t *\n\t * The following lines of code account for non-transaction data\n\t * which occupy space in the on-disk log.\n\t *\n\t * Normal form of a transaction is:\n\t * <oph><trans-hdr><start-oph><reg1-oph><reg1><reg2-oph>...<commit-oph>\n\t * and then there are LR hdrs, split-recs and roundoff at end of syncs.\n\t *\n\t * We need to account for all the leadup data and trailer data\n\t * around the transaction data.\n\t * And then we need to account for the worst case in terms of using\n\t * more space.\n\t * The worst case will happen if:\n\t * - the placement of the transaction happens to be such that the\n\t *   roundoff is at its maximum\n\t * - the transaction data is synced before the commit record is synced\n\t *   i.e. <transaction-data><roundoff> | <commit-rec><roundoff>\n\t *   Therefore the commit record is in its own Log Record.\n\t *   This can happen as the commit record is called with its\n\t *   own region to xlog_write().\n\t *   This then means that in the worst case, roundoff can happen for\n\t *   the commit-rec as well.\n\t *   The commit-rec is smaller than padding in this scenario and so it is\n\t *   not added separately.\n\t */\n\n\t/* for trans header */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\tunit_bytes += sizeof(xfs_trans_header_t);\n\n\t/* for start-rec */\n\tunit_bytes += sizeof(xlog_op_header_t);\n\n\t/*\n\t * for LR headers - the space for data in an iclog is the size minus\n\t * the space used for the headers. If we use the iclog size, then we\n\t * undercalculate the number of headers required.\n\t *\n\t * Furthermore - the addition of op headers for split-recs might\n\t * increase the space required enough to require more log and op\n\t * headers, so take that into account too.\n\t *\n\t * IMPORTANT: This reservation makes the assumption that if this\n\t * transaction is the first in an iclog and hence has the LR headers\n\t * accounted to it, then the remaining space in the iclog is\n\t * exclusively for this transaction.  i.e. if the transaction is larger\n\t * than the iclog, it will be the only thing in that iclog.\n\t * Fundamentally, this means we must pass the entire log vector to\n\t * xlog_write to guarantee this.\n\t */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tnum_headers = howmany(unit_bytes, iclog_space);\n\n\t/* for split-recs - ophdrs added when data split over LRs */\n\tunit_bytes += sizeof(xlog_op_header_t) * num_headers;\n\n\t/* add extra header reservations if we overrun */\n\twhile (!num_headers ||\n\t       howmany(unit_bytes, iclog_space) > num_headers) {\n\t\tunit_bytes += sizeof(xlog_op_header_t);\n\t\tnum_headers++;\n\t}\n\tunit_bytes += log->l_iclog_hsize * num_headers;\n\n\t/* for commit-rec LR header - note: padding will subsume the ophdr */\n\tunit_bytes += log->l_iclog_hsize;\n\n\t/* for roundoff padding for transaction data and one for commit record */\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1) {\n\t\t/* log su roundoff */\n\t\tunit_bytes += 2 * mp->m_sb.sb_logsunit;\n\t} else {\n\t\t/* BB roundoff */\n\t\tunit_bytes += 2 * BBSIZE;\n        }\n\n\treturn unit_bytes;\n}"
  },
  {
    "function_name": "xfs_log_ticket_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3505-3512",
    "snippet": "xlog_ticket_t *\nxfs_log_ticket_get(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tatomic_inc(&ticket->t_ref);\n\treturn ticket;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ticket->t_ref"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&ticket->t_ref) > 0"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ticket->t_ref"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nxlog_ticket_t *\nxfs_log_ticket_get(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tatomic_inc(&ticket->t_ref);\n\treturn ticket;\n}"
  },
  {
    "function_name": "xfs_log_ticket_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3496-3503",
    "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_log_ticket_zone;",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_log_ticket_zone",
            "ticket"
          ],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ticket->t_ref"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&ticket->t_ref) > 0"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ticket->t_ref"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
  },
  {
    "function_name": "xlog_state_want_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3470-3483",
    "snippet": "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR)"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_switch_iclogs",
          "args": [
            "log",
            "iclog",
            "0"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_switch_iclogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3123-3156",
          "snippet": "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}"
  },
  {
    "function_name": "xfs_log_force_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3452-3464",
    "snippet": "void\nxfs_log_force_lsn(\n\txfs_mount_t\t*mp,\n\txfs_lsn_t\tlsn,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, lsn);\n\terror = _xfs_log_force_lsn(mp, lsn, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: error %d returned.\"",
            "__func__",
            "error"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force_lsn",
          "args": [
            "mp",
            "lsn",
            "flags",
            "NULL"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3332-3445",
          "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_force",
          "args": [
            "mp",
            "lsn"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_force_lsn(\n\txfs_mount_t\t*mp,\n\txfs_lsn_t\tlsn,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, lsn);\n\terror = _xfs_log_force_lsn(mp, lsn, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}"
  },
  {
    "function_name": "_xfs_log_force_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3332-3445",
    "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&iclog->ic_force_wait",
            "&log->l_icloglock"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_force_sleep"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_switch_iclogs",
          "args": [
            "log",
            "iclog",
            "0"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_switch_iclogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3123-3156",
          "snippet": "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_force_sleep"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(iclog->ic_state & XLOG_STATE_IOERROR)"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cil_force_lsn",
          "args": [
            "log",
            "lsn"
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "829-913",
          "snippet": "xfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_force"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lsn != 0"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_log_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3304-3315",
    "snippet": "void\nxfs_log_force(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, 0);\n\terror = _xfs_log_force(mp, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: error %d returned.\"",
            "__func__",
            "error"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force",
          "args": [
            "mp",
            "flags",
            "NULL"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3185-3297",
          "snippet": "int\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_force",
          "args": [
            "mp",
            "0"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_force(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\terror;\n\n\ttrace_xfs_log_force(mp, 0);\n\terror = _xfs_log_force(mp, flags, NULL);\n\tif (error)\n\t\txfs_warn(mp, \"%s: error %d returned.\", __func__, error);\n}"
  },
  {
    "function_name": "_xfs_log_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3185-3297",
    "snippet": "int\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&iclog->ic_force_wait",
            "&log->l_icloglock"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_force_sleep"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_switch_iclogs",
          "args": [
            "log",
            "iclog",
            "0"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_switch_iclogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3123-3156",
          "snippet": "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cil_force",
          "args": [
            "log"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "533-537",
          "snippet": "static inline void\nxlog_cil_force(struct xlog *log)\n{\n\txlog_cil_force_lsn(log, log->l_cilp->xc_current_sequence);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_cil_force(struct xlog *log)\n{\n\txlog_cil_force_lsn(log, log->l_cilp->xc_current_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_force"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_state_switch_iclogs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3123-3156",
    "snippet": "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog == log->l_iclog"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log->l_curr_block >= 0"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "log->l_curr_block",
            "sunit_bb"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_mp->m_sb.sb_logsunit"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_iclog_hsize"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "eventual_size"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "log->l_prev_block"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state == XLOG_STATE_ACTIVE"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}"
  },
  {
    "function_name": "xlog_state_release_iclog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3071-3113",
    "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_sync",
          "args": [
            "log",
            "iclog"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1734-1887",
          "snippet": "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\txfs_buf_t\t*bp;\n\tint\t\ti;\n\tuint\t\tcount;\t\t/* byte count of bwrite */\n\tuint\t\tcount_init;\t/* initial count before roundup */\n\tint\t\troundoff;       /* roundoff to BB or stripe */\n\tint\t\tsplit = 0;\t/* split write into two regions */\n\tint\t\terror;\n\tint\t\tv2 = xfs_sb_version_haslogv2(&log->l_mp->m_sb);\n\tint\t\tsize;\n\n\tXFS_STATS_INC(xs_log_writes);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\n\t/* Add for LR header */\n\tcount_init = log->l_iclog_hsize + iclog->ic_offset;\n\n\t/* Round out the log write size */\n\tif (v2 && log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t/* we have a v2 stripe unit to use */\n\t\tcount = XLOG_LSUNITTOB(log, XLOG_BTOLSUNIT(log, count_init));\n\t} else {\n\t\tcount = BBTOB(BTOBB(count_init));\n\t}\n\troundoff = count - count_init;\n\tASSERT(roundoff >= 0);\n\tASSERT((v2 && log->l_mp->m_sb.sb_logsunit > 1 && \n                roundoff < log->l_mp->m_sb.sb_logsunit)\n\t\t|| \n\t\t(log->l_mp->m_sb.sb_logsunit <= 1 && \n\t\t roundoff < BBTOB(1)));\n\n\t/* move grant heads by roundoff in sync */\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, roundoff);\n\txlog_grant_add_space(log, &log->l_write_head.grant, roundoff);\n\n\t/* put cycle number in every block */\n\txlog_pack_data(log, iclog, roundoff); \n\n\t/* real byte length */\n\tsize = iclog->ic_offset;\n\tif (v2)\n\t\tsize += roundoff;\n\ticlog->ic_header.h_len = cpu_to_be32(size);\n\n\tbp = iclog->ic_bp;\n\tXFS_BUF_SET_ADDR(bp, BLOCK_LSN(be64_to_cpu(iclog->ic_header.h_lsn)));\n\n\tXFS_STATS_ADD(xs_log_blocks, BTOBB(count));\n\n\t/* Do we need to split this write into 2 parts? */\n\tif (XFS_BUF_ADDR(bp) + BTOBB(count) > log->l_logBBsize) {\n\t\tchar\t\t*dptr;\n\n\t\tsplit = count - (BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp)));\n\t\tcount = BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp));\n\t\ticlog->ic_bwritecnt = 2;\n\n\t\t/*\n\t\t * Bump the cycle numbers at the start of each block in the\n\t\t * part of the iclog that ends up in the buffer that gets\n\t\t * written to the start of the log.\n\t\t *\n\t\t * Watch out for the header magic number case, though.\n\t\t */\n\t\tdptr = (char *)&iclog->ic_header + count;\n\t\tfor (i = 0; i < split; i += BBSIZE) {\n\t\t\t__uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);\n\t\t\tif (++cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\t\tcycle++;\n\t\t\t*(__be32 *)dptr = cpu_to_be32(cycle);\n\n\t\t\tdptr += BBSIZE;\n\t\t}\n\t} else {\n\t\ticlog->ic_bwritecnt = 1;\n\t}\n\n\t/* calculcate the checksum */\n\ticlog->ic_header.h_crc = xlog_cksum(log, &iclog->ic_header,\n\t\t\t\t\t    iclog->ic_datap, size);\n\n\tbp->b_io_length = BTOBB(count);\n\tbp->b_fspriv = iclog;\n\tXFS_BUF_ZEROFLAGS(bp);\n\tXFS_BUF_ASYNC(bp);\n\tbp->b_flags |= XBF_SYNCIO;\n\n\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\tbp->b_flags |= XBF_FUA;\n\n\t\t/*\n\t\t * Flush the data device before flushing the log to make\n\t\t * sure all meta data written back from the AIL actually made\n\t\t * it to disk before stamping the new log tail LSN into the\n\t\t * log buffer.  For an external log we need to issue the\n\t\t * flush explicitly, and unfortunately synchronously here;\n\t\t * for an internal log we can simply use the block layer\n\t\t * state machine for preflushes.\n\t\t */\n\t\tif (log->l_mp->m_logdev_targp != log->l_mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(log->l_mp->m_ddev_targp);\n\t\telse\n\t\t\tbp->b_flags |= XBF_FLUSH;\n\t}\n\n\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\txlog_verify_iclog(log, iclog, count, true);\n\n\t/* account for log which doesn't start at block #0 */\n\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t/*\n\t * Don't call xfs_bwrite here. We do log-syncs even when the filesystem\n\t * is shutting down.\n\t */\n\tXFS_BUF_WRITE(bp);\n\n\terror = xlog_bdstrat(bp);\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_sync\");\n\t\treturn error;\n\t}\n\tif (split) {\n\t\tbp = iclog->ic_log->l_xbuf;\n\t\tXFS_BUF_SET_ADDR(bp, 0);\t     /* logical 0 */\n\t\txfs_buf_associate_memory(bp,\n\t\t\t\t(char *)&iclog->ic_header + count, split);\n\t\tbp->b_fspriv = iclog;\n\t\tXFS_BUF_ZEROFLAGS(bp);\n\t\tXFS_BUF_ASYNC(bp);\n\t\tbp->b_flags |= XBF_SYNCIO;\n\t\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER)\n\t\t\tbp->b_flags |= XBF_FUA;\n\n\t\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\t\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\t\t/* account for internal log which doesn't start at block #0 */\n\t\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t\tXFS_BUF_WRITE(bp);\n\t\terror = xlog_bdstrat(bp);\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, \"xlog_sync (split)\");\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\txfs_buf_t\t*bp;\n\tint\t\ti;\n\tuint\t\tcount;\t\t/* byte count of bwrite */\n\tuint\t\tcount_init;\t/* initial count before roundup */\n\tint\t\troundoff;       /* roundoff to BB or stripe */\n\tint\t\tsplit = 0;\t/* split write into two regions */\n\tint\t\terror;\n\tint\t\tv2 = xfs_sb_version_haslogv2(&log->l_mp->m_sb);\n\tint\t\tsize;\n\n\tXFS_STATS_INC(xs_log_writes);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\n\t/* Add for LR header */\n\tcount_init = log->l_iclog_hsize + iclog->ic_offset;\n\n\t/* Round out the log write size */\n\tif (v2 && log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t/* we have a v2 stripe unit to use */\n\t\tcount = XLOG_LSUNITTOB(log, XLOG_BTOLSUNIT(log, count_init));\n\t} else {\n\t\tcount = BBTOB(BTOBB(count_init));\n\t}\n\troundoff = count - count_init;\n\tASSERT(roundoff >= 0);\n\tASSERT((v2 && log->l_mp->m_sb.sb_logsunit > 1 && \n                roundoff < log->l_mp->m_sb.sb_logsunit)\n\t\t|| \n\t\t(log->l_mp->m_sb.sb_logsunit <= 1 && \n\t\t roundoff < BBTOB(1)));\n\n\t/* move grant heads by roundoff in sync */\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, roundoff);\n\txlog_grant_add_space(log, &log->l_write_head.grant, roundoff);\n\n\t/* put cycle number in every block */\n\txlog_pack_data(log, iclog, roundoff); \n\n\t/* real byte length */\n\tsize = iclog->ic_offset;\n\tif (v2)\n\t\tsize += roundoff;\n\ticlog->ic_header.h_len = cpu_to_be32(size);\n\n\tbp = iclog->ic_bp;\n\tXFS_BUF_SET_ADDR(bp, BLOCK_LSN(be64_to_cpu(iclog->ic_header.h_lsn)));\n\n\tXFS_STATS_ADD(xs_log_blocks, BTOBB(count));\n\n\t/* Do we need to split this write into 2 parts? */\n\tif (XFS_BUF_ADDR(bp) + BTOBB(count) > log->l_logBBsize) {\n\t\tchar\t\t*dptr;\n\n\t\tsplit = count - (BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp)));\n\t\tcount = BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp));\n\t\ticlog->ic_bwritecnt = 2;\n\n\t\t/*\n\t\t * Bump the cycle numbers at the start of each block in the\n\t\t * part of the iclog that ends up in the buffer that gets\n\t\t * written to the start of the log.\n\t\t *\n\t\t * Watch out for the header magic number case, though.\n\t\t */\n\t\tdptr = (char *)&iclog->ic_header + count;\n\t\tfor (i = 0; i < split; i += BBSIZE) {\n\t\t\t__uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);\n\t\t\tif (++cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\t\tcycle++;\n\t\t\t*(__be32 *)dptr = cpu_to_be32(cycle);\n\n\t\t\tdptr += BBSIZE;\n\t\t}\n\t} else {\n\t\ticlog->ic_bwritecnt = 1;\n\t}\n\n\t/* calculcate the checksum */\n\ticlog->ic_header.h_crc = xlog_cksum(log, &iclog->ic_header,\n\t\t\t\t\t    iclog->ic_datap, size);\n\n\tbp->b_io_length = BTOBB(count);\n\tbp->b_fspriv = iclog;\n\tXFS_BUF_ZEROFLAGS(bp);\n\tXFS_BUF_ASYNC(bp);\n\tbp->b_flags |= XBF_SYNCIO;\n\n\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\tbp->b_flags |= XBF_FUA;\n\n\t\t/*\n\t\t * Flush the data device before flushing the log to make\n\t\t * sure all meta data written back from the AIL actually made\n\t\t * it to disk before stamping the new log tail LSN into the\n\t\t * log buffer.  For an external log we need to issue the\n\t\t * flush explicitly, and unfortunately synchronously here;\n\t\t * for an internal log we can simply use the block layer\n\t\t * state machine for preflushes.\n\t\t */\n\t\tif (log->l_mp->m_logdev_targp != log->l_mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(log->l_mp->m_ddev_targp);\n\t\telse\n\t\t\tbp->b_flags |= XBF_FLUSH;\n\t}\n\n\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\txlog_verify_iclog(log, iclog, count, true);\n\n\t/* account for log which doesn't start at block #0 */\n\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t/*\n\t * Don't call xfs_bwrite here. We do log-syncs even when the filesystem\n\t * is shutting down.\n\t */\n\tXFS_BUF_WRITE(bp);\n\n\terror = xlog_bdstrat(bp);\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_sync\");\n\t\treturn error;\n\t}\n\tif (split) {\n\t\tbp = iclog->ic_log->l_xbuf;\n\t\tXFS_BUF_SET_ADDR(bp, 0);\t     /* logical 0 */\n\t\txfs_buf_associate_memory(bp,\n\t\t\t\t(char *)&iclog->ic_header + count, split);\n\t\tbp->b_fspriv = iclog;\n\t\tXFS_BUF_ZEROFLAGS(bp);\n\t\tXFS_BUF_ASYNC(bp);\n\t\tbp->b_flags |= XBF_SYNCIO;\n\t\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER)\n\t\t\tbp->b_flags |= XBF_FUA;\n\n\t\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\t\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\t\t/* account for internal log which doesn't start at block #0 */\n\t\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t\tXFS_BUF_WRITE(bp);\n\t\terror = xlog_bdstrat(bp);\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, \"xlog_sync (split)\");\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_verify_tail_lsn",
          "args": [
            "log",
            "iclog",
            "tail_lsn"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_verify_tail_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3720-3743",
          "snippet": "STATIC void\nxlog_verify_tail_lsn(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\txfs_lsn_t\t\ttail_lsn)\n{\n    int blocks;\n\n    if (CYCLE_LSN(tail_lsn) == log->l_prev_cycle) {\n\tblocks =\n\t    log->l_logBBsize - (log->l_prev_block - BLOCK_LSN(tail_lsn));\n\tif (blocks < BTOBB(iclog->ic_offset)+BTOBB(log->l_iclog_hsize))\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    } else {\n\tASSERT(CYCLE_LSN(tail_lsn)+1 == log->l_prev_cycle);\n\n\tif (BLOCK_LSN(tail_lsn) == log->l_prev_block)\n\t\txfs_emerg(log->l_mp, \"%s: tail wrapped\", __func__);\n\n\tblocks = BLOCK_LSN(tail_lsn) - log->l_prev_block;\n\tif (blocks < BTOBB(iclog->ic_offset) + 1)\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    }\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_tail_lsn(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\txfs_lsn_t\t\ttail_lsn)\n{\n    int blocks;\n\n    if (CYCLE_LSN(tail_lsn) == log->l_prev_cycle) {\n\tblocks =\n\t    log->l_logBBsize - (log->l_prev_block - BLOCK_LSN(tail_lsn));\n\tif (blocks < BTOBB(iclog->ic_offset)+BTOBB(log->l_iclog_hsize))\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    } else {\n\tASSERT(CYCLE_LSN(tail_lsn)+1 == log->l_prev_cycle);\n\n\tif (BLOCK_LSN(tail_lsn) == log->l_prev_block)\n\t\txfs_emerg(log->l_mp, \"%s: tail wrapped\", __func__);\n\n\tblocks = BLOCK_LSN(tail_lsn) - log->l_prev_block;\n\tif (blocks < BTOBB(iclog->ic_offset) + 1)\n\t\txfs_emerg(log->l_mp, \"%s: ran out of log space\", __func__);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "tail_lsn"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_tail_lsn",
          "args": [
            "log->l_mp"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_tail_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1094-1105",
          "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&iclog->ic_refcnt",
            "&log->l_icloglock"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&iclog->ic_refcnt) > 0"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_ungrant_log_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "3031-3060",
    "snippet": "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_space_wake",
          "args": [
            "log->l_mp"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_space_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "981-1008",
          "snippet": "void\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_ungrant_exit",
          "args": [
            "log",
            "ticket"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_sub_space",
          "args": [
            "log",
            "&log->l_write_head.grant",
            "bytes"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_sub_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "138-162",
          "snippet": "static void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ticket->t_flags & XLOG_TIC_PERM_RESERV"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_ungrant_sub",
          "args": [
            "log",
            "ticket"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_ungrant_enter",
          "args": [
            "log",
            "ticket"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}"
  },
  {
    "function_name": "xlog_regrant_reserve_log_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2984-3014",
    "snippet": "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\ttrace_xfs_log_regrant_reserve_enter(log, ticket);\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\txlog_grant_sub_space(log, &log->l_write_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n\n\ttrace_xfs_log_regrant_reserve_sub(log, ticket);\n\n\t/* just return if we still have some of the pre-reserved space */\n\tif (ticket->t_cnt > 0)\n\t\treturn;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_unit_res);\n\n\ttrace_xfs_log_regrant_reserve_exit(log, ticket);\n\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_tic_reset_res",
          "args": [
            "ticket"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_tic_reset_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "343-349",
          "snippet": "static void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_regrant_reserve_exit",
          "args": [
            "log",
            "ticket"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_add_space",
          "args": [
            "log",
            "&log->l_reserve_head.grant",
            "ticket->t_unit_res"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_add_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "164-191",
          "snippet": "static void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_regrant_reserve_sub",
          "args": [
            "log",
            "ticket"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_sub_space",
          "args": [
            "log",
            "&log->l_write_head.grant",
            "ticket->t_curr_res"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_sub_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "138-162",
          "snippet": "static void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_regrant_reserve_enter",
          "args": [
            "log",
            "ticket"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\ttrace_xfs_log_regrant_reserve_enter(log, ticket);\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\txlog_grant_sub_space(log, &log->l_write_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n\n\ttrace_xfs_log_regrant_reserve_sub(log, ticket);\n\n\t/* just return if we still have some of the pre-reserved space */\n\tif (ticket->t_cnt > 0)\n\t\treturn;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_unit_res);\n\n\ttrace_xfs_log_regrant_reserve_exit(log, ticket);\n\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n}"
  },
  {
    "function_name": "xlog_state_get_iclog_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2873-2975",
    "snippet": "STATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclogp,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp)\n{\n\tint\t\t  log_offset;\n\txlog_rec_header_t *head;\n\txlog_in_core_t\t  *iclog;\n\tint\t\t  error;\n\nrestart:\n\tspin_lock(&log->l_icloglock);\n\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state != XLOG_STATE_ACTIVE) {\n\t\tXFS_STATS_INC(xs_log_noiclogs);\n\n\t\t/* Wait for log writes to have flushed */\n\t\txlog_wait(&log->l_flush_wait, &log->l_icloglock);\n\t\tgoto restart;\n\t}\n\n\thead = &iclog->ic_header;\n\n\tatomic_inc(&iclog->ic_refcnt);\t/* prevents sync */\n\tlog_offset = iclog->ic_offset;\n\n\t/* On the 1st write to an iclog, figure out lsn.  This works\n\t * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are\n\t * committing to.  If the offset is set, that's how many blocks\n\t * must be written.\n\t */\n\tif (log_offset == 0) {\n\t\tticket->t_curr_res -= log->l_iclog_hsize;\n\t\txlog_tic_add_region(ticket,\n\t\t\t\t    log->l_iclog_hsize,\n\t\t\t\t    XLOG_REG_TYPE_LRHEADER);\n\t\thead->h_cycle = cpu_to_be32(log->l_curr_cycle);\n\t\thead->h_lsn = cpu_to_be64(\n\t\t\txlog_assign_lsn(log->l_curr_cycle, log->l_curr_block));\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\n\t/* If there is enough room to write everything, then do it.  Otherwise,\n\t * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC\n\t * bit is on, so this will get flushed out.  Don't update ic_offset\n\t * until you know exactly how many bytes get copied.  Therefore, wait\n\t * until later to update ic_offset.\n\t *\n\t * xlog_write() algorithm assumes that at least 2 xlog_op_header_t's\n\t * can fit into remaining data section.\n\t */\n\tif (iclog->ic_size - iclog->ic_offset < 2*sizeof(xlog_op_header_t)) {\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\n\t\t/*\n\t\t * If I'm the only one writing to this iclog, sync it to disk.\n\t\t * We need to do an atomic compare and decrement here to avoid\n\t\t * racing with concurrent atomic_dec_and_lock() calls in\n\t\t * xlog_state_release_iclog() when there is more than one\n\t\t * reference to the iclog.\n\t\t */\n\t\tif (!atomic_add_unless(&iclog->ic_refcnt, -1, 1)) {\n\t\t\t/* we are the only one */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\terror = xlog_state_release_iclog(log, iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t/* Do we have enough room to write the full amount in the remainder\n\t * of this iclog?  Or must we continue a write on the next iclog and\n\t * mark this iclog as completely taken?  In the case where we switch\n\t * iclogs (to mark it taken), this particular iclog will release/sync\n\t * to disk in xlog_write().\n\t */\n\tif (len <= iclog->ic_size - iclog->ic_offset) {\n\t\t*continued_write = 0;\n\t\ticlog->ic_offset += len;\n\t} else {\n\t\t*continued_write = 1;\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\t}\n\t*iclogp = iclog;\n\n\tASSERT(iclog->ic_offset <= iclog->ic_size);\n\tspin_unlock(&log->l_icloglock);\n\n\t*logoffsetp = log_offset;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclog,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_offset <= iclog->ic_size"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_switch_iclogs",
          "args": [
            "log",
            "iclog",
            "iclog->ic_size"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_switch_iclogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3123-3156",
          "snippet": "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_switch_iclogs(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\teventual_size)\n{\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);\n\tif (!eventual_size)\n\t\teventual_size = iclog->ic_offset;\n\ticlog->ic_state = XLOG_STATE_WANT_SYNC;\n\ticlog->ic_header.h_prev_block = cpu_to_be32(log->l_prev_block);\n\tlog->l_prev_block = log->l_curr_block;\n\tlog->l_prev_cycle = log->l_curr_cycle;\n\n\t/* roll log?: ic_offset changed later */\n\tlog->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);\n\n\t/* Round up to next log-sunit */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&\n\t    log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);\n\t\tlog->l_curr_block = roundup(log->l_curr_block, sunit_bb);\n\t}\n\n\tif (log->l_curr_block >= log->l_logBBsize) {\n\t\tlog->l_curr_cycle++;\n\t\tif (log->l_curr_cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\tlog->l_curr_cycle++;\n\t\tlog->l_curr_block -= log->l_logBBsize;\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\tASSERT(iclog == log->l_iclog);\n\tlog->l_iclog = iclog->ic_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&iclog->ic_refcnt",
            "-1",
            "1"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log->l_curr_block >= 0"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "xlog_assign_lsn(log->l_curr_cycle, log->l_curr_block)"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_lsn",
          "args": [
            "log->l_curr_cycle",
            "log->l_curr_block"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "72-75",
          "snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "log->l_curr_cycle"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_tic_add_region",
          "args": [
            "ticket",
            "log->l_iclog_hsize",
            "XLOG_REG_TYPE_LRHEADER"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_tic_add_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "351-365",
          "snippet": "static void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&log->l_flush_wait",
            "&log->l_icloglock"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_noiclogs"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclog,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclogp,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp)\n{\n\tint\t\t  log_offset;\n\txlog_rec_header_t *head;\n\txlog_in_core_t\t  *iclog;\n\tint\t\t  error;\n\nrestart:\n\tspin_lock(&log->l_icloglock);\n\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state != XLOG_STATE_ACTIVE) {\n\t\tXFS_STATS_INC(xs_log_noiclogs);\n\n\t\t/* Wait for log writes to have flushed */\n\t\txlog_wait(&log->l_flush_wait, &log->l_icloglock);\n\t\tgoto restart;\n\t}\n\n\thead = &iclog->ic_header;\n\n\tatomic_inc(&iclog->ic_refcnt);\t/* prevents sync */\n\tlog_offset = iclog->ic_offset;\n\n\t/* On the 1st write to an iclog, figure out lsn.  This works\n\t * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are\n\t * committing to.  If the offset is set, that's how many blocks\n\t * must be written.\n\t */\n\tif (log_offset == 0) {\n\t\tticket->t_curr_res -= log->l_iclog_hsize;\n\t\txlog_tic_add_region(ticket,\n\t\t\t\t    log->l_iclog_hsize,\n\t\t\t\t    XLOG_REG_TYPE_LRHEADER);\n\t\thead->h_cycle = cpu_to_be32(log->l_curr_cycle);\n\t\thead->h_lsn = cpu_to_be64(\n\t\t\txlog_assign_lsn(log->l_curr_cycle, log->l_curr_block));\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\n\t/* If there is enough room to write everything, then do it.  Otherwise,\n\t * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC\n\t * bit is on, so this will get flushed out.  Don't update ic_offset\n\t * until you know exactly how many bytes get copied.  Therefore, wait\n\t * until later to update ic_offset.\n\t *\n\t * xlog_write() algorithm assumes that at least 2 xlog_op_header_t's\n\t * can fit into remaining data section.\n\t */\n\tif (iclog->ic_size - iclog->ic_offset < 2*sizeof(xlog_op_header_t)) {\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\n\t\t/*\n\t\t * If I'm the only one writing to this iclog, sync it to disk.\n\t\t * We need to do an atomic compare and decrement here to avoid\n\t\t * racing with concurrent atomic_dec_and_lock() calls in\n\t\t * xlog_state_release_iclog() when there is more than one\n\t\t * reference to the iclog.\n\t\t */\n\t\tif (!atomic_add_unless(&iclog->ic_refcnt, -1, 1)) {\n\t\t\t/* we are the only one */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\terror = xlog_state_release_iclog(log, iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t/* Do we have enough room to write the full amount in the remainder\n\t * of this iclog?  Or must we continue a write on the next iclog and\n\t * mark this iclog as completely taken?  In the case where we switch\n\t * iclogs (to mark it taken), this particular iclog will release/sync\n\t * to disk in xlog_write().\n\t */\n\tif (len <= iclog->ic_size - iclog->ic_offset) {\n\t\t*continued_write = 0;\n\t\ticlog->ic_offset += len;\n\t} else {\n\t\t*continued_write = 1;\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\t}\n\t*iclogp = iclog;\n\n\tASSERT(iclog->ic_offset <= iclog->ic_size);\n\tspin_unlock(&log->l_icloglock);\n\n\t*logoffsetp = log_offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_state_done_syncing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2815-2852",
    "snippet": "STATIC void\nxlog_state_done_syncing(\n\txlog_in_core_t\t*iclog,\n\tint\t\taborted)\n{\n\tstruct xlog\t   *log = iclog->ic_log;\n\n\tspin_lock(&log->l_icloglock);\n\n\tASSERT(iclog->ic_state == XLOG_STATE_SYNCING ||\n\t       iclog->ic_state == XLOG_STATE_IOERROR);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\tASSERT(iclog->ic_bwritecnt == 1 || iclog->ic_bwritecnt == 2);\n\n\n\t/*\n\t * If we got an error, either on the first buffer, or in the case of\n\t * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,\n\t * and none should ever be attempted to be written to disk\n\t * again.\n\t */\n\tif (iclog->ic_state != XLOG_STATE_IOERROR) {\n\t\tif (--iclog->ic_bwritecnt == 1) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn;\n\t\t}\n\t\ticlog->ic_state = XLOG_STATE_DONE_SYNC;\n\t}\n\n\t/*\n\t * Someone could be sleeping prior to writing out the next\n\t * iclog buffer, we wake them all, one will get to do the\n\t * I/O, the others get to wait for the result.\n\t */\n\twake_up_all(&iclog->ic_write_wait);\n\tspin_unlock(&log->l_icloglock);\n\txlog_state_do_callback(log, aborted, iclog);\t/* also cleans log */\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_state_do_callback",
          "args": [
            "log",
            "aborted",
            "iclog"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_do_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2583-2799",
          "snippet": "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&iclog->ic_write_wait"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_bwritecnt == 1 || iclog->ic_bwritecnt == 2"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&iclog->ic_refcnt) == 0"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state == XLOG_STATE_SYNCING ||\n\t       iclog->ic_state == XLOG_STATE_IOERROR"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_done_syncing(\n\txlog_in_core_t\t*iclog,\n\tint\t\taborted)\n{\n\tstruct xlog\t   *log = iclog->ic_log;\n\n\tspin_lock(&log->l_icloglock);\n\n\tASSERT(iclog->ic_state == XLOG_STATE_SYNCING ||\n\t       iclog->ic_state == XLOG_STATE_IOERROR);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\tASSERT(iclog->ic_bwritecnt == 1 || iclog->ic_bwritecnt == 2);\n\n\n\t/*\n\t * If we got an error, either on the first buffer, or in the case of\n\t * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,\n\t * and none should ever be attempted to be written to disk\n\t * again.\n\t */\n\tif (iclog->ic_state != XLOG_STATE_IOERROR) {\n\t\tif (--iclog->ic_bwritecnt == 1) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn;\n\t\t}\n\t\ticlog->ic_state = XLOG_STATE_DONE_SYNC;\n\t}\n\n\t/*\n\t * Someone could be sleeping prior to writing out the next\n\t * iclog buffer, we wake them all, one will get to do the\n\t * I/O, the others get to wait for the result.\n\t */\n\twake_up_all(&iclog->ic_write_wait);\n\tspin_unlock(&log->l_icloglock);\n\txlog_state_do_callback(log, aborted, iclog);\t/* also cleans log */\n}"
  },
  {
    "function_name": "xlog_state_do_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2583-2799",
    "snippet": "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&log->l_flush_wait"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state != XLOG_STATE_DO_CALLBACK"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"%s: possible infinite loop (%d iterations)\"",
            "__func__",
            "flushcnt"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&iclog->ic_force_wait"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_clean_log",
          "args": [
            "log"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_clean_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2480-2558",
          "snippet": "STATIC void\nxlog_state_clean_log(\n\tstruct xlog *log)\n{\n\txlog_in_core_t\t*iclog;\n\tint changed = 0;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\ticlog->ic_state\t= XLOG_STATE_ACTIVE;\n\t\t\ticlog->ic_offset       = 0;\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\t/*\n\t\t\t * If the number of ops in this iclog indicate it just\n\t\t\t * contains the dummy transaction, we can\n\t\t\t * change state into IDLE (the second time around).\n\t\t\t * Otherwise we should change the state into\n\t\t\t * NEED a dummy.\n\t\t\t * We don't need to cover the dummy.\n\t\t\t */\n\t\t\tif (!changed &&\n\t\t\t   (be32_to_cpu(iclog->ic_header.h_num_logops) ==\n\t\t\t   \t\tXLOG_COVER_OPS)) {\n\t\t\t\tchanged = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We have two dirty iclogs so start over\n\t\t\t\t * This could also be num of ops indicates\n\t\t\t\t * this is not the dummy going out.\n\t\t\t\t */\n\t\t\t\tchanged = 2;\n\t\t\t}\n\t\t\ticlog->ic_header.h_num_logops = 0;\n\t\t\tmemset(iclog->ic_header.h_cycle_data, 0,\n\t\t\t      sizeof(iclog->ic_header.h_cycle_data));\n\t\t\ticlog->ic_header.h_lsn = 0;\n\t\t} else if (iclog->ic_state == XLOG_STATE_ACTIVE)\n\t\t\t/* do nothing */;\n\t\telse\n\t\t\tbreak;\t/* stop cleaning */\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\n\t/* log is locked when we are called */\n\t/*\n\t * Change state for the dummy log recording.\n\t * We usually go to NEED. But we go to NEED2 if the changed indicates\n\t * we are done writing the dummy record.\n\t * If we are done with the second dummy recored (DONE2), then\n\t * we go to IDLE.\n\t */\n\tif (changed) {\n\t\tswitch (log->l_covered_state) {\n\t\tcase XLOG_STATE_COVER_IDLE:\n\t\tcase XLOG_STATE_COVER_NEED:\n\t\tcase XLOG_STATE_COVER_NEED2:\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED2;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE2:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_clean_log(\n\tstruct xlog *log)\n{\n\txlog_in_core_t\t*iclog;\n\tint changed = 0;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\ticlog->ic_state\t= XLOG_STATE_ACTIVE;\n\t\t\ticlog->ic_offset       = 0;\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\t/*\n\t\t\t * If the number of ops in this iclog indicate it just\n\t\t\t * contains the dummy transaction, we can\n\t\t\t * change state into IDLE (the second time around).\n\t\t\t * Otherwise we should change the state into\n\t\t\t * NEED a dummy.\n\t\t\t * We don't need to cover the dummy.\n\t\t\t */\n\t\t\tif (!changed &&\n\t\t\t   (be32_to_cpu(iclog->ic_header.h_num_logops) ==\n\t\t\t   \t\tXLOG_COVER_OPS)) {\n\t\t\t\tchanged = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We have two dirty iclogs so start over\n\t\t\t\t * This could also be num of ops indicates\n\t\t\t\t * this is not the dummy going out.\n\t\t\t\t */\n\t\t\t\tchanged = 2;\n\t\t\t}\n\t\t\ticlog->ic_header.h_num_logops = 0;\n\t\t\tmemset(iclog->ic_header.h_cycle_data, 0,\n\t\t\t      sizeof(iclog->ic_header.h_cycle_data));\n\t\t\ticlog->ic_header.h_lsn = 0;\n\t\t} else if (iclog->ic_state == XLOG_STATE_ACTIVE)\n\t\t\t/* do nothing */;\n\t\telse\n\t\t\tbreak;\t/* stop cleaning */\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\n\t/* log is locked when we are called */\n\t/*\n\t * Change state for the dummy log recording.\n\t * We usually go to NEED. But we go to NEED2 if the changed indicates\n\t * we are done writing the dummy record.\n\t * If we are done with the second dummy recored (DONE2), then\n\t * we go to IDLE.\n\t */\n\tif (changed) {\n\t\tswitch (log->l_covered_state) {\n\t\tcase XLOG_STATE_COVER_IDLE:\n\t\tcase XLOG_STATE_COVER_NEED:\n\t\tcase XLOG_STATE_COVER_NEED2:\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED2;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE2:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_callback == NULL"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb->cb_func",
          "args": [
            "cb->cb_arg",
            "aborted"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&log->l_last_sync_lsn",
            "be64_to_cpu(iclog->ic_header.h_lsn)"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "atomic64_read(&log->l_last_sync_lsn)",
            "be64_to_cpu(iclog->ic_header.h_lsn)"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&log->l_last_sync_lsn"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lowest_lsn",
            "be64_to_cpu(iclog->ic_header.h_lsn)"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_lowest_lsn",
          "args": [
            "log"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_lowest_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2560-2580",
          "snippet": "STATIC xfs_lsn_t\nxlog_get_lowest_lsn(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t  *lsn_log;\n\txfs_lsn_t\tlowest_lsn, lsn;\n\n\tlsn_log = log->l_iclog;\n\tlowest_lsn = 0;\n\tdo {\n\t    if (!(lsn_log->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY))) {\n\t\tlsn = be64_to_cpu(lsn_log->ic_header.h_lsn);\n\t\tif ((lsn && !lowest_lsn) ||\n\t\t    (XFS_LSN_CMP(lsn, lowest_lsn) < 0)) {\n\t\t\tlowest_lsn = lsn;\n\t\t}\n\t    }\n\t    lsn_log = lsn_log->ic_next;\n\t} while (lsn_log != log->l_iclog);\n\treturn lowest_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC xfs_lsn_t\nxlog_get_lowest_lsn(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t  *lsn_log;\n\txfs_lsn_t\tlowest_lsn, lsn;\n\n\tlsn_log = log->l_iclog;\n\tlowest_lsn = 0;\n\tdo {\n\t    if (!(lsn_log->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY))) {\n\t\tlsn = be64_to_cpu(lsn_log->ic_header.h_lsn);\n\t\tif ((lsn && !lowest_lsn) ||\n\t\t    (XFS_LSN_CMP(lsn, lowest_lsn) < 0)) {\n\t\t\tlowest_lsn = lsn;\n\t\t}\n\t    }\n\t    lsn_log = lsn_log->ic_next;\n\t} while (lsn_log != log->l_iclog);\n\treturn lowest_lsn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*ciclog)\n{\n\txlog_in_core_t\t   *iclog;\n\txlog_in_core_t\t   *first_iclog;\t/* used to know when we've\n\t\t\t\t\t\t * processed all iclogs once */\n\txfs_log_callback_t *cb, *cb_next;\n\tint\t\t   flushcnt = 0;\n\txfs_lsn_t\t   lowest_lsn;\n\tint\t\t   ioerrors;\t/* counter: iclogs with errors */\n\tint\t\t   loopdidcallbacks; /* flag: inner loop did callbacks*/\n\tint\t\t   funcdidcallbacks; /* flag: function did callbacks */\n\tint\t\t   repeats;\t/* for issuing console warnings if\n\t\t\t\t\t * looping too many times */\n\tint\t\t   wake = 0;\n\n\tspin_lock(&log->l_icloglock);\n\tfirst_iclog = iclog = log->l_iclog;\n\tioerrors = 0;\n\tfuncdidcallbacks = 0;\n\trepeats = 0;\n\n\tdo {\n\t\t/*\n\t\t * Scan all iclogs starting with the one pointed to by the\n\t\t * log.  Reset this starting point each time the log is\n\t\t * unlocked (during callbacks).\n\t\t *\n\t\t * Keep looping through iclogs until one full pass is made\n\t\t * without running any callbacks.\n\t\t */\n\t\tfirst_iclog = log->l_iclog;\n\t\ticlog = log->l_iclog;\n\t\tloopdidcallbacks = 0;\n\t\trepeats++;\n\n\t\tdo {\n\n\t\t\t/* skip all iclogs in the ACTIVE & DIRTY states */\n\t\t\tif (iclog->ic_state &\n\t\t\t    (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY)) {\n\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Between marking a filesystem SHUTDOWN and stopping\n\t\t\t * the log, we do flush all iclogs to disk (if there\n\t\t\t * wasn't a log I/O error). So, we do want things to\n\t\t\t * go smoothly in case of just a SHUTDOWN  w/o a\n\t\t\t * LOG_IO_ERROR.\n\t\t\t */\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\t\t/*\n\t\t\t\t * Can only perform callbacks in order.  Since\n\t\t\t\t * this iclog is not in the DONE_SYNC/\n\t\t\t\t * DO_CALLBACK state, we skip the rest and\n\t\t\t\t * just try to clean up.  If we set our iclog\n\t\t\t\t * to DO_CALLBACK, we will not process it when\n\t\t\t\t * we retry since a previous iclog is in the\n\t\t\t\t * CALLBACK and the state cannot change since\n\t\t\t\t * we are holding the l_icloglock.\n\t\t\t\t */\n\t\t\t\tif (!(iclog->ic_state &\n\t\t\t\t\t(XLOG_STATE_DONE_SYNC |\n\t\t\t\t\t\t XLOG_STATE_DO_CALLBACK))) {\n\t\t\t\t\tif (ciclog && (ciclog->ic_state ==\n\t\t\t\t\t\t\tXLOG_STATE_DONE_SYNC)) {\n\t\t\t\t\t\tciclog->ic_state = XLOG_STATE_DO_CALLBACK;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We now have an iclog that is in either the\n\t\t\t\t * DO_CALLBACK or DONE_SYNC states. The other\n\t\t\t\t * states (WANT_SYNC, SYNCING, or CALLBACK were\n\t\t\t\t * caught by the above if and are going to\n\t\t\t\t * clean (i.e. we aren't doing their callbacks)\n\t\t\t\t * see the above if.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * We will do one more check here to see if we\n\t\t\t\t * have chased our tail around.\n\t\t\t\t */\n\n\t\t\t\tlowest_lsn = xlog_get_lowest_lsn(log);\n\t\t\t\tif (lowest_lsn &&\n\t\t\t\t    XFS_LSN_CMP(lowest_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) < 0) {\n\t\t\t\t\ticlog = iclog->ic_next;\n\t\t\t\t\tcontinue; /* Leave this iclog for\n\t\t\t\t\t\t   * another thread */\n\t\t\t\t}\n\n\t\t\t\ticlog->ic_state = XLOG_STATE_CALLBACK;\n\n\n\t\t\t\t/*\n\t\t\t\t * Completion of a iclog IO does not imply that\n\t\t\t\t * a transaction has completed, as transactions\n\t\t\t\t * can be large enough to span many iclogs. We\n\t\t\t\t * cannot change the tail of the log half way\n\t\t\t\t * through a transaction as this may be the only\n\t\t\t\t * transaction in the log and moving th etail to\n\t\t\t\t * point to the middle of it will prevent\n\t\t\t\t * recovery from finding the start of the\n\t\t\t\t * transaction. Hence we should only update the\n\t\t\t\t * last_sync_lsn if this iclog contains\n\t\t\t\t * transaction completion callbacks on it.\n\t\t\t\t *\n\t\t\t\t * We have to do this before we drop the\n\t\t\t\t * icloglock to ensure we are the only one that\n\t\t\t\t * can update it.\n\t\t\t\t */\n\t\t\t\tASSERT(XFS_LSN_CMP(atomic64_read(&log->l_last_sync_lsn),\n\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn)) <= 0);\n\t\t\t\tif (iclog->ic_callback)\n\t\t\t\t\tatomic64_set(&log->l_last_sync_lsn,\n\t\t\t\t\t\tbe64_to_cpu(iclog->ic_header.h_lsn));\n\n\t\t\t} else\n\t\t\t\tioerrors++;\n\n\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t/*\n\t\t\t * Keep processing entries in the callback list until\n\t\t\t * we come around and it is empty.  We need to\n\t\t\t * atomically see that the list is empty and change the\n\t\t\t * state to DIRTY so that we don't miss any more\n\t\t\t * callbacks being added.\n\t\t\t */\n\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\tcb = iclog->ic_callback;\n\t\t\twhile (cb) {\n\t\t\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\t\t\ticlog->ic_callback = NULL;\n\t\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\n\t\t\t\t/* perform callbacks in the order given */\n\t\t\t\tfor (; cb; cb = cb_next) {\n\t\t\t\t\tcb_next = cb->cb_next;\n\t\t\t\t\tcb->cb_func(cb->cb_arg, aborted);\n\t\t\t\t}\n\t\t\t\tspin_lock(&iclog->ic_callback_lock);\n\t\t\t\tcb = iclog->ic_callback;\n\t\t\t}\n\n\t\t\tloopdidcallbacks++;\n\t\t\tfuncdidcallbacks++;\n\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\tspin_unlock(&iclog->ic_callback_lock);\n\t\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR))\n\t\t\t\ticlog->ic_state = XLOG_STATE_DIRTY;\n\n\t\t\t/*\n\t\t\t * Transition from DIRTY to ACTIVE if applicable.\n\t\t\t * NOP if STATE_IOERROR.\n\t\t\t */\n\t\t\txlog_state_clean_log(log);\n\n\t\t\t/* wake up threads waiting in xfs_log_force() */\n\t\t\twake_up_all(&iclog->ic_force_wait);\n\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\n\t\tif (repeats > 5000) {\n\t\t\tflushcnt += repeats;\n\t\t\trepeats = 0;\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: possible infinite loop (%d iterations)\",\n\t\t\t\t__func__, flushcnt);\n\t\t}\n\t} while (!ioerrors && loopdidcallbacks);\n\n\t/*\n\t * make one last gasp attempt to see if iclogs are being left in\n\t * limbo..\n\t */\n#ifdef DEBUG\n\tif (funcdidcallbacks) {\n\t\tfirst_iclog = iclog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_state != XLOG_STATE_DO_CALLBACK);\n\t\t\t/*\n\t\t\t * Terminate the loop if iclogs are found in states\n\t\t\t * which will cause other threads to clean up iclogs.\n\t\t\t *\n\t\t\t * SYNCING - i/o completion will go through logs\n\t\t\t * DONE_SYNC - interrupt thread should be waiting for\n\t\t\t *              l_icloglock\n\t\t\t * IOERROR - give up hope all ye who enter here\n\t\t\t */\n\t\t\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_SYNCING ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DONE_SYNC ||\n\t\t\t    iclog->ic_state == XLOG_STATE_IOERROR )\n\t\t\t\tbreak;\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (first_iclog != iclog);\n\t}\n#endif\n\n\tif (log->l_iclog->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_IOERROR))\n\t\twake = 1;\n\tspin_unlock(&log->l_icloglock);\n\n\tif (wake)\n\t\twake_up_all(&log->l_flush_wait);\n}"
  },
  {
    "function_name": "xlog_get_lowest_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2560-2580",
    "snippet": "STATIC xfs_lsn_t\nxlog_get_lowest_lsn(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t  *lsn_log;\n\txfs_lsn_t\tlowest_lsn, lsn;\n\n\tlsn_log = log->l_iclog;\n\tlowest_lsn = 0;\n\tdo {\n\t    if (!(lsn_log->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY))) {\n\t\tlsn = be64_to_cpu(lsn_log->ic_header.h_lsn);\n\t\tif ((lsn && !lowest_lsn) ||\n\t\t    (XFS_LSN_CMP(lsn, lowest_lsn) < 0)) {\n\t\t\tlowest_lsn = lsn;\n\t\t}\n\t    }\n\t    lsn_log = lsn_log->ic_next;\n\t} while (lsn_log != log->l_iclog);\n\treturn lowest_lsn;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "lowest_lsn"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lsn_log->ic_header.h_lsn"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC xfs_lsn_t\nxlog_get_lowest_lsn(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t  *lsn_log;\n\txfs_lsn_t\tlowest_lsn, lsn;\n\n\tlsn_log = log->l_iclog;\n\tlowest_lsn = 0;\n\tdo {\n\t    if (!(lsn_log->ic_state & (XLOG_STATE_ACTIVE|XLOG_STATE_DIRTY))) {\n\t\tlsn = be64_to_cpu(lsn_log->ic_header.h_lsn);\n\t\tif ((lsn && !lowest_lsn) ||\n\t\t    (XFS_LSN_CMP(lsn, lowest_lsn) < 0)) {\n\t\t\tlowest_lsn = lsn;\n\t\t}\n\t    }\n\t    lsn_log = lsn_log->ic_next;\n\t} while (lsn_log != log->l_iclog);\n\treturn lowest_lsn;\n}"
  },
  {
    "function_name": "xlog_state_clean_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2480-2558",
    "snippet": "STATIC void\nxlog_state_clean_log(\n\tstruct xlog *log)\n{\n\txlog_in_core_t\t*iclog;\n\tint changed = 0;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\ticlog->ic_state\t= XLOG_STATE_ACTIVE;\n\t\t\ticlog->ic_offset       = 0;\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\t/*\n\t\t\t * If the number of ops in this iclog indicate it just\n\t\t\t * contains the dummy transaction, we can\n\t\t\t * change state into IDLE (the second time around).\n\t\t\t * Otherwise we should change the state into\n\t\t\t * NEED a dummy.\n\t\t\t * We don't need to cover the dummy.\n\t\t\t */\n\t\t\tif (!changed &&\n\t\t\t   (be32_to_cpu(iclog->ic_header.h_num_logops) ==\n\t\t\t   \t\tXLOG_COVER_OPS)) {\n\t\t\t\tchanged = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We have two dirty iclogs so start over\n\t\t\t\t * This could also be num of ops indicates\n\t\t\t\t * this is not the dummy going out.\n\t\t\t\t */\n\t\t\t\tchanged = 2;\n\t\t\t}\n\t\t\ticlog->ic_header.h_num_logops = 0;\n\t\t\tmemset(iclog->ic_header.h_cycle_data, 0,\n\t\t\t      sizeof(iclog->ic_header.h_cycle_data));\n\t\t\ticlog->ic_header.h_lsn = 0;\n\t\t} else if (iclog->ic_state == XLOG_STATE_ACTIVE)\n\t\t\t/* do nothing */;\n\t\telse\n\t\t\tbreak;\t/* stop cleaning */\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\n\t/* log is locked when we are called */\n\t/*\n\t * Change state for the dummy log recording.\n\t * We usually go to NEED. But we go to NEED2 if the changed indicates\n\t * we are done writing the dummy record.\n\t * If we are done with the second dummy recored (DONE2), then\n\t * we go to IDLE.\n\t */\n\tif (changed) {\n\t\tswitch (log->l_covered_state) {\n\t\tcase XLOG_STATE_COVER_IDLE:\n\t\tcase XLOG_STATE_COVER_NEED:\n\t\tcase XLOG_STATE_COVER_NEED2:\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED2;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE2:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iclog->ic_header.h_cycle_data",
            "0",
            "sizeof(iclog->ic_header.h_cycle_data)"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "iclog->ic_header.h_num_logops"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_callback == NULL"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_clean_log(\n\tstruct xlog *log)\n{\n\txlog_in_core_t\t*iclog;\n\tint changed = 0;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\ticlog->ic_state\t= XLOG_STATE_ACTIVE;\n\t\t\ticlog->ic_offset       = 0;\n\t\t\tASSERT(iclog->ic_callback == NULL);\n\t\t\t/*\n\t\t\t * If the number of ops in this iclog indicate it just\n\t\t\t * contains the dummy transaction, we can\n\t\t\t * change state into IDLE (the second time around).\n\t\t\t * Otherwise we should change the state into\n\t\t\t * NEED a dummy.\n\t\t\t * We don't need to cover the dummy.\n\t\t\t */\n\t\t\tif (!changed &&\n\t\t\t   (be32_to_cpu(iclog->ic_header.h_num_logops) ==\n\t\t\t   \t\tXLOG_COVER_OPS)) {\n\t\t\t\tchanged = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We have two dirty iclogs so start over\n\t\t\t\t * This could also be num of ops indicates\n\t\t\t\t * this is not the dummy going out.\n\t\t\t\t */\n\t\t\t\tchanged = 2;\n\t\t\t}\n\t\t\ticlog->ic_header.h_num_logops = 0;\n\t\t\tmemset(iclog->ic_header.h_cycle_data, 0,\n\t\t\t      sizeof(iclog->ic_header.h_cycle_data));\n\t\t\ticlog->ic_header.h_lsn = 0;\n\t\t} else if (iclog->ic_state == XLOG_STATE_ACTIVE)\n\t\t\t/* do nothing */;\n\t\telse\n\t\t\tbreak;\t/* stop cleaning */\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\n\t/* log is locked when we are called */\n\t/*\n\t * Change state for the dummy log recording.\n\t * We usually go to NEED. But we go to NEED2 if the changed indicates\n\t * we are done writing the dummy record.\n\t * If we are done with the second dummy recored (DONE2), then\n\t * we go to IDLE.\n\t */\n\tif (changed) {\n\t\tswitch (log->l_covered_state) {\n\t\tcase XLOG_STATE_COVER_IDLE:\n\t\tcase XLOG_STATE_COVER_NEED:\n\t\tcase XLOG_STATE_COVER_NEED2:\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED2;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tcase XLOG_STATE_COVER_DONE2:\n\t\t\tif (changed == 1)\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\t\t\telse\n\t\t\t\tlog->l_covered_state = XLOG_STATE_COVER_NEED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xlog_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2298-2462",
    "snippet": "int\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XLOG_COMMIT_TRANS"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_finish_copy",
          "args": [
            "log",
            "iclog",
            "record_cnt",
            "data_cnt"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_finish_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1939-1952",
          "snippet": "static inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len == 0"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_write_copy_finish",
          "args": [
            "log",
            "iclog",
            "flags",
            "&record_cnt",
            "&data_cnt",
            "&partial_copy",
            "&partial_copy_len",
            "log_offset",
            "commit_iclog"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_copy_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2213-2256",
          "snippet": "static int\nxlog_write_copy_finish(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tuint\t\t\tflags,\n\tint\t\t\t*record_cnt,\n\tint\t\t\t*data_cnt,\n\tint\t\t\t*partial_copy,\n\tint\t\t\t*partial_copy_len,\n\tint\t\t\tlog_offset,\n\tstruct xlog_in_core\t**commit_iclog)\n{\n\tif (*partial_copy) {\n\t\t/*\n\t\t * This iclog has already been marked WANT_SYNC by\n\t\t * xlog_state_get_iclog_space.\n\t\t */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\t\treturn xlog_state_release_iclog(log, iclog);\n\t}\n\n\t*partial_copy = 0;\n\t*partial_copy_len = 0;\n\n\tif (iclog->ic_size - log_offset <= sizeof(xlog_op_header_t)) {\n\t\t/* no more space in this iclog - push it. */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\n\t\tif (!commit_iclog)\n\t\t\treturn xlog_state_release_iclog(log, iclog);\n\t\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t\t*commit_iclog = iclog;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_copy_finish(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tuint\t\t\tflags,\n\tint\t\t\t*record_cnt,\n\tint\t\t\t*data_cnt,\n\tint\t\t\t*partial_copy,\n\tint\t\t\t*partial_copy_len,\n\tint\t\t\tlog_offset,\n\tstruct xlog_in_core\t**commit_iclog)\n{\n\tif (*partial_copy) {\n\t\t/*\n\t\t * This iclog has already been marked WANT_SYNC by\n\t\t * xlog_state_get_iclog_space.\n\t\t */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\t\treturn xlog_state_release_iclog(log, iclog);\n\t}\n\n\t*partial_copy = 0;\n\t*partial_copy_len = 0;\n\n\tif (iclog->ic_size - log_offset <= sizeof(xlog_op_header_t)) {\n\t\t/* no more space in this iclog - push it. */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\n\t\tif (!commit_iclog)\n\t\t\treturn xlog_state_release_iclog(log, iclog);\n\t\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t\t*commit_iclog = iclog;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write_adv_cnt",
          "args": [
            "&ptr",
            "&len",
            "&log_offset",
            "copy_len"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_adv_cnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "444-450",
          "snippet": "static inline void\nxlog_write_adv_cnt(void **ptr, int *len, int *off, size_t bytes)\n{\n\t*ptr += bytes;\n\t*len -= bytes;\n\t*off += bytes;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_write_adv_cnt(void **ptr, int *len, int *off, size_t bytes)\n{\n\t*ptr += bytes;\n\t*len -= bytes;\n\t*off += bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "reg->i_addr + copy_off",
            "copy_len"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "copy_len >= 0"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_verify_dest_ptr",
          "args": [
            "log",
            "ptr"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_verify_dest_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3664-3680",
          "snippet": "void\nxlog_verify_dest_ptr(\n\tstruct xlog\t*log,\n\tchar\t\t*ptr)\n{\n\tint i;\n\tint good_ptr = 0;\n\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\tif (ptr >= log->l_iclog_bak[i] &&\n\t\t    ptr <= log->l_iclog_bak[i] + log->l_iclog_size)\n\t\t\tgood_ptr++;\n\t}\n\n\tif (!good_ptr)\n\t\txfs_emerg(log->l_mp, \"%s: invalid ptr\", __func__);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxlog_verify_dest_ptr(\n\tstruct xlog\t*log,\n\tchar\t\t*ptr)\n{\n\tint i;\n\tint good_ptr = 0;\n\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\tif (ptr >= log->l_iclog_bak[i] &&\n\t\t    ptr <= log->l_iclog_bak[i] + log->l_iclog_size)\n\t\t\tgood_ptr++;\n\t}\n\n\tif (!good_ptr)\n\t\txfs_emerg(log->l_mp, \"%s: invalid ptr\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write_setup_copy",
          "args": [
            "ticket",
            "ophdr",
            "iclog->ic_size-log_offset",
            "reg->i_len",
            "&copy_off",
            "&copy_len",
            "&partial_copy",
            "&partial_copy_len"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_setup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2170-2211",
          "snippet": "static int\nxlog_write_setup_copy(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_op_header\t*ophdr,\n\tint\t\t\tspace_available,\n\tint\t\t\tspace_required,\n\tint\t\t\t*copy_off,\n\tint\t\t\t*copy_len,\n\tint\t\t\t*last_was_partial_copy,\n\tint\t\t\t*bytes_consumed)\n{\n\tint\t\t\tstill_to_copy;\n\n\tstill_to_copy = space_required - *bytes_consumed;\n\t*copy_off = *bytes_consumed;\n\n\tif (still_to_copy <= space_available) {\n\t\t/* write of region completes here */\n\t\t*copy_len = still_to_copy;\n\t\tophdr->oh_len = cpu_to_be32(*copy_len);\n\t\tif (*last_was_partial_copy)\n\t\t\tophdr->oh_flags |= (XLOG_END_TRANS|XLOG_WAS_CONT_TRANS);\n\t\t*last_was_partial_copy = 0;\n\t\t*bytes_consumed = 0;\n\t\treturn 0;\n\t}\n\n\t/* partial write of region, needs extra log op header reservation */\n\t*copy_len = space_available;\n\tophdr->oh_len = cpu_to_be32(*copy_len);\n\tophdr->oh_flags |= XLOG_CONTINUE_TRANS;\n\tif (*last_was_partial_copy)\n\t\tophdr->oh_flags |= XLOG_WAS_CONT_TRANS;\n\t*bytes_consumed += *copy_len;\n\t(*last_was_partial_copy)++;\n\n\t/* account for new log op header */\n\tticket->t_curr_res -= sizeof(struct xlog_op_header);\n\tticket->t_res_num_ophdrs++;\n\n\treturn sizeof(struct xlog_op_header);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_setup_copy(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_op_header\t*ophdr,\n\tint\t\t\tspace_available,\n\tint\t\t\tspace_required,\n\tint\t\t\t*copy_off,\n\tint\t\t\t*copy_len,\n\tint\t\t\t*last_was_partial_copy,\n\tint\t\t\t*bytes_consumed)\n{\n\tint\t\t\tstill_to_copy;\n\n\tstill_to_copy = space_required - *bytes_consumed;\n\t*copy_off = *bytes_consumed;\n\n\tif (still_to_copy <= space_available) {\n\t\t/* write of region completes here */\n\t\t*copy_len = still_to_copy;\n\t\tophdr->oh_len = cpu_to_be32(*copy_len);\n\t\tif (*last_was_partial_copy)\n\t\t\tophdr->oh_flags |= (XLOG_END_TRANS|XLOG_WAS_CONT_TRANS);\n\t\t*last_was_partial_copy = 0;\n\t\t*bytes_consumed = 0;\n\t\treturn 0;\n\t}\n\n\t/* partial write of region, needs extra log op header reservation */\n\t*copy_len = space_available;\n\tophdr->oh_len = cpu_to_be32(*copy_len);\n\tophdr->oh_flags |= XLOG_CONTINUE_TRANS;\n\tif (*last_was_partial_copy)\n\t\tophdr->oh_flags |= XLOG_WAS_CONT_TRANS;\n\t*bytes_consumed += *copy_len;\n\t(*last_was_partial_copy)++;\n\n\t/* account for new log op header */\n\tticket->t_curr_res -= sizeof(struct xlog_op_header);\n\tticket->t_res_num_ophdrs++;\n\n\treturn sizeof(struct xlog_op_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write_setup_ophdr",
          "args": [
            "log",
            "ptr",
            "ticket",
            "flags"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_setup_ophdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2130-2162",
          "snippet": "static xlog_op_header_t *\nxlog_write_setup_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket,\n\tuint\t\t\tflags)\n{\n\tophdr->oh_tid = cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_res2 = 0;\n\n\t/* are we copying a commit or unmount record? */\n\tophdr->oh_flags = flags;\n\n\t/*\n\t * We've seen logs corrupted with bad transaction client ids.  This\n\t * makes sure that XFS doesn't generate them on.  Turn this into an EIO\n\t * and shut down the filesystem.\n\t */\n\tswitch (ophdr->oh_clientid)  {\n\tcase XFS_TRANSACTION:\n\tcase XFS_VOLUME:\n\tcase XFS_LOG:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Bad XFS transaction clientid 0x%x in ticket 0x%p\",\n\t\t\tophdr->oh_clientid, ticket);\n\t\treturn NULL;\n\t}\n\n\treturn ophdr;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic xlog_op_header_t *\nxlog_write_setup_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket,\n\tuint\t\t\tflags)\n{\n\tophdr->oh_tid = cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_res2 = 0;\n\n\t/* are we copying a commit or unmount record? */\n\tophdr->oh_flags = flags;\n\n\t/*\n\t * We've seen logs corrupted with bad transaction client ids.  This\n\t * makes sure that XFS doesn't generate them on.  Turn this into an EIO\n\t * and shut down the filesystem.\n\t */\n\tswitch (ophdr->oh_clientid)  {\n\tcase XFS_TRANSACTION:\n\tcase XFS_VOLUME:\n\tcase XFS_LOG:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Bad XFS transaction clientid 0x%x in ticket 0x%p\",\n\t\t\tophdr->oh_clientid, ticket);\n\t\treturn NULL;\n\t}\n\n\treturn ophdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write_start_rec",
          "args": [
            "ptr",
            "ticket"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_start_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2111-2128",
          "snippet": "static int\nxlog_write_start_rec(\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket)\n{\n\tif (!(ticket->t_flags & XLOG_TIC_INITED))\n\t\treturn 0;\n\n\tophdr->oh_tid\t= cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_len = 0;\n\tophdr->oh_flags = XLOG_START_TRANS;\n\tophdr->oh_res2 = 0;\n\n\tticket->t_flags &= ~XLOG_TIC_INITED;\n\n\treturn sizeof(struct xlog_op_header);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nstatic int\nxlog_write_start_rec(\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket)\n{\n\tif (!(ticket->t_flags & XLOG_TIC_INITED))\n\t\treturn 0;\n\n\tophdr->oh_tid\t= cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_len = 0;\n\tophdr->oh_flags = XLOG_START_TRANS;\n\tophdr->oh_res2 = 0;\n\n\tticket->t_flags &= ~XLOG_TIC_INITED;\n\n\treturn sizeof(struct xlog_op_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(unsigned long)ptr % sizeof(__int32_t) == 0"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "reg->i_len % sizeof(__int32_t) == 0"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lv->lv_niovecs == 0"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log_offset <= iclog->ic_size - 1"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_get_iclog_space",
          "args": [
            "log",
            "len",
            "&iclog",
            "ticket",
            "&contwr",
            "&log_offset"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_get_iclog_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2873-2975",
          "snippet": "STATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclogp,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp)\n{\n\tint\t\t  log_offset;\n\txlog_rec_header_t *head;\n\txlog_in_core_t\t  *iclog;\n\tint\t\t  error;\n\nrestart:\n\tspin_lock(&log->l_icloglock);\n\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state != XLOG_STATE_ACTIVE) {\n\t\tXFS_STATS_INC(xs_log_noiclogs);\n\n\t\t/* Wait for log writes to have flushed */\n\t\txlog_wait(&log->l_flush_wait, &log->l_icloglock);\n\t\tgoto restart;\n\t}\n\n\thead = &iclog->ic_header;\n\n\tatomic_inc(&iclog->ic_refcnt);\t/* prevents sync */\n\tlog_offset = iclog->ic_offset;\n\n\t/* On the 1st write to an iclog, figure out lsn.  This works\n\t * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are\n\t * committing to.  If the offset is set, that's how many blocks\n\t * must be written.\n\t */\n\tif (log_offset == 0) {\n\t\tticket->t_curr_res -= log->l_iclog_hsize;\n\t\txlog_tic_add_region(ticket,\n\t\t\t\t    log->l_iclog_hsize,\n\t\t\t\t    XLOG_REG_TYPE_LRHEADER);\n\t\thead->h_cycle = cpu_to_be32(log->l_curr_cycle);\n\t\thead->h_lsn = cpu_to_be64(\n\t\t\txlog_assign_lsn(log->l_curr_cycle, log->l_curr_block));\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\n\t/* If there is enough room to write everything, then do it.  Otherwise,\n\t * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC\n\t * bit is on, so this will get flushed out.  Don't update ic_offset\n\t * until you know exactly how many bytes get copied.  Therefore, wait\n\t * until later to update ic_offset.\n\t *\n\t * xlog_write() algorithm assumes that at least 2 xlog_op_header_t's\n\t * can fit into remaining data section.\n\t */\n\tif (iclog->ic_size - iclog->ic_offset < 2*sizeof(xlog_op_header_t)) {\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\n\t\t/*\n\t\t * If I'm the only one writing to this iclog, sync it to disk.\n\t\t * We need to do an atomic compare and decrement here to avoid\n\t\t * racing with concurrent atomic_dec_and_lock() calls in\n\t\t * xlog_state_release_iclog() when there is more than one\n\t\t * reference to the iclog.\n\t\t */\n\t\tif (!atomic_add_unless(&iclog->ic_refcnt, -1, 1)) {\n\t\t\t/* we are the only one */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\terror = xlog_state_release_iclog(log, iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t/* Do we have enough room to write the full amount in the remainder\n\t * of this iclog?  Or must we continue a write on the next iclog and\n\t * mark this iclog as completely taken?  In the case where we switch\n\t * iclogs (to mark it taken), this particular iclog will release/sync\n\t * to disk in xlog_write().\n\t */\n\tif (len <= iclog->ic_size - iclog->ic_offset) {\n\t\t*continued_write = 0;\n\t\ticlog->ic_offset += len;\n\t} else {\n\t\t*continued_write = 1;\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\t}\n\t*iclogp = iclog;\n\n\tASSERT(iclog->ic_offset <= iclog->ic_size);\n\tspin_unlock(&log->l_icloglock);\n\n\t*logoffsetp = log_offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclog,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclog,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_get_iclog_space(\n\tstruct xlog\t\t*log,\n\tint\t\t\tlen,\n\tstruct xlog_in_core\t**iclogp,\n\tstruct xlog_ticket\t*ticket,\n\tint\t\t\t*continued_write,\n\tint\t\t\t*logoffsetp)\n{\n\tint\t\t  log_offset;\n\txlog_rec_header_t *head;\n\txlog_in_core_t\t  *iclog;\n\tint\t\t  error;\n\nrestart:\n\tspin_lock(&log->l_icloglock);\n\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state != XLOG_STATE_ACTIVE) {\n\t\tXFS_STATS_INC(xs_log_noiclogs);\n\n\t\t/* Wait for log writes to have flushed */\n\t\txlog_wait(&log->l_flush_wait, &log->l_icloglock);\n\t\tgoto restart;\n\t}\n\n\thead = &iclog->ic_header;\n\n\tatomic_inc(&iclog->ic_refcnt);\t/* prevents sync */\n\tlog_offset = iclog->ic_offset;\n\n\t/* On the 1st write to an iclog, figure out lsn.  This works\n\t * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are\n\t * committing to.  If the offset is set, that's how many blocks\n\t * must be written.\n\t */\n\tif (log_offset == 0) {\n\t\tticket->t_curr_res -= log->l_iclog_hsize;\n\t\txlog_tic_add_region(ticket,\n\t\t\t\t    log->l_iclog_hsize,\n\t\t\t\t    XLOG_REG_TYPE_LRHEADER);\n\t\thead->h_cycle = cpu_to_be32(log->l_curr_cycle);\n\t\thead->h_lsn = cpu_to_be64(\n\t\t\txlog_assign_lsn(log->l_curr_cycle, log->l_curr_block));\n\t\tASSERT(log->l_curr_block >= 0);\n\t}\n\n\t/* If there is enough room to write everything, then do it.  Otherwise,\n\t * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC\n\t * bit is on, so this will get flushed out.  Don't update ic_offset\n\t * until you know exactly how many bytes get copied.  Therefore, wait\n\t * until later to update ic_offset.\n\t *\n\t * xlog_write() algorithm assumes that at least 2 xlog_op_header_t's\n\t * can fit into remaining data section.\n\t */\n\tif (iclog->ic_size - iclog->ic_offset < 2*sizeof(xlog_op_header_t)) {\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\n\t\t/*\n\t\t * If I'm the only one writing to this iclog, sync it to disk.\n\t\t * We need to do an atomic compare and decrement here to avoid\n\t\t * racing with concurrent atomic_dec_and_lock() calls in\n\t\t * xlog_state_release_iclog() when there is more than one\n\t\t * reference to the iclog.\n\t\t */\n\t\tif (!atomic_add_unless(&iclog->ic_refcnt, -1, 1)) {\n\t\t\t/* we are the only one */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\terror = xlog_state_release_iclog(log, iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t/* Do we have enough room to write the full amount in the remainder\n\t * of this iclog?  Or must we continue a write on the next iclog and\n\t * mark this iclog as completely taken?  In the case where we switch\n\t * iclogs (to mark it taken), this particular iclog will release/sync\n\t * to disk in xlog_write().\n\t */\n\tif (len <= iclog->ic_size - iclog->ic_offset) {\n\t\t*continued_write = 0;\n\t\ticlog->ic_offset += len;\n\t} else {\n\t\t*continued_write = 1;\n\t\txlog_state_switch_iclogs(log, iclog, iclog->ic_size);\n\t}\n\t*iclogp = iclog;\n\n\tASSERT(iclog->ic_offset <= iclog->ic_size);\n\tspin_unlock(&log->l_icloglock);\n\n\t*logoffsetp = log_offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_print_tic_res",
          "args": [
            "log->l_mp",
            "ticket"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write_calc_vec_length",
          "args": [
            "ticket",
            "log_vector"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write_calc_vec_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2072-2105",
          "snippet": "static int\nxlog_write_calc_vec_length(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\theaders = 0;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\t/* acct for start rec of xact */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\theaders++;\n\n\tfor (lv = log_vector; lv; lv = lv->lv_next) {\n\t\t/* we don't write ordered log vectors */\n\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED)\n\t\t\tcontinue;\n\n\t\theaders += lv->lv_niovecs;\n\n\t\tfor (i = 0; i < lv->lv_niovecs; i++) {\n\t\t\tstruct xfs_log_iovec\t*vecp = &lv->lv_iovecp[i];\n\n\t\t\tlen += vecp->i_len;\n\t\t\txlog_tic_add_region(ticket, vecp->i_len, vecp->i_type);\n\t\t}\n\t}\n\n\tticket->t_res_num_ophdrs += headers;\n\tlen += headers * sizeof(struct xlog_op_header);\n\n\treturn len;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_calc_vec_length(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\theaders = 0;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\t/* acct for start rec of xact */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\theaders++;\n\n\tfor (lv = log_vector; lv; lv = lv->lv_next) {\n\t\t/* we don't write ordered log vectors */\n\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED)\n\t\t\tcontinue;\n\n\t\theaders += lv->lv_niovecs;\n\n\t\tfor (i = 0; i < lv->lv_niovecs; i++) {\n\t\t\tstruct xfs_log_iovec\t*vecp = &lv->lv_iovecp[i];\n\n\t\t\tlen += vecp->i_len;\n\t\t\txlog_tic_add_region(ticket, vecp->i_len, vecp->i_type);\n\t\t}\n\t}\n\n\tticket->t_res_num_ophdrs += headers;\n\tlen += headers * sizeof(struct xlog_op_header);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_write_copy_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2213-2256",
    "snippet": "static int\nxlog_write_copy_finish(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tuint\t\t\tflags,\n\tint\t\t\t*record_cnt,\n\tint\t\t\t*data_cnt,\n\tint\t\t\t*partial_copy,\n\tint\t\t\t*partial_copy_len,\n\tint\t\t\tlog_offset,\n\tstruct xlog_in_core\t**commit_iclog)\n{\n\tif (*partial_copy) {\n\t\t/*\n\t\t * This iclog has already been marked WANT_SYNC by\n\t\t * xlog_state_get_iclog_space.\n\t\t */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\t\treturn xlog_state_release_iclog(log, iclog);\n\t}\n\n\t*partial_copy = 0;\n\t*partial_copy_len = 0;\n\n\tif (iclog->ic_size - log_offset <= sizeof(xlog_op_header_t)) {\n\t\t/* no more space in this iclog - push it. */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\n\t\tif (!commit_iclog)\n\t\t\treturn xlog_state_release_iclog(log, iclog);\n\t\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t\t*commit_iclog = iclog;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XLOG_COMMIT_TRANS"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_want_sync",
          "args": [
            "log",
            "iclog"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_want_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3470-3483",
          "snippet": "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_finish_copy",
          "args": [
            "log",
            "iclog",
            "*record_cnt",
            "*data_cnt"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_finish_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1939-1952",
          "snippet": "static inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_copy_finish(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tuint\t\t\tflags,\n\tint\t\t\t*record_cnt,\n\tint\t\t\t*data_cnt,\n\tint\t\t\t*partial_copy,\n\tint\t\t\t*partial_copy_len,\n\tint\t\t\tlog_offset,\n\tstruct xlog_in_core\t**commit_iclog)\n{\n\tif (*partial_copy) {\n\t\t/*\n\t\t * This iclog has already been marked WANT_SYNC by\n\t\t * xlog_state_get_iclog_space.\n\t\t */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\t\treturn xlog_state_release_iclog(log, iclog);\n\t}\n\n\t*partial_copy = 0;\n\t*partial_copy_len = 0;\n\n\tif (iclog->ic_size - log_offset <= sizeof(xlog_op_header_t)) {\n\t\t/* no more space in this iclog - push it. */\n\t\txlog_state_finish_copy(log, iclog, *record_cnt, *data_cnt);\n\t\t*record_cnt = 0;\n\t\t*data_cnt = 0;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\n\t\tif (!commit_iclog)\n\t\t\treturn xlog_state_release_iclog(log, iclog);\n\t\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t\t*commit_iclog = iclog;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_write_setup_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2170-2211",
    "snippet": "static int\nxlog_write_setup_copy(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_op_header\t*ophdr,\n\tint\t\t\tspace_available,\n\tint\t\t\tspace_required,\n\tint\t\t\t*copy_off,\n\tint\t\t\t*copy_len,\n\tint\t\t\t*last_was_partial_copy,\n\tint\t\t\t*bytes_consumed)\n{\n\tint\t\t\tstill_to_copy;\n\n\tstill_to_copy = space_required - *bytes_consumed;\n\t*copy_off = *bytes_consumed;\n\n\tif (still_to_copy <= space_available) {\n\t\t/* write of region completes here */\n\t\t*copy_len = still_to_copy;\n\t\tophdr->oh_len = cpu_to_be32(*copy_len);\n\t\tif (*last_was_partial_copy)\n\t\t\tophdr->oh_flags |= (XLOG_END_TRANS|XLOG_WAS_CONT_TRANS);\n\t\t*last_was_partial_copy = 0;\n\t\t*bytes_consumed = 0;\n\t\treturn 0;\n\t}\n\n\t/* partial write of region, needs extra log op header reservation */\n\t*copy_len = space_available;\n\tophdr->oh_len = cpu_to_be32(*copy_len);\n\tophdr->oh_flags |= XLOG_CONTINUE_TRANS;\n\tif (*last_was_partial_copy)\n\t\tophdr->oh_flags |= XLOG_WAS_CONT_TRANS;\n\t*bytes_consumed += *copy_len;\n\t(*last_was_partial_copy)++;\n\n\t/* account for new log op header */\n\tticket->t_curr_res -= sizeof(struct xlog_op_header);\n\tticket->t_res_num_ophdrs++;\n\n\treturn sizeof(struct xlog_op_header);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "*copy_len"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "*copy_len"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_setup_copy(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_op_header\t*ophdr,\n\tint\t\t\tspace_available,\n\tint\t\t\tspace_required,\n\tint\t\t\t*copy_off,\n\tint\t\t\t*copy_len,\n\tint\t\t\t*last_was_partial_copy,\n\tint\t\t\t*bytes_consumed)\n{\n\tint\t\t\tstill_to_copy;\n\n\tstill_to_copy = space_required - *bytes_consumed;\n\t*copy_off = *bytes_consumed;\n\n\tif (still_to_copy <= space_available) {\n\t\t/* write of region completes here */\n\t\t*copy_len = still_to_copy;\n\t\tophdr->oh_len = cpu_to_be32(*copy_len);\n\t\tif (*last_was_partial_copy)\n\t\t\tophdr->oh_flags |= (XLOG_END_TRANS|XLOG_WAS_CONT_TRANS);\n\t\t*last_was_partial_copy = 0;\n\t\t*bytes_consumed = 0;\n\t\treturn 0;\n\t}\n\n\t/* partial write of region, needs extra log op header reservation */\n\t*copy_len = space_available;\n\tophdr->oh_len = cpu_to_be32(*copy_len);\n\tophdr->oh_flags |= XLOG_CONTINUE_TRANS;\n\tif (*last_was_partial_copy)\n\t\tophdr->oh_flags |= XLOG_WAS_CONT_TRANS;\n\t*bytes_consumed += *copy_len;\n\t(*last_was_partial_copy)++;\n\n\t/* account for new log op header */\n\tticket->t_curr_res -= sizeof(struct xlog_op_header);\n\tticket->t_res_num_ophdrs++;\n\n\treturn sizeof(struct xlog_op_header);\n}"
  },
  {
    "function_name": "xlog_write_setup_ophdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2130-2162",
    "snippet": "static xlog_op_header_t *\nxlog_write_setup_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket,\n\tuint\t\t\tflags)\n{\n\tophdr->oh_tid = cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_res2 = 0;\n\n\t/* are we copying a commit or unmount record? */\n\tophdr->oh_flags = flags;\n\n\t/*\n\t * We've seen logs corrupted with bad transaction client ids.  This\n\t * makes sure that XFS doesn't generate them on.  Turn this into an EIO\n\t * and shut down the filesystem.\n\t */\n\tswitch (ophdr->oh_clientid)  {\n\tcase XFS_TRANSACTION:\n\tcase XFS_VOLUME:\n\tcase XFS_LOG:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Bad XFS transaction clientid 0x%x in ticket 0x%p\",\n\t\t\tophdr->oh_clientid, ticket);\n\t\treturn NULL;\n\t}\n\n\treturn ophdr;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "log->l_mp",
            "\"Bad XFS transaction clientid 0x%x in ticket 0x%p\"",
            "ophdr->oh_clientid",
            "ticket"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ticket->t_tid"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic xlog_op_header_t *\nxlog_write_setup_ophdr(\n\tstruct xlog\t\t*log,\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket,\n\tuint\t\t\tflags)\n{\n\tophdr->oh_tid = cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_res2 = 0;\n\n\t/* are we copying a commit or unmount record? */\n\tophdr->oh_flags = flags;\n\n\t/*\n\t * We've seen logs corrupted with bad transaction client ids.  This\n\t * makes sure that XFS doesn't generate them on.  Turn this into an EIO\n\t * and shut down the filesystem.\n\t */\n\tswitch (ophdr->oh_clientid)  {\n\tcase XFS_TRANSACTION:\n\tcase XFS_VOLUME:\n\tcase XFS_LOG:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(log->l_mp,\n\t\t\t\"Bad XFS transaction clientid 0x%x in ticket 0x%p\",\n\t\t\tophdr->oh_clientid, ticket);\n\t\treturn NULL;\n\t}\n\n\treturn ophdr;\n}"
  },
  {
    "function_name": "xlog_write_start_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2111-2128",
    "snippet": "static int\nxlog_write_start_rec(\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket)\n{\n\tif (!(ticket->t_flags & XLOG_TIC_INITED))\n\t\treturn 0;\n\n\tophdr->oh_tid\t= cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_len = 0;\n\tophdr->oh_flags = XLOG_START_TRANS;\n\tophdr->oh_res2 = 0;\n\n\tticket->t_flags &= ~XLOG_TIC_INITED;\n\n\treturn sizeof(struct xlog_op_header);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ticket->t_tid"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nstatic int\nxlog_write_start_rec(\n\tstruct xlog_op_header\t*ophdr,\n\tstruct xlog_ticket\t*ticket)\n{\n\tif (!(ticket->t_flags & XLOG_TIC_INITED))\n\t\treturn 0;\n\n\tophdr->oh_tid\t= cpu_to_be32(ticket->t_tid);\n\tophdr->oh_clientid = ticket->t_clientid;\n\tophdr->oh_len = 0;\n\tophdr->oh_flags = XLOG_START_TRANS;\n\tophdr->oh_res2 = 0;\n\n\tticket->t_flags &= ~XLOG_TIC_INITED;\n\n\treturn sizeof(struct xlog_op_header);\n}"
  },
  {
    "function_name": "xlog_write_calc_vec_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "2072-2105",
    "snippet": "static int\nxlog_write_calc_vec_length(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\theaders = 0;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\t/* acct for start rec of xact */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\theaders++;\n\n\tfor (lv = log_vector; lv; lv = lv->lv_next) {\n\t\t/* we don't write ordered log vectors */\n\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED)\n\t\t\tcontinue;\n\n\t\theaders += lv->lv_niovecs;\n\n\t\tfor (i = 0; i < lv->lv_niovecs; i++) {\n\t\t\tstruct xfs_log_iovec\t*vecp = &lv->lv_iovecp[i];\n\n\t\t\tlen += vecp->i_len;\n\t\t\txlog_tic_add_region(ticket, vecp->i_len, vecp->i_type);\n\t\t}\n\t}\n\n\tticket->t_res_num_ophdrs += headers;\n\tlen += headers * sizeof(struct xlog_op_header);\n\n\treturn len;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_tic_add_region",
          "args": [
            "ticket",
            "vecp->i_len",
            "vecp->i_type"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_tic_add_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "351-365",
          "snippet": "static void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic int\nxlog_write_calc_vec_length(\n\tstruct xlog_ticket\t*ticket,\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\theaders = 0;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\t/* acct for start rec of xact */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\theaders++;\n\n\tfor (lv = log_vector; lv; lv = lv->lv_next) {\n\t\t/* we don't write ordered log vectors */\n\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED)\n\t\t\tcontinue;\n\n\t\theaders += lv->lv_niovecs;\n\n\t\tfor (i = 0; i < lv->lv_niovecs; i++) {\n\t\t\tstruct xfs_log_iovec\t*vecp = &lv->lv_iovecp[i];\n\n\t\t\tlen += vecp->i_len;\n\t\t\txlog_tic_add_region(ticket, vecp->i_len, vecp->i_type);\n\t\t}\n\t}\n\n\tticket->t_res_num_ophdrs += headers;\n\tlen += headers * sizeof(struct xlog_op_header);\n\n\treturn len;\n}"
  },
  {
    "function_name": "xlog_print_tic_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1961-2066",
    "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "mp",
            "XFS_PTAG_LOGRES",
            "\"xlog_write: reservation ran out. Need to up reservation\""
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"region[%u]: %s - %u bytes\"",
            "i",
            "((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1])",
            "ticket->t_res_arr[i].r_len"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\"",
            "((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1])",
            "ticket->t_trans_type",
            "ticket->t_unit_res",
            "ticket->t_curr_res",
            "ticket->t_res_arr_sum",
            "ticket->t_res_o_flow",
            "ticket->t_res_num_ophdrs",
            "ophdr_spc",
            "ticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc",
            "ticket->t_res_num"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
  },
  {
    "function_name": "xlog_state_finish_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1939-1952",
    "snippet": "static inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&iclog->ic_header.h_num_logops",
            "record_cnt"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline void\nxlog_state_finish_copy(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\trecord_cnt,\n\tint\t\t\tcopy_bytes)\n{\n\tspin_lock(&log->l_icloglock);\n\n\tbe32_add_cpu(&iclog->ic_header.h_num_logops, record_cnt);\n\ticlog->ic_offset += copy_bytes;\n\n\tspin_unlock(&log->l_icloglock);\n}"
  },
  {
    "function_name": "xlog_dealloc_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1892-1933",
    "snippet": "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "log"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spinlock_destroy",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_free",
          "args": [
            "iclog->ic_bp"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "255-280",
          "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_set_empty",
          "args": [
            "log->l_xbuf",
            "BTOBB(log->l_iclog_size)"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "728-746",
          "snippet": "void\nxfs_buf_set_empty(\n\tstruct xfs_buf\t\t*bp,\n\tsize_t\t\t\tnumblks)\n{\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_page_count = 0;\n\tbp->b_addr = NULL;\n\tbp->b_length = numblks;\n\tbp->b_io_length = numblks;\n\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_len = bp->b_length;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_set_empty(\n\tstruct xfs_buf\t\t*bp,\n\tsize_t\t\t\tnumblks)\n{\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_page_count = 0;\n\tbp->b_addr = NULL;\n\tbp->b_length = numblks;\n\tbp->b_io_length = numblks;\n\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_len = bp->b_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_iclog_size"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "log->l_xbuf"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "log->l_xbuf"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_destroy",
          "args": [
            "log"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "985-997",
          "snippet": "void\nxlog_cil_destroy(\n\tstruct xlog\t*log)\n{\n\tif (log->l_cilp->xc_ctx) {\n\t\tif (log->l_cilp->xc_ctx->ticket)\n\t\t\txfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\n\t\tkmem_free(log->l_cilp->xc_ctx);\n\t}\n\n\tASSERT(list_empty(&log->l_cilp->xc_cil));\n\tkmem_free(log->l_cilp);\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxlog_cil_destroy(\n\tstruct xlog\t*log)\n{\n\tif (log->l_cilp->xc_ctx) {\n\t\tif (log->l_cilp->xc_ctx->ticket)\n\t\t\txfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\n\t\tkmem_free(log->l_cilp->xc_ctx);\n\t}\n\n\tASSERT(list_empty(&log->l_cilp->xc_cil));\n\tkmem_free(log->l_cilp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}"
  },
  {
    "function_name": "xlog_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1734-1887",
    "snippet": "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\txfs_buf_t\t*bp;\n\tint\t\ti;\n\tuint\t\tcount;\t\t/* byte count of bwrite */\n\tuint\t\tcount_init;\t/* initial count before roundup */\n\tint\t\troundoff;       /* roundoff to BB or stripe */\n\tint\t\tsplit = 0;\t/* split write into two regions */\n\tint\t\terror;\n\tint\t\tv2 = xfs_sb_version_haslogv2(&log->l_mp->m_sb);\n\tint\t\tsize;\n\n\tXFS_STATS_INC(xs_log_writes);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\n\t/* Add for LR header */\n\tcount_init = log->l_iclog_hsize + iclog->ic_offset;\n\n\t/* Round out the log write size */\n\tif (v2 && log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t/* we have a v2 stripe unit to use */\n\t\tcount = XLOG_LSUNITTOB(log, XLOG_BTOLSUNIT(log, count_init));\n\t} else {\n\t\tcount = BBTOB(BTOBB(count_init));\n\t}\n\troundoff = count - count_init;\n\tASSERT(roundoff >= 0);\n\tASSERT((v2 && log->l_mp->m_sb.sb_logsunit > 1 && \n                roundoff < log->l_mp->m_sb.sb_logsunit)\n\t\t|| \n\t\t(log->l_mp->m_sb.sb_logsunit <= 1 && \n\t\t roundoff < BBTOB(1)));\n\n\t/* move grant heads by roundoff in sync */\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, roundoff);\n\txlog_grant_add_space(log, &log->l_write_head.grant, roundoff);\n\n\t/* put cycle number in every block */\n\txlog_pack_data(log, iclog, roundoff); \n\n\t/* real byte length */\n\tsize = iclog->ic_offset;\n\tif (v2)\n\t\tsize += roundoff;\n\ticlog->ic_header.h_len = cpu_to_be32(size);\n\n\tbp = iclog->ic_bp;\n\tXFS_BUF_SET_ADDR(bp, BLOCK_LSN(be64_to_cpu(iclog->ic_header.h_lsn)));\n\n\tXFS_STATS_ADD(xs_log_blocks, BTOBB(count));\n\n\t/* Do we need to split this write into 2 parts? */\n\tif (XFS_BUF_ADDR(bp) + BTOBB(count) > log->l_logBBsize) {\n\t\tchar\t\t*dptr;\n\n\t\tsplit = count - (BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp)));\n\t\tcount = BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp));\n\t\ticlog->ic_bwritecnt = 2;\n\n\t\t/*\n\t\t * Bump the cycle numbers at the start of each block in the\n\t\t * part of the iclog that ends up in the buffer that gets\n\t\t * written to the start of the log.\n\t\t *\n\t\t * Watch out for the header magic number case, though.\n\t\t */\n\t\tdptr = (char *)&iclog->ic_header + count;\n\t\tfor (i = 0; i < split; i += BBSIZE) {\n\t\t\t__uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);\n\t\t\tif (++cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\t\tcycle++;\n\t\t\t*(__be32 *)dptr = cpu_to_be32(cycle);\n\n\t\t\tdptr += BBSIZE;\n\t\t}\n\t} else {\n\t\ticlog->ic_bwritecnt = 1;\n\t}\n\n\t/* calculcate the checksum */\n\ticlog->ic_header.h_crc = xlog_cksum(log, &iclog->ic_header,\n\t\t\t\t\t    iclog->ic_datap, size);\n\n\tbp->b_io_length = BTOBB(count);\n\tbp->b_fspriv = iclog;\n\tXFS_BUF_ZEROFLAGS(bp);\n\tXFS_BUF_ASYNC(bp);\n\tbp->b_flags |= XBF_SYNCIO;\n\n\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\tbp->b_flags |= XBF_FUA;\n\n\t\t/*\n\t\t * Flush the data device before flushing the log to make\n\t\t * sure all meta data written back from the AIL actually made\n\t\t * it to disk before stamping the new log tail LSN into the\n\t\t * log buffer.  For an external log we need to issue the\n\t\t * flush explicitly, and unfortunately synchronously here;\n\t\t * for an internal log we can simply use the block layer\n\t\t * state machine for preflushes.\n\t\t */\n\t\tif (log->l_mp->m_logdev_targp != log->l_mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(log->l_mp->m_ddev_targp);\n\t\telse\n\t\t\tbp->b_flags |= XBF_FLUSH;\n\t}\n\n\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\txlog_verify_iclog(log, iclog, count, true);\n\n\t/* account for log which doesn't start at block #0 */\n\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t/*\n\t * Don't call xfs_bwrite here. We do log-syncs even when the filesystem\n\t * is shutting down.\n\t */\n\tXFS_BUF_WRITE(bp);\n\n\terror = xlog_bdstrat(bp);\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_sync\");\n\t\treturn error;\n\t}\n\tif (split) {\n\t\tbp = iclog->ic_log->l_xbuf;\n\t\tXFS_BUF_SET_ADDR(bp, 0);\t     /* logical 0 */\n\t\txfs_buf_associate_memory(bp,\n\t\t\t\t(char *)&iclog->ic_header + count, split);\n\t\tbp->b_fspriv = iclog;\n\t\tXFS_BUF_ZEROFLAGS(bp);\n\t\tXFS_BUF_ASYNC(bp);\n\t\tbp->b_flags |= XBF_SYNCIO;\n\t\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER)\n\t\t\tbp->b_flags |= XBF_FUA;\n\n\t\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\t\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\t\t/* account for internal log which doesn't start at block #0 */\n\t\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t\tXFS_BUF_WRITE(bp);\n\t\terror = xlog_bdstrat(bp);\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, \"xlog_sync (split)\");\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "\"xlog_sync (split)\""
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_bdstrat",
          "args": [
            "bp"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_bdstrat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1685-1707",
          "snippet": "STATIC int\nxlog_bdstrat(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\n\txfs_buf_lock(bp);\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\t/*\n\t\t * It would seem logical to return EIO here, but we rely on\n\t\t * the log state machine to propagate I/O errors instead of\n\t\t * doing it here. Similarly, IO completion will unlock the\n\t\t * buffer, so we don't do it here.\n\t\t */\n\t\treturn 0;\n\t}\n\n\txfs_buf_submit(bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_bdstrat(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\n\txfs_buf_lock(bp);\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\t/*\n\t\t * It would seem logical to return EIO here, but we rely on\n\t\t * the log state machine to propagate I/O errors instead of\n\t\t * doing it here. Similarly, IO completion will unlock the\n\t\t * buffer, so we don't do it here.\n\t\t */\n\t\treturn 0;\n\t}\n\n\txfs_buf_submit(bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_WRITE",
          "args": [
            "bp"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "XFS_BUF_ADDR(bp) + log->l_logBBstart"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ADDR(bp) <= log->l_logBBsize-1"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ASYNC",
          "args": [
            "bp"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ZEROFLAGS",
          "args": [
            "bp"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_associate_memory",
          "args": [
            "bp",
            "(char *)&iclog->ic_header + count",
            "split"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_associate_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "759-799",
          "snippet": "int\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "0"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_WRITE",
          "args": [
            "bp"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "XFS_BUF_ADDR(bp) + log->l_logBBstart"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_verify_iclog",
          "args": [
            "log",
            "iclog",
            "count",
            "true"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_verify_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3760-3849",
          "snippet": "STATIC void\nxlog_verify_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\tcount,\n\tbool                    syncing)\n{\n\txlog_op_header_t\t*ophead;\n\txlog_in_core_t\t\t*icptr;\n\txlog_in_core_2_t\t*xhdr;\n\txfs_caddr_t\t\tptr;\n\txfs_caddr_t\t\tbase_ptr;\n\t__psint_t\t\tfield_offset;\n\t__uint8_t\t\tclientid;\n\tint\t\t\tlen, i, j, k, op_len;\n\tint\t\t\tidx;\n\n\t/* check validity of iclog pointers */\n\tspin_lock(&log->l_icloglock);\n\ticptr = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++, icptr = icptr->ic_next)\n\t\tASSERT(icptr);\n\n\tif (icptr != log->l_iclog)\n\t\txfs_emerg(log->l_mp, \"%s: corrupt iclog ring\", __func__);\n\tspin_unlock(&log->l_icloglock);\n\n\t/* check log magic numbers */\n\tif (iclog->ic_header.h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\txfs_emerg(log->l_mp, \"%s: invalid magic num\", __func__);\n\n\tptr = (xfs_caddr_t) &iclog->ic_header;\n\tfor (ptr += BBSIZE; ptr < ((xfs_caddr_t)&iclog->ic_header) + count;\n\t     ptr += BBSIZE) {\n\t\tif (*(__be32 *)ptr == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\txfs_emerg(log->l_mp, \"%s: unexpected magic num\",\n\t\t\t\t__func__);\n\t}\n\n\t/* check fields */\n\tlen = be32_to_cpu(iclog->ic_header.h_num_logops);\n\tptr = iclog->ic_datap;\n\tbase_ptr = ptr;\n\tophead = (xlog_op_header_t *)ptr;\n\txhdr = iclog->ic_data;\n\tfor (i = 0; i < len; i++) {\n\t\tophead = (xlog_op_header_t *)ptr;\n\n\t\t/* clientid is only 1 byte */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_clientid) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\tclientid = ophead->oh_clientid;\n\t\t} else {\n\t\t\tidx = BTOBBT((xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\txhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\ticlog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tif (clientid != XFS_TRANSACTION && clientid != XFS_LOG)\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: invalid clientid %d op 0x%p offset 0x%lx\",\n\t\t\t\t__func__, clientid, ophead,\n\t\t\t\t(unsigned long)field_offset);\n\n\t\t/* check length */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_len) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\top_len = be32_to_cpu(ophead->oh_len);\n\t\t} else {\n\t\t\tidx = BTOBBT((__psint_t)&ophead->oh_len -\n\t\t\t\t    (__psint_t)iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\top_len = be32_to_cpu(xhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\top_len = be32_to_cpu(iclog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tptr += sizeof(xlog_op_header_t) + op_len;\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\tcount,\n\tbool                    syncing)\n{\n\txlog_op_header_t\t*ophead;\n\txlog_in_core_t\t\t*icptr;\n\txlog_in_core_2_t\t*xhdr;\n\txfs_caddr_t\t\tptr;\n\txfs_caddr_t\t\tbase_ptr;\n\t__psint_t\t\tfield_offset;\n\t__uint8_t\t\tclientid;\n\tint\t\t\tlen, i, j, k, op_len;\n\tint\t\t\tidx;\n\n\t/* check validity of iclog pointers */\n\tspin_lock(&log->l_icloglock);\n\ticptr = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++, icptr = icptr->ic_next)\n\t\tASSERT(icptr);\n\n\tif (icptr != log->l_iclog)\n\t\txfs_emerg(log->l_mp, \"%s: corrupt iclog ring\", __func__);\n\tspin_unlock(&log->l_icloglock);\n\n\t/* check log magic numbers */\n\tif (iclog->ic_header.h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\txfs_emerg(log->l_mp, \"%s: invalid magic num\", __func__);\n\n\tptr = (xfs_caddr_t) &iclog->ic_header;\n\tfor (ptr += BBSIZE; ptr < ((xfs_caddr_t)&iclog->ic_header) + count;\n\t     ptr += BBSIZE) {\n\t\tif (*(__be32 *)ptr == cpu_to_be32(XLOG_HEADER_MAGIC_NUM))\n\t\t\txfs_emerg(log->l_mp, \"%s: unexpected magic num\",\n\t\t\t\t__func__);\n\t}\n\n\t/* check fields */\n\tlen = be32_to_cpu(iclog->ic_header.h_num_logops);\n\tptr = iclog->ic_datap;\n\tbase_ptr = ptr;\n\tophead = (xlog_op_header_t *)ptr;\n\txhdr = iclog->ic_data;\n\tfor (i = 0; i < len; i++) {\n\t\tophead = (xlog_op_header_t *)ptr;\n\n\t\t/* clientid is only 1 byte */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_clientid) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\tclientid = ophead->oh_clientid;\n\t\t} else {\n\t\t\tidx = BTOBBT((xfs_caddr_t)&(ophead->oh_clientid) - iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\txhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\tclientid = xlog_get_client_id(\n\t\t\t\t\ticlog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tif (clientid != XFS_TRANSACTION && clientid != XFS_LOG)\n\t\t\txfs_warn(log->l_mp,\n\t\t\t\t\"%s: invalid clientid %d op 0x%p offset 0x%lx\",\n\t\t\t\t__func__, clientid, ophead,\n\t\t\t\t(unsigned long)field_offset);\n\n\t\t/* check length */\n\t\tfield_offset = (__psint_t)\n\t\t\t       ((xfs_caddr_t)&(ophead->oh_len) - base_ptr);\n\t\tif (!syncing || (field_offset & 0x1ff)) {\n\t\t\top_len = be32_to_cpu(ophead->oh_len);\n\t\t} else {\n\t\t\tidx = BTOBBT((__psint_t)&ophead->oh_len -\n\t\t\t\t    (__psint_t)iclog->ic_datap);\n\t\t\tif (idx >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE)) {\n\t\t\t\tj = idx / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\tk = idx % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\t\top_len = be32_to_cpu(xhdr[j].hic_xheader.xh_cycle_data[k]);\n\t\t\t} else {\n\t\t\t\top_len = be32_to_cpu(iclog->ic_header.h_cycle_data[idx]);\n\t\t\t}\n\t\t}\n\t\tptr += sizeof(xlog_op_header_t) + op_len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ADDR(bp) <= log->l_logBBsize-1"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_blkdev_issue_flush",
          "args": [
            "log->l_mp->m_ddev_targp"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_issue_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "702-707",
          "snippet": "void\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ASYNC",
          "args": [
            "bp"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ZEROFLAGS",
          "args": [
            "bp"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cksum",
          "args": [
            "log",
            "&iclog->ic_header",
            "iclog->ic_datap",
            "size"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1640-1669",
          "snippet": "__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\n__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cycle"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)dptr"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "log->l_logBBsize - XFS_BUF_ADDR(bp)"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "log->l_logBBsize - XFS_BUF_ADDR(bp)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_log_blocks",
            "BTOBB(count)"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_SET_ADDR",
          "args": [
            "bp",
            "BLOCK_LSN(be64_to_cpu(iclog->ic_header.h_lsn))"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "be64_to_cpu(iclog->ic_header.h_lsn)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "size"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_pack_data",
          "args": [
            "log",
            "iclog",
            "roundoff"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_pack_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1596-1632",
          "snippet": "STATIC void\nxlog_pack_data(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\troundoff)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\tsize = iclog->ic_offset + roundoff;\n\t__be32\t\t\tcycle_lsn;\n\txfs_caddr_t\t\tdp;\n\n\tcycle_lsn = CYCLE_LSN_DISK(iclog->ic_header.h_lsn);\n\n\tdp = iclog->ic_datap;\n\tfor (i = 0; i < BTOBB(size); i++) {\n\t\tif (i >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE))\n\t\t\tbreak;\n\t\ticlog->ic_header.h_cycle_data[i] = *(__be32 *)dp;\n\t\t*(__be32 *)dp = cycle_lsn;\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = iclog->ic_data;\n\n\t\tfor ( ; i < BTOBB(size); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\txhdr[j].hic_xheader.xh_cycle_data[k] = *(__be32 *)dp;\n\t\t\t*(__be32 *)dp = cycle_lsn;\n\t\t\tdp += BBSIZE;\n\t\t}\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++)\n\t\t\txhdr[i].hic_xheader.xh_cycle = cycle_lsn;\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_pack_data(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\troundoff)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\tsize = iclog->ic_offset + roundoff;\n\t__be32\t\t\tcycle_lsn;\n\txfs_caddr_t\t\tdp;\n\n\tcycle_lsn = CYCLE_LSN_DISK(iclog->ic_header.h_lsn);\n\n\tdp = iclog->ic_datap;\n\tfor (i = 0; i < BTOBB(size); i++) {\n\t\tif (i >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE))\n\t\t\tbreak;\n\t\ticlog->ic_header.h_cycle_data[i] = *(__be32 *)dp;\n\t\t*(__be32 *)dp = cycle_lsn;\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = iclog->ic_data;\n\n\t\tfor ( ; i < BTOBB(size); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\txhdr[j].hic_xheader.xh_cycle_data[k] = *(__be32 *)dp;\n\t\t\t*(__be32 *)dp = cycle_lsn;\n\t\t\tdp += BBSIZE;\n\t\t}\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++)\n\t\t\txhdr[i].hic_xheader.xh_cycle = cycle_lsn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_add_space",
          "args": [
            "log",
            "&log->l_write_head.grant",
            "roundoff"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_add_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "164-191",
          "snippet": "static void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(v2 && log->l_mp->m_sb.sb_logsunit > 1 && \n                roundoff < log->l_mp->m_sb.sb_logsunit)\n\t\t|| \n\t\t(log->l_mp->m_sb.sb_logsunit <= 1 && \n\t\t roundoff < BBTOB(1))"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "1"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "roundoff >= 0"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "BTOBB(count_init)"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "count_init"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_LSUNITTOB",
          "args": [
            "log",
            "XLOG_BTOLSUNIT(log, count_init)"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_BTOLSUNIT",
          "args": [
            "log",
            "count_init"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&iclog->ic_refcnt) == 0"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_log_writes"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\txfs_buf_t\t*bp;\n\tint\t\ti;\n\tuint\t\tcount;\t\t/* byte count of bwrite */\n\tuint\t\tcount_init;\t/* initial count before roundup */\n\tint\t\troundoff;       /* roundoff to BB or stripe */\n\tint\t\tsplit = 0;\t/* split write into two regions */\n\tint\t\terror;\n\tint\t\tv2 = xfs_sb_version_haslogv2(&log->l_mp->m_sb);\n\tint\t\tsize;\n\n\tXFS_STATS_INC(xs_log_writes);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\n\t/* Add for LR header */\n\tcount_init = log->l_iclog_hsize + iclog->ic_offset;\n\n\t/* Round out the log write size */\n\tif (v2 && log->l_mp->m_sb.sb_logsunit > 1) {\n\t\t/* we have a v2 stripe unit to use */\n\t\tcount = XLOG_LSUNITTOB(log, XLOG_BTOLSUNIT(log, count_init));\n\t} else {\n\t\tcount = BBTOB(BTOBB(count_init));\n\t}\n\troundoff = count - count_init;\n\tASSERT(roundoff >= 0);\n\tASSERT((v2 && log->l_mp->m_sb.sb_logsunit > 1 && \n                roundoff < log->l_mp->m_sb.sb_logsunit)\n\t\t|| \n\t\t(log->l_mp->m_sb.sb_logsunit <= 1 && \n\t\t roundoff < BBTOB(1)));\n\n\t/* move grant heads by roundoff in sync */\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, roundoff);\n\txlog_grant_add_space(log, &log->l_write_head.grant, roundoff);\n\n\t/* put cycle number in every block */\n\txlog_pack_data(log, iclog, roundoff); \n\n\t/* real byte length */\n\tsize = iclog->ic_offset;\n\tif (v2)\n\t\tsize += roundoff;\n\ticlog->ic_header.h_len = cpu_to_be32(size);\n\n\tbp = iclog->ic_bp;\n\tXFS_BUF_SET_ADDR(bp, BLOCK_LSN(be64_to_cpu(iclog->ic_header.h_lsn)));\n\n\tXFS_STATS_ADD(xs_log_blocks, BTOBB(count));\n\n\t/* Do we need to split this write into 2 parts? */\n\tif (XFS_BUF_ADDR(bp) + BTOBB(count) > log->l_logBBsize) {\n\t\tchar\t\t*dptr;\n\n\t\tsplit = count - (BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp)));\n\t\tcount = BBTOB(log->l_logBBsize - XFS_BUF_ADDR(bp));\n\t\ticlog->ic_bwritecnt = 2;\n\n\t\t/*\n\t\t * Bump the cycle numbers at the start of each block in the\n\t\t * part of the iclog that ends up in the buffer that gets\n\t\t * written to the start of the log.\n\t\t *\n\t\t * Watch out for the header magic number case, though.\n\t\t */\n\t\tdptr = (char *)&iclog->ic_header + count;\n\t\tfor (i = 0; i < split; i += BBSIZE) {\n\t\t\t__uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);\n\t\t\tif (++cycle == XLOG_HEADER_MAGIC_NUM)\n\t\t\t\tcycle++;\n\t\t\t*(__be32 *)dptr = cpu_to_be32(cycle);\n\n\t\t\tdptr += BBSIZE;\n\t\t}\n\t} else {\n\t\ticlog->ic_bwritecnt = 1;\n\t}\n\n\t/* calculcate the checksum */\n\ticlog->ic_header.h_crc = xlog_cksum(log, &iclog->ic_header,\n\t\t\t\t\t    iclog->ic_datap, size);\n\n\tbp->b_io_length = BTOBB(count);\n\tbp->b_fspriv = iclog;\n\tXFS_BUF_ZEROFLAGS(bp);\n\tXFS_BUF_ASYNC(bp);\n\tbp->b_flags |= XBF_SYNCIO;\n\n\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\tbp->b_flags |= XBF_FUA;\n\n\t\t/*\n\t\t * Flush the data device before flushing the log to make\n\t\t * sure all meta data written back from the AIL actually made\n\t\t * it to disk before stamping the new log tail LSN into the\n\t\t * log buffer.  For an external log we need to issue the\n\t\t * flush explicitly, and unfortunately synchronously here;\n\t\t * for an internal log we can simply use the block layer\n\t\t * state machine for preflushes.\n\t\t */\n\t\tif (log->l_mp->m_logdev_targp != log->l_mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(log->l_mp->m_ddev_targp);\n\t\telse\n\t\t\tbp->b_flags |= XBF_FLUSH;\n\t}\n\n\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\txlog_verify_iclog(log, iclog, count, true);\n\n\t/* account for log which doesn't start at block #0 */\n\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t/*\n\t * Don't call xfs_bwrite here. We do log-syncs even when the filesystem\n\t * is shutting down.\n\t */\n\tXFS_BUF_WRITE(bp);\n\n\terror = xlog_bdstrat(bp);\n\tif (error) {\n\t\txfs_buf_ioerror_alert(bp, \"xlog_sync\");\n\t\treturn error;\n\t}\n\tif (split) {\n\t\tbp = iclog->ic_log->l_xbuf;\n\t\tXFS_BUF_SET_ADDR(bp, 0);\t     /* logical 0 */\n\t\txfs_buf_associate_memory(bp,\n\t\t\t\t(char *)&iclog->ic_header + count, split);\n\t\tbp->b_fspriv = iclog;\n\t\tXFS_BUF_ZEROFLAGS(bp);\n\t\tXFS_BUF_ASYNC(bp);\n\t\tbp->b_flags |= XBF_SYNCIO;\n\t\tif (log->l_mp->m_flags & XFS_MOUNT_BARRIER)\n\t\t\tbp->b_flags |= XBF_FUA;\n\n\t\tASSERT(XFS_BUF_ADDR(bp) <= log->l_logBBsize-1);\n\t\tASSERT(XFS_BUF_ADDR(bp) + BTOBB(count) <= log->l_logBBsize);\n\n\t\t/* account for internal log which doesn't start at block #0 */\n\t\tXFS_BUF_SET_ADDR(bp, XFS_BUF_ADDR(bp) + log->l_logBBstart);\n\t\tXFS_BUF_WRITE(bp);\n\t\terror = xlog_bdstrat(bp);\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, \"xlog_sync (split)\");\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_bdstrat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1685-1707",
    "snippet": "STATIC int\nxlog_bdstrat(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\n\txfs_buf_lock(bp);\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\t/*\n\t\t * It would seem logical to return EIO here, but we rely on\n\t\t * the log state machine to propagate I/O errors instead of\n\t\t * doing it here. Similarly, IO completion will unlock the\n\t\t * buffer, so we don't do it here.\n\t\t */\n\t\treturn 0;\n\t}\n\n\txfs_buf_submit(bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_submit",
          "args": [
            "bp"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_bdstrat(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\n\txfs_buf_lock(bp);\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\t/*\n\t\t * It would seem logical to return EIO here, but we rely on\n\t\t * the log state machine to propagate I/O errors instead of\n\t\t * doing it here. Similarly, IO completion will unlock the\n\t\t * buffer, so we don't do it here.\n\t\t */\n\t\treturn 0;\n\t}\n\n\txfs_buf_submit(bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_cksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1640-1669",
    "snippet": "__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_end_cksum",
          "args": [
            "crc"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_end_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "35-39",
          "snippet": "static inline __le32\nxfs_end_cksum(__uint32_t crc)\n{\n\treturn ~cpu_to_le32(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __le32\nxfs_end_cksum(__uint32_t crc)\n{\n\treturn ~cpu_to_le32(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c",
          "args": [
            "crc",
            "dp",
            "size"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_crc32c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "32-46",
          "snippet": "u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nu32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_start_cksum",
          "args": [
            "(char *)rhead",
            "sizeof(struct xlog_rec_header)",
            "offsetof(struct xlog_rec_header, h_crc)"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_start_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "11-26",
          "snippet": "static inline __uint32_t\nxfs_start_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t zero = 0;\n\t__uint32_t crc;\n\n\t/* Calculate CRC up to the checksum. */\n\tcrc = crc32c(XFS_CRC_SEED, buffer, cksum_offset);\n\n\t/* Skip checksum field */\n\tcrc = crc32c(crc, &zero, sizeof(__u32));\n\n\t/* Calculate the rest of the CRC. */\n\treturn crc32c(crc, &buffer[cksum_offset + sizeof(__be32)],\n\t\t      length - (cksum_offset + sizeof(__be32)));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_CRC_SEED\t(~(__uint32_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_CRC_SEED\t(~(__uint32_t)0)\n\nstatic inline __uint32_t\nxfs_start_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t zero = 0;\n\t__uint32_t crc;\n\n\t/* Calculate CRC up to the checksum. */\n\tcrc = crc32c(XFS_CRC_SEED, buffer, cksum_offset);\n\n\t/* Skip checksum field */\n\tcrc = crc32c(crc, &zero, sizeof(__u32));\n\n\t/* Calculate the rest of the CRC. */\n\treturn crc32c(crc, &buffer[cksum_offset + sizeof(__be32)],\n\t\t      length - (cksum_offset + sizeof(__be32)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\n__le32\nxlog_cksum(\n\tstruct xlog\t\t*log,\n\tstruct xlog_rec_header\t*rhead,\n\tchar\t\t\t*dp,\n\tint\t\t\tsize)\n{\n\t__uint32_t\t\tcrc;\n\n\t/* first generate the crc for the record header ... */\n\tcrc = xfs_start_cksum((char *)rhead,\n\t\t\t      sizeof(struct xlog_rec_header),\n\t\t\t      offsetof(struct xlog_rec_header, h_crc));\n\n\t/* ... then for additional cycle data for v2 logs ... */\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\tunion xlog_in_core2 *xhdr = (union xlog_in_core2 *)rhead;\n\t\tint\t\ti;\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++) {\n\t\t\tcrc = crc32c(crc, &xhdr[i].hic_xheader,\n\t\t\t\t     sizeof(struct xlog_rec_ext_header));\n\t\t}\n\t}\n\n\t/* ... and finally for the payload */\n\tcrc = crc32c(crc, dp, size);\n\n\treturn xfs_end_cksum(crc);\n}"
  },
  {
    "function_name": "xlog_pack_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1596-1632",
    "snippet": "STATIC void\nxlog_pack_data(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\troundoff)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\tsize = iclog->ic_offset + roundoff;\n\t__be32\t\t\tcycle_lsn;\n\txfs_caddr_t\t\tdp;\n\n\tcycle_lsn = CYCLE_LSN_DISK(iclog->ic_header.h_lsn);\n\n\tdp = iclog->ic_datap;\n\tfor (i = 0; i < BTOBB(size); i++) {\n\t\tif (i >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE))\n\t\t\tbreak;\n\t\ticlog->ic_header.h_cycle_data[i] = *(__be32 *)dp;\n\t\t*(__be32 *)dp = cycle_lsn;\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = iclog->ic_data;\n\n\t\tfor ( ; i < BTOBB(size); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\txhdr[j].hic_xheader.xh_cycle_data[k] = *(__be32 *)dp;\n\t\t\t*(__be32 *)dp = cycle_lsn;\n\t\t\tdp += BBSIZE;\n\t\t}\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++)\n\t\t\txhdr[i].hic_xheader.xh_cycle = cycle_lsn;\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "size"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "size"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN_DISK",
          "args": [
            "iclog->ic_header.h_lsn"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_pack_data(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog,\n\tint\t\t\troundoff)\n{\n\tint\t\t\ti, j, k;\n\tint\t\t\tsize = iclog->ic_offset + roundoff;\n\t__be32\t\t\tcycle_lsn;\n\txfs_caddr_t\t\tdp;\n\n\tcycle_lsn = CYCLE_LSN_DISK(iclog->ic_header.h_lsn);\n\n\tdp = iclog->ic_datap;\n\tfor (i = 0; i < BTOBB(size); i++) {\n\t\tif (i >= (XLOG_HEADER_CYCLE_SIZE / BBSIZE))\n\t\t\tbreak;\n\t\ticlog->ic_header.h_cycle_data[i] = *(__be32 *)dp;\n\t\t*(__be32 *)dp = cycle_lsn;\n\t\tdp += BBSIZE;\n\t}\n\n\tif (xfs_sb_version_haslogv2(&log->l_mp->m_sb)) {\n\t\txlog_in_core_2_t *xhdr = iclog->ic_data;\n\n\t\tfor ( ; i < BTOBB(size); i++) {\n\t\t\tj = i / (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\tk = i % (XLOG_HEADER_CYCLE_SIZE / BBSIZE);\n\t\t\txhdr[j].hic_xheader.xh_cycle_data[k] = *(__be32 *)dp;\n\t\t\t*(__be32 *)dp = cycle_lsn;\n\t\t\tdp += BBSIZE;\n\t\t}\n\n\t\tfor (i = 1; i < log->l_iclog_heads; i++)\n\t\t\txhdr[i].hic_xheader.xh_cycle = cycle_lsn;\n\t}\n}"
  },
  {
    "function_name": "xlog_grant_push_ail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1537-1591",
    "snippet": "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ail_push",
          "args": [
            "log->l_ailp",
            "threshold_lsn"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "555-576",
          "snippet": "void\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "threshold_lsn",
            "last_sync_lsn"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&log->l_last_sync_lsn"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_lsn",
          "args": [
            "threshold_cycle",
            "threshold_block"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "72-75",
          "snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_crack_atomic_lsn",
          "args": [
            "&log->l_tail_lsn",
            "&threshold_cycle",
            "&threshold_block"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_atomic_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "469-476",
          "snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "free_threshold",
            "256"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "free_threshold",
            "(log->l_logBBsize >> 2)"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "need_bytes"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBBT",
          "args": [
            "free_bytes"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_space_left",
          "args": [
            "log",
            "&log->l_reserve_head.grant"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1121-1157",
          "snippet": "STATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "BTOBB(need_bytes) < log->l_logBBsize"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "need_bytes"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}"
  },
  {
    "function_name": "xlog_commit_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1503-1528",
    "snippet": "STATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp)\n{\n\tstruct xfs_mount *mp = log->l_mp;\n\tint\terror;\n\tstruct xfs_log_iovec reg = {\n\t\t.i_addr = NULL,\n\t\t.i_len = 0,\n\t\t.i_type = XLOG_REG_TYPE_COMMIT,\n\t};\n\tstruct xfs_log_vec vec = {\n\t\t.lv_niovecs = 1,\n\t\t.lv_iovecp = &reg,\n\t};\n\n\tASSERT_ALWAYS(iclog);\n\terror = xlog_write(log, &vec, ticket, commitlsnp, iclog,\n\t\t\t\t\tXLOG_COMMIT_TRANS);\n\tif (error)\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp);",
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_write",
          "args": [
            "log",
            "&vec",
            "ticket",
            "commitlsnp",
            "iclog",
            "XLOG_COMMIT_TRANS"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2298-2462",
          "snippet": "int\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_ALWAYS",
          "args": [
            "iclog"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp);\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp)\n{\n\tstruct xfs_mount *mp = log->l_mp;\n\tint\terror;\n\tstruct xfs_log_iovec reg = {\n\t\t.i_addr = NULL,\n\t\t.i_len = 0,\n\t\t.i_type = XLOG_REG_TYPE_COMMIT,\n\t};\n\tstruct xfs_log_vec vec = {\n\t\t.lv_niovecs = 1,\n\t\t.lv_iovecp = &reg,\n\t};\n\n\tASSERT_ALWAYS(iclog);\n\terror = xlog_write(log, &vec, ticket, commitlsnp, iclog,\n\t\t\t\t\tXLOG_COMMIT_TRANS);\n\tif (error)\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_alloc_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1322-1496",
    "snippet": "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks)\n{\n\tstruct xlog\t\t*log;\n\txlog_rec_header_t\t*head;\n\txlog_in_core_t\t\t**iclogp;\n\txlog_in_core_t\t\t*iclog, *prev_iclog=NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\ti;\n\tint\t\t\terror = -ENOMEM;\n\tuint\t\t\tlog2_size = 0;\n\n\tlog = kmem_zalloc(sizeof(struct xlog), KM_MAYFAIL);\n\tif (!log) {\n\t\txfs_warn(mp, \"Log allocation failed: No memory!\");\n\t\tgoto out;\n\t}\n\n\tlog->l_mp\t   = mp;\n\tlog->l_targ\t   = log_target;\n\tlog->l_logsize     = BBTOB(num_bblks);\n\tlog->l_logBBstart  = blk_offset;\n\tlog->l_logBBsize   = num_bblks;\n\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\tlog->l_flags\t   |= XLOG_ACTIVE_RECOVERY;\n\tINIT_DELAYED_WORK(&log->l_work, xfs_log_worker);\n\n\tlog->l_prev_block  = -1;\n\t/* log->l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */\n\txlog_assign_atomic_lsn(&log->l_tail_lsn, 1, 0);\n\txlog_assign_atomic_lsn(&log->l_last_sync_lsn, 1, 0);\n\tlog->l_curr_cycle  = 1;\t    /* 0 is bad since this is initial value */\n\n\txlog_grant_head_init(&log->l_reserve_head);\n\txlog_grant_head_init(&log->l_write_head);\n\n\terror = -EFSCORRUPTED;\n\tif (xfs_sb_version_hassector(&mp->m_sb)) {\n\t        log2_size = mp->m_sb.sb_logsectlog;\n\t\tif (log2_size < BBSHIFT) {\n\t\t\txfs_warn(mp, \"Log sector size too small (0x%x < 0x%x)\",\n\t\t\t\tlog2_size, BBSHIFT);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t        log2_size -= BBSHIFT;\n\t\tif (log2_size > mp->m_sectbb_log) {\n\t\t\txfs_warn(mp, \"Log sector size too large (0x%x > 0x%x)\",\n\t\t\t\tlog2_size, mp->m_sectbb_log);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t\t/* for larger sector sizes, must have v2 or external log */\n\t\tif (log2_size && log->l_logBBstart > 0 &&\n\t\t\t    !xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\txfs_warn(mp,\n\t\t\"log sector size (0x%x) invalid for configuration.\",\n\t\t\t\tlog2_size);\n\t\t\tgoto out_free_log;\n\t\t}\n\t}\n\tlog->l_sectBBsize = 1 << log2_size;\n\n\txlog_get_iclog_buffer_size(mp, log);\n\n\t/*\n\t * Use a NULL block for the extra log buffer used during splits so that\n\t * it will trigger errors if we ever try to do IO on it without first\n\t * having set it up properly.\n\t */\n\terror = -ENOMEM;\n\tbp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,\n\t\t\t   BTOBB(log->l_iclog_size), 0);\n\tif (!bp)\n\t\tgoto out_free_log;\n\n\t/*\n\t * The iclogbuf buffer locks are held over IO but we are not going to do\n\t * IO yet.  Hence unlock the buffer so that the log IO path can grab it\n\t * when appropriately.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_buf_unlock(bp);\n\n\t/* use high priority wq for log I/O completion */\n\tbp->b_ioend_wq = mp->m_log_workqueue;\n\tbp->b_iodone = xlog_iodone;\n\tlog->l_xbuf = bp;\n\n\tspin_lock_init(&log->l_icloglock);\n\tinit_waitqueue_head(&log->l_flush_wait);\n\n\ticlogp = &log->l_iclog;\n\t/*\n\t * The amount of memory to allocate for the iclog structure is\n\t * rather funky due to the way the structure is defined.  It is\n\t * done this way so that we can use different sizes for machines\n\t * with different amounts of memory.  See the definition of\n\t * xlog_in_core_t in xfs_log_priv.h for details.\n\t */\n\tASSERT(log->l_iclog_size >= 4096);\n\tfor (i=0; i < log->l_iclog_bufs; i++) {\n\t\t*iclogp = kmem_zalloc(sizeof(xlog_in_core_t), KM_MAYFAIL);\n\t\tif (!*iclogp)\n\t\t\tgoto out_free_iclog;\n\n\t\ticlog = *iclogp;\n\t\ticlog->ic_prev = prev_iclog;\n\t\tprev_iclog = iclog;\n\n\t\tbp = xfs_buf_get_uncached(mp->m_logdev_targp,\n\t\t\t\t\t\tBTOBB(log->l_iclog_size), 0);\n\t\tif (!bp)\n\t\t\tgoto out_free_iclog;\n\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\txfs_buf_unlock(bp);\n\n\t\t/* use high priority wq for log I/O completion */\n\t\tbp->b_ioend_wq = mp->m_log_workqueue;\n\t\tbp->b_iodone = xlog_iodone;\n\t\ticlog->ic_bp = bp;\n\t\ticlog->ic_data = bp->b_addr;\n#ifdef DEBUG\n\t\tlog->l_iclog_bak[i] = (xfs_caddr_t)&(iclog->ic_header);\n#endif\n\t\thead = &iclog->ic_header;\n\t\tmemset(head, 0, sizeof(xlog_rec_header_t));\n\t\thead->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\t\thead->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\t\thead->h_size = cpu_to_be32(log->l_iclog_size);\n\t\t/* new fields */\n\t\thead->h_fmt = cpu_to_be32(XLOG_FMT);\n\t\tmemcpy(&head->h_fs_uuid, &mp->m_sb.sb_uuid, sizeof(uuid_t));\n\n\t\ticlog->ic_size = BBTOB(bp->b_length) - log->l_iclog_hsize;\n\t\ticlog->ic_state = XLOG_STATE_ACTIVE;\n\t\ticlog->ic_log = log;\n\t\tatomic_set(&iclog->ic_refcnt, 0);\n\t\tspin_lock_init(&iclog->ic_callback_lock);\n\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\ticlog->ic_datap = (char *)iclog->ic_data + log->l_iclog_hsize;\n\n\t\tinit_waitqueue_head(&iclog->ic_force_wait);\n\t\tinit_waitqueue_head(&iclog->ic_write_wait);\n\n\t\ticlogp = &iclog->ic_next;\n\t}\n\t*iclogp = log->l_iclog;\t\t\t/* complete ring */\n\tlog->l_iclog->ic_prev = prev_iclog;\t/* re-write 1st prev ptr */\n\n\terror = xlog_cil_init(log);\n\tif (error)\n\t\tgoto out_free_iclog;\n\treturn log;\n\nout_free_iclog:\n\tfor (iclog = log->l_iclog; iclog; iclog = prev_iclog) {\n\t\tprev_iclog = iclog->ic_next;\n\t\tif (iclog->ic_bp)\n\t\t\txfs_buf_free(iclog->ic_bp);\n\t\tkmem_free(iclog);\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\txfs_buf_free(log->l_xbuf);\nout_free_log:\n\tkmem_free(log);\nout:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "log"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_free",
          "args": [
            "log->l_xbuf"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "255-280",
          "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spinlock_destroy",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cil_init",
          "args": [
            "log"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "948-983",
          "snippet": "int\nxlog_cil_init(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil;\n\tstruct xfs_cil_ctx *ctx;\n\n\tcil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\n\tif (!cil)\n\t\treturn -ENOMEM;\n\n\tctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\n\tif (!ctx) {\n\t\tkmem_free(cil);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&cil->xc_push_work, xlog_cil_push_work);\n\tINIT_LIST_HEAD(&cil->xc_cil);\n\tINIT_LIST_HEAD(&cil->xc_committing);\n\tspin_lock_init(&cil->xc_cil_lock);\n\tspin_lock_init(&cil->xc_push_lock);\n\tinit_rwsem(&cil->xc_ctx_lock);\n\tinit_waitqueue_head(&cil->xc_commit_wait);\n\n\tINIT_LIST_HEAD(&ctx->committing);\n\tINIT_LIST_HEAD(&ctx->busy_extents);\n\tctx->sequence = 1;\n\tctx->cil = cil;\n\tcil->xc_ctx = ctx;\n\tcil->xc_current_sequence = ctx->sequence;\n\n\tcil->xc_log = log;\n\tlog->l_cilp = cil;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxlog_cil_init(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil;\n\tstruct xfs_cil_ctx *ctx;\n\n\tcil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\n\tif (!cil)\n\t\treturn -ENOMEM;\n\n\tctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\n\tif (!ctx) {\n\t\tkmem_free(cil);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&cil->xc_push_work, xlog_cil_push_work);\n\tINIT_LIST_HEAD(&cil->xc_cil);\n\tINIT_LIST_HEAD(&cil->xc_committing);\n\tspin_lock_init(&cil->xc_cil_lock);\n\tspin_lock_init(&cil->xc_push_lock);\n\tinit_rwsem(&cil->xc_ctx_lock);\n\tinit_waitqueue_head(&cil->xc_commit_wait);\n\n\tINIT_LIST_HEAD(&ctx->committing);\n\tINIT_LIST_HEAD(&ctx->busy_extents);\n\tctx->sequence = 1;\n\tctx->cil = cil;\n\tcil->xc_ctx = ctx;\n\tcil->xc_current_sequence = ctx->sequence;\n\n\tcil->xc_log = log;\n\tlog->l_cilp = cil;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&iclog->ic_write_wait"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&iclog->ic_force_wait"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&iclog->ic_callback_lock"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&iclog->ic_refcnt",
            "0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&head->h_fs_uuid",
            "&mp->m_sb.sb_uuid",
            "sizeof(uuid_t)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_FMT"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "log->l_iclog_size"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&log->l_mp->m_sb"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XLOG_HEADER_MAGIC_NUM"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "head",
            "0",
            "sizeof(xlog_rec_header_t)"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_uncached",
          "args": [
            "mp->m_logdev_targp",
            "BTOBB(log->l_iclog_size)",
            "0"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "801-847",
          "snippet": "xfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nxfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_iclog_size"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(xlog_in_core_t)",
            "KM_MAYFAIL"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log->l_iclog_size >= 4096"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&log->l_flush_wait"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_alloc",
          "args": [
            "mp->m_logdev_targp",
            "XFS_BUF_DADDR_NULL",
            "BTOBB(log->l_iclog_size)",
            "0"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "211-220",
          "snippet": "static inline struct xfs_buf *\nxfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_alloc(target, &map, 1, flags);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_alloc(target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "log->l_iclog_size"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_get_iclog_buffer_size",
          "args": [
            "mp",
            "log"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_get_iclog_buffer_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1213-1269",
          "snippet": "STATIC void\nxlog_get_iclog_buffer_size(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog\t\t*log)\n{\n\tint size;\n\tint xhdrs;\n\n\tif (mp->m_logbufs <= 0)\n\t\tlog->l_iclog_bufs = XLOG_MAX_ICLOGS;\n\telse\n\t\tlog->l_iclog_bufs = mp->m_logbufs;\n\n\t/*\n\t * Buffer size passed in from mount system call.\n\t */\n\tif (mp->m_logbsize > 0) {\n\t\tsize = log->l_iclog_size = mp->m_logbsize;\n\t\tlog->l_iclog_size_log = 0;\n\t\twhile (size != 1) {\n\t\t\tlog->l_iclog_size_log++;\n\t\t\tsize >>= 1;\n\t\t}\n\n\t\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\t/* # headers = size / 32k\n\t\t\t * one header holds cycles from 32k of data\n\t\t\t */\n\n\t\t\txhdrs = mp->m_logbsize / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (mp->m_logbsize % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\txhdrs++;\n\t\t\tlog->l_iclog_hsize = xhdrs << BBSHIFT;\n\t\t\tlog->l_iclog_heads = xhdrs;\n\t\t} else {\n\t\t\tASSERT(mp->m_logbsize <= XLOG_BIG_RECORD_BSIZE);\n\t\t\tlog->l_iclog_hsize = BBSIZE;\n\t\t\tlog->l_iclog_heads = 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* All machines use 32kB buffers by default. */\n\tlog->l_iclog_size = XLOG_BIG_RECORD_BSIZE;\n\tlog->l_iclog_size_log = XLOG_BIG_RECORD_BSHIFT;\n\n\t/* the default log size is 16k or 32k which is one header sector */\n\tlog->l_iclog_hsize = BBSIZE;\n\tlog->l_iclog_heads = 1;\n\ndone:\n\t/* are we being asked to make the sizes selected above visible? */\n\tif (mp->m_logbufs == 0)\n\t\tmp->m_logbufs = log->l_iclog_bufs;\n\tif (mp->m_logbsize == 0)\n\t\tmp->m_logbsize = log->l_iclog_size;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_get_iclog_buffer_size(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog\t\t*log)\n{\n\tint size;\n\tint xhdrs;\n\n\tif (mp->m_logbufs <= 0)\n\t\tlog->l_iclog_bufs = XLOG_MAX_ICLOGS;\n\telse\n\t\tlog->l_iclog_bufs = mp->m_logbufs;\n\n\t/*\n\t * Buffer size passed in from mount system call.\n\t */\n\tif (mp->m_logbsize > 0) {\n\t\tsize = log->l_iclog_size = mp->m_logbsize;\n\t\tlog->l_iclog_size_log = 0;\n\t\twhile (size != 1) {\n\t\t\tlog->l_iclog_size_log++;\n\t\t\tsize >>= 1;\n\t\t}\n\n\t\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\t/* # headers = size / 32k\n\t\t\t * one header holds cycles from 32k of data\n\t\t\t */\n\n\t\t\txhdrs = mp->m_logbsize / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (mp->m_logbsize % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\txhdrs++;\n\t\t\tlog->l_iclog_hsize = xhdrs << BBSHIFT;\n\t\t\tlog->l_iclog_heads = xhdrs;\n\t\t} else {\n\t\t\tASSERT(mp->m_logbsize <= XLOG_BIG_RECORD_BSIZE);\n\t\t\tlog->l_iclog_hsize = BBSIZE;\n\t\t\tlog->l_iclog_heads = 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* All machines use 32kB buffers by default. */\n\tlog->l_iclog_size = XLOG_BIG_RECORD_BSIZE;\n\tlog->l_iclog_size_log = XLOG_BIG_RECORD_BSHIFT;\n\n\t/* the default log size is 16k or 32k which is one header sector */\n\tlog->l_iclog_hsize = BBSIZE;\n\tlog->l_iclog_heads = 1;\n\ndone:\n\t/* are we being asked to make the sizes selected above visible? */\n\tif (mp->m_logbufs == 0)\n\t\tmp->m_logbufs = log->l_iclog_bufs;\n\tif (mp->m_logbsize == 0)\n\t\tmp->m_logbsize = log->l_iclog_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log sector size (0x%x) invalid for configuration.\"",
            "log2_size"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Log sector size too large (0x%x > 0x%x)\"",
            "log2_size",
            "mp->m_sectbb_log"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Log sector size too small (0x%x < 0x%x)\"",
            "log2_size",
            "BBSHIFT"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hassector",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hassector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "422-425",
          "snippet": "static inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_SECTORBIT\t0x0800"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_SECTORBIT\t0x0800\n\nstatic inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_init",
          "args": [
            "&log->l_write_head"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "193-200",
          "snippet": "STATIC void\nxlog_grant_head_init(\n\tstruct xlog_grant_head\t*head)\n{\n\txlog_assign_grant_head(&head->grant, 1, 0);\n\tINIT_LIST_HEAD(&head->waiters);\n\tspin_lock_init(&head->lock);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_head_init(\n\tstruct xlog_grant_head\t*head)\n{\n\txlog_assign_grant_head(&head->grant, 1, 0);\n\tINIT_LIST_HEAD(&head->waiters);\n\tspin_lock_init(&head->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_atomic_lsn",
          "args": [
            "&log->l_last_sync_lsn",
            "1",
            "0"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_atomic_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "481-485",
          "snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&log->l_work",
            "xfs_log_worker"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "num_bblks"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Log allocation failed: No memory!\""
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks)\n{\n\tstruct xlog\t\t*log;\n\txlog_rec_header_t\t*head;\n\txlog_in_core_t\t\t**iclogp;\n\txlog_in_core_t\t\t*iclog, *prev_iclog=NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\ti;\n\tint\t\t\terror = -ENOMEM;\n\tuint\t\t\tlog2_size = 0;\n\n\tlog = kmem_zalloc(sizeof(struct xlog), KM_MAYFAIL);\n\tif (!log) {\n\t\txfs_warn(mp, \"Log allocation failed: No memory!\");\n\t\tgoto out;\n\t}\n\n\tlog->l_mp\t   = mp;\n\tlog->l_targ\t   = log_target;\n\tlog->l_logsize     = BBTOB(num_bblks);\n\tlog->l_logBBstart  = blk_offset;\n\tlog->l_logBBsize   = num_bblks;\n\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\tlog->l_flags\t   |= XLOG_ACTIVE_RECOVERY;\n\tINIT_DELAYED_WORK(&log->l_work, xfs_log_worker);\n\n\tlog->l_prev_block  = -1;\n\t/* log->l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */\n\txlog_assign_atomic_lsn(&log->l_tail_lsn, 1, 0);\n\txlog_assign_atomic_lsn(&log->l_last_sync_lsn, 1, 0);\n\tlog->l_curr_cycle  = 1;\t    /* 0 is bad since this is initial value */\n\n\txlog_grant_head_init(&log->l_reserve_head);\n\txlog_grant_head_init(&log->l_write_head);\n\n\terror = -EFSCORRUPTED;\n\tif (xfs_sb_version_hassector(&mp->m_sb)) {\n\t        log2_size = mp->m_sb.sb_logsectlog;\n\t\tif (log2_size < BBSHIFT) {\n\t\t\txfs_warn(mp, \"Log sector size too small (0x%x < 0x%x)\",\n\t\t\t\tlog2_size, BBSHIFT);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t        log2_size -= BBSHIFT;\n\t\tif (log2_size > mp->m_sectbb_log) {\n\t\t\txfs_warn(mp, \"Log sector size too large (0x%x > 0x%x)\",\n\t\t\t\tlog2_size, mp->m_sectbb_log);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t\t/* for larger sector sizes, must have v2 or external log */\n\t\tif (log2_size && log->l_logBBstart > 0 &&\n\t\t\t    !xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\txfs_warn(mp,\n\t\t\"log sector size (0x%x) invalid for configuration.\",\n\t\t\t\tlog2_size);\n\t\t\tgoto out_free_log;\n\t\t}\n\t}\n\tlog->l_sectBBsize = 1 << log2_size;\n\n\txlog_get_iclog_buffer_size(mp, log);\n\n\t/*\n\t * Use a NULL block for the extra log buffer used during splits so that\n\t * it will trigger errors if we ever try to do IO on it without first\n\t * having set it up properly.\n\t */\n\terror = -ENOMEM;\n\tbp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,\n\t\t\t   BTOBB(log->l_iclog_size), 0);\n\tif (!bp)\n\t\tgoto out_free_log;\n\n\t/*\n\t * The iclogbuf buffer locks are held over IO but we are not going to do\n\t * IO yet.  Hence unlock the buffer so that the log IO path can grab it\n\t * when appropriately.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_buf_unlock(bp);\n\n\t/* use high priority wq for log I/O completion */\n\tbp->b_ioend_wq = mp->m_log_workqueue;\n\tbp->b_iodone = xlog_iodone;\n\tlog->l_xbuf = bp;\n\n\tspin_lock_init(&log->l_icloglock);\n\tinit_waitqueue_head(&log->l_flush_wait);\n\n\ticlogp = &log->l_iclog;\n\t/*\n\t * The amount of memory to allocate for the iclog structure is\n\t * rather funky due to the way the structure is defined.  It is\n\t * done this way so that we can use different sizes for machines\n\t * with different amounts of memory.  See the definition of\n\t * xlog_in_core_t in xfs_log_priv.h for details.\n\t */\n\tASSERT(log->l_iclog_size >= 4096);\n\tfor (i=0; i < log->l_iclog_bufs; i++) {\n\t\t*iclogp = kmem_zalloc(sizeof(xlog_in_core_t), KM_MAYFAIL);\n\t\tif (!*iclogp)\n\t\t\tgoto out_free_iclog;\n\n\t\ticlog = *iclogp;\n\t\ticlog->ic_prev = prev_iclog;\n\t\tprev_iclog = iclog;\n\n\t\tbp = xfs_buf_get_uncached(mp->m_logdev_targp,\n\t\t\t\t\t\tBTOBB(log->l_iclog_size), 0);\n\t\tif (!bp)\n\t\t\tgoto out_free_iclog;\n\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\txfs_buf_unlock(bp);\n\n\t\t/* use high priority wq for log I/O completion */\n\t\tbp->b_ioend_wq = mp->m_log_workqueue;\n\t\tbp->b_iodone = xlog_iodone;\n\t\ticlog->ic_bp = bp;\n\t\ticlog->ic_data = bp->b_addr;\n#ifdef DEBUG\n\t\tlog->l_iclog_bak[i] = (xfs_caddr_t)&(iclog->ic_header);\n#endif\n\t\thead = &iclog->ic_header;\n\t\tmemset(head, 0, sizeof(xlog_rec_header_t));\n\t\thead->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\t\thead->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\t\thead->h_size = cpu_to_be32(log->l_iclog_size);\n\t\t/* new fields */\n\t\thead->h_fmt = cpu_to_be32(XLOG_FMT);\n\t\tmemcpy(&head->h_fs_uuid, &mp->m_sb.sb_uuid, sizeof(uuid_t));\n\n\t\ticlog->ic_size = BBTOB(bp->b_length) - log->l_iclog_hsize;\n\t\ticlog->ic_state = XLOG_STATE_ACTIVE;\n\t\ticlog->ic_log = log;\n\t\tatomic_set(&iclog->ic_refcnt, 0);\n\t\tspin_lock_init(&iclog->ic_callback_lock);\n\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\ticlog->ic_datap = (char *)iclog->ic_data + log->l_iclog_hsize;\n\n\t\tinit_waitqueue_head(&iclog->ic_force_wait);\n\t\tinit_waitqueue_head(&iclog->ic_write_wait);\n\n\t\ticlogp = &iclog->ic_next;\n\t}\n\t*iclogp = log->l_iclog;\t\t\t/* complete ring */\n\tlog->l_iclog->ic_prev = prev_iclog;\t/* re-write 1st prev ptr */\n\n\terror = xlog_cil_init(log);\n\tif (error)\n\t\tgoto out_free_iclog;\n\treturn log;\n\nout_free_iclog:\n\tfor (iclog = log->l_iclog; iclog; iclog = prev_iclog) {\n\t\tprev_iclog = iclog->ic_next;\n\t\tif (iclog->ic_bp)\n\t\t\txfs_buf_free(iclog->ic_bp);\n\t\tkmem_free(iclog);\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\txfs_buf_free(log->l_xbuf);\nout_free_log:\n\tkmem_free(log);\nout:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "xfs_log_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1285-1315",
    "snippet": "void\nxfs_log_worker(\n\tstruct work_struct\t*work)\n{\n\tstruct xlog\t\t*log = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct xlog, l_work);\n\tstruct xfs_mount\t*mp = log->l_mp;\n\n\t/* dgc: errors ignored - not fatal and nowhere to report them */\n\tif (xfs_log_need_covered(mp)) {\n\t\t/*\n\t\t * Dump a transaction into the log that contains no real change.\n\t\t * This is needed to stamp the current tail LSN into the log\n\t\t * during the covering operation.\n\t\t *\n\t\t * We cannot use an inode here for this - that will push dirty\n\t\t * state back up into the VFS and then periodic inode flushing\n\t\t * will prevent log covering from making progress. Hence we\n\t\t * synchronously log the superblock instead to ensure the\n\t\t * superblock is immediately unpinned and can be written back.\n\t\t */\n\t\txfs_sync_sb(mp, true);\n\t} else\n\t\txfs_log_force(mp, 0);\n\n\t/* start pushing all the metadata that is currently dirty */\n\txfs_ail_push_all(mp->m_ail);\n\n\t/* queue us up again */\n\txfs_log_work_queue(mp);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_work_queue",
          "args": [
            "mp"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1272-1278",
          "snippet": "void\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_push_all",
          "args": [
            "mp->m_ail"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push_all_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "594-613",
          "snippet": "void\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "0"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "true"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_need_covered",
          "args": [
            "mp"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_need_covered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1027-1064",
          "snippet": "int\nxfs_log_need_covered(xfs_mount_t *mp)\n{\n\tstruct xlog\t*log = mp->m_log;\n\tint\t\tneeded = 0;\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\tif (!xlog_cil_empty(log))\n\t\treturn 0;\n\n\tspin_lock(&log->l_icloglock);\n\tswitch (log->l_covered_state) {\n\tcase XLOG_STATE_COVER_DONE:\n\tcase XLOG_STATE_COVER_DONE2:\n\tcase XLOG_STATE_COVER_IDLE:\n\t\tbreak;\n\tcase XLOG_STATE_COVER_NEED:\n\tcase XLOG_STATE_COVER_NEED2:\n\t\tif (xfs_ail_min_lsn(log->l_ailp))\n\t\t\tbreak;\n\t\tif (!xlog_iclogs_empty(log))\n\t\t\tbreak;\n\n\t\tneeded = 1;\n\t\tif (log->l_covered_state == XLOG_STATE_COVER_NEED)\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE;\n\t\telse\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE2;\n\t\tbreak;\n\tdefault:\n\t\tneeded = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&log->l_icloglock);\n\treturn needed;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_need_covered(xfs_mount_t *mp)\n{\n\tstruct xlog\t*log = mp->m_log;\n\tint\t\tneeded = 0;\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\tif (!xlog_cil_empty(log))\n\t\treturn 0;\n\n\tspin_lock(&log->l_icloglock);\n\tswitch (log->l_covered_state) {\n\tcase XLOG_STATE_COVER_DONE:\n\tcase XLOG_STATE_COVER_DONE2:\n\tcase XLOG_STATE_COVER_IDLE:\n\t\tbreak;\n\tcase XLOG_STATE_COVER_NEED:\n\tcase XLOG_STATE_COVER_NEED2:\n\t\tif (xfs_ail_min_lsn(log->l_ailp))\n\t\t\tbreak;\n\t\tif (!xlog_iclogs_empty(log))\n\t\t\tbreak;\n\n\t\tneeded = 1;\n\t\tif (log->l_covered_state == XLOG_STATE_COVER_NEED)\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE;\n\t\telse\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE2;\n\t\tbreak;\n\tdefault:\n\t\tneeded = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&log->l_icloglock);\n\treturn needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_delayed_work(work)",
            "structxlog",
            "l_work"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxfs_log_worker(\n\tstruct work_struct\t*work)\n{\n\tstruct xlog\t\t*log = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct xlog, l_work);\n\tstruct xfs_mount\t*mp = log->l_mp;\n\n\t/* dgc: errors ignored - not fatal and nowhere to report them */\n\tif (xfs_log_need_covered(mp)) {\n\t\t/*\n\t\t * Dump a transaction into the log that contains no real change.\n\t\t * This is needed to stamp the current tail LSN into the log\n\t\t * during the covering operation.\n\t\t *\n\t\t * We cannot use an inode here for this - that will push dirty\n\t\t * state back up into the VFS and then periodic inode flushing\n\t\t * will prevent log covering from making progress. Hence we\n\t\t * synchronously log the superblock instead to ensure the\n\t\t * superblock is immediately unpinned and can be written back.\n\t\t */\n\t\txfs_sync_sb(mp, true);\n\t} else\n\t\txfs_log_force(mp, 0);\n\n\t/* start pushing all the metadata that is currently dirty */\n\txfs_ail_push_all(mp->m_ail);\n\n\t/* queue us up again */\n\txfs_log_work_queue(mp);\n}"
  },
  {
    "function_name": "xfs_log_work_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1272-1278",
    "snippet": "void\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "mp->m_log_workqueue",
            "&mp->m_log->l_work",
            "msecs_to_jiffies(xfs_syncd_centisecs * 10)"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "xfs_syncd_centisecs * 10"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}"
  },
  {
    "function_name": "xlog_get_iclog_buffer_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1213-1269",
    "snippet": "STATIC void\nxlog_get_iclog_buffer_size(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog\t\t*log)\n{\n\tint size;\n\tint xhdrs;\n\n\tif (mp->m_logbufs <= 0)\n\t\tlog->l_iclog_bufs = XLOG_MAX_ICLOGS;\n\telse\n\t\tlog->l_iclog_bufs = mp->m_logbufs;\n\n\t/*\n\t * Buffer size passed in from mount system call.\n\t */\n\tif (mp->m_logbsize > 0) {\n\t\tsize = log->l_iclog_size = mp->m_logbsize;\n\t\tlog->l_iclog_size_log = 0;\n\t\twhile (size != 1) {\n\t\t\tlog->l_iclog_size_log++;\n\t\t\tsize >>= 1;\n\t\t}\n\n\t\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\t/* # headers = size / 32k\n\t\t\t * one header holds cycles from 32k of data\n\t\t\t */\n\n\t\t\txhdrs = mp->m_logbsize / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (mp->m_logbsize % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\txhdrs++;\n\t\t\tlog->l_iclog_hsize = xhdrs << BBSHIFT;\n\t\t\tlog->l_iclog_heads = xhdrs;\n\t\t} else {\n\t\t\tASSERT(mp->m_logbsize <= XLOG_BIG_RECORD_BSIZE);\n\t\t\tlog->l_iclog_hsize = BBSIZE;\n\t\t\tlog->l_iclog_heads = 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* All machines use 32kB buffers by default. */\n\tlog->l_iclog_size = XLOG_BIG_RECORD_BSIZE;\n\tlog->l_iclog_size_log = XLOG_BIG_RECORD_BSHIFT;\n\n\t/* the default log size is 16k or 32k which is one header sector */\n\tlog->l_iclog_hsize = BBSIZE;\n\tlog->l_iclog_heads = 1;\n\ndone:\n\t/* are we being asked to make the sizes selected above visible? */\n\tif (mp->m_logbufs == 0)\n\t\tmp->m_logbufs = log->l_iclog_bufs;\n\tif (mp->m_logbsize == 0)\n\t\tmp->m_logbsize = log->l_iclog_size;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_logbsize <= XLOG_BIG_RECORD_BSIZE"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslogv2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslogv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "410-414",
          "snippet": "static inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_get_iclog_buffer_size(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog\t\t*log)\n{\n\tint size;\n\tint xhdrs;\n\n\tif (mp->m_logbufs <= 0)\n\t\tlog->l_iclog_bufs = XLOG_MAX_ICLOGS;\n\telse\n\t\tlog->l_iclog_bufs = mp->m_logbufs;\n\n\t/*\n\t * Buffer size passed in from mount system call.\n\t */\n\tif (mp->m_logbsize > 0) {\n\t\tsize = log->l_iclog_size = mp->m_logbsize;\n\t\tlog->l_iclog_size_log = 0;\n\t\twhile (size != 1) {\n\t\t\tlog->l_iclog_size_log++;\n\t\t\tsize >>= 1;\n\t\t}\n\n\t\tif (xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\t/* # headers = size / 32k\n\t\t\t * one header holds cycles from 32k of data\n\t\t\t */\n\n\t\t\txhdrs = mp->m_logbsize / XLOG_HEADER_CYCLE_SIZE;\n\t\t\tif (mp->m_logbsize % XLOG_HEADER_CYCLE_SIZE)\n\t\t\t\txhdrs++;\n\t\t\tlog->l_iclog_hsize = xhdrs << BBSHIFT;\n\t\t\tlog->l_iclog_heads = xhdrs;\n\t\t} else {\n\t\t\tASSERT(mp->m_logbsize <= XLOG_BIG_RECORD_BSIZE);\n\t\t\tlog->l_iclog_hsize = BBSIZE;\n\t\t\tlog->l_iclog_heads = 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* All machines use 32kB buffers by default. */\n\tlog->l_iclog_size = XLOG_BIG_RECORD_BSIZE;\n\tlog->l_iclog_size_log = XLOG_BIG_RECORD_BSHIFT;\n\n\t/* the default log size is 16k or 32k which is one header sector */\n\tlog->l_iclog_hsize = BBSIZE;\n\tlog->l_iclog_heads = 1;\n\ndone:\n\t/* are we being asked to make the sizes selected above visible? */\n\tif (mp->m_logbufs == 0)\n\t\tmp->m_logbufs = log->l_iclog_bufs;\n\tif (mp->m_logbsize == 0)\n\t\tmp->m_logbsize = log->l_iclog_size;\n}"
  },
  {
    "function_name": "xlog_iodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1166-1202",
    "snippet": "void\nxlog_iodone(xfs_buf_t *bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\tstruct xlog\t\t*l = iclog->ic_log;\n\tint\t\t\taborted = 0;\n\n\t/*\n\t * Race to shutdown the filesystem if we see an error.\n\t */\n\tif (XFS_TEST_ERROR(bp->b_error, l->l_mp,\n\t\t\tXFS_ERRTAG_IODONE_IOERR, XFS_RANDOM_IODONE_IOERR)) {\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\txfs_buf_stale(bp);\n\t\txfs_force_shutdown(l->l_mp, SHUTDOWN_LOG_IO_ERROR);\n\t\t/*\n\t\t * This flag will be propagated to the trans-committed\n\t\t * callback routines to let them know that the log-commit\n\t\t * didn't succeed.\n\t\t */\n\t\taborted = XFS_LI_ABORTED;\n\t} else if (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\taborted = XFS_LI_ABORTED;\n\t}\n\n\t/* log I/O is always issued ASYNC */\n\tASSERT(XFS_BUF_ISASYNC(bp));\n\txlog_state_done_syncing(iclog, aborted);\n\n\t/*\n\t * drop the buffer lock now that we are done. Nothing references\n\t * the buffer after this, so an unmount waiting on this lock can now\n\t * tear it down safely. As such, it is unsafe to reference the buffer\n\t * (bp) after the unlock as we could race with it being freed.\n\t */\n\txfs_buf_unlock(bp);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_done_syncing",
          "args": [
            "iclog",
            "aborted"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_done_syncing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2815-2852",
          "snippet": "STATIC void\nxlog_state_done_syncing(\n\txlog_in_core_t\t*iclog,\n\tint\t\taborted)\n{\n\tstruct xlog\t   *log = iclog->ic_log;\n\n\tspin_lock(&log->l_icloglock);\n\n\tASSERT(iclog->ic_state == XLOG_STATE_SYNCING ||\n\t       iclog->ic_state == XLOG_STATE_IOERROR);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\tASSERT(iclog->ic_bwritecnt == 1 || iclog->ic_bwritecnt == 2);\n\n\n\t/*\n\t * If we got an error, either on the first buffer, or in the case of\n\t * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,\n\t * and none should ever be attempted to be written to disk\n\t * again.\n\t */\n\tif (iclog->ic_state != XLOG_STATE_IOERROR) {\n\t\tif (--iclog->ic_bwritecnt == 1) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn;\n\t\t}\n\t\ticlog->ic_state = XLOG_STATE_DONE_SYNC;\n\t}\n\n\t/*\n\t * Someone could be sleeping prior to writing out the next\n\t * iclog buffer, we wake them all, one will get to do the\n\t * I/O, the others get to wait for the result.\n\t */\n\twake_up_all(&iclog->ic_write_wait);\n\tspin_unlock(&log->l_icloglock);\n\txlog_state_do_callback(log, aborted, iclog);\t/* also cleans log */\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_done_syncing(\n\txlog_in_core_t\t*iclog,\n\tint\t\taborted)\n{\n\tstruct xlog\t   *log = iclog->ic_log;\n\n\tspin_lock(&log->l_icloglock);\n\n\tASSERT(iclog->ic_state == XLOG_STATE_SYNCING ||\n\t       iclog->ic_state == XLOG_STATE_IOERROR);\n\tASSERT(atomic_read(&iclog->ic_refcnt) == 0);\n\tASSERT(iclog->ic_bwritecnt == 1 || iclog->ic_bwritecnt == 2);\n\n\n\t/*\n\t * If we got an error, either on the first buffer, or in the case of\n\t * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,\n\t * and none should ever be attempted to be written to disk\n\t * again.\n\t */\n\tif (iclog->ic_state != XLOG_STATE_IOERROR) {\n\t\tif (--iclog->ic_bwritecnt == 1) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn;\n\t\t}\n\t\ticlog->ic_state = XLOG_STATE_DONE_SYNC;\n\t}\n\n\t/*\n\t * Someone could be sleeping prior to writing out the next\n\t * iclog buffer, we wake them all, one will get to do the\n\t * I/O, the others get to wait for the result.\n\t */\n\twake_up_all(&iclog->ic_write_wait);\n\tspin_unlock(&log->l_icloglock);\n\txlog_state_do_callback(log, aborted, iclog);\t/* also cleans log */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ISASYNC(bp)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISASYNC",
          "args": [
            "bp"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "l->l_mp",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "bp->b_error",
            "l->l_mp",
            "XFS_ERRTAG_IODONE_IOERR",
            "XFS_RANDOM_IODONE_IOERR"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxlog_iodone(xfs_buf_t *bp)\n{\n\tstruct xlog_in_core\t*iclog = bp->b_fspriv;\n\tstruct xlog\t\t*l = iclog->ic_log;\n\tint\t\t\taborted = 0;\n\n\t/*\n\t * Race to shutdown the filesystem if we see an error.\n\t */\n\tif (XFS_TEST_ERROR(bp->b_error, l->l_mp,\n\t\t\tXFS_ERRTAG_IODONE_IOERR, XFS_RANDOM_IODONE_IOERR)) {\n\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\txfs_buf_stale(bp);\n\t\txfs_force_shutdown(l->l_mp, SHUTDOWN_LOG_IO_ERROR);\n\t\t/*\n\t\t * This flag will be propagated to the trans-committed\n\t\t * callback routines to let them know that the log-commit\n\t\t * didn't succeed.\n\t\t */\n\t\taborted = XFS_LI_ABORTED;\n\t} else if (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\taborted = XFS_LI_ABORTED;\n\t}\n\n\t/* log I/O is always issued ASYNC */\n\tASSERT(XFS_BUF_ISASYNC(bp));\n\txlog_state_done_syncing(iclog, aborted);\n\n\t/*\n\t * drop the buffer lock now that we are done. Nothing references\n\t * the buffer after this, so an unmount waiting on this lock can now\n\t * tear it down safely. As such, it is unsafe to reference the buffer\n\t * (bp) after the unlock as we could race with it being freed.\n\t */\n\txfs_buf_unlock(bp);\n}"
  },
  {
    "function_name": "xlog_space_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1121-1157",
    "snippet": "STATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "log->l_mp",
            "\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\"",
            "tail_cycle",
            "tail_bytes",
            "head_cycle",
            "head_bytes"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tail_cycle == (head_cycle - 1)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "tail_bytes"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_crack_atomic_lsn",
          "args": [
            "&log->l_tail_lsn",
            "&tail_cycle",
            "&tail_bytes"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_atomic_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "469-476",
          "snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_crack_grant_head",
          "args": [
            "head",
            "&head_cycle",
            "&head_bytes"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_grant_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "499-503",
          "snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}"
  },
  {
    "function_name": "xlog_assign_tail_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1094-1105",
    "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_ail->xa_lock"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_tail_lsn_locked",
          "args": [
            "mp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_tail_lsn_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1069-1092",
          "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_ail->xa_lock"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_lsn_t\t\ttail_lsn;\n\n\tspin_lock(&mp->m_ail->xa_lock);\n\ttail_lsn = xlog_assign_tail_lsn_locked(mp);\n\tspin_unlock(&mp->m_ail->xa_lock);\n\n\treturn tail_lsn;\n}"
  },
  {
    "function_name": "xlog_assign_tail_lsn_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1069-1092",
    "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&log->l_tail_lsn",
            "tail_lsn"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_assign_tail_lsn",
          "args": [
            "log",
            "tail_lsn"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&log->l_last_sync_lsn"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "mp->m_ail"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mp->m_ail->xa_lock"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}"
  },
  {
    "function_name": "xfs_log_need_covered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "1027-1064",
    "snippet": "int\nxfs_log_need_covered(xfs_mount_t *mp)\n{\n\tstruct xlog\t*log = mp->m_log;\n\tint\t\tneeded = 0;\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\tif (!xlog_cil_empty(log))\n\t\treturn 0;\n\n\tspin_lock(&log->l_icloglock);\n\tswitch (log->l_covered_state) {\n\tcase XLOG_STATE_COVER_DONE:\n\tcase XLOG_STATE_COVER_DONE2:\n\tcase XLOG_STATE_COVER_IDLE:\n\t\tbreak;\n\tcase XLOG_STATE_COVER_NEED:\n\tcase XLOG_STATE_COVER_NEED2:\n\t\tif (xfs_ail_min_lsn(log->l_ailp))\n\t\t\tbreak;\n\t\tif (!xlog_iclogs_empty(log))\n\t\t\tbreak;\n\n\t\tneeded = 1;\n\t\tif (log->l_covered_state == XLOG_STATE_COVER_NEED)\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE;\n\t\telse\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE2;\n\t\tbreak;\n\tdefault:\n\t\tneeded = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&log->l_icloglock);\n\treturn needed;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_iclogs_empty",
          "args": [
            "log"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_iclogs_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3990-4006",
          "snippet": "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\t/* endianness does not matter here, zero is zero in\n\t\t * any language.\n\t\t */\n\t\tif (iclog->ic_header.h_num_logops)\n\t\t\treturn 0;\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog;\n\n\ticlog = log->l_iclog;\n\tdo {\n\t\t/* endianness does not matter here, zero is zero in\n\t\t * any language.\n\t\t */\n\t\tif (iclog->ic_header.h_num_logops)\n\t\t\treturn 0;\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != log->l_iclog);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_min_lsn",
          "args": [
            "log->l_ailp"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_empty",
          "args": [
            "log"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "744-756",
          "snippet": "bool\nxlog_cil_empty(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tbool\t\tempty = false;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil))\n\t\tempty = true;\n\tspin_unlock(&cil->xc_push_lock);\n\treturn empty;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxlog_cil_empty(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tbool\t\tempty = false;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil))\n\t\tempty = true;\n\tspin_unlock(&cil->xc_push_lock);\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fs_writable",
          "args": [
            "mp",
            "SB_FREEZE_WRITE"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1061-1072",
          "snippet": "bool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_fs_writable(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlevel)\n{\n\tASSERT(level > SB_UNFROZEN);\n\tif ((mp->m_super->s_writers.frozen >= level) ||\n\t    XFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_need_covered(xfs_mount_t *mp)\n{\n\tstruct xlog\t*log = mp->m_log;\n\tint\t\tneeded = 0;\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\tif (!xlog_cil_empty(log))\n\t\treturn 0;\n\n\tspin_lock(&log->l_icloglock);\n\tswitch (log->l_covered_state) {\n\tcase XLOG_STATE_COVER_DONE:\n\tcase XLOG_STATE_COVER_DONE2:\n\tcase XLOG_STATE_COVER_IDLE:\n\t\tbreak;\n\tcase XLOG_STATE_COVER_NEED:\n\tcase XLOG_STATE_COVER_NEED2:\n\t\tif (xfs_ail_min_lsn(log->l_ailp))\n\t\t\tbreak;\n\t\tif (!xlog_iclogs_empty(log))\n\t\t\tbreak;\n\n\t\tneeded = 1;\n\t\tif (log->l_covered_state == XLOG_STATE_COVER_NEED)\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE;\n\t\telse\n\t\t\tlog->l_covered_state = XLOG_STATE_COVER_DONE2;\n\t\tbreak;\n\tdefault:\n\t\tneeded = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&log->l_icloglock);\n\treturn needed;\n}"
  },
  {
    "function_name": "xfs_log_space_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "981-1008",
    "snippet": "void\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_reserve_head.lock"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_wake",
          "args": [
            "log",
            "&log->l_reserve_head",
            "&free_bytes"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "231-251",
          "snippet": "STATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_space_left",
          "args": [
            "log",
            "&log->l_reserve_head.grant"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1121-1157",
          "snippet": "STATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_reserve_head.lock"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(log->l_flags & XLOG_ACTIVE_RECOVERY)"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&log->l_reserve_head.waiters"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(log->l_flags & XLOG_ACTIVE_RECOVERY)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&log->l_write_head.waiters"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}"
  },
  {
    "function_name": "xfs_log_item_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "961-976",
    "snippet": "void\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&item->li_cil"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&item->li_ail"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}"
  },
  {
    "function_name": "xfs_log_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "948-959",
    "snippet": "void\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_dealloc_log",
          "args": [
            "mp->m_log"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_dealloc_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1892-1933",
          "snippet": "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_del",
          "args": [
            "&mp->m_log->l_kobj"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "51-58",
          "snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_sysfs_del(\n\tstruct xfs_kobj\t*kobj)\n{\n\tkobject_del(&kobj->kobject);\n\tkobject_put(&kobj->kobject);\n\twait_for_completion(&kobj->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_destroy",
          "args": [
            "mp"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "786-794",
          "snippet": "void\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_quiesce",
          "args": [
            "mp"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_quiesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "919-939",
          "snippet": "void\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_log_quiesce(mp);\n\n\txfs_trans_ail_destroy(mp);\n\n\txfs_sysfs_del(&mp->m_log->l_kobj);\n\n\txlog_dealloc_log(mp->m_log);\n}"
  },
  {
    "function_name": "xfs_log_quiesce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "919-939",
    "snippet": "void\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_unmount_write",
          "args": [
            "mp"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_unmount_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "778-908",
          "snippet": "int\nxfs_log_unmount_write(xfs_mount_t *mp)\n{\n\tstruct xlog\t *log = mp->m_log;\n\txlog_in_core_t\t *iclog;\n#ifdef DEBUG\n\txlog_in_core_t\t *first_iclog;\n#endif\n\txlog_ticket_t\t*tic = NULL;\n\txfs_lsn_t\t lsn;\n\tint\t\t error;\n\n\t/*\n\t * Don't write out unmount record on read-only mounts.\n\t * Or, if we are doing a forced umount (typically because of IO errors).\n\t */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\terror = _xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\tASSERT(error || !(XLOG_FORCED_SHUTDOWN(log)));\n\n#ifdef DEBUG\n\tfirst_iclog = iclog = log->l_iclog;\n\tdo {\n\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\tASSERT(iclog->ic_state & XLOG_STATE_ACTIVE);\n\t\t\tASSERT(iclog->ic_offset == 0);\n\t\t}\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != first_iclog);\n#endif\n\tif (! (XLOG_FORCED_SHUTDOWN(log))) {\n\t\terror = xfs_log_reserve(mp, 600, 1, &tic,\n\t\t\t\t\tXFS_LOG, 0, XLOG_UNMOUNT_REC_TYPE);\n\t\tif (!error) {\n\t\t\t/* the data section must be 32 bit size aligned */\n\t\t\tstruct {\n\t\t\t    __uint16_t magic;\n\t\t\t    __uint16_t pad1;\n\t\t\t    __uint32_t pad2; /* may as well make it 64 bits */\n\t\t\t} magic = {\n\t\t\t\t.magic = XLOG_UNMOUNT_TYPE,\n\t\t\t};\n\t\t\tstruct xfs_log_iovec reg = {\n\t\t\t\t.i_addr = &magic,\n\t\t\t\t.i_len = sizeof(magic),\n\t\t\t\t.i_type = XLOG_REG_TYPE_UNMOUNT,\n\t\t\t};\n\t\t\tstruct xfs_log_vec vec = {\n\t\t\t\t.lv_niovecs = 1,\n\t\t\t\t.lv_iovecp = &reg,\n\t\t\t};\n\n\t\t\t/* remove inited flag, and account for space used */\n\t\t\ttic->t_flags = 0;\n\t\t\ttic->t_curr_res -= sizeof(magic);\n\t\t\terror = xlog_write(log, &vec, tic, &lsn,\n\t\t\t\t\t   NULL, XLOG_UNMOUNT_TRANS);\n\t\t\t/*\n\t\t\t * At this point, we're umounting anyway,\n\t\t\t * so there's no point in transitioning log state\n\t\t\t * to IOERROR. Just continue...\n\t\t\t */\n\t\t}\n\n\t\tif (error)\n\t\t\txfs_alert(mp, \"%s: unmount record failed\", __func__);\n\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror = xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\t\tif (!(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t      iclog->ic_state == XLOG_STATE_DIRTY)) {\n\t\t\tif (!XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tif (tic) {\n\t\t\ttrace_xfs_log_umount_write(log, tic);\n\t\t\txlog_ungrant_log_space(log, tic);\n\t\t\txfs_log_ticket_put(tic);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're already in forced_shutdown mode, couldn't\n\t\t * even attempt to write out the unmount transaction.\n\t\t *\n\t\t * Go through the motions of sync'ing and releasing\n\t\t * the iclog, even though no I/O will actually happen,\n\t\t * we need to wait for other log I/Os that may already\n\t\t * be in progress.  Do this as a separate section of\n\t\t * code so we'll know if we ever get stuck here that\n\t\t * we're in this odd situation of trying to unmount\n\t\t * a file system that went into forced_shutdown as\n\t\t * the result of an unmount..\n\t\t */\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror =  xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\n\t\tif ( ! (   iclog->ic_state == XLOG_STATE_ACTIVE\n\t\t\t|| iclog->ic_state == XLOG_STATE_DIRTY\n\t\t\t|| iclog->ic_state == XLOG_STATE_IOERROR) ) {\n\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_unmount_write(xfs_mount_t *mp)\n{\n\tstruct xlog\t *log = mp->m_log;\n\txlog_in_core_t\t *iclog;\n#ifdef DEBUG\n\txlog_in_core_t\t *first_iclog;\n#endif\n\txlog_ticket_t\t*tic = NULL;\n\txfs_lsn_t\t lsn;\n\tint\t\t error;\n\n\t/*\n\t * Don't write out unmount record on read-only mounts.\n\t * Or, if we are doing a forced umount (typically because of IO errors).\n\t */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\terror = _xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\tASSERT(error || !(XLOG_FORCED_SHUTDOWN(log)));\n\n#ifdef DEBUG\n\tfirst_iclog = iclog = log->l_iclog;\n\tdo {\n\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\tASSERT(iclog->ic_state & XLOG_STATE_ACTIVE);\n\t\t\tASSERT(iclog->ic_offset == 0);\n\t\t}\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != first_iclog);\n#endif\n\tif (! (XLOG_FORCED_SHUTDOWN(log))) {\n\t\terror = xfs_log_reserve(mp, 600, 1, &tic,\n\t\t\t\t\tXFS_LOG, 0, XLOG_UNMOUNT_REC_TYPE);\n\t\tif (!error) {\n\t\t\t/* the data section must be 32 bit size aligned */\n\t\t\tstruct {\n\t\t\t    __uint16_t magic;\n\t\t\t    __uint16_t pad1;\n\t\t\t    __uint32_t pad2; /* may as well make it 64 bits */\n\t\t\t} magic = {\n\t\t\t\t.magic = XLOG_UNMOUNT_TYPE,\n\t\t\t};\n\t\t\tstruct xfs_log_iovec reg = {\n\t\t\t\t.i_addr = &magic,\n\t\t\t\t.i_len = sizeof(magic),\n\t\t\t\t.i_type = XLOG_REG_TYPE_UNMOUNT,\n\t\t\t};\n\t\t\tstruct xfs_log_vec vec = {\n\t\t\t\t.lv_niovecs = 1,\n\t\t\t\t.lv_iovecp = &reg,\n\t\t\t};\n\n\t\t\t/* remove inited flag, and account for space used */\n\t\t\ttic->t_flags = 0;\n\t\t\ttic->t_curr_res -= sizeof(magic);\n\t\t\terror = xlog_write(log, &vec, tic, &lsn,\n\t\t\t\t\t   NULL, XLOG_UNMOUNT_TRANS);\n\t\t\t/*\n\t\t\t * At this point, we're umounting anyway,\n\t\t\t * so there's no point in transitioning log state\n\t\t\t * to IOERROR. Just continue...\n\t\t\t */\n\t\t}\n\n\t\tif (error)\n\t\t\txfs_alert(mp, \"%s: unmount record failed\", __func__);\n\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror = xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\t\tif (!(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t      iclog->ic_state == XLOG_STATE_DIRTY)) {\n\t\t\tif (!XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tif (tic) {\n\t\t\ttrace_xfs_log_umount_write(log, tic);\n\t\t\txlog_ungrant_log_space(log, tic);\n\t\t\txfs_log_ticket_put(tic);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're already in forced_shutdown mode, couldn't\n\t\t * even attempt to write out the unmount transaction.\n\t\t *\n\t\t * Go through the motions of sync'ing and releasing\n\t\t * the iclog, even though no I/O will actually happen,\n\t\t * we need to wait for other log I/Os that may already\n\t\t * be in progress.  Do this as a separate section of\n\t\t * code so we'll know if we ever get stuck here that\n\t\t * we're in this odd situation of trying to unmount\n\t\t * a file system that went into forced_shutdown as\n\t\t * the result of an unmount..\n\t\t */\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror =  xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\n\t\tif ( ! (   iclog->ic_state == XLOG_STATE_ACTIVE\n\t\t\t|| iclog->ic_state == XLOG_STATE_DIRTY\n\t\t\t|| iclog->ic_state == XLOG_STATE_IOERROR) ) {\n\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "mp->m_sb_bp"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "mp->m_sb_bp"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_wait_buftarg",
          "args": [
            "mp->m_ddev_targp"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_wait_buftarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1518-1545",
          "snippet": "void\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_push_all_sync",
          "args": [
            "mp->m_ail"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push_all_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "594-613",
          "snippet": "void\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mp->m_log->l_work"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_quiesce(\n\tstruct xfs_mount\t*mp)\n{\n\tcancel_delayed_work_sync(&mp->m_log->l_work);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\n\t/*\n\t * The superblock buffer is uncached and while xfs_ail_push_all_sync()\n\t * will push it, xfs_wait_buftarg() will not wait for it. Further,\n\t * xfs_buf_iowait() cannot be used because it was pushed with the\n\t * XBF_ASYNC flag set, so we need to use a lock/unlock pair to wait for\n\t * the IO to complete.\n\t */\n\txfs_ail_push_all_sync(mp->m_ail);\n\txfs_wait_buftarg(mp->m_ddev_targp);\n\txfs_buf_lock(mp->m_sb_bp);\n\txfs_buf_unlock(mp->m_sb_bp);\n\n\txfs_log_unmount_write(mp);\n}"
  },
  {
    "function_name": "xfs_log_unmount_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "778-908",
    "snippet": "int\nxfs_log_unmount_write(xfs_mount_t *mp)\n{\n\tstruct xlog\t *log = mp->m_log;\n\txlog_in_core_t\t *iclog;\n#ifdef DEBUG\n\txlog_in_core_t\t *first_iclog;\n#endif\n\txlog_ticket_t\t*tic = NULL;\n\txfs_lsn_t\t lsn;\n\tint\t\t error;\n\n\t/*\n\t * Don't write out unmount record on read-only mounts.\n\t * Or, if we are doing a forced umount (typically because of IO errors).\n\t */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\terror = _xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\tASSERT(error || !(XLOG_FORCED_SHUTDOWN(log)));\n\n#ifdef DEBUG\n\tfirst_iclog = iclog = log->l_iclog;\n\tdo {\n\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\tASSERT(iclog->ic_state & XLOG_STATE_ACTIVE);\n\t\t\tASSERT(iclog->ic_offset == 0);\n\t\t}\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != first_iclog);\n#endif\n\tif (! (XLOG_FORCED_SHUTDOWN(log))) {\n\t\terror = xfs_log_reserve(mp, 600, 1, &tic,\n\t\t\t\t\tXFS_LOG, 0, XLOG_UNMOUNT_REC_TYPE);\n\t\tif (!error) {\n\t\t\t/* the data section must be 32 bit size aligned */\n\t\t\tstruct {\n\t\t\t    __uint16_t magic;\n\t\t\t    __uint16_t pad1;\n\t\t\t    __uint32_t pad2; /* may as well make it 64 bits */\n\t\t\t} magic = {\n\t\t\t\t.magic = XLOG_UNMOUNT_TYPE,\n\t\t\t};\n\t\t\tstruct xfs_log_iovec reg = {\n\t\t\t\t.i_addr = &magic,\n\t\t\t\t.i_len = sizeof(magic),\n\t\t\t\t.i_type = XLOG_REG_TYPE_UNMOUNT,\n\t\t\t};\n\t\t\tstruct xfs_log_vec vec = {\n\t\t\t\t.lv_niovecs = 1,\n\t\t\t\t.lv_iovecp = &reg,\n\t\t\t};\n\n\t\t\t/* remove inited flag, and account for space used */\n\t\t\ttic->t_flags = 0;\n\t\t\ttic->t_curr_res -= sizeof(magic);\n\t\t\terror = xlog_write(log, &vec, tic, &lsn,\n\t\t\t\t\t   NULL, XLOG_UNMOUNT_TRANS);\n\t\t\t/*\n\t\t\t * At this point, we're umounting anyway,\n\t\t\t * so there's no point in transitioning log state\n\t\t\t * to IOERROR. Just continue...\n\t\t\t */\n\t\t}\n\n\t\tif (error)\n\t\t\txfs_alert(mp, \"%s: unmount record failed\", __func__);\n\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror = xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\t\tif (!(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t      iclog->ic_state == XLOG_STATE_DIRTY)) {\n\t\t\tif (!XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tif (tic) {\n\t\t\ttrace_xfs_log_umount_write(log, tic);\n\t\t\txlog_ungrant_log_space(log, tic);\n\t\t\txfs_log_ticket_put(tic);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're already in forced_shutdown mode, couldn't\n\t\t * even attempt to write out the unmount transaction.\n\t\t *\n\t\t * Go through the motions of sync'ing and releasing\n\t\t * the iclog, even though no I/O will actually happen,\n\t\t * we need to wait for other log I/Os that may already\n\t\t * be in progress.  Do this as a separate section of\n\t\t * code so we'll know if we ever get stuck here that\n\t\t * we're in this odd situation of trying to unmount\n\t\t * a file system that went into forced_shutdown as\n\t\t * the result of an unmount..\n\t\t */\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror =  xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\n\t\tif ( ! (   iclog->ic_state == XLOG_STATE_ACTIVE\n\t\t\t|| iclog->ic_state == XLOG_STATE_DIRTY\n\t\t\t|| iclog->ic_state == XLOG_STATE_IOERROR) ) {\n\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&iclog->ic_force_wait",
            "&log->l_icloglock"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&log->l_icloglock"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "log",
            "iclog"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_state_want_sync",
          "args": [
            "log",
            "iclog"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_want_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3470-3483",
          "snippet": "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tassert_spin_locked(&log->l_icloglock);\n\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t} else {\n\t\tASSERT(iclog->ic_state &\n\t\t\t(XLOG_STATE_WANT_SYNC|XLOG_STATE_IOERROR));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "tic"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_ungrant_log_space",
          "args": [
            "log",
            "tic"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ungrant_log_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3031-3060",
          "snippet": "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_umount_write",
          "args": [
            "log",
            "tic"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iclog->ic_refcnt"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: unmount record failed\"",
            "__func__"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_write",
          "args": [
            "log",
            "&vec",
            "tic",
            "&lsn",
            "NULL",
            "XLOG_UNMOUNT_TRANS"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2298-2462",
          "snippet": "int\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_reserve",
          "args": [
            "mp",
            "600",
            "1",
            "&tic",
            "XFS_LOG",
            "0",
            "XLOG_UNMOUNT_REC_TYPE"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "431-487",
          "snippet": "int\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_offset == 0"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iclog->ic_state & XLOG_STATE_ACTIVE"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error || !(XLOG_FORCED_SHUTDOWN(log))"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC",
            "NULL"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3185-3297",
          "snippet": "int\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\txfs_lsn_t\t\tlsn;\n\n\tXFS_STATS_INC(xs_log_force);\n\n\txlog_cil_force(log);\n\n\tspin_lock(&log->l_icloglock);\n\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\t/* If the head iclog is not active nor dirty, we just attach\n\t * ourselves to the head and go to sleep.\n\t */\n\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t    iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t/*\n\t\t * If the head is dirty or (active and empty), then\n\t\t * we need to look at the previous iclog.  If the previous\n\t\t * iclog is active or dirty we are done.  There is nothing\n\t\t * to sync out.  Otherwise, we attach ourselves to the\n\t\t * previous iclog and go to sleep.\n\t\t */\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY ||\n\t\t    (atomic_read(&iclog->ic_refcnt) == 0\n\t\t     && iclog->ic_offset == 0)) {\n\t\t\ticlog = iclog->ic_prev;\n\t\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t\t    iclog->ic_state == XLOG_STATE_DIRTY)\n\t\t\t\tgoto no_sleep;\n\t\t\telse\n\t\t\t\tgoto maybe_sleep;\n\t\t} else {\n\t\t\tif (atomic_read(&iclog->ic_refcnt) == 0) {\n\t\t\t\t/* We are the only one with access to this\n\t\t\t\t * iclog.  Flush it out now.  There should\n\t\t\t\t * be a roundoff of zero to show that someone\n\t\t\t\t * has already taken care of the roundoff from\n\t\t\t\t * the previous sync.\n\t\t\t\t */\n\t\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\t\tlsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\n\t\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\tspin_lock(&log->l_icloglock);\n\t\t\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) == lsn &&\n\t\t\t\t    iclog->ic_state != XLOG_STATE_DIRTY)\n\t\t\t\t\tgoto maybe_sleep;\n\t\t\t\telse\n\t\t\t\t\tgoto no_sleep;\n\t\t\t} else {\n\t\t\t\t/* Someone else is writing to this iclog.\n\t\t\t\t * Use its call to flush out the data.  However,\n\t\t\t\t * the other thread may not force out this LR,\n\t\t\t\t * so we mark it WANT_SYNC.\n\t\t\t\t */\n\t\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\t\tgoto maybe_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By the time we come around again, the iclog could've been filled\n\t * which would give it another lsn.  If we have a new lsn, just\n\t * return because the relevant data has been flushed.\n\t */\nmaybe_sleep:\n\tif (flags & XFS_LOG_SYNC) {\n\t\t/*\n\t\t * We must check if we're shutting down here, before\n\t\t * we wait, while we're holding the l_icloglock.\n\t\t * Then we check again after waking up, in case our\n\t\t * sleep was disturbed by a bad news.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn -EIO;\n\t\t}\n\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t/*\n\t\t * No need to grab the log lock here since we're\n\t\t * only deciding whether or not to return EIO\n\t\t * and the memory read should be atomic.\n\t\t */\n\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\treturn -EIO;\n\t\tif (log_flushed)\n\t\t\t*log_flushed = 1;\n\t} else {\n\nno_sleep:\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_unmount_write(xfs_mount_t *mp)\n{\n\tstruct xlog\t *log = mp->m_log;\n\txlog_in_core_t\t *iclog;\n#ifdef DEBUG\n\txlog_in_core_t\t *first_iclog;\n#endif\n\txlog_ticket_t\t*tic = NULL;\n\txfs_lsn_t\t lsn;\n\tint\t\t error;\n\n\t/*\n\t * Don't write out unmount record on read-only mounts.\n\t * Or, if we are doing a forced umount (typically because of IO errors).\n\t */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\terror = _xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\tASSERT(error || !(XLOG_FORCED_SHUTDOWN(log)));\n\n#ifdef DEBUG\n\tfirst_iclog = iclog = log->l_iclog;\n\tdo {\n\t\tif (!(iclog->ic_state & XLOG_STATE_IOERROR)) {\n\t\t\tASSERT(iclog->ic_state & XLOG_STATE_ACTIVE);\n\t\t\tASSERT(iclog->ic_offset == 0);\n\t\t}\n\t\ticlog = iclog->ic_next;\n\t} while (iclog != first_iclog);\n#endif\n\tif (! (XLOG_FORCED_SHUTDOWN(log))) {\n\t\terror = xfs_log_reserve(mp, 600, 1, &tic,\n\t\t\t\t\tXFS_LOG, 0, XLOG_UNMOUNT_REC_TYPE);\n\t\tif (!error) {\n\t\t\t/* the data section must be 32 bit size aligned */\n\t\t\tstruct {\n\t\t\t    __uint16_t magic;\n\t\t\t    __uint16_t pad1;\n\t\t\t    __uint32_t pad2; /* may as well make it 64 bits */\n\t\t\t} magic = {\n\t\t\t\t.magic = XLOG_UNMOUNT_TYPE,\n\t\t\t};\n\t\t\tstruct xfs_log_iovec reg = {\n\t\t\t\t.i_addr = &magic,\n\t\t\t\t.i_len = sizeof(magic),\n\t\t\t\t.i_type = XLOG_REG_TYPE_UNMOUNT,\n\t\t\t};\n\t\t\tstruct xfs_log_vec vec = {\n\t\t\t\t.lv_niovecs = 1,\n\t\t\t\t.lv_iovecp = &reg,\n\t\t\t};\n\n\t\t\t/* remove inited flag, and account for space used */\n\t\t\ttic->t_flags = 0;\n\t\t\ttic->t_curr_res -= sizeof(magic);\n\t\t\terror = xlog_write(log, &vec, tic, &lsn,\n\t\t\t\t\t   NULL, XLOG_UNMOUNT_TRANS);\n\t\t\t/*\n\t\t\t * At this point, we're umounting anyway,\n\t\t\t * so there's no point in transitioning log state\n\t\t\t * to IOERROR. Just continue...\n\t\t\t */\n\t\t}\n\n\t\tif (error)\n\t\t\txfs_alert(mp, \"%s: unmount record failed\", __func__);\n\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror = xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\t\tif (!(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t\t      iclog->ic_state == XLOG_STATE_DIRTY)) {\n\t\t\tif (!XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t\tif (tic) {\n\t\t\ttrace_xfs_log_umount_write(log, tic);\n\t\t\txlog_ungrant_log_space(log, tic);\n\t\t\txfs_log_ticket_put(tic);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're already in forced_shutdown mode, couldn't\n\t\t * even attempt to write out the unmount transaction.\n\t\t *\n\t\t * Go through the motions of sync'ing and releasing\n\t\t * the iclog, even though no I/O will actually happen,\n\t\t * we need to wait for other log I/Os that may already\n\t\t * be in progress.  Do this as a separate section of\n\t\t * code so we'll know if we ever get stuck here that\n\t\t * we're in this odd situation of trying to unmount\n\t\t * a file system that went into forced_shutdown as\n\t\t * the result of an unmount..\n\t\t */\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tatomic_inc(&iclog->ic_refcnt);\n\n\t\txlog_state_want_sync(log, iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t\terror =  xlog_state_release_iclog(log, iclog);\n\n\t\tspin_lock(&log->l_icloglock);\n\n\t\tif ( ! (   iclog->ic_state == XLOG_STATE_ACTIVE\n\t\t\t|| iclog->ic_state == XLOG_STATE_DIRTY\n\t\t\t|| iclog->ic_state == XLOG_STATE_IOERROR) ) {\n\n\t\t\t\txlog_wait(&iclog->ic_force_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t} else {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_log_mount_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "745-760",
    "snippet": "int\nxfs_log_mount_finish(xfs_mount_t *mp)\n{\n\tint\terror = 0;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\terror = xlog_recover_finish(mp->m_log);\n\t\tif (!error)\n\t\t\txfs_log_work_queue(mp);\n\t} else {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_flags & XFS_MOUNT_RDONLY"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_work_queue",
          "args": [
            "mp"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1272-1278",
          "snippet": "void\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_work_queue(\n\tstruct xfs_mount        *mp)\n{\n\tqueue_delayed_work(mp->m_log_workqueue, &mp->m_log->l_work,\n\t\t\t\tmsecs_to_jiffies(xfs_syncd_centisecs * 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_recover_finish",
          "args": [
            "mp->m_log"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4560-4599",
          "snippet": "int\nxlog_recover_finish(\n\tstruct xlog\t*log)\n{\n\t/*\n\t * Now we're ready to do the transactions needed for the\n\t * rest of recovery.  Start with completing all the extent\n\t * free intent records and then process the unlinked inode\n\t * lists.  At this point, we essentially run in normal mode\n\t * except that we're still performing recovery actions\n\t * rather than accepting new requests.\n\t */\n\tif (log->l_flags & XLOG_RECOVERY_NEEDED) {\n\t\tint\terror;\n\t\terror = xlog_recover_process_efis(log);\n\t\tif (error) {\n\t\t\txfs_alert(log->l_mp, \"Failed to recover EFIs\");\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Sync the log to get all the EFIs out of the AIL.\n\t\t * This isn't absolutely necessary, but it helps in\n\t\t * case the unlink transactions would have problems\n\t\t * pushing the EFIs out of the way.\n\t\t */\n\t\txfs_log_force(log->l_mp, XFS_LOG_SYNC);\n\n\t\txlog_recover_process_iunlinks(log);\n\n\t\txlog_recover_check_summary(log);\n\n\t\txfs_notice(log->l_mp, \"Ending recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\t\tlog->l_flags &= ~XLOG_RECOVERY_NEEDED;\n\t} else {\n\t\txfs_info(log->l_mp, \"Ending clean mount\");\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxlog_recover_finish(\n\tstruct xlog\t*log)\n{\n\t/*\n\t * Now we're ready to do the transactions needed for the\n\t * rest of recovery.  Start with completing all the extent\n\t * free intent records and then process the unlinked inode\n\t * lists.  At this point, we essentially run in normal mode\n\t * except that we're still performing recovery actions\n\t * rather than accepting new requests.\n\t */\n\tif (log->l_flags & XLOG_RECOVERY_NEEDED) {\n\t\tint\terror;\n\t\terror = xlog_recover_process_efis(log);\n\t\tif (error) {\n\t\t\txfs_alert(log->l_mp, \"Failed to recover EFIs\");\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Sync the log to get all the EFIs out of the AIL.\n\t\t * This isn't absolutely necessary, but it helps in\n\t\t * case the unlink transactions would have problems\n\t\t * pushing the EFIs out of the way.\n\t\t */\n\t\txfs_log_force(log->l_mp, XFS_LOG_SYNC);\n\n\t\txlog_recover_process_iunlinks(log);\n\n\t\txlog_recover_check_summary(log);\n\n\t\txfs_notice(log->l_mp, \"Ending recovery (logdev: %s)\",\n\t\t\t\tlog->l_mp->m_logname ? log->l_mp->m_logname\n\t\t\t\t\t\t     : \"internal\");\n\t\tlog->l_flags &= ~XLOG_RECOVERY_NEEDED;\n\t} else {\n\t\txfs_info(log->l_mp, \"Ending clean mount\");\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_mount_finish(xfs_mount_t *mp)\n{\n\tint\terror = 0;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\terror = xlog_recover_finish(mp->m_log);\n\t\tif (!error)\n\t\t\txfs_log_work_queue(mp);\n\t} else {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_log_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "609-733",
    "snippet": "int\nxfs_log_mount(\n\txfs_mount_t\t*mp,\n\txfs_buftarg_t\t*log_target,\n\txfs_daddr_t\tblk_offset,\n\tint\t\tnum_bblks)\n{\n\tint\t\terror = 0;\n\tint\t\tmin_logfsbs;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\txfs_notice(mp, \"Mounting V%d Filesystem\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t} else {\n\t\txfs_notice(mp,\n\"Mounting V%d filesystem in no-recovery mode. Filesystem will be inconsistent.\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\tmp->m_log = xlog_alloc_log(mp, log_target, blk_offset, num_bblks);\n\tif (IS_ERR(mp->m_log)) {\n\t\terror = PTR_ERR(mp->m_log);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Validate the given log space and drop a critical message via syslog\n\t * if the log size is too small that would lead to some unexpected\n\t * situations in transaction log space reservation stage.\n\t *\n\t * Note: we can't just reject the mount if the validation fails.  This\n\t * would mean that people would have to downgrade their kernel just to\n\t * remedy the situation as there is no way to grow the log (short of\n\t * black magic surgery with xfs_db).\n\t *\n\t * We can, however, reject mounts for CRC format filesystems, as the\n\t * mkfs binary being used to make the filesystem should never create a\n\t * filesystem with a log that is too small.\n\t */\n\tmin_logfsbs = xfs_log_calc_minimum_size(mp);\n\n\tif (mp->m_sb.sb_logblocks < min_logfsbs) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too small, minimum size is %d blocks\",\n\t\t\t mp->m_sb.sb_logblocks, min_logfsbs);\n\t\terror = -EINVAL;\n\t} else if (mp->m_sb.sb_logblocks > XFS_MAX_LOG_BLOCKS) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too large, maximum size is %lld blocks\",\n\t\t\t mp->m_sb.sb_logblocks, XFS_MAX_LOG_BLOCKS);\n\t\terror = -EINVAL;\n\t} else if (XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks) > XFS_MAX_LOG_BYTES) {\n\t\txfs_warn(mp,\n\t\t\"log size %lld bytes too large, maximum size is %lld bytes\",\n\t\t\t XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks),\n\t\t\t XFS_MAX_LOG_BYTES);\n\t\terror = -EINVAL;\n\t}\n\tif (error) {\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_crit(mp, \"AAIEEE! Log failed size checks. Abort!\");\n\t\t\tASSERT(0);\n\t\t\tgoto out_free_log;\n\t\t}\n\t\txfs_crit(mp,\n\"Log size out of supported range. Continuing onwards, but if log hangs are\\n\"\n\"experienced then please report this message in the bug report.\");\n\t}\n\n\t/*\n\t * Initialize the AIL now we have a log.\n\t */\n\terror = xfs_trans_ail_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"AIL initialisation failed: error %d\", error);\n\t\tgoto out_free_log;\n\t}\n\tmp->m_log->l_ailp = mp->m_ail;\n\n\t/*\n\t * skip log recovery on a norecovery mount.  pretend it all\n\t * just worked.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\tint\treadonly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\terror = xlog_recover(mp->m_log);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"log mount/recovery failed: error %d\",\n\t\t\t\terror);\n\t\t\tgoto out_destroy_ail;\n\t\t}\n\t}\n\n\terror = xfs_sysfs_init(&mp->m_log->l_kobj, &xfs_log_ktype, &mp->m_kobj,\n\t\t\t       \"log\");\n\tif (error)\n\t\tgoto out_destroy_ail;\n\n\t/* Normal transactions can now occur */\n\tmp->m_log->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\n\t/*\n\t * Now the log has been fully initialised and we know were our\n\t * space grant counters are, we can initialise the permanent ticket\n\t * needed for delayed logging to work.\n\t */\n\txlog_cil_init_post_recovery(mp->m_log);\n\n\treturn 0;\n\nout_destroy_ail:\n\txfs_trans_ail_destroy(mp);\nout_free_log:\n\txlog_dealloc_log(mp->m_log);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_dealloc_log",
          "args": [
            "mp->m_log"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_dealloc_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1892-1933",
          "snippet": "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t*log)\n{\n\txlog_in_core_t\t*iclog, *next_iclog;\n\tint\t\ti;\n\n\txlog_cil_destroy(log);\n\n\t/*\n\t * Cycle all the iclogbuf locks to make sure all log IO completion\n\t * is done before we tear down these buffers.\n\t */\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_lock(iclog->ic_bp);\n\t\txfs_buf_unlock(iclog->ic_bp);\n\t\ticlog = iclog->ic_next;\n\t}\n\n\t/*\n\t * Always need to ensure that the extra buffer does not point to memory\n\t * owned by another log buffer before we free it. Also, cycle the lock\n\t * first to ensure we've completed IO on it.\n\t */\n\txfs_buf_lock(log->l_xbuf);\n\txfs_buf_unlock(log->l_xbuf);\n\txfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));\n\txfs_buf_free(log->l_xbuf);\n\n\ticlog = log->l_iclog;\n\tfor (i = 0; i < log->l_iclog_bufs; i++) {\n\t\txfs_buf_free(iclog->ic_bp);\n\t\tnext_iclog = iclog->ic_next;\n\t\tkmem_free(iclog);\n\t\ticlog = next_iclog;\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\n\tlog->l_mp->m_log = NULL;\n\tkmem_free(log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_destroy",
          "args": [
            "mp"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "786-794",
          "snippet": "void\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_init_post_recovery",
          "args": [
            "mp->m_log"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_init_post_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "74-80",
          "snippet": "void\nxlog_cil_init_post_recovery(\n\tstruct xlog\t*log)\n{\n\tlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\n\tlog->l_cilp->xc_ctx->sequence = 1;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxlog_cil_init_post_recovery(\n\tstruct xlog\t*log)\n{\n\tlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\n\tlog->l_cilp->xc_ctx->sequence = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sysfs_init",
          "args": [
            "&mp->m_log->l_kobj",
            "&xfs_log_ktype",
            "&mp->m_kobj",
            "\"log\""
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysfs.h",
          "lines": "39-49",
          "snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_sysfs_init(\n\tstruct xfs_kobj\t\t*kobj,\n\tstruct kobj_type\t*ktype,\n\tstruct xfs_kobj\t\t*parent_kobj,\n\tconst char\t\t*name)\n{\n\tinit_completion(&kobj->complete);\n\treturn kobject_init_and_add(&kobj->kobject, ktype,\n\t\t\t\t    &parent_kobj->kobject, \"%s\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log mount/recovery failed: error %d\"",
            "error"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_recover",
          "args": [
            "mp->m_log"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_recover_check_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_recover.c",
          "lines": "4607-4650",
          "snippet": "void\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxlog_recover_check_summary(\n\tstruct xlog\t*log)\n{\n\txfs_mount_t\t*mp;\n\txfs_agf_t\t*agfp;\n\txfs_buf_t\t*agfbp;\n\txfs_buf_t\t*agibp;\n\txfs_agnumber_t\tagno;\n\t__uint64_t\tfreeblks;\n\t__uint64_t\titotal;\n\t__uint64_t\tifree;\n\tint\t\terror;\n\n\tmp = log->l_mp;\n\n\tfreeblks = 0LL;\n\titotal = 0LL;\n\tifree = 0LL;\n\tfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\n\t\terror = xfs_read_agf(mp, NULL, agno, 0, &agfbp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agf read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tagfp = XFS_BUF_TO_AGF(agfbp);\n\t\t\tfreeblks += be32_to_cpu(agfp->agf_freeblks) +\n\t\t\t\t    be32_to_cpu(agfp->agf_flcount);\n\t\t\txfs_buf_relse(agfbp);\n\t\t}\n\n\t\terror = xfs_read_agi(mp, NULL, agno, &agibp);\n\t\tif (error) {\n\t\t\txfs_alert(mp, \"%s agi read failed agno %d error %d\",\n\t\t\t\t\t\t__func__, agno, error);\n\t\t} else {\n\t\t\tstruct xfs_agi\t*agi = XFS_BUF_TO_AGI(agibp);\n\n\t\t\titotal += be32_to_cpu(agi->agi_count);\n\t\t\tifree += be32_to_cpu(agi->agi_freecount);\n\t\t\txfs_buf_relse(agibp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"AIL initialisation failed: error %d\"",
            "error"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_init",
          "args": [
            "mp"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "756-784",
          "snippet": "int\nxfs_trans_ail_init(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp;\n\n\tailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\n\tif (!ailp)\n\t\treturn -ENOMEM;\n\n\tailp->xa_mount = mp;\n\tINIT_LIST_HEAD(&ailp->xa_ail);\n\tINIT_LIST_HEAD(&ailp->xa_cursors);\n\tspin_lock_init(&ailp->xa_lock);\n\tINIT_LIST_HEAD(&ailp->xa_buf_list);\n\tinit_waitqueue_head(&ailp->xa_empty);\n\n\tailp->xa_task = kthread_run(xfsaild, ailp, \"xfsaild/%s\",\n\t\t\tailp->xa_mount->m_fsname);\n\tif (IS_ERR(ailp->xa_task))\n\t\tgoto out_free_ailp;\n\n\tmp->m_ail = ailp;\n\treturn 0;\n\nout_free_ailp:\n\tkmem_free(ailp);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_ail_init(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp;\n\n\tailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\n\tif (!ailp)\n\t\treturn -ENOMEM;\n\n\tailp->xa_mount = mp;\n\tINIT_LIST_HEAD(&ailp->xa_ail);\n\tINIT_LIST_HEAD(&ailp->xa_cursors);\n\tspin_lock_init(&ailp->xa_lock);\n\tINIT_LIST_HEAD(&ailp->xa_buf_list);\n\tinit_waitqueue_head(&ailp->xa_empty);\n\n\tailp->xa_task = kthread_run(xfsaild, ailp, \"xfsaild/%s\",\n\t\t\tailp->xa_mount->m_fsname);\n\tif (IS_ERR(ailp->xa_task))\n\t\tgoto out_free_ailp;\n\n\tmp->m_ail = ailp;\n\treturn 0;\n\nout_free_ailp:\n\tkmem_free(ailp);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_crit",
          "args": [
            "mp",
            "\"Log size out of supported range. Continuing onwards, but if log hangs are\\n\"\n\"experienced then please report this message in the bug report.\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_crit",
          "args": [
            "mp",
            "\"AAIEEE! Log failed size checks. Abort!\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"log size %lld bytes too large, maximum size is %lld bytes\"",
            "XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks)",
            "XFS_MAX_LOG_BYTES"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "mp->m_sb.sb_logblocks"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "mp->m_sb.sb_logblocks"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Log size %d blocks too large, maximum size is %lld blocks\"",
            "mp->m_sb.sb_logblocks",
            "XFS_MAX_LOG_BLOCKS"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Log size %d blocks too small, minimum size is %d blocks\"",
            "mp->m_sb.sb_logblocks",
            "min_logfsbs"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_calc_minimum_size",
          "args": [
            "mp"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_calc_minimum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_rlimit.c",
          "lines": "94-148",
          "snippet": "int\nxfs_log_calc_minimum_size(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\ttres = {0};\n\tint\t\t\tmax_logres;\n\tint\t\t\tmin_logblks = 0;\n\tint\t\t\tlsunit = 0;\n\n\txfs_log_get_max_trans_res(mp, &tres);\n\n\tmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\n\tif (tres.tr_logcount > 1)\n\t\tmax_logres *= tres.tr_logcount;\n\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1)\n\t\tlsunit = BTOBB(mp->m_sb.sb_logsunit);\n\n\t/*\n\t * Two factors should be taken into account for calculating the minimum\n\t * log space.\n\t * 1) The fundamental limitation is that no single transaction can be\n\t *    larger than half size of the log.\n\t *\n\t *    From mkfs.xfs, this is considered by the XFS_MIN_LOG_FACTOR\n\t *    define, which is set to 3. That means we can definitely fit\n\t *    maximally sized 2 transactions in the log. We'll use this same\n\t *    value here.\n\t *\n\t * 2) If the lsunit option is specified, a transaction requires 2 LSU\n\t *    for the reservation because there are two log writes that can\n\t *    require padding - the transaction data and the commit record which\n\t *    are written separately and both can require padding to the LSU.\n\t *    Consider that we can have an active CIL reservation holding 2*LSU,\n\t *    but the CIL is not over a push threshold, in this case, if we\n\t *    don't have enough log space for at one new transaction, which\n\t *    includes another 2*LSU in the reservation, we will run into dead\n\t *    loop situation in log space grant procedure. i.e.\n\t *    xlog_grant_head_wait().\n\t *\n\t *    Hence the log size needs to be able to contain two maximally sized\n\t *    and padded transactions, which is (2 * (2 * LSU + maxlres)).\n\t *\n\t * Also, the log size should be a multiple of the log stripe unit, round\n\t * it up to lsunit boundary if lsunit is specified.\n\t */\n\tif (lsunit) {\n\t\tmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\n\t\t\t      2 * lsunit;\n\t} else\n\t\tmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\n\tmin_logblks *= XFS_MIN_LOG_FACTOR;\n\n\treturn XFS_BB_TO_FSB(mp, min_logblks);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_calc_minimum_size(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xfs_trans_res\ttres = {0};\n\tint\t\t\tmax_logres;\n\tint\t\t\tmin_logblks = 0;\n\tint\t\t\tlsunit = 0;\n\n\txfs_log_get_max_trans_res(mp, &tres);\n\n\tmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\n\tif (tres.tr_logcount > 1)\n\t\tmax_logres *= tres.tr_logcount;\n\n\tif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1)\n\t\tlsunit = BTOBB(mp->m_sb.sb_logsunit);\n\n\t/*\n\t * Two factors should be taken into account for calculating the minimum\n\t * log space.\n\t * 1) The fundamental limitation is that no single transaction can be\n\t *    larger than half size of the log.\n\t *\n\t *    From mkfs.xfs, this is considered by the XFS_MIN_LOG_FACTOR\n\t *    define, which is set to 3. That means we can definitely fit\n\t *    maximally sized 2 transactions in the log. We'll use this same\n\t *    value here.\n\t *\n\t * 2) If the lsunit option is specified, a transaction requires 2 LSU\n\t *    for the reservation because there are two log writes that can\n\t *    require padding - the transaction data and the commit record which\n\t *    are written separately and both can require padding to the LSU.\n\t *    Consider that we can have an active CIL reservation holding 2*LSU,\n\t *    but the CIL is not over a push threshold, in this case, if we\n\t *    don't have enough log space for at one new transaction, which\n\t *    includes another 2*LSU in the reservation, we will run into dead\n\t *    loop situation in log space grant procedure. i.e.\n\t *    xlog_grant_head_wait().\n\t *\n\t *    Hence the log size needs to be able to contain two maximally sized\n\t *    and padded transactions, which is (2 * (2 * LSU + maxlres)).\n\t *\n\t * Also, the log size should be a multiple of the log stripe unit, round\n\t * it up to lsunit boundary if lsunit is specified.\n\t */\n\tif (lsunit) {\n\t\tmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\n\t\t\t      2 * lsunit;\n\t} else\n\t\tmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\n\tmin_logblks *= XFS_MIN_LOG_FACTOR;\n\n\treturn XFS_BB_TO_FSB(mp, min_logblks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mp->m_log"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mp->m_log"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_alloc_log",
          "args": [
            "mp",
            "log_target",
            "blk_offset",
            "num_bblks"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_alloc_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1322-1496",
          "snippet": "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks)\n{\n\tstruct xlog\t\t*log;\n\txlog_rec_header_t\t*head;\n\txlog_in_core_t\t\t**iclogp;\n\txlog_in_core_t\t\t*iclog, *prev_iclog=NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\ti;\n\tint\t\t\terror = -ENOMEM;\n\tuint\t\t\tlog2_size = 0;\n\n\tlog = kmem_zalloc(sizeof(struct xlog), KM_MAYFAIL);\n\tif (!log) {\n\t\txfs_warn(mp, \"Log allocation failed: No memory!\");\n\t\tgoto out;\n\t}\n\n\tlog->l_mp\t   = mp;\n\tlog->l_targ\t   = log_target;\n\tlog->l_logsize     = BBTOB(num_bblks);\n\tlog->l_logBBstart  = blk_offset;\n\tlog->l_logBBsize   = num_bblks;\n\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\tlog->l_flags\t   |= XLOG_ACTIVE_RECOVERY;\n\tINIT_DELAYED_WORK(&log->l_work, xfs_log_worker);\n\n\tlog->l_prev_block  = -1;\n\t/* log->l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */\n\txlog_assign_atomic_lsn(&log->l_tail_lsn, 1, 0);\n\txlog_assign_atomic_lsn(&log->l_last_sync_lsn, 1, 0);\n\tlog->l_curr_cycle  = 1;\t    /* 0 is bad since this is initial value */\n\n\txlog_grant_head_init(&log->l_reserve_head);\n\txlog_grant_head_init(&log->l_write_head);\n\n\terror = -EFSCORRUPTED;\n\tif (xfs_sb_version_hassector(&mp->m_sb)) {\n\t        log2_size = mp->m_sb.sb_logsectlog;\n\t\tif (log2_size < BBSHIFT) {\n\t\t\txfs_warn(mp, \"Log sector size too small (0x%x < 0x%x)\",\n\t\t\t\tlog2_size, BBSHIFT);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t        log2_size -= BBSHIFT;\n\t\tif (log2_size > mp->m_sectbb_log) {\n\t\t\txfs_warn(mp, \"Log sector size too large (0x%x > 0x%x)\",\n\t\t\t\tlog2_size, mp->m_sectbb_log);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t\t/* for larger sector sizes, must have v2 or external log */\n\t\tif (log2_size && log->l_logBBstart > 0 &&\n\t\t\t    !xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\txfs_warn(mp,\n\t\t\"log sector size (0x%x) invalid for configuration.\",\n\t\t\t\tlog2_size);\n\t\t\tgoto out_free_log;\n\t\t}\n\t}\n\tlog->l_sectBBsize = 1 << log2_size;\n\n\txlog_get_iclog_buffer_size(mp, log);\n\n\t/*\n\t * Use a NULL block for the extra log buffer used during splits so that\n\t * it will trigger errors if we ever try to do IO on it without first\n\t * having set it up properly.\n\t */\n\terror = -ENOMEM;\n\tbp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,\n\t\t\t   BTOBB(log->l_iclog_size), 0);\n\tif (!bp)\n\t\tgoto out_free_log;\n\n\t/*\n\t * The iclogbuf buffer locks are held over IO but we are not going to do\n\t * IO yet.  Hence unlock the buffer so that the log IO path can grab it\n\t * when appropriately.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_buf_unlock(bp);\n\n\t/* use high priority wq for log I/O completion */\n\tbp->b_ioend_wq = mp->m_log_workqueue;\n\tbp->b_iodone = xlog_iodone;\n\tlog->l_xbuf = bp;\n\n\tspin_lock_init(&log->l_icloglock);\n\tinit_waitqueue_head(&log->l_flush_wait);\n\n\ticlogp = &log->l_iclog;\n\t/*\n\t * The amount of memory to allocate for the iclog structure is\n\t * rather funky due to the way the structure is defined.  It is\n\t * done this way so that we can use different sizes for machines\n\t * with different amounts of memory.  See the definition of\n\t * xlog_in_core_t in xfs_log_priv.h for details.\n\t */\n\tASSERT(log->l_iclog_size >= 4096);\n\tfor (i=0; i < log->l_iclog_bufs; i++) {\n\t\t*iclogp = kmem_zalloc(sizeof(xlog_in_core_t), KM_MAYFAIL);\n\t\tif (!*iclogp)\n\t\t\tgoto out_free_iclog;\n\n\t\ticlog = *iclogp;\n\t\ticlog->ic_prev = prev_iclog;\n\t\tprev_iclog = iclog;\n\n\t\tbp = xfs_buf_get_uncached(mp->m_logdev_targp,\n\t\t\t\t\t\tBTOBB(log->l_iclog_size), 0);\n\t\tif (!bp)\n\t\t\tgoto out_free_iclog;\n\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\txfs_buf_unlock(bp);\n\n\t\t/* use high priority wq for log I/O completion */\n\t\tbp->b_ioend_wq = mp->m_log_workqueue;\n\t\tbp->b_iodone = xlog_iodone;\n\t\ticlog->ic_bp = bp;\n\t\ticlog->ic_data = bp->b_addr;\n#ifdef DEBUG\n\t\tlog->l_iclog_bak[i] = (xfs_caddr_t)&(iclog->ic_header);\n#endif\n\t\thead = &iclog->ic_header;\n\t\tmemset(head, 0, sizeof(xlog_rec_header_t));\n\t\thead->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\t\thead->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\t\thead->h_size = cpu_to_be32(log->l_iclog_size);\n\t\t/* new fields */\n\t\thead->h_fmt = cpu_to_be32(XLOG_FMT);\n\t\tmemcpy(&head->h_fs_uuid, &mp->m_sb.sb_uuid, sizeof(uuid_t));\n\n\t\ticlog->ic_size = BBTOB(bp->b_length) - log->l_iclog_hsize;\n\t\ticlog->ic_state = XLOG_STATE_ACTIVE;\n\t\ticlog->ic_log = log;\n\t\tatomic_set(&iclog->ic_refcnt, 0);\n\t\tspin_lock_init(&iclog->ic_callback_lock);\n\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\ticlog->ic_datap = (char *)iclog->ic_data + log->l_iclog_hsize;\n\n\t\tinit_waitqueue_head(&iclog->ic_force_wait);\n\t\tinit_waitqueue_head(&iclog->ic_write_wait);\n\n\t\ticlogp = &iclog->ic_next;\n\t}\n\t*iclogp = log->l_iclog;\t\t\t/* complete ring */\n\tlog->l_iclog->ic_prev = prev_iclog;\t/* re-write 1st prev ptr */\n\n\terror = xlog_cil_init(log);\n\tif (error)\n\t\tgoto out_free_iclog;\n\treturn log;\n\nout_free_iclog:\n\tfor (iclog = log->l_iclog; iclog; iclog = prev_iclog) {\n\t\tprev_iclog = iclog->ic_next;\n\t\tif (iclog->ic_bp)\n\t\t\txfs_buf_free(iclog->ic_bp);\n\t\tkmem_free(iclog);\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\txfs_buf_free(log->l_xbuf);\nout_free_log:\n\tkmem_free(log);\nout:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "xlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks)\n{\n\tstruct xlog\t\t*log;\n\txlog_rec_header_t\t*head;\n\txlog_in_core_t\t\t**iclogp;\n\txlog_in_core_t\t\t*iclog, *prev_iclog=NULL;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\ti;\n\tint\t\t\terror = -ENOMEM;\n\tuint\t\t\tlog2_size = 0;\n\n\tlog = kmem_zalloc(sizeof(struct xlog), KM_MAYFAIL);\n\tif (!log) {\n\t\txfs_warn(mp, \"Log allocation failed: No memory!\");\n\t\tgoto out;\n\t}\n\n\tlog->l_mp\t   = mp;\n\tlog->l_targ\t   = log_target;\n\tlog->l_logsize     = BBTOB(num_bblks);\n\tlog->l_logBBstart  = blk_offset;\n\tlog->l_logBBsize   = num_bblks;\n\tlog->l_covered_state = XLOG_STATE_COVER_IDLE;\n\tlog->l_flags\t   |= XLOG_ACTIVE_RECOVERY;\n\tINIT_DELAYED_WORK(&log->l_work, xfs_log_worker);\n\n\tlog->l_prev_block  = -1;\n\t/* log->l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */\n\txlog_assign_atomic_lsn(&log->l_tail_lsn, 1, 0);\n\txlog_assign_atomic_lsn(&log->l_last_sync_lsn, 1, 0);\n\tlog->l_curr_cycle  = 1;\t    /* 0 is bad since this is initial value */\n\n\txlog_grant_head_init(&log->l_reserve_head);\n\txlog_grant_head_init(&log->l_write_head);\n\n\terror = -EFSCORRUPTED;\n\tif (xfs_sb_version_hassector(&mp->m_sb)) {\n\t        log2_size = mp->m_sb.sb_logsectlog;\n\t\tif (log2_size < BBSHIFT) {\n\t\t\txfs_warn(mp, \"Log sector size too small (0x%x < 0x%x)\",\n\t\t\t\tlog2_size, BBSHIFT);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t        log2_size -= BBSHIFT;\n\t\tif (log2_size > mp->m_sectbb_log) {\n\t\t\txfs_warn(mp, \"Log sector size too large (0x%x > 0x%x)\",\n\t\t\t\tlog2_size, mp->m_sectbb_log);\n\t\t\tgoto out_free_log;\n\t\t}\n\n\t\t/* for larger sector sizes, must have v2 or external log */\n\t\tif (log2_size && log->l_logBBstart > 0 &&\n\t\t\t    !xfs_sb_version_haslogv2(&mp->m_sb)) {\n\t\t\txfs_warn(mp,\n\t\t\"log sector size (0x%x) invalid for configuration.\",\n\t\t\t\tlog2_size);\n\t\t\tgoto out_free_log;\n\t\t}\n\t}\n\tlog->l_sectBBsize = 1 << log2_size;\n\n\txlog_get_iclog_buffer_size(mp, log);\n\n\t/*\n\t * Use a NULL block for the extra log buffer used during splits so that\n\t * it will trigger errors if we ever try to do IO on it without first\n\t * having set it up properly.\n\t */\n\terror = -ENOMEM;\n\tbp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,\n\t\t\t   BTOBB(log->l_iclog_size), 0);\n\tif (!bp)\n\t\tgoto out_free_log;\n\n\t/*\n\t * The iclogbuf buffer locks are held over IO but we are not going to do\n\t * IO yet.  Hence unlock the buffer so that the log IO path can grab it\n\t * when appropriately.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_buf_unlock(bp);\n\n\t/* use high priority wq for log I/O completion */\n\tbp->b_ioend_wq = mp->m_log_workqueue;\n\tbp->b_iodone = xlog_iodone;\n\tlog->l_xbuf = bp;\n\n\tspin_lock_init(&log->l_icloglock);\n\tinit_waitqueue_head(&log->l_flush_wait);\n\n\ticlogp = &log->l_iclog;\n\t/*\n\t * The amount of memory to allocate for the iclog structure is\n\t * rather funky due to the way the structure is defined.  It is\n\t * done this way so that we can use different sizes for machines\n\t * with different amounts of memory.  See the definition of\n\t * xlog_in_core_t in xfs_log_priv.h for details.\n\t */\n\tASSERT(log->l_iclog_size >= 4096);\n\tfor (i=0; i < log->l_iclog_bufs; i++) {\n\t\t*iclogp = kmem_zalloc(sizeof(xlog_in_core_t), KM_MAYFAIL);\n\t\tif (!*iclogp)\n\t\t\tgoto out_free_iclog;\n\n\t\ticlog = *iclogp;\n\t\ticlog->ic_prev = prev_iclog;\n\t\tprev_iclog = iclog;\n\n\t\tbp = xfs_buf_get_uncached(mp->m_logdev_targp,\n\t\t\t\t\t\tBTOBB(log->l_iclog_size), 0);\n\t\tif (!bp)\n\t\t\tgoto out_free_iclog;\n\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\txfs_buf_unlock(bp);\n\n\t\t/* use high priority wq for log I/O completion */\n\t\tbp->b_ioend_wq = mp->m_log_workqueue;\n\t\tbp->b_iodone = xlog_iodone;\n\t\ticlog->ic_bp = bp;\n\t\ticlog->ic_data = bp->b_addr;\n#ifdef DEBUG\n\t\tlog->l_iclog_bak[i] = (xfs_caddr_t)&(iclog->ic_header);\n#endif\n\t\thead = &iclog->ic_header;\n\t\tmemset(head, 0, sizeof(xlog_rec_header_t));\n\t\thead->h_magicno = cpu_to_be32(XLOG_HEADER_MAGIC_NUM);\n\t\thead->h_version = cpu_to_be32(\n\t\t\txfs_sb_version_haslogv2(&log->l_mp->m_sb) ? 2 : 1);\n\t\thead->h_size = cpu_to_be32(log->l_iclog_size);\n\t\t/* new fields */\n\t\thead->h_fmt = cpu_to_be32(XLOG_FMT);\n\t\tmemcpy(&head->h_fs_uuid, &mp->m_sb.sb_uuid, sizeof(uuid_t));\n\n\t\ticlog->ic_size = BBTOB(bp->b_length) - log->l_iclog_hsize;\n\t\ticlog->ic_state = XLOG_STATE_ACTIVE;\n\t\ticlog->ic_log = log;\n\t\tatomic_set(&iclog->ic_refcnt, 0);\n\t\tspin_lock_init(&iclog->ic_callback_lock);\n\t\ticlog->ic_callback_tail = &(iclog->ic_callback);\n\t\ticlog->ic_datap = (char *)iclog->ic_data + log->l_iclog_hsize;\n\n\t\tinit_waitqueue_head(&iclog->ic_force_wait);\n\t\tinit_waitqueue_head(&iclog->ic_write_wait);\n\n\t\ticlogp = &iclog->ic_next;\n\t}\n\t*iclogp = log->l_iclog;\t\t\t/* complete ring */\n\tlog->l_iclog->ic_prev = prev_iclog;\t/* re-write 1st prev ptr */\n\n\terror = xlog_cil_init(log);\n\tif (error)\n\t\tgoto out_free_iclog;\n\treturn log;\n\nout_free_iclog:\n\tfor (iclog = log->l_iclog; iclog; iclog = prev_iclog) {\n\t\tprev_iclog = iclog->ic_next;\n\t\tif (iclog->ic_bp)\n\t\t\txfs_buf_free(iclog->ic_bp);\n\t\tkmem_free(iclog);\n\t}\n\tspinlock_destroy(&log->l_icloglock);\n\txfs_buf_free(log->l_xbuf);\nout_free_log:\n\tkmem_free(log);\nout:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_flags & XFS_MOUNT_RDONLY"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Mounting V%d filesystem in no-recovery mode. Filesystem will be inconsistent.\"",
            "XFS_SB_VERSION_NUM(&mp->m_sb)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SB_VERSION_NUM",
          "args": [
            "&mp->m_sb"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Mounting V%d Filesystem\"",
            "XFS_SB_VERSION_NUM(&mp->m_sb)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SB_VERSION_NUM",
          "args": [
            "&mp->m_sb"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxlog *\nxlog_alloc_log(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*log_target,\n\txfs_daddr_t\t\tblk_offset,\n\tint\t\t\tnum_bblks);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\n\nint\nxfs_log_mount(\n\txfs_mount_t\t*mp,\n\txfs_buftarg_t\t*log_target,\n\txfs_daddr_t\tblk_offset,\n\tint\t\tnum_bblks)\n{\n\tint\t\terror = 0;\n\tint\t\tmin_logfsbs;\n\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\txfs_notice(mp, \"Mounting V%d Filesystem\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t} else {\n\t\txfs_notice(mp,\n\"Mounting V%d filesystem in no-recovery mode. Filesystem will be inconsistent.\",\n\t\t\t   XFS_SB_VERSION_NUM(&mp->m_sb));\n\t\tASSERT(mp->m_flags & XFS_MOUNT_RDONLY);\n\t}\n\n\tmp->m_log = xlog_alloc_log(mp, log_target, blk_offset, num_bblks);\n\tif (IS_ERR(mp->m_log)) {\n\t\terror = PTR_ERR(mp->m_log);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Validate the given log space and drop a critical message via syslog\n\t * if the log size is too small that would lead to some unexpected\n\t * situations in transaction log space reservation stage.\n\t *\n\t * Note: we can't just reject the mount if the validation fails.  This\n\t * would mean that people would have to downgrade their kernel just to\n\t * remedy the situation as there is no way to grow the log (short of\n\t * black magic surgery with xfs_db).\n\t *\n\t * We can, however, reject mounts for CRC format filesystems, as the\n\t * mkfs binary being used to make the filesystem should never create a\n\t * filesystem with a log that is too small.\n\t */\n\tmin_logfsbs = xfs_log_calc_minimum_size(mp);\n\n\tif (mp->m_sb.sb_logblocks < min_logfsbs) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too small, minimum size is %d blocks\",\n\t\t\t mp->m_sb.sb_logblocks, min_logfsbs);\n\t\terror = -EINVAL;\n\t} else if (mp->m_sb.sb_logblocks > XFS_MAX_LOG_BLOCKS) {\n\t\txfs_warn(mp,\n\t\t\"Log size %d blocks too large, maximum size is %lld blocks\",\n\t\t\t mp->m_sb.sb_logblocks, XFS_MAX_LOG_BLOCKS);\n\t\terror = -EINVAL;\n\t} else if (XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks) > XFS_MAX_LOG_BYTES) {\n\t\txfs_warn(mp,\n\t\t\"log size %lld bytes too large, maximum size is %lld bytes\",\n\t\t\t XFS_FSB_TO_B(mp, mp->m_sb.sb_logblocks),\n\t\t\t XFS_MAX_LOG_BYTES);\n\t\terror = -EINVAL;\n\t}\n\tif (error) {\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_crit(mp, \"AAIEEE! Log failed size checks. Abort!\");\n\t\t\tASSERT(0);\n\t\t\tgoto out_free_log;\n\t\t}\n\t\txfs_crit(mp,\n\"Log size out of supported range. Continuing onwards, but if log hangs are\\n\"\n\"experienced then please report this message in the bug report.\");\n\t}\n\n\t/*\n\t * Initialize the AIL now we have a log.\n\t */\n\terror = xfs_trans_ail_init(mp);\n\tif (error) {\n\t\txfs_warn(mp, \"AIL initialisation failed: error %d\", error);\n\t\tgoto out_free_log;\n\t}\n\tmp->m_log->l_ailp = mp->m_ail;\n\n\t/*\n\t * skip log recovery on a norecovery mount.  pretend it all\n\t * just worked.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_NORECOVERY)) {\n\t\tint\treadonly = (mp->m_flags & XFS_MOUNT_RDONLY);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags &= ~XFS_MOUNT_RDONLY;\n\n\t\terror = xlog_recover(mp->m_log);\n\n\t\tif (readonly)\n\t\t\tmp->m_flags |= XFS_MOUNT_RDONLY;\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"log mount/recovery failed: error %d\",\n\t\t\t\terror);\n\t\t\tgoto out_destroy_ail;\n\t\t}\n\t}\n\n\terror = xfs_sysfs_init(&mp->m_log->l_kobj, &xfs_log_ktype, &mp->m_kobj,\n\t\t\t       \"log\");\n\tif (error)\n\t\tgoto out_destroy_ail;\n\n\t/* Normal transactions can now occur */\n\tmp->m_log->l_flags &= ~XLOG_ACTIVE_RECOVERY;\n\n\t/*\n\t * Now the log has been fully initialised and we know were our\n\t * space grant counters are, we can initialise the permanent ticket\n\t * needed for delayed logging to work.\n\t */\n\txlog_cil_init_post_recovery(mp->m_log);\n\n\treturn 0;\n\nout_destroy_ail:\n\txfs_trans_ail_destroy(mp);\nout_free_log:\n\txlog_dealloc_log(mp->m_log);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_log_release_iclog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "586-597",
    "snippet": "int\nxfs_log_release_iclog(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog)\n{\n\tif (xlog_state_release_iclog(mp->m_log, iclog)) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_state_release_iclog",
          "args": [
            "mp->m_log",
            "iclog"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_state_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3071-3113",
          "snippet": "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog)\n{\n\tint\t\tsync = 0;\t/* do we sync? */\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\treturn -EIO;\n\n\tASSERT(atomic_read(&iclog->ic_refcnt) > 0);\n\tif (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))\n\t\treturn 0;\n\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\tASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||\n\t       iclog->ic_state == XLOG_STATE_WANT_SYNC);\n\n\tif (iclog->ic_state == XLOG_STATE_WANT_SYNC) {\n\t\t/* update tail before writing to iclog */\n\t\txfs_lsn_t tail_lsn = xlog_assign_tail_lsn(log->l_mp);\n\t\tsync++;\n\t\ticlog->ic_state = XLOG_STATE_SYNCING;\n\t\ticlog->ic_header.h_tail_lsn = cpu_to_be64(tail_lsn);\n\t\txlog_verify_tail_lsn(log, iclog, tail_lsn);\n\t\t/* cycle incremented when incrementing curr_block */\n\t}\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We let the log lock go, so it's possible that we hit a log I/O\n\t * error or some other SHUTDOWN condition that marks the iclog\n\t * as XLOG_STATE_IOERROR before the bwrite. However, we know that\n\t * this iclog has consistent data, so we ignore IOERROR\n\t * flags after this point.\n\t */\n\tif (sync)\n\t\treturn xlog_sync(log, iclog);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC struct;\n\nint\nxfs_log_release_iclog(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog)\n{\n\tif (xlog_state_release_iclog(mp->m_log, iclog)) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_log_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "565-584",
    "snippet": "int\nxfs_log_notify(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog,\n\txfs_log_callback_t\t*cb)\n{\n\tint\tabortflg;\n\n\tspin_lock(&iclog->ic_callback_lock);\n\tabortflg = (iclog->ic_state & XLOG_STATE_IOERROR);\n\tif (!abortflg) {\n\t\tASSERT_ALWAYS((iclog->ic_state == XLOG_STATE_ACTIVE) ||\n\t\t\t      (iclog->ic_state == XLOG_STATE_WANT_SYNC));\n\t\tcb->cb_next = NULL;\n\t\t*(iclog->ic_callback_tail) = cb;\n\t\ticlog->ic_callback_tail = &(cb->cb_next);\n\t}\n\tspin_unlock(&iclog->ic_callback_lock);\n\treturn abortflg;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iclog->ic_callback_lock"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_ALWAYS",
          "args": [
            "(iclog->ic_state == XLOG_STATE_ACTIVE) ||\n\t\t\t      (iclog->ic_state == XLOG_STATE_WANT_SYNC)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iclog->ic_callback_lock"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC struct;\n\nint\nxfs_log_notify(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog,\n\txfs_log_callback_t\t*cb)\n{\n\tint\tabortflg;\n\n\tspin_lock(&iclog->ic_callback_lock);\n\tabortflg = (iclog->ic_state & XLOG_STATE_IOERROR);\n\tif (!abortflg) {\n\t\tASSERT_ALWAYS((iclog->ic_state == XLOG_STATE_ACTIVE) ||\n\t\t\t      (iclog->ic_state == XLOG_STATE_WANT_SYNC));\n\t\tcb->cb_next = NULL;\n\t\t*(iclog->ic_callback_tail) = cb;\n\t\ticlog->ic_callback_tail = &(cb->cb_next);\n\t}\n\tspin_unlock(&iclog->ic_callback_lock);\n\treturn abortflg;\n}"
  },
  {
    "function_name": "xfs_log_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "511-557",
    "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
      "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_regrant_reserve_log_space",
          "args": [
            "log",
            "ticket"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_regrant_reserve_log_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2984-3014",
          "snippet": "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\ttrace_xfs_log_regrant_reserve_enter(log, ticket);\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\txlog_grant_sub_space(log, &log->l_write_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n\n\ttrace_xfs_log_regrant_reserve_sub(log, ticket);\n\n\t/* just return if we still have some of the pre-reserved space */\n\tif (ticket->t_cnt > 0)\n\t\treturn;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_unit_res);\n\n\ttrace_xfs_log_regrant_reserve_exit(log, ticket);\n\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\ttrace_xfs_log_regrant_reserve_enter(log, ticket);\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\txlog_grant_sub_space(log, &log->l_write_head.grant,\n\t\t\t\t\tticket->t_curr_res);\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n\n\ttrace_xfs_log_regrant_reserve_sub(log, ticket);\n\n\t/* just return if we still have some of the pre-reserved space */\n\tif (ticket->t_cnt > 0)\n\t\treturn;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant,\n\t\t\t\t\tticket->t_unit_res);\n\n\ttrace_xfs_log_regrant_reserve_exit(log, ticket);\n\n\tticket->t_curr_res = ticket->t_unit_res;\n\txlog_tic_reset_res(ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_done_perm",
          "args": [
            "log",
            "ticket"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "ticket"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_ungrant_log_space",
          "args": [
            "log",
            "ticket"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ungrant_log_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3031-3060",
          "snippet": "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket)\n{\n\tint\tbytes;\n\n\tif (ticket->t_cnt > 0)\n\t\tticket->t_cnt--;\n\n\ttrace_xfs_log_ungrant_enter(log, ticket);\n\ttrace_xfs_log_ungrant_sub(log, ticket);\n\n\t/*\n\t * If this is a permanent reservation ticket, we may be able to free\n\t * up more space based on the remaining count.\n\t */\n\tbytes = ticket->t_curr_res;\n\tif (ticket->t_cnt > 0) {\n\t\tASSERT(ticket->t_flags & XLOG_TIC_PERM_RESERV);\n\t\tbytes += ticket->t_unit_res*ticket->t_cnt;\n\t}\n\n\txlog_grant_sub_space(log, &log->l_reserve_head.grant, bytes);\n\txlog_grant_sub_space(log, &log->l_write_head.grant, bytes);\n\n\ttrace_xfs_log_ungrant_exit(log, ticket);\n\n\txfs_log_space_wake(log->l_mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_done_nonperm",
          "args": [
            "log",
            "ticket"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_commit_record",
          "args": [
            "log",
            "ticket",
            "iclog",
            "&lsn"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_commit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1503-1528",
          "snippet": "STATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp)\n{\n\tstruct xfs_mount *mp = log->l_mp;\n\tint\terror;\n\tstruct xfs_log_iovec reg = {\n\t\t.i_addr = NULL,\n\t\t.i_len = 0,\n\t\t.i_type = XLOG_REG_TYPE_COMMIT,\n\t};\n\tstruct xfs_log_vec vec = {\n\t\t.lv_niovecs = 1,\n\t\t.lv_iovecp = &reg,\n\t};\n\n\tASSERT_ALWAYS(iclog);\n\terror = xlog_write(log, &vec, ticket, commitlsnp, iclog,\n\t\t\t\t\tXLOG_COMMIT_TRANS);\n\tif (error)\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp);",
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp);\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_commit_record(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\txfs_lsn_t\t\t*commitlsnp)\n{\n\tstruct xfs_mount *mp = log->l_mp;\n\tint\terror;\n\tstruct xfs_log_iovec reg = {\n\t\t.i_addr = NULL,\n\t\t.i_len = 0,\n\t\t.i_type = XLOG_REG_TYPE_COMMIT,\n\t};\n\tstruct xfs_log_vec vec = {\n\t\t.lv_niovecs = 1,\n\t\t.lv_iovecp = &reg,\n\t};\n\n\tASSERT_ALWAYS(iclog);\n\terror = xlog_write(log, &vec, ticket, commitlsnp, iclog,\n\t\t\t\t\tXLOG_COMMIT_TRANS);\n\tif (error)\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_log_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "431-487",
    "snippet": "int\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_verify_grant_tail",
          "args": [
            "log"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_verify_grant_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3693-3717",
          "snippet": "STATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_reserve_exit",
          "args": [
            "log",
            "tic"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_add_space",
          "args": [
            "log",
            "&log->l_write_head.grant",
            "need_bytes"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_add_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "164-191",
          "snippet": "static void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_check",
          "args": [
            "log",
            "&log->l_reserve_head",
            "tic",
            "&need_bytes"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "306-341",
          "snippet": "STATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_reserve",
          "args": [
            "log",
            "tic"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_push_ail",
          "args": [
            "log",
            "tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_push_ail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1537-1591",
          "snippet": "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_ticket_alloc",
          "args": [
            "log",
            "unit_bytes",
            "cnt",
            "client",
            "permanent",
            "KM_SLEEP | KM_MAYFAIL"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ticket_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3614-3649",
          "snippet": "struct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstruct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*ticp == NULL"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_try_logspace"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "client == XFS_TRANSACTION || client == XFS_LOG"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_log_regrant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "370-421",
    "snippet": "int\nxfs_log_regrant(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*tic)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\t/*\n\t * This is a new transaction on the ticket, so we need to change the\n\t * transaction ID so that the next transaction has a different TID in\n\t * the log. Just add one to the existing tid so that we can see chains\n\t * of rolling transactions in the log easily.\n\t */\n\ttic->t_tid++;\n\n\txlog_grant_push_ail(log, tic->t_unit_res);\n\n\ttic->t_curr_res = tic->t_unit_res;\n\txlog_tic_reset_res(tic);\n\n\tif (tic->t_cnt > 0)\n\t\treturn 0;\n\n\ttrace_xfs_log_regrant(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_write_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_regrant_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_verify_grant_tail",
          "args": [
            "log"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_verify_grant_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3693-3717",
          "snippet": "STATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_verify_grant_tail(\n\tstruct xlog\t*log)\n{\n\tint\t\ttail_cycle, tail_blocks;\n\tint\t\tcycle, space;\n\n\txlog_crack_grant_head(&log->l_write_head.grant, &cycle, &space);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_blocks);\n\tif (tail_cycle != cycle) {\n\t\tif (cycle - 1 != tail_cycle &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: cycle - 1 != tail_cycle\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\n\t\tif (space > BBTOB(tail_blocks) &&\n\t\t    !(log->l_flags & XLOG_TAIL_WARN)) {\n\t\t\txfs_alert_tag(log->l_mp, XFS_PTAG_LOGRES,\n\t\t\t\t\"%s: space > BBTOB(tail_blocks)\", __func__);\n\t\t\tlog->l_flags |= XLOG_TAIL_WARN;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_regrant_exit",
          "args": [
            "log",
            "tic"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_add_space",
          "args": [
            "log",
            "&log->l_write_head.grant",
            "need_bytes"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_add_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "164-191",
          "snippet": "static void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_check",
          "args": [
            "log",
            "&log->l_write_head",
            "tic",
            "&need_bytes"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "306-341",
          "snippet": "STATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_regrant",
          "args": [
            "log",
            "tic"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_tic_reset_res",
          "args": [
            "tic"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_tic_reset_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "343-349",
          "snippet": "static void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_push_ail",
          "args": [
            "log",
            "tic->t_unit_res"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_push_ail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1537-1591",
          "snippet": "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_try_logspace"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_regrant(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*tic)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\t/*\n\t * This is a new transaction on the ticket, so we need to change the\n\t * transaction ID so that the next transaction has a different TID in\n\t * the log. Just add one to the existing tid so that we can see chains\n\t * of rolling transactions in the log easily.\n\t */\n\ttic->t_tid++;\n\n\txlog_grant_push_ail(log, tic->t_unit_res);\n\n\ttic->t_curr_res = tic->t_unit_res;\n\txlog_tic_reset_res(tic);\n\n\tif (tic->t_cnt > 0)\n\t\treturn 0;\n\n\ttrace_xfs_log_regrant(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_write_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_regrant_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_tic_add_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "351-365",
    "snippet": "static void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_add_region(xlog_ticket_t *tic, uint len, uint type)\n{\n\tif (tic->t_res_num == XLOG_TIC_LEN_MAX) {\n\t\t/* add to overflow and start again */\n\t\ttic->t_res_o_flow += tic->t_res_arr_sum;\n\t\ttic->t_res_num = 0;\n\t\ttic->t_res_arr_sum = 0;\n\t}\n\n\ttic->t_res_arr[tic->t_res_num].r_len = len;\n\ttic->t_res_arr[tic->t_res_num].r_type = type;\n\ttic->t_res_arr_sum += len;\n\ttic->t_res_num++;\n}"
  },
  {
    "function_name": "xlog_tic_reset_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "343-349",
    "snippet": "static void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_tic_reset_res(xlog_ticket_t *tic)\n{\n\ttic->t_res_num = 0;\n\ttic->t_res_arr_sum = 0;\n\ttic->t_res_num_ophdrs = 0;\n}"
  },
  {
    "function_name": "xlog_grant_head_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "306-341",
    "snippet": "STATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_wait",
          "args": [
            "log",
            "head",
            "tic",
            "*need_bytes"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "253-287",
          "snippet": "STATIC int\nxlog_grant_head_wait(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\tneed_bytes) __releases(&head->lock)\n\t\t\t\t\t    __acquires(&head->lock)\n{\n\tlist_add_tail(&tic->t_queue, &head->waiters);\n\n\tdo {\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t\txlog_grant_push_ail(log, need_bytes);\n\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&head->lock);\n\n\t\tXFS_STATS_INC(xs_sleep_logspace);\n\n\t\ttrace_xfs_log_grant_sleep(log, tic);\n\t\tschedule();\n\t\ttrace_xfs_log_grant_wake(log, tic);\n\n\t\tspin_lock(&head->lock);\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t} while (xlog_space_left(log, &head->grant) < need_bytes);\n\n\tlist_del_init(&tic->t_queue);\n\treturn 0;\nshutdown:\n\tlist_del_init(&tic->t_queue);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_grant_head_wait(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\tneed_bytes) __releases(&head->lock)\n\t\t\t\t\t    __acquires(&head->lock)\n{\n\tlist_add_tail(&tic->t_queue, &head->waiters);\n\n\tdo {\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t\txlog_grant_push_ail(log, need_bytes);\n\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&head->lock);\n\n\t\tXFS_STATS_INC(xs_sleep_logspace);\n\n\t\ttrace_xfs_log_grant_sleep(log, tic);\n\t\tschedule();\n\t\ttrace_xfs_log_grant_wake(log, tic);\n\n\t\tspin_lock(&head->lock);\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t} while (xlog_space_left(log, &head->grant) < need_bytes);\n\n\tlist_del_init(&tic->t_queue);\n\treturn 0;\nshutdown:\n\tlist_del_init(&tic->t_queue);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head->lock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_grant_head_wake",
          "args": [
            "log",
            "head",
            "&free_bytes"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_head_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "231-251",
          "snippet": "STATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&head->waiters"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_space_left",
          "args": [
            "log",
            "&head->grant"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1121-1157",
          "snippet": "STATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_ticket_reservation",
          "args": [
            "log",
            "head",
            "tic"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ticket_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "214-229",
          "snippet": "static inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(log->l_flags & XLOG_ACTIVE_RECOVERY)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_grant_head_check(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\t*need_bytes)\n{\n\tint\t\t\tfree_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t/*\n\t * If there are other waiters on the queue then give them a chance at\n\t * logspace before us.  Wake up the first waiters, if we do not wake\n\t * up all the waiters then go to sleep waiting for more free space,\n\t * otherwise try to get some space for this transaction.\n\t */\n\t*need_bytes = xlog_ticket_reservation(log, head, tic);\n\tfree_bytes = xlog_space_left(log, &head->grant);\n\tif (!list_empty_careful(&head->waiters)) {\n\t\tspin_lock(&head->lock);\n\t\tif (!xlog_grant_head_wake(log, head, &free_bytes) ||\n\t\t    free_bytes < *need_bytes) {\n\t\t\terror = xlog_grant_head_wait(log, head, tic,\n\t\t\t\t\t\t     *need_bytes);\n\t\t}\n\t\tspin_unlock(&head->lock);\n\t} else if (free_bytes < *need_bytes) {\n\t\tspin_lock(&head->lock);\n\t\terror = xlog_grant_head_wait(log, head, tic, *need_bytes);\n\t\tspin_unlock(&head->lock);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xlog_grant_head_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "253-287",
    "snippet": "STATIC int\nxlog_grant_head_wait(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\tneed_bytes) __releases(&head->lock)\n\t\t\t\t\t    __acquires(&head->lock)\n{\n\tlist_add_tail(&tic->t_queue, &head->waiters);\n\n\tdo {\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t\txlog_grant_push_ail(log, need_bytes);\n\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&head->lock);\n\n\t\tXFS_STATS_INC(xs_sleep_logspace);\n\n\t\ttrace_xfs_log_grant_sleep(log, tic);\n\t\tschedule();\n\t\ttrace_xfs_log_grant_wake(log, tic);\n\n\t\tspin_lock(&head->lock);\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t} while (xlog_space_left(log, &head->grant) < need_bytes);\n\n\tlist_del_init(&tic->t_queue);\n\treturn 0;\nshutdown:\n\tlist_del_init(&tic->t_queue);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tic->t_queue"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tic->t_queue"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_space_left",
          "args": [
            "log",
            "&head->grant"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1121-1157",
          "snippet": "STATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t*log,\n\tatomic64_t\t*head)\n{\n\tint\t\tfree_bytes;\n\tint\t\ttail_bytes;\n\tint\t\ttail_cycle;\n\tint\t\thead_cycle;\n\tint\t\thead_bytes;\n\n\txlog_crack_grant_head(head, &head_cycle, &head_bytes);\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &tail_cycle, &tail_bytes);\n\ttail_bytes = BBTOB(tail_bytes);\n\tif (tail_cycle == head_cycle && head_bytes >= tail_bytes)\n\t\tfree_bytes = log->l_logsize - (head_bytes - tail_bytes);\n\telse if (tail_cycle + 1 < head_cycle)\n\t\treturn 0;\n\telse if (tail_cycle < head_cycle) {\n\t\tASSERT(tail_cycle == (head_cycle - 1));\n\t\tfree_bytes = tail_bytes - head_bytes;\n\t} else {\n\t\t/*\n\t\t * The reservation head is behind the tail.\n\t\t * In this case we just want to return the size of the\n\t\t * log as the amount of space left.\n\t\t */\n\t\txfs_alert(log->l_mp,\n\t\t\t\"xlog_space_left: head behind tail\\n\"\n\t\t\t\"  tail_cycle = %d, tail_bytes = %d\\n\"\n\t\t\t\"  GH   cycle = %d, GH   bytes = %d\",\n\t\t\ttail_cycle, tail_bytes, head_cycle, head_bytes);\n\t\tASSERT(0);\n\t\tfree_bytes = log->l_logsize;\n\t}\n\treturn free_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head->lock"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_grant_wake",
          "args": [
            "log",
            "tic"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_grant_sleep",
          "args": [
            "log",
            "tic"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_sleep_logspace"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_grant_push_ail",
          "args": [
            "log",
            "need_bytes"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_grant_push_ail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1537-1591",
          "snippet": "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t*log,\n\tint\t\tneed_bytes)\n{\n\txfs_lsn_t\tthreshold_lsn = 0;\n\txfs_lsn_t\tlast_sync_lsn;\n\tint\t\tfree_blocks;\n\tint\t\tfree_bytes;\n\tint\t\tthreshold_block;\n\tint\t\tthreshold_cycle;\n\tint\t\tfree_threshold;\n\n\tASSERT(BTOBB(need_bytes) < log->l_logBBsize);\n\n\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\tfree_blocks = BTOBBT(free_bytes);\n\n\t/*\n\t * Set the threshold for the minimum number of free blocks in the\n\t * log to the maximum of what the caller needs, one quarter of the\n\t * log, and 256 blocks.\n\t */\n\tfree_threshold = BTOBB(need_bytes);\n\tfree_threshold = MAX(free_threshold, (log->l_logBBsize >> 2));\n\tfree_threshold = MAX(free_threshold, 256);\n\tif (free_blocks >= free_threshold)\n\t\treturn;\n\n\txlog_crack_atomic_lsn(&log->l_tail_lsn, &threshold_cycle,\n\t\t\t\t\t\t&threshold_block);\n\tthreshold_block += free_threshold;\n\tif (threshold_block >= log->l_logBBsize) {\n\t\tthreshold_block -= log->l_logBBsize;\n\t\tthreshold_cycle += 1;\n\t}\n\tthreshold_lsn = xlog_assign_lsn(threshold_cycle,\n\t\t\t\t\tthreshold_block);\n\t/*\n\t * Don't pass in an lsn greater than the lsn of the last\n\t * log record known to be on disk. Use a snapshot of the last sync lsn\n\t * so that it doesn't change between the compare and the set.\n\t */\n\tlast_sync_lsn = atomic64_read(&log->l_last_sync_lsn);\n\tif (XFS_LSN_CMP(threshold_lsn, last_sync_lsn) > 0)\n\t\tthreshold_lsn = last_sync_lsn;\n\n\t/*\n\t * Get the transaction layer to kick the dirty buffers out to\n\t * disk asynchronously. No point in trying to do this if\n\t * the filesystem is shutting down.\n\t */\n\tif (!XLOG_FORCED_SHUTDOWN(log))\n\t\txfs_ail_push(log->l_ailp, threshold_lsn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tic->t_queue",
            "&head->waiters"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&head->lock"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&head->lock"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC int\nxlog_grant_head_wait(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic,\n\tint\t\t\tneed_bytes) __releases(&head->lock)\n\t\t\t\t\t    __acquires(&head->lock)\n{\n\tlist_add_tail(&tic->t_queue, &head->waiters);\n\n\tdo {\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t\txlog_grant_push_ail(log, need_bytes);\n\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&head->lock);\n\n\t\tXFS_STATS_INC(xs_sleep_logspace);\n\n\t\ttrace_xfs_log_grant_sleep(log, tic);\n\t\tschedule();\n\t\ttrace_xfs_log_grant_wake(log, tic);\n\n\t\tspin_lock(&head->lock);\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto shutdown;\n\t} while (xlog_space_left(log, &head->grant) < need_bytes);\n\n\tlist_del_init(&tic->t_queue);\n\treturn 0;\nshutdown:\n\tlist_del_init(&tic->t_queue);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "xlog_grant_head_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "231-251",
    "snippet": "STATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tic->t_task"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_log_grant_wake_up",
          "args": [
            "log",
            "tic"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_ticket_reservation",
          "args": [
            "log",
            "head",
            "tic"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ticket_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "214-229",
          "snippet": "static inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tic",
            "&head->waiters",
            "t_queue"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nSTATIC bool\nxlog_grant_head_wake(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tint\t\t\t*free_bytes)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\n\tlist_for_each_entry(tic, &head->waiters, t_queue) {\n\t\tneed_bytes = xlog_ticket_reservation(log, head, tic);\n\t\tif (*free_bytes < need_bytes)\n\t\t\treturn false;\n\n\t\t*free_bytes -= need_bytes;\n\t\ttrace_xfs_log_grant_wake_up(log, tic);\n\t\twake_up_process(tic->t_task);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "xlog_ticket_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "214-229",
    "snippet": "static inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tic->t_flags & XLOG_TIC_PERM_RESERV"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic inline int\nxlog_ticket_reservation(\n\tstruct xlog\t\t*log,\n\tstruct xlog_grant_head\t*head,\n\tstruct xlog_ticket\t*tic)\n{\n\tif (head == &log->l_write_head) {\n\t\tASSERT(tic->t_flags & XLOG_TIC_PERM_RESERV);\n\t\treturn tic->t_unit_res;\n\t} else {\n\t\tif (tic->t_flags & XLOG_TIC_PERM_RESERV)\n\t\t\treturn tic->t_unit_res * tic->t_cnt;\n\t\telse\n\t\t\treturn tic->t_unit_res;\n\t}\n}"
  },
  {
    "function_name": "xlog_grant_head_wake_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "202-212",
    "snippet": "STATIC void\nxlog_grant_head_wake_all(\n\tstruct xlog_grant_head\t*head)\n{\n\tstruct xlog_ticket\t*tic;\n\n\tspin_lock(&head->lock);\n\tlist_for_each_entry(tic, &head->waiters, t_queue)\n\t\twake_up_process(tic->t_task);\n\tspin_unlock(&head->lock);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tic->t_task"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tic",
            "&head->waiters",
            "t_queue"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head->lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_head_wake_all(\n\tstruct xlog_grant_head\t*head)\n{\n\tstruct xlog_ticket\t*tic;\n\n\tspin_lock(&head->lock);\n\tlist_for_each_entry(tic, &head->waiters, t_queue)\n\t\twake_up_process(tic->t_task);\n\tspin_unlock(&head->lock);\n}"
  },
  {
    "function_name": "xlog_grant_head_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "193-200",
    "snippet": "STATIC void\nxlog_grant_head_init(\n\tstruct xlog_grant_head\t*head)\n{\n\txlog_assign_grant_head(&head->grant, 1, 0);\n\tINIT_LIST_HEAD(&head->waiters);\n\tspin_lock_init(&head->lock);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&head->lock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head->waiters"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_grant_head",
          "args": [
            "&head->grant",
            "1",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_grant_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "511-515",
          "snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC struct;\n\nSTATIC void\nxlog_grant_head_init(\n\tstruct xlog_grant_head\t*head)\n{\n\txlog_assign_grant_head(&head->grant, 1, 0);\n\tINIT_LIST_HEAD(&head->waiters);\n\tspin_lock_init(&head->lock);\n}"
  },
  {
    "function_name": "xlog_grant_add_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "164-191",
    "snippet": "static void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_cmpxchg",
          "args": [
            "head",
            "old",
            "new"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_grant_head_val",
          "args": [
            "cycle",
            "space"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "505-509",
          "snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_crack_grant_head_val",
          "args": [
            "head_val",
            "&cycle",
            "&space"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "492-497",
          "snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "head"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_add_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\t\ttmp;\n\t\tint\t\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\ttmp = log->l_logsize - space;\n\t\tif (tmp > bytes)\n\t\t\tspace += bytes;\n\t\telse {\n\t\t\tspace = bytes - tmp;\n\t\t\tcycle++;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
  },
  {
    "function_name": "xlog_grant_sub_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
    "lines": "138-162",
    "snippet": "static void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}",
    "includes": [
      "#include \"xfs_sb.h\"",
      "#include \"xfs_sysfs.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_log_recover.h\"",
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);",
      "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
      "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_cmpxchg",
          "args": [
            "head",
            "old",
            "new"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_grant_head_val",
          "args": [
            "cycle",
            "space"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "505-509",
          "snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_crack_grant_head_val",
          "args": [
            "head_val",
            "&cycle",
            "&space"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "492-497",
          "snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "head"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_space_left(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstatic void\nxlog_grant_sub_space(\n\tstruct xlog\t\t*log,\n\tatomic64_t\t\t*head,\n\tint\t\t\tbytes)\n{\n\tint64_t\thead_val = atomic64_read(head);\n\tint64_t new, old;\n\n\tdo {\n\t\tint\tcycle, space;\n\n\t\txlog_crack_grant_head_val(head_val, &cycle, &space);\n\n\t\tspace -= bytes;\n\t\tif (space < 0) {\n\t\t\tspace += log->l_logsize;\n\t\t\tcycle--;\n\t\t}\n\n\t\told = head_val;\n\t\tnew = xlog_assign_grant_head_val(cycle, space);\n\t\thead_val = atomic64_cmpxchg(head, old, new);\n\t} while (head_val != old);\n}"
  }
]