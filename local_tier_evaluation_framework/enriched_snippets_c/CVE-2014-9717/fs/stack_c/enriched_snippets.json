[
  {
    "function_name": "fsstack_copy_attr_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
    "lines": "63-75",
    "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
    "includes": [
      "#include <linux/fs_stack.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "dest",
            "src->i_nlink"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
  },
  {
    "function_name": "fsstack_copy_inode_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
    "lines": "10-59",
    "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
    "includes": [
      "#include <linux/fs_stack.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dst->i_lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dst",
            "i_size"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dst->i_lock"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "src"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
  }
]