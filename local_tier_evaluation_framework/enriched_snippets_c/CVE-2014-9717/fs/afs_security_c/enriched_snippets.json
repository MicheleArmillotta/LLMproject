[
  {
    "function_name": "afs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "288-363",
    "snippet": "int afs_permission(struct inode *inode, int mask)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_access_t uninitialized_var(access);\n\tstruct key *key;\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\t_enter(\"{{%x:%u},%lx},%x,\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags, mask);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\t/* if the promise has expired, we need to check the server again */\n\tif (!vnode->cb_promised) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\t/* check the permits to see if we've got one yet */\n\tret = afs_check_permit(vnode, key, &access);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* interpret the access mask */\n\t_debug(\"REQ %x ACC %x on %s\",\n\t       mask, access, S_ISDIR(inode->i_mode) ? \"dir\" : \"file\");\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mask & MAY_EXEC) {\n\t\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_READ) {\n\t\t\tif (!(access & AFS_ACE_READ))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_WRITE) {\n\t\t\tif (!(access & (AFS_ACE_DELETE | /* rmdir, unlink, rename from */\n\t\t\t\t\tAFS_ACE_INSERT | /* create, mkdir, symlink, rename to */\n\t\t\t\t\tAFS_ACE_WRITE))) /* chmod */\n\t\t\t\tgoto permission_denied;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\tgoto permission_denied;\n\t\tif (mask & (MAY_EXEC | MAY_READ)) {\n\t\t\tif (!(access & AFS_ACE_READ))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_WRITE) {\n\t\t\tif (!(access & AFS_ACE_WRITE))\n\t\t\t\tgoto permission_denied;\n\t\t}\n\t}\n\n\tkey_put(key);\n\tret = generic_permission(inode, mask);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\npermission_denied:\n\tret = -EACCES;\nerror:\n\tkey_put(key);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"REQ %x ACC %x on %s\"",
            "mask",
            "access",
            "S_ISDIR(inode->i_mode) ? \"dir\" : \"file\""
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_check_permit",
          "args": [
            "vnode",
            "key",
            "&access"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "afs_check_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "217-281",
          "snippet": "static int afs_check_permit(struct afs_vnode *vnode, struct key *key,\n\t\t\t    afs_access_t *_access)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tbool valid;\n\tint loop, ret;\n\n\t_enter(\"{%x:%u},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t*_access = 0;\n\t\t_leave(\" = %ld\", PTR_ERR(auth_vnode));\n\t\treturn PTR_ERR(auth_vnode);\n\t}\n\n\tASSERT(S_ISDIR(auth_vnode->vfs_inode.i_mode));\n\n\t/* check the permits to see if we've got one yet */\n\tif (key == auth_vnode->volume->cell->anonymous_key) {\n\t\t_debug(\"anon\");\n\t\t*_access = auth_vnode->status.anon_access;\n\t\tvalid = true;\n\t} else {\n\t\tvalid = false;\n\t\trcu_read_lock();\n\t\tpermits = rcu_dereference(auth_vnode->permits);\n\t\tif (permits) {\n\t\t\tpermit = permits->permits;\n\t\t\tfor (loop = permits->count; loop > 0; loop--) {\n\t\t\t\tif (permit->key == key) {\n\t\t\t\t\t_debug(\"found in cache\");\n\t\t\t\t\t*_access = permit->access_mask;\n\t\t\t\t\tvalid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpermit++;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!valid) {\n\t\t/* check the status on the file we're actually interested in\n\t\t * (the post-processing will cache the result on auth_vnode) */\n\t\t_debug(\"no valid permit\");\n\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, auth_vnode, key);\n\t\tif (ret < 0) {\n\t\t\tiput(&auth_vnode->vfs_inode);\n\t\t\t*_access = 0;\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*_access = vnode->status.caller_access;\n\t}\n\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\" = 0 [access %x]\", *_access);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_check_permit(struct afs_vnode *vnode, struct key *key,\n\t\t\t    afs_access_t *_access)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tbool valid;\n\tint loop, ret;\n\n\t_enter(\"{%x:%u},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t*_access = 0;\n\t\t_leave(\" = %ld\", PTR_ERR(auth_vnode));\n\t\treturn PTR_ERR(auth_vnode);\n\t}\n\n\tASSERT(S_ISDIR(auth_vnode->vfs_inode.i_mode));\n\n\t/* check the permits to see if we've got one yet */\n\tif (key == auth_vnode->volume->cell->anonymous_key) {\n\t\t_debug(\"anon\");\n\t\t*_access = auth_vnode->status.anon_access;\n\t\tvalid = true;\n\t} else {\n\t\tvalid = false;\n\t\trcu_read_lock();\n\t\tpermits = rcu_dereference(auth_vnode->permits);\n\t\tif (permits) {\n\t\t\tpermit = permits->permits;\n\t\t\tfor (loop = permits->count; loop > 0; loop--) {\n\t\t\t\tif (permit->key == key) {\n\t\t\t\t\t_debug(\"found in cache\");\n\t\t\t\t\t*_access = permit->access_mask;\n\t\t\t\t\tvalid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpermit++;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!valid) {\n\t\t/* check the status on the file we're actually interested in\n\t\t * (the post-processing will cache the result on auth_vnode) */\n\t\t_debug(\"no valid permit\");\n\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, auth_vnode, key);\n\t\tif (ret < 0) {\n\t\t\tiput(&auth_vnode->vfs_inode);\n\t\t\t*_access = 0;\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*_access = vnode->status.caller_access;\n\t}\n\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\" = 0 [access %x]\", *_access);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"new promise [fl=%lx]\"",
            "vnode->flags"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "NULL",
            "key"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"not promised\""
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "vnode->volume->cell"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{{%x:%u},%lx},%x,\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "vnode->flags",
            "mask"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nint afs_permission(struct inode *inode, int mask)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tafs_access_t uninitialized_var(access);\n\tstruct key *key;\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\t_enter(\"{{%x:%u},%lx},%x,\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags, mask);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\t/* if the promise has expired, we need to check the server again */\n\tif (!vnode->cb_promised) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\t/* check the permits to see if we've got one yet */\n\tret = afs_check_permit(vnode, key, &access);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* interpret the access mask */\n\t_debug(\"REQ %x ACC %x on %s\",\n\t       mask, access, S_ISDIR(inode->i_mode) ? \"dir\" : \"file\");\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mask & MAY_EXEC) {\n\t\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_READ) {\n\t\t\tif (!(access & AFS_ACE_READ))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_WRITE) {\n\t\t\tif (!(access & (AFS_ACE_DELETE | /* rmdir, unlink, rename from */\n\t\t\t\t\tAFS_ACE_INSERT | /* create, mkdir, symlink, rename to */\n\t\t\t\t\tAFS_ACE_WRITE))) /* chmod */\n\t\t\t\tgoto permission_denied;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tif (!(access & AFS_ACE_LOOKUP))\n\t\t\tgoto permission_denied;\n\t\tif (mask & (MAY_EXEC | MAY_READ)) {\n\t\t\tif (!(access & AFS_ACE_READ))\n\t\t\t\tgoto permission_denied;\n\t\t} else if (mask & MAY_WRITE) {\n\t\t\tif (!(access & AFS_ACE_WRITE))\n\t\t\t\tgoto permission_denied;\n\t\t}\n\t}\n\n\tkey_put(key);\n\tret = generic_permission(inode, mask);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\npermission_denied:\n\tret = -EACCES;\nerror:\n\tkey_put(key);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_check_permit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "217-281",
    "snippet": "static int afs_check_permit(struct afs_vnode *vnode, struct key *key,\n\t\t\t    afs_access_t *_access)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tbool valid;\n\tint loop, ret;\n\n\t_enter(\"{%x:%u},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t*_access = 0;\n\t\t_leave(\" = %ld\", PTR_ERR(auth_vnode));\n\t\treturn PTR_ERR(auth_vnode);\n\t}\n\n\tASSERT(S_ISDIR(auth_vnode->vfs_inode.i_mode));\n\n\t/* check the permits to see if we've got one yet */\n\tif (key == auth_vnode->volume->cell->anonymous_key) {\n\t\t_debug(\"anon\");\n\t\t*_access = auth_vnode->status.anon_access;\n\t\tvalid = true;\n\t} else {\n\t\tvalid = false;\n\t\trcu_read_lock();\n\t\tpermits = rcu_dereference(auth_vnode->permits);\n\t\tif (permits) {\n\t\t\tpermit = permits->permits;\n\t\t\tfor (loop = permits->count; loop > 0; loop--) {\n\t\t\t\tif (permit->key == key) {\n\t\t\t\t\t_debug(\"found in cache\");\n\t\t\t\t\t*_access = permit->access_mask;\n\t\t\t\t\tvalid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpermit++;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!valid) {\n\t\t/* check the status on the file we're actually interested in\n\t\t * (the post-processing will cache the result on auth_vnode) */\n\t\t_debug(\"no valid permit\");\n\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, auth_vnode, key);\n\t\tif (ret < 0) {\n\t\t\tiput(&auth_vnode->vfs_inode);\n\t\t\t*_access = 0;\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*_access = vnode->status.caller_access;\n\t}\n\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\" = 0 [access %x]\", *_access);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [access %x]\"",
            "*_access"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&auth_vnode->vfs_inode"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_status",
          "args": [
            "vnode",
            "auth_vnode",
            "key"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "264-389",
          "snippet": "int afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\n\t\t\t   struct afs_vnode *auth_vnode, struct key *key)\n{\n\tstruct afs_server *server;\n\tunsigned long acl_order;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"%s,{%x:%u.%u}\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" [deleted]\");\n\t\treturn -ENOENT;\n\t}\n\n\tacl_order = 0;\n\tif (auth_vnode)\n\t\tacl_order = auth_vnode->acl_order;\n\n\tspin_lock(&vnode->lock);\n\n\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    vnode->cb_promised) {\n\t\tspin_unlock(&vnode->lock);\n\t\t_leave(\" [unchanged]\");\n\t\treturn 0;\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\tif (vnode->update_cnt > 0) {\n\t\t/* someone else started a fetch */\n\t\t_debug(\"wait on fetch %d\", vnode->update_cnt);\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tASSERT(myself.func != NULL);\n\t\tadd_wait_queue(&vnode->update_waitq, &myself);\n\n\t\t/* wait for the status to be updated */\n\t\tfor (;;) {\n\t\t\tif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t\tbreak;\n\t\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t\tbreak;\n\n\t\t\t/* check to see if it got updated and invalidated all\n\t\t\t * before we saw it */\n\t\t\tif (vnode->update_cnt == 0) {\n\t\t\t\tremove_wait_queue(&vnode->update_waitq,\n\t\t\t\t\t\t  &myself);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tgoto get_anyway;\n\t\t\t}\n\n\t\t\tspin_unlock(&vnode->lock);\n\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t\tspin_lock(&vnode->lock);\n\t\t}\n\n\t\tremove_wait_queue(&vnode->update_waitq, &myself);\n\t\tspin_unlock(&vnode->lock);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\treturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\n\t\t\t-ENOENT : 0;\n\t}\n\nget_anyway:\n\t/* okay... we're going to have to initiate the op */\n\tvnode->update_cnt++;\n\n\tspin_unlock(&vnode->lock);\n\n\t/* merge AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %p{%08x}\",\n\t\t       server, ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_file_status(server, key, vnode, NULL,\n\t\t\t\t\t       &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\t_debug(\"adjust\");\n\t\tif (auth_vnode)\n\t\t\tafs_cache_permit(vnode, key, acl_order);\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\t_debug(\"failed [%d]\", ret);\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"no valid permit\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auth_vnode->permits"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(auth_vnode->vfs_inode.i_mode)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "auth_vnode->vfs_inode.i_mode"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "auth_vnode"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "auth_vnode"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "auth_vnode"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_auth_inode",
          "args": [
            "vnode",
            "key"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_auth_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "83-104",
          "snippet": "static struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%x\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "key_serial(key)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_check_permit(struct afs_vnode *vnode, struct key *key,\n\t\t\t    afs_access_t *_access)\n{\n\tstruct afs_permits *permits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tbool valid;\n\tint loop, ret;\n\n\t_enter(\"{%x:%u},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key));\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t*_access = 0;\n\t\t_leave(\" = %ld\", PTR_ERR(auth_vnode));\n\t\treturn PTR_ERR(auth_vnode);\n\t}\n\n\tASSERT(S_ISDIR(auth_vnode->vfs_inode.i_mode));\n\n\t/* check the permits to see if we've got one yet */\n\tif (key == auth_vnode->volume->cell->anonymous_key) {\n\t\t_debug(\"anon\");\n\t\t*_access = auth_vnode->status.anon_access;\n\t\tvalid = true;\n\t} else {\n\t\tvalid = false;\n\t\trcu_read_lock();\n\t\tpermits = rcu_dereference(auth_vnode->permits);\n\t\tif (permits) {\n\t\t\tpermit = permits->permits;\n\t\t\tfor (loop = permits->count; loop > 0; loop--) {\n\t\t\t\tif (permit->key == key) {\n\t\t\t\t\t_debug(\"found in cache\");\n\t\t\t\t\t*_access = permit->access_mask;\n\t\t\t\t\tvalid = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpermit++;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!valid) {\n\t\t/* check the status on the file we're actually interested in\n\t\t * (the post-processing will cache the result on auth_vnode) */\n\t\t_debug(\"no valid permit\");\n\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, auth_vnode, key);\n\t\tif (ret < 0) {\n\t\t\tiput(&auth_vnode->vfs_inode);\n\t\t\t*_access = 0;\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*_access = vnode->status.caller_access;\n\t}\n\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\" = 0 [access %x]\", *_access);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_cache_permit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "129-210",
    "snippet": "void afs_cache_permit(struct afs_vnode *vnode, struct key *key, long acl_order)\n{\n\tstruct afs_permits *permits, *xpermits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tint count, loop;\n\n\t_enter(\"{%x:%u},%x,%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key), acl_order);\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t_leave(\" [get error %ld]\", PTR_ERR(auth_vnode));\n\t\treturn;\n\t}\n\n\tmutex_lock(&auth_vnode->permits_lock);\n\n\t/* guard against a rename being detected whilst we waited for the\n\t * lock */\n\tif (memcmp(&auth_vnode->fid, &vnode->status.parent,\n\t\t   sizeof(struct afs_fid)) != 0) {\n\t\t_debug(\"renamed\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* have to be careful as the directory's callback may be broken between\n\t * us receiving the status we're trying to cache and us getting the\n\t * lock to update the cache for the status */\n\tif (auth_vnode->acl_order - acl_order > 0) {\n\t\t_debug(\"ACL changed?\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* always update the anonymous mask */\n\t_debug(\"anon access %x\", vnode->status.anon_access);\n\tauth_vnode->status.anon_access = vnode->status.anon_access;\n\tif (key == vnode->volume->cell->anonymous_key)\n\t\tgoto out_unlock;\n\n\txpermits = auth_vnode->permits;\n\tcount = 0;\n\tif (xpermits) {\n\t\t/* see if the permit is already in the list\n\t\t * - if it is then we just amend the list\n\t\t */\n\t\tcount = xpermits->count;\n\t\tpermit = xpermits->permits;\n\t\tfor (loop = count; loop > 0; loop--) {\n\t\t\tif (permit->key == key) {\n\t\t\t\tpermit->access_mask =\n\t\t\t\t\tvnode->status.caller_access;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tpermit++;\n\t\t}\n\t}\n\n\tpermits = kmalloc(sizeof(*permits) + sizeof(*permit) * (count + 1),\n\t\t\t  GFP_NOFS);\n\tif (!permits)\n\t\tgoto out_unlock;\n\n\tif (xpermits)\n\t\tmemcpy(permits->permits, xpermits->permits,\n\t\t\tcount * sizeof(struct afs_permit));\n\n\t_debug(\"key %x access %x\",\n\t       key_serial(key), vnode->status.caller_access);\n\tpermits->permits[count].access_mask = vnode->status.caller_access;\n\tpermits->permits[count].key = key_get(key);\n\tpermits->count = count + 1;\n\n\trcu_assign_pointer(auth_vnode->permits, permits);\n\tif (xpermits)\n\t\tcall_rcu(&xpermits->rcu, afs_dispose_of_permits);\n\nout_unlock:\n\tmutex_unlock(&auth_vnode->permits_lock);\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&auth_vnode->vfs_inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&auth_vnode->permits_lock"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&xpermits->rcu",
            "afs_dispose_of_permits"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "auth_vnode->permits",
            "permits"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "key"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"key %x access %x\"",
            "key_serial(key)",
            "vnode->status.caller_access"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "permits->permits",
            "xpermits->permits",
            "count * sizeof(struct afs_permit)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*permits) + sizeof(*permit) * (count + 1)",
            "GFP_NOFS"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"anon access %x\"",
            "vnode->status.anon_access"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"ACL changed?\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&auth_vnode->fid",
            "&vnode->status.parent",
            "sizeof(struct afs_fid)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&auth_vnode->permits_lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "auth_vnode"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "auth_vnode"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_auth_inode",
          "args": [
            "vnode",
            "key"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_auth_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "83-104",
          "snippet": "static struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%x,%lx\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "key_serial(key)",
            "acl_order"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nvoid afs_cache_permit(struct afs_vnode *vnode, struct key *key, long acl_order)\n{\n\tstruct afs_permits *permits, *xpermits;\n\tstruct afs_permit *permit;\n\tstruct afs_vnode *auth_vnode;\n\tint count, loop;\n\n\t_enter(\"{%x:%u},%x,%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, key_serial(key), acl_order);\n\n\tauth_vnode = afs_get_auth_inode(vnode, key);\n\tif (IS_ERR(auth_vnode)) {\n\t\t_leave(\" [get error %ld]\", PTR_ERR(auth_vnode));\n\t\treturn;\n\t}\n\n\tmutex_lock(&auth_vnode->permits_lock);\n\n\t/* guard against a rename being detected whilst we waited for the\n\t * lock */\n\tif (memcmp(&auth_vnode->fid, &vnode->status.parent,\n\t\t   sizeof(struct afs_fid)) != 0) {\n\t\t_debug(\"renamed\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* have to be careful as the directory's callback may be broken between\n\t * us receiving the status we're trying to cache and us getting the\n\t * lock to update the cache for the status */\n\tif (auth_vnode->acl_order - acl_order > 0) {\n\t\t_debug(\"ACL changed?\");\n\t\tgoto out_unlock;\n\t}\n\n\t/* always update the anonymous mask */\n\t_debug(\"anon access %x\", vnode->status.anon_access);\n\tauth_vnode->status.anon_access = vnode->status.anon_access;\n\tif (key == vnode->volume->cell->anonymous_key)\n\t\tgoto out_unlock;\n\n\txpermits = auth_vnode->permits;\n\tcount = 0;\n\tif (xpermits) {\n\t\t/* see if the permit is already in the list\n\t\t * - if it is then we just amend the list\n\t\t */\n\t\tcount = xpermits->count;\n\t\tpermit = xpermits->permits;\n\t\tfor (loop = count; loop > 0; loop--) {\n\t\t\tif (permit->key == key) {\n\t\t\t\tpermit->access_mask =\n\t\t\t\t\tvnode->status.caller_access;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tpermit++;\n\t\t}\n\t}\n\n\tpermits = kmalloc(sizeof(*permits) + sizeof(*permit) * (count + 1),\n\t\t\t  GFP_NOFS);\n\tif (!permits)\n\t\tgoto out_unlock;\n\n\tif (xpermits)\n\t\tmemcpy(permits->permits, xpermits->permits,\n\t\t\tcount * sizeof(struct afs_permit));\n\n\t_debug(\"key %x access %x\",\n\t       key_serial(key), vnode->status.caller_access);\n\tpermits->permits[count].access_mask = vnode->status.caller_access;\n\tpermits->permits[count].key = key_get(key);\n\tpermits->count = count + 1;\n\n\trcu_assign_pointer(auth_vnode->permits, permits);\n\tif (xpermits)\n\t\tcall_rcu(&xpermits->rcu, afs_dispose_of_permits);\n\nout_unlock:\n\tmutex_unlock(&auth_vnode->permits_lock);\n\tiput(&auth_vnode->vfs_inode);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_clear_permits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "109-123",
    "snippet": "void afs_clear_permits(struct afs_vnode *vnode)\n{\n\tstruct afs_permits *permits;\n\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tmutex_lock(&vnode->permits_lock);\n\tpermits = vnode->permits;\n\trcu_assign_pointer(vnode->permits, NULL);\n\tmutex_unlock(&vnode->permits_lock);\n\n\tif (permits)\n\t\tcall_rcu(&permits->rcu, afs_zap_permits);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&permits->rcu",
            "afs_zap_permits"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vnode->permits_lock"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "vnode->permits",
            "NULL"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vnode->permits_lock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nvoid afs_clear_permits(struct afs_vnode *vnode)\n{\n\tstruct afs_permits *permits;\n\n\t_enter(\"{%x:%u}\", vnode->fid.vid, vnode->fid.vnode);\n\n\tmutex_lock(&vnode->permits_lock);\n\tpermits = vnode->permits;\n\trcu_assign_pointer(vnode->permits, NULL);\n\tmutex_unlock(&vnode->permits_lock);\n\n\tif (permits)\n\t\tcall_rcu(&permits->rcu, afs_zap_permits);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_get_auth_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "83-104",
    "snippet": "static struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = {%x}\"",
            "auth_vnode->fid.vnode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "auth_inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "auth_inode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "auth_inode"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "vnode->vfs_inode.i_sb",
            "key",
            "&vnode->status.parent",
            "NULL",
            "NULL"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "auth_inode != NULL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vnode->vfs_inode.i_mode"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic struct afs_vnode *afs_get_auth_inode(struct afs_vnode *vnode,\n\t\t\t\t\t    struct key *key)\n{\n\tstruct afs_vnode *auth_vnode;\n\tstruct inode *auth_inode;\n\n\t_enter(\"\");\n\n\tif (S_ISDIR(vnode->vfs_inode.i_mode)) {\n\t\tauth_inode = igrab(&vnode->vfs_inode);\n\t\tASSERT(auth_inode != NULL);\n\t} else {\n\t\tauth_inode = afs_iget(vnode->vfs_inode.i_sb, key,\n\t\t\t\t      &vnode->status.parent, NULL, NULL);\n\t\tif (IS_ERR(auth_inode))\n\t\t\treturn ERR_CAST(auth_inode);\n\t}\n\n\tauth_vnode = AFS_FS_I(auth_inode);\n\t_leave(\" = {%x}\", auth_vnode->fid.vnode);\n\treturn auth_vnode;\n}"
  },
  {
    "function_name": "afs_dispose_of_permits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "67-75",
    "snippet": "static void afs_dispose_of_permits(struct rcu_head *rcu)\n{\n\tstruct afs_permits *permits =\n\t\tcontainer_of(rcu, struct afs_permits, rcu);\n\n\t_enter(\"{%d}\", permits->count);\n\n\tkfree(permits);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "permits"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%d}\"",
            "permits->count"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structafs_permits",
            "rcu"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void afs_dispose_of_permits(struct rcu_head *rcu)\n{\n\tstruct afs_permits *permits =\n\t\tcontainer_of(rcu, struct afs_permits, rcu);\n\n\t_enter(\"{%d}\", permits->count);\n\n\tkfree(permits);\n}"
  },
  {
    "function_name": "afs_zap_permits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "51-62",
    "snippet": "void afs_zap_permits(struct rcu_head *rcu)\n{\n\tstruct afs_permits *permits =\n\t\tcontainer_of(rcu, struct afs_permits, rcu);\n\tint loop;\n\n\t_enter(\"{%d}\", permits->count);\n\n\tfor (loop = permits->count - 1; loop >= 0; loop--)\n\t\tkey_put(permits->permits[loop].key);\n\tkfree(permits);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "permits"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "permits->permits[loop].key"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%d}\"",
            "permits->count"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structafs_permits",
            "rcu"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nvoid afs_zap_permits(struct rcu_head *rcu)\n{\n\tstruct afs_permits *permits =\n\t\tcontainer_of(rcu, struct afs_permits, rcu);\n\tint loop;\n\n\t_enter(\"{%d}\", permits->count);\n\n\tfor (loop = permits->count - 1; loop >= 0; loop--)\n\t\tkey_put(permits->permits[loop].key);\n\tkfree(permits);\n}"
  },
  {
    "function_name": "afs_request_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
    "lines": "23-46",
    "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/rxrpc-type.h>",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = {%x} [auth]\"",
            "key_serial(key)"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "cell->anonymous_key"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "cell->anonymous_key"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_rxrpc",
            "cell->anonymous_key->description",
            "NULL"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"key %s\"",
            "cell->anonymous_key->description"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x}\"",
            "key_serial(cell->anonymous_key)"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "cell->anonymous_key"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
  }
]