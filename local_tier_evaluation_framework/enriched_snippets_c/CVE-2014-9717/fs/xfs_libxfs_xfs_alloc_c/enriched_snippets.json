[
  {
    "function_name": "xfs_free_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2587-2633",
    "snippet": "int\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "args.pag"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_insert",
          "args": [
            "tp",
            "args.agno",
            "args.agbno",
            "len",
            "0"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "34-93",
          "snippet": "void\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_ag_extent",
          "args": [
            "tp",
            "args.agbp",
            "args.agno",
            "args.agbno",
            "len",
            "0"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_ag_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1540-1787",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args.agbp)->agf_length"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args.agbp"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_freelist",
          "args": [
            "&args",
            "XFS_ALLOC_FLAG_FREEING"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1839-2008",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.pag"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "args.mp",
            "args.agno"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "args.mp",
            "bno"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "args.mp",
            "bno"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(xfs_alloc_arg_t)"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len != 0"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_vextent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2371-2580",
    "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "args->pag"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AG_CHECK_DADDR",
          "args": [
            "mp",
            "XFS_FSB_TO_DADDR(mp, args->fsbno)",
            "args->len"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->agbno % args->alignment == 0"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->len <= args->maxlen"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->len >= args->minlen"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "args->agno",
            "args->agbno"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_allfailed",
          "args": [
            "args"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_loopfailed",
          "args": [
            "args"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent",
          "args": [
            "args"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1246-1445",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_nofix",
          "args": [
            "args"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_freelist",
          "args": [
            "args",
            "flags"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1839-2008",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "args->agno"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount)",
            "0"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_noagbp",
          "args": [
            "args"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_nofix",
          "args": [
            "args"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_vextent_badargs",
          "args": [
            "args"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->mod < args->prod"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->minlen <= agsize"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->minlen <= args->maxlen"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_read_agf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2310-2364",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi])"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_CNTi]"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi])"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_BNOi]"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_longest == be32_to_cpu(agf->agf_longest)"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_longest"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_flcount == be32_to_cpu(agf->agf_flcount)"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks)"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_btreeblks"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks)"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_CNTi]"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_BNOi]"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_longest"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_btreeblks"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "*bpp"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(*bpp)->b_error"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_read_agf",
          "args": [
            "mp",
            "tp",
            "agno",
            "(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0",
            "bpp"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2280-2305",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};\n\nint\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_read_agf",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_read_agf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2280-2305",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "*bpp",
            "XFS_AGF_REF"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(*bpp)->b_error"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "XFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp))",
            "XFS_FSS_TO_BB(mp, 1)",
            "flags",
            "bpp",
            "&xfs_agf_buf_ops"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGF_DADDR(mp)"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGF_DADDR",
          "args": [
            "mp"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_read_agf",
          "args": [
            "mp",
            "agno"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agf_buf_ops = {\n\t.verify_read = xfs_agf_read_verify,\n\t.verify_write = xfs_agf_write_verify,\n};\n\nint\t\t\t\t\t/* error */\nxfs_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_BUF_ */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tint\t\terror;\n\n\ttrace_xfs_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), flags, bpp, &xfs_agf_buf_ops);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\n\tASSERT(!(*bpp)->b_error);\n\txfs_buf_set_ref(*bpp, XFS_AGF_REF);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_agf_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2250-2270",
    "snippet": "static void\nxfs_agf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_agf_verify(mp, bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGF(bp)->agf_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGF_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_AGF_CRC_OFF"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "bp"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_agf_verify",
          "args": [
            "mp",
            "bp"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2192-2230",
          "snippet": "static bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_agf_verify(mp, bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGF(bp)->agf_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGF_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_agf_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2232-2248",
    "snippet": "static void\nxfs_agf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (XFS_TEST_ERROR(!xfs_agf_verify(mp, bp), mp,\n\t\t\t\tXFS_ERRTAG_ALLOC_READ_AGF,\n\t\t\t\tXFS_RANDOM_ALLOC_READ_AGF))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!xfs_agf_verify(mp, bp)",
            "mp",
            "XFS_ERRTAG_ALLOC_READ_AGF",
            "XFS_RANDOM_ALLOC_READ_AGF"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_agf_verify",
          "args": [
            "mp",
            "bp"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2192-2230",
          "snippet": "static bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_AGF_CRC_OFF"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (XFS_TEST_ERROR(!xfs_agf_verify(mp, bp), mp,\n\t\t\t\tXFS_ERRTAG_ALLOC_READ_AGF,\n\t\t\t\tXFS_RANDOM_ALLOC_READ_AGF))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_agf_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2192-2230",
    "snippet": "static bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_btreeblks"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_CNT]"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_levels[XFS_BTNUM_BNO]"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_fllast"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flfirst"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGF_GOOD_VERSION",
          "args": [
            "be32_to_cpu(agf->agf_versionnum)"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_versionnum"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_AGF_MAGIC"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&agf->agf_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "bp"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agf_verify(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp)\n {\n\tstruct xfs_agf\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\n\tif (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&\n\t      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))\n\t\treturn false;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn false;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn false;\n\n\treturn true;;\n\n}"
  },
  {
    "function_name": "xfs_alloc_put_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2135-2190",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "agflbp",
            "startoff",
            "startoff + sizeof(xfs_agblock_t) - 1"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "agflbp",
            "XFS_BLFT_AGFL_BUF"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "tp",
            "agbp",
            "logflags"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bno"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_fllast"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL_BNO",
          "args": [
            "mp",
            "agflbp"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_btreeblks",
            "-1"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_agflist_delta",
          "args": [
            "tp",
            "1"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_flcount",
            "1"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "be32_to_cpu(agf->agf_seqno)"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_fllast"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_fllast",
            "1"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agfl",
          "args": [
            "mp",
            "tp",
            "be32_to_cpu(agf->agf_seqno)",
            "&agflbp"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "524-544",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_pagf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2115-2130",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agf",
          "args": [
            "mp",
            "tp",
            "agno",
            "flags",
            "&bp"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2310-2364",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_log_agf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2079-2110",
    "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "(uint)first",
            "(uint)last"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_offsets",
          "args": [
            "fields",
            "offsets",
            "XFS_AGF_NUM_BITS",
            "&first",
            "&last"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "663-693",
          "snippet": "void\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_AGF_BUF"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_agf",
          "args": [
            "tp->t_mountp",
            "XFS_BUF_TO_AGF(bp)",
            "fields",
            "_RET_IP_"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "bp"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
  },
  {
    "function_name": "xfs_alloc_get_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "2014-2074",
    "snippet": "int\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "tp",
            "agbp",
            "logflags"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_btreeblks",
            "1"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_agflist_delta",
          "args": [
            "tp",
            "-1"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_flcount",
            "-1"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "be32_to_cpu(agf->agf_seqno)"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flfirst"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "agflbp"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_flfirst",
            "1"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfl_bno[be32_to_cpu(agf->agf_flfirst)]"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flfirst"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL_BNO",
          "args": [
            "mp",
            "agflbp"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agfl",
          "args": [
            "mp",
            "tp",
            "be32_to_cpu(agf->agf_seqno)",
            "&agflbp"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "524-544",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_seqno"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_fix_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1839-2008",
    "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "agflbp"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_put_freelist",
          "args": [
            "tp",
            "agbp",
            "agflbp",
            "bno",
            "0"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_put_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2135-2190",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_put_freelist(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_buf_t\t\t*agflbp,/* buffer for a.g. free block array */\n\txfs_agblock_t\t\tbno,\t/* block being freed */\n\tint\t\t\tbtreeblk) /* block came from a AGF btree */\n{\n\txfs_agf_t\t\t*agf;\t/* a.g. freespace structure */\n\t__be32\t\t\t*blockp;/* pointer to array entry */\n\tint\t\t\terror;\n\tint\t\t\tlogflags;\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_perag_t\t\t*pag;\t/* per allocation group data */\n\t__be32\t\t\t*agfl_bno;\n\tint\t\t\tstartoff;\n\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tmp = tp->t_mountp;\n\n\tif (!agflbp && (error = xfs_alloc_read_agfl(mp, tp,\n\t\t\tbe32_to_cpu(agf->agf_seqno), &agflbp)))\n\t\treturn error;\n\tbe32_add_cpu(&agf->agf_fllast, 1);\n\tif (be32_to_cpu(agf->agf_fllast) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_fllast = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, 1);\n\txfs_trans_agflist_delta(tp, 1);\n\tpag->pagf_flcount++;\n\n\tlogflags = XFS_AGF_FLLAST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, -1);\n\t\tpag->pagf_btreeblks--;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\txfs_perag_put(pag);\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\tASSERT(be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp));\n\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tblockp = &agfl_bno[be32_to_cpu(agf->agf_fllast)];\n\t*blockp = cpu_to_be32(bno);\n\tstartoff = (char *)blockp - (char *)agflbp->b_addr;\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\n\txfs_trans_buf_set_type(tp, agflbp, XFS_BLFT_AGFL_BUF);\n\txfs_trans_log_buf(tp, agflbp, startoff,\n\t\t\t  startoff + sizeof(xfs_agblock_t) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent",
          "args": [
            "&targs"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1246-1445",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agfl",
          "args": [
            "mp",
            "tp",
            "targs.agno",
            "&agflbp"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "524-544",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&targs",
            "0",
            "sizeof(targs)"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "bp"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_bufs",
          "args": [
            "mp",
            "tp",
            "args->agno",
            "bno",
            "0"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "566-580",
          "snippet": "xfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_ag_extent",
          "args": [
            "tp",
            "agbp",
            "args->agno",
            "bno",
            "1",
            "1"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_ag_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1540-1787",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_freelist",
          "args": [
            "tp",
            "agbp",
            "&bno",
            "0"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2014-2074",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_longest"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_flcount"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_MIN_FREELIST",
          "args": [
            "agf",
            "mp"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_ALLOC_FLAG_FREEING)"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_ALLOC_FLAG_TRYLOCK"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_read_agf",
          "args": [
            "mp",
            "tp",
            "args->agno",
            "flags",
            "&agbp"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_read_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2310-2364",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_read_agf(\n\tstruct xfs_mount\t*mp,\t/* mount point structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags,\t/* XFS_ALLOC_FLAG_... */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer for the ag freelist header */\n{\n\tstruct xfs_agf\t\t*agf;\t\t/* ag freelist header */\n\tstruct xfs_perag\t*pag;\t\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_read_agf(mp, agno);\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_read_agf(mp, tp, agno,\n\t\t\t(flags & XFS_ALLOC_FLAG_TRYLOCK) ? XBF_TRYLOCK : 0,\n\t\t\tbpp);\n\tif (error)\n\t\treturn error;\n\tif (!*bpp)\n\t\treturn 0;\n\tASSERT(!(*bpp)->b_error);\n\n\tagf = XFS_BUF_TO_AGF(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagf_init) {\n\t\tpag->pagf_freeblks = be32_to_cpu(agf->agf_freeblks);\n\t\tpag->pagf_btreeblks = be32_to_cpu(agf->agf_btreeblks);\n\t\tpag->pagf_flcount = be32_to_cpu(agf->agf_flcount);\n\t\tpag->pagf_longest = be32_to_cpu(agf->agf_longest);\n\t\tpag->pagf_levels[XFS_BTNUM_BNOi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);\n\t\tpag->pagf_levels[XFS_BTNUM_CNTi] =\n\t\t\tbe32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);\n\t\tspin_lock_init(&pag->pagb_lock);\n\t\tpag->pagb_count = 0;\n\t\tpag->pagb_tree = RB_ROOT;\n\t\tpag->pagf_init = 1;\n\t}\n#ifdef DEBUG\n\telse if (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_BNOi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]));\n\t\tASSERT(pag->pagf_levels[XFS_BTNUM_CNTi] ==\n\t\t       be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]));\n\t}\n#endif\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_longest_free_extent",
          "args": [
            "mp",
            "pag"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_longest_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1819-1833",
          "snippet": "xfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nxfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_MIN_FREELIST_PAG",
          "args": [
            "pag",
            "mp"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_ALLOC_FLAG_FREEING)"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_ALLOC_FLAG_FREEING)"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_ALLOC_FLAG_TRYLOCK"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_fix_freelist(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\tint\t\tflags)\t/* XFS_ALLOC_FLAG_... */\n{\n\txfs_buf_t\t*agbp;\t/* agf buffer pointer */\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure pointer */\n\txfs_buf_t\t*agflbp;/* agfl buffer pointer */\n\txfs_agblock_t\tbno;\t/* freelist block */\n\txfs_extlen_t\tdelta;\t/* new blocks needed in freelist */\n\tint\t\terror;\t/* error result code */\n\txfs_extlen_t\tlongest;/* longest extent in allocation group */\n\txfs_mount_t\t*mp;\t/* file system mount point structure */\n\txfs_extlen_t\tneed;\t/* total blocks needed in freelist */\n\txfs_perag_t\t*pag;\t/* per-ag information structure */\n\txfs_alloc_arg_t\ttargs;\t/* local allocation arguments */\n\txfs_trans_t\t*tp;\t/* transaction pointer */\n\n\tmp = args->mp;\n\n\tpag = args->pag;\n\ttp = args->tp;\n\tif (!pag->pagf_init) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (!pag->pagf_init) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tagbp = NULL;\n\n\t/*\n\t * If this is a metadata preferred pag and we are user data\n\t * then try somewhere else if we are not being asked to\n\t * try harder at this point\n\t */\n\tif (pag->pagf_metadata && args->userdata &&\n\t    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {\n\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\targs->agbp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\t/*\n\t\t * If it looks like there isn't a long enough extent, or enough\n\t\t * total blocks, reject it.\n\t\t */\n\t\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(pag->pagf_freeblks + pag->pagf_flcount -\n\t\t\t   need - args->total) < (int)args->minleft)) {\n\t\t\tif (agbp)\n\t\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Get the a.g. freespace buffer.\n\t * Can fail if we're not blocking on locks, and it's held.\n\t */\n\tif (agbp == NULL) {\n\t\tif ((error = xfs_alloc_read_agf(mp, tp, args->agno, flags,\n\t\t\t\t&agbp)))\n\t\t\treturn error;\n\t\tif (agbp == NULL) {\n\t\t\tASSERT(flags & XFS_ALLOC_FLAG_TRYLOCK);\n\t\t\tASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Figure out how many blocks we should have in the freelist.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tneed = XFS_MIN_FREELIST(agf, mp);\n\t/*\n\t * If there isn't enough total or single-extent, reject it.\n\t */\n\tif (!(flags & XFS_ALLOC_FLAG_FREEING)) {\n\t\tdelta = need > be32_to_cpu(agf->agf_flcount) ?\n\t\t\t(need - be32_to_cpu(agf->agf_flcount)) : 0;\n\t\tlongest = be32_to_cpu(agf->agf_longest);\n\t\tlongest = (longest > delta) ? (longest - delta) :\n\t\t\t(be32_to_cpu(agf->agf_flcount) > 0 || longest > 0);\n\t\tif ((args->minlen + args->alignment + args->minalignslop - 1) >\n\t\t\t\tlongest ||\n\t\t    ((int)(be32_to_cpu(agf->agf_freeblks) +\n\t\t     be32_to_cpu(agf->agf_flcount) - need - args->total) <\n\t\t\t\t(int)args->minleft)) {\n\t\t\txfs_trans_brelse(tp, agbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Make the freelist shorter if it's too long.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) > need) {\n\t\txfs_buf_t\t*bp;\n\n\t\terror = xfs_alloc_get_freelist(tp, agbp, &bno, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif ((error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1)))\n\t\t\treturn error;\n\t\tbp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Initialize the args structure.\n\t */\n\tmemset(&targs, 0, sizeof(targs));\n\ttargs.tp = tp;\n\ttargs.mp = mp;\n\ttargs.agbp = agbp;\n\ttargs.agno = args->agno;\n\ttargs.alignment = targs.minlen = targs.prod = targs.isfl = 1;\n\ttargs.type = XFS_ALLOCTYPE_THIS_AG;\n\ttargs.pag = pag;\n\tif ((error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp)))\n\t\treturn error;\n\t/*\n\t * Make the freelist longer if it's too short.\n\t */\n\twhile (be32_to_cpu(agf->agf_flcount) < need) {\n\t\ttargs.agbno = 0;\n\t\ttargs.maxlen = need - be32_to_cpu(agf->agf_flcount);\n\t\t/*\n\t\t * Allocate as many blocks as possible at once.\n\t\t */\n\t\tif ((error = xfs_alloc_ag_vextent(&targs))) {\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Stop if we run out.  Won't happen if callers are obeying\n\t\t * the restrictions correctly.  Can happen for free calls\n\t\t * on a completely full ag.\n\t\t */\n\t\tif (targs.agbno == NULLAGBLOCK) {\n\t\t\tif (flags & XFS_ALLOC_FLAG_FREEING)\n\t\t\t\tbreak;\n\t\t\txfs_trans_brelse(tp, agflbp);\n\t\t\targs->agbp = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Put each allocated block on the list.\n\t\t */\n\t\tfor (bno = targs.agbno; bno < targs.agbno + targs.len; bno++) {\n\t\t\terror = xfs_alloc_put_freelist(tp, agbp,\n\t\t\t\t\t\t\tagflbp, bno, 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\txfs_trans_brelse(tp, agflbp);\n\targs->agbp = agbp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_longest_free_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1819-1833",
    "snippet": "xfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_MIN_FREELIST_PAG",
          "args": [
            "pag",
            "mp"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nxfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}"
  },
  {
    "function_name": "xfs_alloc_compute_maxlevels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1797-1814",
    "snippet": "void\nxfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (mp->m_sb.sb_agblocks + 1) / 2;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_ag_maxlevels = level;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tint\t\tlevel;\n\tuint\t\tmaxblocks;\n\tuint\t\tmaxleafents;\n\tint\t\tminleafrecs;\n\tint\t\tminnoderecs;\n\n\tmaxleafents = (mp->m_sb.sb_agblocks + 1) / 2;\n\tminleafrecs = mp->m_alloc_mnr[0];\n\tminnoderecs = mp->m_alloc_mnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++)\n\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\tmp->m_ag_maxlevels = level;\n}"
  },
  {
    "function_name": "xfs_free_ag_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1540-1787",
    "snippet": "STATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cnt_cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_free_extent",
          "args": [
            "mp",
            "agno",
            "bno",
            "len",
            "isfl",
            "-1",
            "-1"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_free_extent",
          "args": [
            "mp",
            "agno",
            "bno",
            "len",
            "isfl",
            "haveleft",
            "haveright"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_freeb",
            "len"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_freex"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_FDBLOCKS",
            "(long)len"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_update_counters",
          "args": [
            "tp",
            "pag",
            "agbp",
            "len"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_update_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "546-565",
          "snippet": "STATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "cnt_cur",
            "&i"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "error0"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_eq",
          "args": [
            "cnt_cur",
            "nbno",
            "nlen",
            "&i"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "55-65",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_update",
          "args": [
            "bno_cur",
            "nbno",
            "nlen"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "104-115",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cnt_cur",
            "&i"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "bno_cur",
            "0",
            "&i"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1 && xxbno == ltbno && xxlen == ltlen",
            "error0"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "bno_cur",
            "&xxbno",
            "&xxlen",
            "&i"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "mp",
            "tp",
            "agbp",
            "agno",
            "XFS_BTNUM_CNT"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "gtbno >= bno + len",
            "error0"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "bno_cur",
            "0",
            "&haveright"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "ltbno + ltlen <= bno",
            "error0"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_le",
          "args": [
            "bno_cur",
            "bno",
            "len",
            "&haveleft"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "87-97",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_free_ag_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer for a.g. freelist header */\n\txfs_agnumber_t\tagno,\t/* allocation group number */\n\txfs_agblock_t\tbno,\t/* starting block number */\n\txfs_extlen_t\tlen,\t/* length of extent */\n\tint\t\tisfl)\t/* set if is freelist blocks - no sb acctg */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for by-block btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for by-size btree */\n\tint\t\terror;\t\t/* error return value */\n\txfs_agblock_t\tgtbno;\t\t/* start of right neighbor block */\n\txfs_extlen_t\tgtlen;\t\t/* length of right neighbor block */\n\tint\t\thaveleft;\t/* have a left neighbor block */\n\tint\t\thaveright;\t/* have a right neighbor block */\n\tint\t\ti;\t\t/* temp, result code */\n\txfs_agblock_t\tltbno;\t\t/* start of left neighbor block */\n\txfs_extlen_t\tltlen;\t\t/* length of left neighbor block */\n\txfs_mount_t\t*mp;\t\t/* mount point struct for filesystem */\n\txfs_agblock_t\tnbno;\t\t/* new starting block of freespace */\n\txfs_extlen_t\tnlen;\t\t/* new length of freespace */\n\txfs_perag_t\t*pag;\t\t/* per allocation group data */\n\n\tmp = tp->t_mountp;\n\t/*\n\t * Allocate and initialize a cursor for the by-block btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);\n\tcnt_cur = NULL;\n\t/*\n\t * Look for a neighboring block on the left (lower block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur, bno, len, &haveleft)))\n\t\tgoto error0;\n\tif (haveleft) {\n\t\t/*\n\t\t * There is a block to our left.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (ltbno + ltlen < bno)\n\t\t\thaveleft = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(ltbno + ltlen <= bno, error0);\n\t\t}\n\t}\n\t/*\n\t * Look for a neighboring block on the right (higher block numbers)\n\t * that is contiguous with this space.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur, 0, &haveright)))\n\t\tgoto error0;\n\tif (haveright) {\n\t\t/*\n\t\t * There is a block to our right.\n\t\t */\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &gtbno, &gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * It's not contiguous, though.\n\t\t */\n\t\tif (bno + len < gtbno)\n\t\t\thaveright = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If this failure happens the request to free this\n\t\t\t * space was invalid, it's (partly) already free.\n\t\t\t * Very bad.\n\t\t\t */\n\t\t\tXFS_WANT_CORRUPTED_GOTO(gtbno >= bno + len, error0);\n\t\t}\n\t}\n\t/*\n\t * Now allocate and initialize a cursor for the by-size tree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_CNT);\n\t/*\n\t * Have both left and right contiguous neighbors.\n\t * Merge all three into a single free block.\n\t */\n\tif (haveleft && haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Delete the old by-block entry for the right block.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Move the by-block cursor back to the left neighbor.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n#ifdef DEBUG\n\t\t/*\n\t\t * Check that this is the right record: delete didn't\n\t\t * mangle the cursor.\n\t\t */\n\t\t{\n\t\t\txfs_agblock_t\txxbno;\n\t\t\txfs_extlen_t\txxlen;\n\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur, &xxbno, &xxlen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\ti == 1 && xxbno == ltbno && xxlen == ltlen,\n\t\t\t\terror0);\n\t\t}\n#endif\n\t\t/*\n\t\t * Update remaining by-block entry to the new, joined block.\n\t\t */\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a left contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveleft) {\n\t\t/*\n\t\t * Delete the old by-size entry on the left.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, ltbno, ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Back up the by-block cursor to the left neighbor, and\n\t\t * update its length.\n\t\t */\n\t\tif ((error = xfs_btree_decrement(bno_cur, 0, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tnbno = ltbno;\n\t\tnlen = len + ltlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * Have only a right contiguous neighbor.\n\t * Merge it together with the new freespace.\n\t */\n\telse if (haveright) {\n\t\t/*\n\t\t * Delete the old by-size entry on the right.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, gtbno, gtlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t/*\n\t\t * Update the starting block and length of the right\n\t\t * neighbor in the by-block tree.\n\t\t */\n\t\tnbno = bno;\n\t\tnlen = len + gtlen;\n\t\tif ((error = xfs_alloc_update(bno_cur, nbno, nlen)))\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * No contiguous neighbors.\n\t * Insert the new freespace into the by-block tree.\n\t */\n\telse {\n\t\tnbno = bno;\n\t\tnlen = len;\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tbno_cur = NULL;\n\t/*\n\t * In all cases we need to insert the new freespace in the by-size tree.\n\t */\n\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nbno, nlen, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 0, error0);\n\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = NULL;\n\n\t/*\n\t * Update the freespace totals in the ag and superblock.\n\t */\n\tpag = xfs_perag_get(mp, agno);\n\terror = xfs_alloc_update_counters(tp, pag, agbp, len);\n\txfs_perag_put(pag);\n\tif (error)\n\t\tgoto error0;\n\n\tif (!isfl)\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);\n\tXFS_STATS_INC(xs_freex);\n\tXFS_STATS_ADD(xs_freeb, len);\n\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);\n\n\treturn 0;\n\n error0:\n\ttrace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_ag_vextent_small",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1452-1535",
    "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_alloc_small_error",
          "args": [
            "args"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_small_done",
          "args": [
            "args"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_small_notenough",
          "args": [
            "args"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_small_freelist",
          "args": [
            "args"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "args->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length)",
            "error0"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_length"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "args->tp",
            "bp"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_bufs",
          "args": [
            "args->mp",
            "args->tp",
            "args->agno",
            "fbno",
            "0"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "566-580",
          "snippet": "xfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_reuse",
          "args": [
            "args->mp",
            "args->agno",
            "fbno",
            "1",
            "args->userdata"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "304-341",
          "snippet": "void\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_freelist",
          "args": [
            "args->tp",
            "args->agbp",
            "&fbno",
            "0"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2014-2074",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_alloc_get_freelist(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*agbp,\t/* buffer containing the agf structure */\n\txfs_agblock_t\t*bnop,\t/* block address retrieved from freelist */\n\tint\t\tbtreeblk) /* destination is a AGF btree */\n{\n\txfs_agf_t\t*agf;\t/* a.g. freespace structure */\n\txfs_buf_t\t*agflbp;/* buffer for a.g. freelist structure */\n\txfs_agblock_t\tbno;\t/* block number returned */\n\t__be32\t\t*agfl_bno;\n\tint\t\terror;\n\tint\t\tlogflags;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\txfs_perag_t\t*pag;\t/* per allocation group data */\n\n\t/*\n\t * Freelist is empty, give up.\n\t */\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tif (!agf->agf_flcount) {\n\t\t*bnop = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Read the array of free blocks.\n\t */\n\terror = xfs_alloc_read_agfl(mp, tp, be32_to_cpu(agf->agf_seqno),\n\t\t\t\t    &agflbp);\n\tif (error)\n\t\treturn error;\n\n\n\t/*\n\t * Get the block number and update the data structures.\n\t */\n\tagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, agflbp);\n\tbno = be32_to_cpu(agfl_bno[be32_to_cpu(agf->agf_flfirst)]);\n\tbe32_add_cpu(&agf->agf_flfirst, 1);\n\txfs_trans_brelse(tp, agflbp);\n\tif (be32_to_cpu(agf->agf_flfirst) == XFS_AGFL_SIZE(mp))\n\t\tagf->agf_flfirst = 0;\n\n\tpag = xfs_perag_get(mp, be32_to_cpu(agf->agf_seqno));\n\tbe32_add_cpu(&agf->agf_flcount, -1);\n\txfs_trans_agflist_delta(tp, -1);\n\tpag->pagf_flcount--;\n\txfs_perag_put(pag);\n\n\tlogflags = XFS_AGF_FLFIRST | XFS_AGF_FLCOUNT;\n\tif (btreeblk) {\n\t\tbe32_add_cpu(&agf->agf_btreeblks, 1);\n\t\tpag->pagf_btreeblks++;\n\t\tlogflags |= XFS_AGF_BTREEBLKS;\n\t}\n\n\txfs_alloc_log_agf(tp, agbp, logflags);\n\t*bnop = bno;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_flcount"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "ccur",
            "&fbno",
            "&flen",
            "&i"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "ccur",
            "0",
            "&i"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_ag_vextent_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "1246-1445",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tXFSA_FIXUP_CNT_OK\t2"
    ],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_nominleft",
          "args": [
            "args"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cnt_cur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_error",
          "args": [
            "args"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_done",
          "args": [
            "args"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "args->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length)",
            "error0"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_length"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fixup_trees",
          "args": [
            "cnt_cur",
            "bno_cur",
            "fbno",
            "flen",
            "rbno",
            "rlen",
            "XFSA_FIXUP_CNT_OK"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fixup_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "302-438",
          "snippet": "STATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2",
            "#define\tXFSA_FIXUP_BNO_OK\t1"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "args->mp",
            "args->tp",
            "args->agbp",
            "args->agno",
            "XFS_BTNUM_BNO"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "rlen <= flen",
            "error0"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_minleft",
          "args": [
            "args"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_minleft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "274-293",
          "snippet": "STATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\n\nSTATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_len",
          "args": [
            "args"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "242-268",
          "snippet": "STATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "args->mp",
            "XFS_LOG_SYNC"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_busy",
          "args": [
            "args"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_eq",
          "args": [
            "cnt_cur",
            "bestfbno",
            "bestflen",
            "&i"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "55-65",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen)",
            "error0"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "args->maxlen",
            "rlen"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_aligned",
          "args": [
            "args",
            "fbno",
            "flen",
            "&rbno",
            "&rlen"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "142-166",
          "snippet": "STATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "cnt_cur",
            "&fbno",
            "&flen",
            "&i"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cnt_cur",
            "0",
            "&i"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen)",
            "error0"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "args->maxlen",
            "rlen"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_busy",
          "args": [
            "args"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cnt_cur",
            "0",
            "&i"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 1"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_noentry",
          "args": [
            "args"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent_small",
          "args": [
            "args",
            "cnt_cur",
            "&fbno",
            "&flen",
            "&i"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_small",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1452-1535",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_ge",
          "args": [
            "cnt_cur",
            "0",
            "args->maxlen + args->alignment - 1",
            "&i"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_ge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "71-81",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_ag_vextent_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "849-1238",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_near(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur_gt;\t/* cursor for bno btree, right side */\n\txfs_btree_cur_t\t*bno_cur_lt;\t/* cursor for bno btree, left side */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for count btree */\n\txfs_agblock_t\tgtbno;\t\t/* start bno of right side entry */\n\txfs_agblock_t\tgtbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tgtdiff;\t\t/* difference to right side entry */\n\txfs_extlen_t\tgtlen;\t\t/* length of right side entry */\n\txfs_extlen_t\tgtlena;\t\t/* aligned ... */\n\txfs_agblock_t\tgtnew;\t\t/* useful start bno of right side */\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* result code, temporary */\n\tint\t\tj;\t\t/* result code, temporary */\n\txfs_agblock_t\tltbno;\t\t/* start bno of left side entry */\n\txfs_agblock_t\tltbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tltdiff;\t\t/* difference to left side entry */\n\txfs_extlen_t\tltlen;\t\t/* length of left side entry */\n\txfs_extlen_t\tltlena;\t\t/* aligned ... */\n\txfs_agblock_t\tltnew;\t\t/* useful start bno of left side */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n#ifdef DEBUG\n\t/*\n\t * Randomly don't execute the first algorithm.\n\t */\n\tint\t\tdofirst;\t/* set to do first algorithm */\n\n\tdofirst = prandom_u32() & 1;\n#endif\n\nrestart:\n\tbno_cur_lt = NULL;\n\tbno_cur_gt = NULL;\n\tltlen = 0;\n\tgtlena = 0;\n\tltlena = 0;\n\n\t/*\n\t * Get a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * See if there are any free extents as big as maxlen.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0, args->maxlen, &i)))\n\t\tgoto error0;\n\t/*\n\t * If none, then pick up the last entry in the tree unless the\n\t * tree is empty.\n\t */\n\tif (!i) {\n\t\tif ((error = xfs_alloc_ag_vextent_small(args, cnt_cur, &ltbno,\n\t\t\t\t&ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (i == 0 || ltlen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\targs->wasfromfl = 0;\n\n\t/*\n\t * First algorithm.\n\t * If the requested extent is large wrt the freespaces available\n\t * in this a.g., then the cursor will be pointing to a btree entry\n\t * near the right edge of the tree.  If it's in the last btree leaf\n\t * block, then we just examine all the entries in that block\n\t * that are big enough, and pick the best one.\n\t * This is written as a while loop so we can break out of it,\n\t * but we never loop back to the top.\n\t */\n\twhile (xfs_btree_islastblock(cnt_cur, 0)) {\n\t\txfs_extlen_t\tbdiff;\n\t\tint\t\tbesti=0;\n\t\txfs_extlen_t\tblen=0;\n\t\txfs_agblock_t\tbnew=0;\n\n#ifdef DEBUG\n\t\tif (dofirst)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Start from the entry that lookup found, sequence through\n\t\t * all larger free blocks.  If we're actually pointing at a\n\t\t * record smaller than maxlen, go to the start of this block,\n\t\t * and skip all those smaller than minlen.\n\t\t */\n\t\tif (ltlen || args->alignment > 1) {\n\t\t\tcnt_cur->bc_ptrs[0] = 1;\n\t\t\tdo {\n\t\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno,\n\t\t\t\t\t\t&ltlen, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\t\tif (ltlen >= args->minlen)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((error = xfs_btree_increment(cnt_cur, 0, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t} while (i);\n\t\t\tASSERT(ltlen >= args->minlen);\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = cnt_cur->bc_ptrs[0];\n\t\tfor (j = 1, blen = 0, bdiff = 0;\n\t\t     !error && j && (blen < args->maxlen || bdiff > 0);\n\t\t     error = xfs_btree_increment(cnt_cur, 0, &j)) {\n\t\t\t/*\n\t\t\t * For each entry, decide if it's better than\n\t\t\t * the previous best entry.\n\t\t\t */\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena < args->minlen)\n\t\t\t\tcontinue;\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tASSERT(args->len >= args->minlen);\n\t\t\tif (args->len < blen)\n\t\t\t\tcontinue;\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\t\t\tif (ltnew != NULLAGBLOCK &&\n\t\t\t    (args->len > blen || ltdiff < bdiff)) {\n\t\t\t\tbdiff = ltdiff;\n\t\t\t\tbnew = ltnew;\n\t\t\t\tblen = args->len;\n\t\t\t\tbesti = cnt_cur->bc_ptrs[0];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * It didn't work.  We COULD be in a case where\n\t\t * there's a good record somewhere, so try again.\n\t\t */\n\t\tif (blen == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Point at the best entry, and retrieve it again.\n\t\t */\n\t\tcnt_cur->bc_ptrs[0] = besti;\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tASSERT(ltbno + ltlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\t\targs->len = blen;\n\t\tif (!xfs_alloc_fix_minleft(args)) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\t\treturn 0;\n\t\t}\n\t\tblen = args->len;\n\t\t/*\n\t\t * We are allocating starting at bnew for blen blocks.\n\t\t */\n\t\targs->agbno = bnew;\n\t\tASSERT(bnew >= ltbno);\n\t\tASSERT(bnew + blen <= ltbno + ltlen);\n\t\t/*\n\t\t * Set up a cursor for the by-bno tree.\n\t\t */\n\t\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\targs->agbp, args->agno, XFS_BTNUM_BNO);\n\t\t/*\n\t\t * Fix up the btree entries.\n\t\t */\n\t\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno,\n\t\t\t\tltlen, bnew, blen, XFSA_FIXUP_CNT_OK)))\n\t\t\tgoto error0;\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\n\t\ttrace_xfs_alloc_near_first(args);\n\t\treturn 0;\n\t}\n\t/*\n\t * Second algorithm.\n\t * Search in the by-bno tree to the left and to the right\n\t * simultaneously, until in each case we find a space big enough,\n\t * or run into the edge of the tree.  When we run into the edge,\n\t * we deallocate that cursor.\n\t * If both searches succeed, we compare the two spaces and pick\n\t * the better one.\n\t * With alignment, it's possible for both to fail; the upper\n\t * level algorithm that picks allocation groups for allocations\n\t * is not supposed to do this.\n\t */\n\t/*\n\t * Allocate and initialize the cursor for the leftward search.\n\t */\n\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\t/*\n\t * Lookup <= bno to find the leftward search's starting point.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur_lt, args->agbno, args->maxlen, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * Didn't find anything; use this cursor for the rightward\n\t\t * search.\n\t\t */\n\t\tbno_cur_gt = bno_cur_lt;\n\t\tbno_cur_lt = NULL;\n\t}\n\t/*\n\t * Found something.  Duplicate the cursor for the rightward search.\n\t */\n\telse if ((error = xfs_btree_dup_cursor(bno_cur_lt, &bno_cur_gt)))\n\t\tgoto error0;\n\t/*\n\t * Increment the cursor, so we will point at the entry just right\n\t * of the leftward entry if any, or to the leftmost entry.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * It failed, there are no rightward entries.\n\t\t */\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_NOERROR);\n\t\tbno_cur_gt = NULL;\n\t}\n\t/*\n\t * Loop going left with the leftward cursor, right with the\n\t * rightward cursor, until either both directions give up or\n\t * we find an entry at least as big as minlen.\n\t */\n\tdo {\n\t\tif (bno_cur_lt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_lt, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_decrement(bno_cur_lt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_lt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_lt = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bno_cur_gt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_gt, &gtbno, &gtlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, gtbno, gtlen,\n\t\t\t\t\t\t  &gtbnoa, &gtlena);\n\t\t\tif (gtlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_gt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_gt = NULL;\n\t\t\t}\n\t\t}\n\t} while (bno_cur_lt || bno_cur_gt);\n\n\t/*\n\t * Got both cursors still active, need to find better entry.\n\t */\n\tif (bno_cur_lt && bno_cur_gt) {\n\t\tif (ltlena >= args->minlen) {\n\t\t\t/*\n\t\t\t * Left side is good, look for a right side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_lt, &bno_cur_gt,\n\t\t\t\t\t\tltdiff, &gtbno, &gtlen,\n\t\t\t\t\t\t&gtbnoa, &gtlena,\n\t\t\t\t\t\t0 /* search right */);\n\t\t} else {\n\t\t\tASSERT(gtlena >= args->minlen);\n\n\t\t\t/*\n\t\t\t * Right side is good, look for a left side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(gtlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tgtdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, gtbnoa,\n\t\t\t\tgtlena, &gtnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_gt, &bno_cur_lt,\n\t\t\t\t\t\tgtdiff, &ltbno, &ltlen,\n\t\t\t\t\t\t&ltbnoa, &ltlena,\n\t\t\t\t\t\t1 /* search left */);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we couldn't get anything, give up.\n\t */\n\tif (bno_cur_lt == NULL && bno_cur_gt == NULL) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\t\tif (!forced++) {\n\t\t\ttrace_xfs_alloc_near_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\ttrace_xfs_alloc_size_neither(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point we have selected a freespace entry, either to the\n\t * left or to the right.  If it's on the right, copy all the\n\t * useful variables to the \"left\" set so we only have one\n\t * copy of this code.\n\t */\n\tif (bno_cur_gt) {\n\t\tbno_cur_lt = bno_cur_gt;\n\t\tbno_cur_gt = NULL;\n\t\tltbno = gtbno;\n\t\tltbnoa = gtbnoa;\n\t\tltlen = gtlen;\n\t\tltlena = gtlena;\n\t\tj = 1;\n\t} else\n\t\tj = 0;\n\n\t/*\n\t * Fix up the length and compute the useful address.\n\t */\n\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args)) {\n\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\treturn 0;\n\t}\n\trlen = args->len;\n\t(void)xfs_alloc_compute_diff(args->agbno, rlen, args->alignment,\n\t\t\t\t     args->userdata, ltbnoa, ltlena, &ltnew);\n\tASSERT(ltnew >= ltbno);\n\tASSERT(ltnew + rlen <= ltbnoa + ltlena);\n\tASSERT(ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\targs->agbno = ltnew;\n\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno, ltlen,\n\t\t\tltnew, rlen, XFSA_FIXUP_BNO_OK)))\n\t\tgoto error0;\n\n\tif (j)\n\t\ttrace_xfs_alloc_near_greater(args);\n\telse\n\t\ttrace_xfs_alloc_near_lesser(args);\n\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\treturn 0;\n\n error0:\n\ttrace_xfs_alloc_near_error(args);\n\tif (cnt_cur != NULL)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur_lt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_ERROR);\n\tif (bno_cur_gt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tXFSA_FIXUP_CNT_OK\t2",
      "#define\tXFSA_FIXUP_BNO_OK\t1"
    ],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "bno_cur_gt",
            "XFS_BTREE_ERROR"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_error",
          "args": [
            "args"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_lesser",
          "args": [
            "args"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_greater",
          "args": [
            "args"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fixup_trees",
          "args": [
            "cnt_cur",
            "bno_cur_lt",
            "ltbno",
            "ltlen",
            "ltnew",
            "rlen",
            "XFSA_FIXUP_BNO_OK"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fixup_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "302-438",
          "snippet": "STATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2",
            "#define\tXFSA_FIXUP_BNO_OK\t1"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_length"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ltnew + rlen <= ltbnoa + ltlena"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ltnew >= ltbno"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_diff",
          "args": [
            "args->agbno",
            "rlen",
            "args->alignment",
            "args->userdata",
            "ltbnoa",
            "ltlena",
            "&ltnew"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "172-234",
          "snippet": "STATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_nominleft",
          "args": [
            "args"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_minleft",
          "args": [
            "args"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_minleft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "274-293",
          "snippet": "STATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\n\nSTATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_len",
          "args": [
            "args"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "242-268",
          "snippet": "STATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "ltlena",
            "args->maxlen"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_size_neither",
          "args": [
            "args"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "args->mp",
            "XFS_LOG_SYNC"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_busy",
          "args": [
            "args"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_find_best_extent",
          "args": [
            "args",
            "&bno_cur_gt",
            "&bno_cur_lt",
            "gtdiff",
            "&ltbno",
            "&ltlen",
            "&ltbnoa",
            "&ltlena",
            "1/* search left */"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_find_best_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "758-841",
          "snippet": "STATIC int\nxfs_alloc_find_best_extent(\n\tstruct xfs_alloc_arg\t*args,\t/* allocation argument structure */\n\tstruct xfs_btree_cur\t**gcur,\t/* good cursor */\n\tstruct xfs_btree_cur\t**scur,\t/* searching cursor */\n\txfs_agblock_t\t\tgdiff,\t/* difference for search comparison */\n\txfs_agblock_t\t\t*sbno,\t/* extent found by search */\n\txfs_extlen_t\t\t*slen,\t/* extent length */\n\txfs_agblock_t\t\t*sbnoa,\t/* aligned extent found by search */\n\txfs_extlen_t\t\t*slena,\t/* aligned extent length */\n\tint\t\t\tdir)\t/* 0 = search right, 1 = search left */\n{\n\txfs_agblock_t\t\tnew;\n\txfs_agblock_t\t\tsdiff;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/* The good extent is perfect, no need to  search. */\n\tif (!gdiff)\n\t\tgoto out_use_good;\n\n\t/*\n\t * Look until we find a better one, run out of space or run off the end.\n\t */\n\tdo {\n\t\terror = xfs_alloc_get_rec(*scur, sbno, slen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\txfs_alloc_compute_aligned(args, *sbno, *slen, sbnoa, slena);\n\n\t\t/*\n\t\t * The good extent is closer than this one.\n\t\t */\n\t\tif (!dir) {\n\t\t\tif (*sbnoa >= args->agbno + gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t} else {\n\t\t\tif (*sbnoa <= args->agbno - gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t}\n\n\t\t/*\n\t\t * Same distance, compare length and pick the best.\n\t\t */\n\t\tif (*slena >= args->minlen) {\n\t\t\targs->len = XFS_EXTLEN_MIN(*slena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\n\t\t\tsdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\t\t\t       args->alignment,\n\t\t\t\t\t\t       args->userdata, *sbnoa,\n\t\t\t\t\t\t       *slena, &new);\n\n\t\t\t/*\n\t\t\t * Choose closer size and invalidate other cursor.\n\t\t\t */\n\t\t\tif (sdiff < gdiff)\n\t\t\t\tgoto out_use_search;\n\t\t\tgoto out_use_good;\n\t\t}\n\n\t\tif (!dir)\n\t\t\terror = xfs_btree_increment(*scur, 0, &i);\n\t\telse\n\t\t\terror = xfs_btree_decrement(*scur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t} while (i);\n\nout_use_good:\n\txfs_btree_del_cursor(*scur, XFS_BTREE_NOERROR);\n\t*scur = NULL;\n\treturn 0;\n\nout_use_search:\n\txfs_btree_del_cursor(*gcur, XFS_BTREE_NOERROR);\n\t*gcur = NULL;\n\treturn 0;\n\nerror0:\n\t/* caller invalidates cursors */\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\nxfs_alloc_find_best_extent(\n\tstruct xfs_alloc_arg\t*args,\t/* allocation argument structure */\n\tstruct xfs_btree_cur\t**gcur,\t/* good cursor */\n\tstruct xfs_btree_cur\t**scur,\t/* searching cursor */\n\txfs_agblock_t\t\tgdiff,\t/* difference for search comparison */\n\txfs_agblock_t\t\t*sbno,\t/* extent found by search */\n\txfs_extlen_t\t\t*slen,\t/* extent length */\n\txfs_agblock_t\t\t*sbnoa,\t/* aligned extent found by search */\n\txfs_extlen_t\t\t*slena,\t/* aligned extent length */\n\tint\t\t\tdir)\t/* 0 = search right, 1 = search left */\n{\n\txfs_agblock_t\t\tnew;\n\txfs_agblock_t\t\tsdiff;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/* The good extent is perfect, no need to  search. */\n\tif (!gdiff)\n\t\tgoto out_use_good;\n\n\t/*\n\t * Look until we find a better one, run out of space or run off the end.\n\t */\n\tdo {\n\t\terror = xfs_alloc_get_rec(*scur, sbno, slen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\txfs_alloc_compute_aligned(args, *sbno, *slen, sbnoa, slena);\n\n\t\t/*\n\t\t * The good extent is closer than this one.\n\t\t */\n\t\tif (!dir) {\n\t\t\tif (*sbnoa >= args->agbno + gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t} else {\n\t\t\tif (*sbnoa <= args->agbno - gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t}\n\n\t\t/*\n\t\t * Same distance, compare length and pick the best.\n\t\t */\n\t\tif (*slena >= args->minlen) {\n\t\t\targs->len = XFS_EXTLEN_MIN(*slena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\n\t\t\tsdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\t\t\t       args->alignment,\n\t\t\t\t\t\t       args->userdata, *sbnoa,\n\t\t\t\t\t\t       *slena, &new);\n\n\t\t\t/*\n\t\t\t * Choose closer size and invalidate other cursor.\n\t\t\t */\n\t\t\tif (sdiff < gdiff)\n\t\t\t\tgoto out_use_search;\n\t\t\tgoto out_use_good;\n\t\t}\n\n\t\tif (!dir)\n\t\t\terror = xfs_btree_increment(*scur, 0, &i);\n\t\telse\n\t\t\terror = xfs_btree_decrement(*scur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t} while (i);\n\nout_use_good:\n\txfs_btree_del_cursor(*scur, XFS_BTREE_NOERROR);\n\t*scur = NULL;\n\treturn 0;\n\nout_use_search:\n\txfs_btree_del_cursor(*gcur, XFS_BTREE_NOERROR);\n\t*gcur = NULL;\n\treturn 0;\n\nerror0:\n\t/* caller invalidates cursors */\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "gtlena",
            "args->maxlen"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "gtlena >= args->minlen"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "ltlena",
            "args->maxlen"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "bno_cur_gt",
            "0",
            "&i"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_aligned",
          "args": [
            "args",
            "gtbno",
            "gtlen",
            "&gtbnoa",
            "&gtlena"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "142-166",
          "snippet": "STATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "bno_cur_gt",
            "&gtbno",
            "&gtlen",
            "&i"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "bno_cur_lt",
            "0",
            "&i"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "bno_cur_lt",
            "&bno_cur_gt"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_le",
          "args": [
            "bno_cur_lt",
            "args->agbno",
            "args->maxlen",
            "&i"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "87-97",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "args->mp",
            "args->tp",
            "args->agbp",
            "args->agno",
            "XFS_BTNUM_BNO"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_first",
          "args": [
            "args"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bnew + blen <= ltbno + ltlen"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bnew >= ltbno"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_nominleft",
          "args": [
            "args"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ltbno + ltlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_length"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->len >= args->minlen"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "ltlena",
            "args->maxlen"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ltlen >= args->minlen"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_islastblock",
          "args": [
            "cnt_cur",
            "0"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_islastblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "585-599",
          "snippet": "int\t\t\t\t\t/* 1=is last block, 0=not last block */\nxfs_btree_islastblock(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to check */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* 1=is last block, 0=not last block */\nxfs_btree_islastblock(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to check */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 1"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_near_noentry",
          "args": [
            "args"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent_small",
          "args": [
            "args",
            "cnt_cur",
            "&ltbno",
            "&ltlen",
            "&i"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_small",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1452-1535",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_small(\n\txfs_alloc_arg_t\t*args,\t/* allocation argument structure */\n\txfs_btree_cur_t\t*ccur,\t/* by-size cursor */\n\txfs_agblock_t\t*fbnop,\t/* result block number */\n\txfs_extlen_t\t*flenp,\t/* result length */\n\tint\t\t*stat)\t/* status: 0-freelist, 1-normal/none */\n{\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\n\txfs_extlen_t\tflen;\n\tint\t\ti;\n\n\tif ((error = xfs_btree_decrement(ccur, 0, &i)))\n\t\tgoto error0;\n\tif (i) {\n\t\tif ((error = xfs_alloc_get_rec(ccur, &fbno, &flen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t}\n\t/*\n\t * Nothing in the btree, try the freelist.  Make sure\n\t * to respect minleft even when pulling from the\n\t * freelist.\n\t */\n\telse if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&\n\t\t (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)\n\t\t  > args->minleft)) {\n\t\terror = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (fbno != NULLAGBLOCK) {\n\t\t\txfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,\n\t\t\t\t\t     args->userdata);\n\n\t\t\tif (args->userdata) {\n\t\t\t\txfs_buf_t\t*bp;\n\n\t\t\t\tbp = xfs_btree_get_bufs(args->mp, args->tp,\n\t\t\t\t\targs->agno, fbno, 0);\n\t\t\t\txfs_trans_binval(args->tp, bp);\n\t\t\t}\n\t\t\targs->len = 1;\n\t\t\targs->agbno = fbno;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\t\targs->agbno + args->len <=\n\t\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\t\t\terror0);\n\t\t\targs->wasfromfl = 1;\n\t\t\ttrace_xfs_alloc_small_freelist(args);\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Nothing in the freelist.\n\t\t */\n\t\telse\n\t\t\tflen = 0;\n\t}\n\t/*\n\t * Can't allocate from the freelist for some reason.\n\t */\n\telse {\n\t\tfbno = NULLAGBLOCK;\n\t\tflen = 0;\n\t}\n\t/*\n\t * Can't do the allocation, give up.\n\t */\n\tif (flen < args->minlen) {\n\t\targs->agbno = NULLAGBLOCK;\n\t\ttrace_xfs_alloc_small_notenough(args);\n\t\tflen = 0;\n\t}\n\t*fbnop = fbno;\n\t*flenp = flen;\n\t*stat = 1;\n\ttrace_xfs_alloc_small_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_small_error(args);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_ge",
          "args": [
            "cnt_cur",
            "0",
            "args->maxlen",
            "&i"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_ge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "71-81",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_near(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur_gt;\t/* cursor for bno btree, right side */\n\txfs_btree_cur_t\t*bno_cur_lt;\t/* cursor for bno btree, left side */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for count btree */\n\txfs_agblock_t\tgtbno;\t\t/* start bno of right side entry */\n\txfs_agblock_t\tgtbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tgtdiff;\t\t/* difference to right side entry */\n\txfs_extlen_t\tgtlen;\t\t/* length of right side entry */\n\txfs_extlen_t\tgtlena;\t\t/* aligned ... */\n\txfs_agblock_t\tgtnew;\t\t/* useful start bno of right side */\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* result code, temporary */\n\tint\t\tj;\t\t/* result code, temporary */\n\txfs_agblock_t\tltbno;\t\t/* start bno of left side entry */\n\txfs_agblock_t\tltbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tltdiff;\t\t/* difference to left side entry */\n\txfs_extlen_t\tltlen;\t\t/* length of left side entry */\n\txfs_extlen_t\tltlena;\t\t/* aligned ... */\n\txfs_agblock_t\tltnew;\t\t/* useful start bno of left side */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n#ifdef DEBUG\n\t/*\n\t * Randomly don't execute the first algorithm.\n\t */\n\tint\t\tdofirst;\t/* set to do first algorithm */\n\n\tdofirst = prandom_u32() & 1;\n#endif\n\nrestart:\n\tbno_cur_lt = NULL;\n\tbno_cur_gt = NULL;\n\tltlen = 0;\n\tgtlena = 0;\n\tltlena = 0;\n\n\t/*\n\t * Get a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * See if there are any free extents as big as maxlen.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0, args->maxlen, &i)))\n\t\tgoto error0;\n\t/*\n\t * If none, then pick up the last entry in the tree unless the\n\t * tree is empty.\n\t */\n\tif (!i) {\n\t\tif ((error = xfs_alloc_ag_vextent_small(args, cnt_cur, &ltbno,\n\t\t\t\t&ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (i == 0 || ltlen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\targs->wasfromfl = 0;\n\n\t/*\n\t * First algorithm.\n\t * If the requested extent is large wrt the freespaces available\n\t * in this a.g., then the cursor will be pointing to a btree entry\n\t * near the right edge of the tree.  If it's in the last btree leaf\n\t * block, then we just examine all the entries in that block\n\t * that are big enough, and pick the best one.\n\t * This is written as a while loop so we can break out of it,\n\t * but we never loop back to the top.\n\t */\n\twhile (xfs_btree_islastblock(cnt_cur, 0)) {\n\t\txfs_extlen_t\tbdiff;\n\t\tint\t\tbesti=0;\n\t\txfs_extlen_t\tblen=0;\n\t\txfs_agblock_t\tbnew=0;\n\n#ifdef DEBUG\n\t\tif (dofirst)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Start from the entry that lookup found, sequence through\n\t\t * all larger free blocks.  If we're actually pointing at a\n\t\t * record smaller than maxlen, go to the start of this block,\n\t\t * and skip all those smaller than minlen.\n\t\t */\n\t\tif (ltlen || args->alignment > 1) {\n\t\t\tcnt_cur->bc_ptrs[0] = 1;\n\t\t\tdo {\n\t\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno,\n\t\t\t\t\t\t&ltlen, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\t\tif (ltlen >= args->minlen)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((error = xfs_btree_increment(cnt_cur, 0, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t} while (i);\n\t\t\tASSERT(ltlen >= args->minlen);\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = cnt_cur->bc_ptrs[0];\n\t\tfor (j = 1, blen = 0, bdiff = 0;\n\t\t     !error && j && (blen < args->maxlen || bdiff > 0);\n\t\t     error = xfs_btree_increment(cnt_cur, 0, &j)) {\n\t\t\t/*\n\t\t\t * For each entry, decide if it's better than\n\t\t\t * the previous best entry.\n\t\t\t */\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena < args->minlen)\n\t\t\t\tcontinue;\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tASSERT(args->len >= args->minlen);\n\t\t\tif (args->len < blen)\n\t\t\t\tcontinue;\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\t\t\tif (ltnew != NULLAGBLOCK &&\n\t\t\t    (args->len > blen || ltdiff < bdiff)) {\n\t\t\t\tbdiff = ltdiff;\n\t\t\t\tbnew = ltnew;\n\t\t\t\tblen = args->len;\n\t\t\t\tbesti = cnt_cur->bc_ptrs[0];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * It didn't work.  We COULD be in a case where\n\t\t * there's a good record somewhere, so try again.\n\t\t */\n\t\tif (blen == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Point at the best entry, and retrieve it again.\n\t\t */\n\t\tcnt_cur->bc_ptrs[0] = besti;\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tASSERT(ltbno + ltlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\t\targs->len = blen;\n\t\tif (!xfs_alloc_fix_minleft(args)) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\t\treturn 0;\n\t\t}\n\t\tblen = args->len;\n\t\t/*\n\t\t * We are allocating starting at bnew for blen blocks.\n\t\t */\n\t\targs->agbno = bnew;\n\t\tASSERT(bnew >= ltbno);\n\t\tASSERT(bnew + blen <= ltbno + ltlen);\n\t\t/*\n\t\t * Set up a cursor for the by-bno tree.\n\t\t */\n\t\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\targs->agbp, args->agno, XFS_BTNUM_BNO);\n\t\t/*\n\t\t * Fix up the btree entries.\n\t\t */\n\t\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno,\n\t\t\t\tltlen, bnew, blen, XFSA_FIXUP_CNT_OK)))\n\t\t\tgoto error0;\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\n\t\ttrace_xfs_alloc_near_first(args);\n\t\treturn 0;\n\t}\n\t/*\n\t * Second algorithm.\n\t * Search in the by-bno tree to the left and to the right\n\t * simultaneously, until in each case we find a space big enough,\n\t * or run into the edge of the tree.  When we run into the edge,\n\t * we deallocate that cursor.\n\t * If both searches succeed, we compare the two spaces and pick\n\t * the better one.\n\t * With alignment, it's possible for both to fail; the upper\n\t * level algorithm that picks allocation groups for allocations\n\t * is not supposed to do this.\n\t */\n\t/*\n\t * Allocate and initialize the cursor for the leftward search.\n\t */\n\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\t/*\n\t * Lookup <= bno to find the leftward search's starting point.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur_lt, args->agbno, args->maxlen, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * Didn't find anything; use this cursor for the rightward\n\t\t * search.\n\t\t */\n\t\tbno_cur_gt = bno_cur_lt;\n\t\tbno_cur_lt = NULL;\n\t}\n\t/*\n\t * Found something.  Duplicate the cursor for the rightward search.\n\t */\n\telse if ((error = xfs_btree_dup_cursor(bno_cur_lt, &bno_cur_gt)))\n\t\tgoto error0;\n\t/*\n\t * Increment the cursor, so we will point at the entry just right\n\t * of the leftward entry if any, or to the leftmost entry.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * It failed, there are no rightward entries.\n\t\t */\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_NOERROR);\n\t\tbno_cur_gt = NULL;\n\t}\n\t/*\n\t * Loop going left with the leftward cursor, right with the\n\t * rightward cursor, until either both directions give up or\n\t * we find an entry at least as big as minlen.\n\t */\n\tdo {\n\t\tif (bno_cur_lt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_lt, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_decrement(bno_cur_lt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_lt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_lt = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bno_cur_gt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_gt, &gtbno, &gtlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, gtbno, gtlen,\n\t\t\t\t\t\t  &gtbnoa, &gtlena);\n\t\t\tif (gtlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_gt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_gt = NULL;\n\t\t\t}\n\t\t}\n\t} while (bno_cur_lt || bno_cur_gt);\n\n\t/*\n\t * Got both cursors still active, need to find better entry.\n\t */\n\tif (bno_cur_lt && bno_cur_gt) {\n\t\tif (ltlena >= args->minlen) {\n\t\t\t/*\n\t\t\t * Left side is good, look for a right side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_lt, &bno_cur_gt,\n\t\t\t\t\t\tltdiff, &gtbno, &gtlen,\n\t\t\t\t\t\t&gtbnoa, &gtlena,\n\t\t\t\t\t\t0 /* search right */);\n\t\t} else {\n\t\t\tASSERT(gtlena >= args->minlen);\n\n\t\t\t/*\n\t\t\t * Right side is good, look for a left side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(gtlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tgtdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, gtbnoa,\n\t\t\t\tgtlena, &gtnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_gt, &bno_cur_lt,\n\t\t\t\t\t\tgtdiff, &ltbno, &ltlen,\n\t\t\t\t\t\t&ltbnoa, &ltlena,\n\t\t\t\t\t\t1 /* search left */);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we couldn't get anything, give up.\n\t */\n\tif (bno_cur_lt == NULL && bno_cur_gt == NULL) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\t\tif (!forced++) {\n\t\t\ttrace_xfs_alloc_near_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\ttrace_xfs_alloc_size_neither(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point we have selected a freespace entry, either to the\n\t * left or to the right.  If it's on the right, copy all the\n\t * useful variables to the \"left\" set so we only have one\n\t * copy of this code.\n\t */\n\tif (bno_cur_gt) {\n\t\tbno_cur_lt = bno_cur_gt;\n\t\tbno_cur_gt = NULL;\n\t\tltbno = gtbno;\n\t\tltbnoa = gtbnoa;\n\t\tltlen = gtlen;\n\t\tltlena = gtlena;\n\t\tj = 1;\n\t} else\n\t\tj = 0;\n\n\t/*\n\t * Fix up the length and compute the useful address.\n\t */\n\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args)) {\n\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\treturn 0;\n\t}\n\trlen = args->len;\n\t(void)xfs_alloc_compute_diff(args->agbno, rlen, args->alignment,\n\t\t\t\t     args->userdata, ltbnoa, ltlena, &ltnew);\n\tASSERT(ltnew >= ltbno);\n\tASSERT(ltnew + rlen <= ltbnoa + ltlena);\n\tASSERT(ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\targs->agbno = ltnew;\n\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno, ltlen,\n\t\t\tltnew, rlen, XFSA_FIXUP_BNO_OK)))\n\t\tgoto error0;\n\n\tif (j)\n\t\ttrace_xfs_alloc_near_greater(args);\n\telse\n\t\ttrace_xfs_alloc_near_lesser(args);\n\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\treturn 0;\n\n error0:\n\ttrace_xfs_alloc_near_error(args);\n\tif (cnt_cur != NULL)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur_lt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_ERROR);\n\tif (bno_cur_gt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_find_best_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "758-841",
    "snippet": "STATIC int\nxfs_alloc_find_best_extent(\n\tstruct xfs_alloc_arg\t*args,\t/* allocation argument structure */\n\tstruct xfs_btree_cur\t**gcur,\t/* good cursor */\n\tstruct xfs_btree_cur\t**scur,\t/* searching cursor */\n\txfs_agblock_t\t\tgdiff,\t/* difference for search comparison */\n\txfs_agblock_t\t\t*sbno,\t/* extent found by search */\n\txfs_extlen_t\t\t*slen,\t/* extent length */\n\txfs_agblock_t\t\t*sbnoa,\t/* aligned extent found by search */\n\txfs_extlen_t\t\t*slena,\t/* aligned extent length */\n\tint\t\t\tdir)\t/* 0 = search right, 1 = search left */\n{\n\txfs_agblock_t\t\tnew;\n\txfs_agblock_t\t\tsdiff;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/* The good extent is perfect, no need to  search. */\n\tif (!gdiff)\n\t\tgoto out_use_good;\n\n\t/*\n\t * Look until we find a better one, run out of space or run off the end.\n\t */\n\tdo {\n\t\terror = xfs_alloc_get_rec(*scur, sbno, slen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\txfs_alloc_compute_aligned(args, *sbno, *slen, sbnoa, slena);\n\n\t\t/*\n\t\t * The good extent is closer than this one.\n\t\t */\n\t\tif (!dir) {\n\t\t\tif (*sbnoa >= args->agbno + gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t} else {\n\t\t\tif (*sbnoa <= args->agbno - gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t}\n\n\t\t/*\n\t\t * Same distance, compare length and pick the best.\n\t\t */\n\t\tif (*slena >= args->minlen) {\n\t\t\targs->len = XFS_EXTLEN_MIN(*slena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\n\t\t\tsdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\t\t\t       args->alignment,\n\t\t\t\t\t\t       args->userdata, *sbnoa,\n\t\t\t\t\t\t       *slena, &new);\n\n\t\t\t/*\n\t\t\t * Choose closer size and invalidate other cursor.\n\t\t\t */\n\t\t\tif (sdiff < gdiff)\n\t\t\t\tgoto out_use_search;\n\t\t\tgoto out_use_good;\n\t\t}\n\n\t\tif (!dir)\n\t\t\terror = xfs_btree_increment(*scur, 0, &i);\n\t\telse\n\t\t\terror = xfs_btree_decrement(*scur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t} while (i);\n\nout_use_good:\n\txfs_btree_del_cursor(*scur, XFS_BTREE_NOERROR);\n\t*scur = NULL;\n\treturn 0;\n\nout_use_search:\n\txfs_btree_del_cursor(*gcur, XFS_BTREE_NOERROR);\n\t*gcur = NULL;\n\treturn 0;\n\nerror0:\n\t/* caller invalidates cursors */\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "*gcur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "*scur",
            "0",
            "&i"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "*scur",
            "0",
            "&i"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_diff",
          "args": [
            "args->agbno",
            "args->len",
            "args->alignment",
            "args->userdata",
            "*sbnoa",
            "*slena",
            "&new"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "172-234",
          "snippet": "STATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_len",
          "args": [
            "args"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "242-268",
          "snippet": "STATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "*slena",
            "args->maxlen"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_compute_aligned",
          "args": [
            "args",
            "*sbno",
            "*slen",
            "sbnoa",
            "slena"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_compute_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "142-166",
          "snippet": "STATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "*scur",
            "sbno",
            "slen",
            "&i"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\nxfs_alloc_find_best_extent(\n\tstruct xfs_alloc_arg\t*args,\t/* allocation argument structure */\n\tstruct xfs_btree_cur\t**gcur,\t/* good cursor */\n\tstruct xfs_btree_cur\t**scur,\t/* searching cursor */\n\txfs_agblock_t\t\tgdiff,\t/* difference for search comparison */\n\txfs_agblock_t\t\t*sbno,\t/* extent found by search */\n\txfs_extlen_t\t\t*slen,\t/* extent length */\n\txfs_agblock_t\t\t*sbnoa,\t/* aligned extent found by search */\n\txfs_extlen_t\t\t*slena,\t/* aligned extent length */\n\tint\t\t\tdir)\t/* 0 = search right, 1 = search left */\n{\n\txfs_agblock_t\t\tnew;\n\txfs_agblock_t\t\tsdiff;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/* The good extent is perfect, no need to  search. */\n\tif (!gdiff)\n\t\tgoto out_use_good;\n\n\t/*\n\t * Look until we find a better one, run out of space or run off the end.\n\t */\n\tdo {\n\t\terror = xfs_alloc_get_rec(*scur, sbno, slen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\txfs_alloc_compute_aligned(args, *sbno, *slen, sbnoa, slena);\n\n\t\t/*\n\t\t * The good extent is closer than this one.\n\t\t */\n\t\tif (!dir) {\n\t\t\tif (*sbnoa >= args->agbno + gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t} else {\n\t\t\tif (*sbnoa <= args->agbno - gdiff)\n\t\t\t\tgoto out_use_good;\n\t\t}\n\n\t\t/*\n\t\t * Same distance, compare length and pick the best.\n\t\t */\n\t\tif (*slena >= args->minlen) {\n\t\t\targs->len = XFS_EXTLEN_MIN(*slena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\n\t\t\tsdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\t\t\t       args->alignment,\n\t\t\t\t\t\t       args->userdata, *sbnoa,\n\t\t\t\t\t\t       *slena, &new);\n\n\t\t\t/*\n\t\t\t * Choose closer size and invalidate other cursor.\n\t\t\t */\n\t\t\tif (sdiff < gdiff)\n\t\t\t\tgoto out_use_search;\n\t\t\tgoto out_use_good;\n\t\t}\n\n\t\tif (!dir)\n\t\t\terror = xfs_btree_increment(*scur, 0, &i);\n\t\telse\n\t\t\terror = xfs_btree_decrement(*scur, 0, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t} while (i);\n\nout_use_good:\n\txfs_btree_del_cursor(*scur, XFS_BTREE_NOERROR);\n\t*scur = NULL;\n\treturn 0;\n\nout_use_search:\n\txfs_btree_del_cursor(*gcur, XFS_BTREE_NOERROR);\n\t*gcur = NULL;\n\treturn 0;\n\nerror0:\n\t/* caller invalidates cursors */\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_ag_vextent_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "646-752",
    "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_exact(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;/* by block-number btree cursor */\n\txfs_btree_cur_t\t*cnt_cur;/* by count btree cursor */\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\t/* start block of found extent */\n\txfs_extlen_t\tflen;\t/* length of found extent */\n\txfs_agblock_t\ttbno;\t/* start block of trimmed extent */\n\txfs_extlen_t\ttlen;\t/* length of trimmed extent */\n\txfs_agblock_t\ttend;\t/* end block of trimmed extent */\n\tint\t\ti;\t/* success/failure of operation */\n\n\tASSERT(args->alignment == 1);\n\n\t/*\n\t * Allocate/initialize a cursor for the by-number freespace btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\t  args->agno, XFS_BTNUM_BNO);\n\n\t/*\n\t * Lookup bno and minlen in the btree (minlen is irrelevant, really).\n\t * Look for the closest free block <= bno, it must contain bno\n\t * if any free block does.\n\t */\n\terror = xfs_alloc_lookup_le(bno_cur, args->agbno, args->minlen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (!i)\n\t\tgoto not_found;\n\n\t/*\n\t * Grab the freespace record.\n\t */\n\terror = xfs_alloc_get_rec(bno_cur, &fbno, &flen, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\tASSERT(fbno <= args->agbno);\n\n\t/*\n\t * Check for overlapping busy extents.\n\t */\n\txfs_extent_busy_trim(args, fbno, flen, &tbno, &tlen);\n\n\t/*\n\t * Give up if the start of the extent is busy, or the freespace isn't\n\t * long enough for the minimum request.\n\t */\n\tif (tbno > args->agbno)\n\t\tgoto not_found;\n\tif (tlen < args->minlen)\n\t\tgoto not_found;\n\ttend = tbno + tlen;\n\tif (tend < args->agbno + args->minlen)\n\t\tgoto not_found;\n\n\t/*\n\t * End of extent will be smaller of the freespace end and the\n\t * maximal requested end.\n\t *\n\t * Fix the length according to mod and prod if given.\n\t */\n\targs->len = XFS_AGBLOCK_MIN(tend, args->agbno + args->maxlen)\n\t\t\t\t\t\t- args->agbno;\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto not_found;\n\n\tASSERT(args->agbno + args->len <= tend);\n\n\t/*\n\t * We are allocating agbno for args->len\n\t * Allocate/initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tASSERT(args->agbno + args->len <=\n\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\terror = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen, args->agbno,\n\t\t\t\t      args->len, XFSA_FIXUP_BNO_OK);\n\tif (error) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\t\tgoto error0;\n\t}\n\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\targs->wasfromfl = 0;\n\ttrace_xfs_alloc_exact_done(args);\n\treturn 0;\n\nnot_found:\n\t/* Didn't find it, return null. */\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\targs->agbno = NULLAGBLOCK;\n\ttrace_xfs_alloc_exact_notfound(args);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\ttrace_xfs_alloc_exact_error(args);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tXFSA_FIXUP_BNO_OK\t1"
    ],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_alloc_exact_error",
          "args": [
            "args"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "bno_cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_exact_notfound",
          "args": [
            "args"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_exact_done",
          "args": [
            "args"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fixup_trees",
          "args": [
            "cnt_cur",
            "bno_cur",
            "fbno",
            "flen",
            "args->agbno",
            "args->len",
            "XFSA_FIXUP_BNO_OK"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fixup_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "302-438",
          "snippet": "STATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2",
            "#define\tXFSA_FIXUP_BNO_OK\t1"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->agbno + args->len <=\n\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "XFS_BUF_TO_AGF(args->agbp)->agf_length"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_init_cursor",
          "args": [
            "args->mp",
            "args->tp",
            "args->agbp",
            "args->agno",
            "XFS_BTNUM_CNT"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "452-487",
          "snippet": "struct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_allocbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_alloc_rec_t),\n\t.key_len\t\t= sizeof(xfs_alloc_key_t),\n\n\t.dup_cursor\t\t= xfs_allocbt_dup_cursor,\n\t.set_root\t\t= xfs_allocbt_set_root,\n\t.alloc_block\t\t= xfs_allocbt_alloc_block,\n\t.free_block\t\t= xfs_allocbt_free_block,\n\t.update_lastrec\t\t= xfs_allocbt_update_lastrec,\n\t.get_minrecs\t\t= xfs_allocbt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_allocbt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_allocbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_allocbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_allocbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_allocbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_allocbt_key_diff,\n\t.buf_ops\t\t= &xfs_allocbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_allocbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_allocbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t/* new alloc btree cursor */\nxfs_allocbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agf structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* btree identifier */\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\tcur->bc_ops = &xfs_allocbt_ops;\n\n\tif (btnum == XFS_BTNUM_CNT) {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);\n\t\tcur->bc_flags = XFS_BTREE_LASTREC_UPDATE;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);\n\t}\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->agbno + args->len <= tend"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_minleft",
          "args": [
            "args"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_minleft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "274-293",
          "snippet": "STATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\n\nSTATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_fix_len",
          "args": [
            "args"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_fix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "242-268",
          "snippet": "STATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGBLOCK_MIN",
          "args": [
            "tend",
            "args->agbno + args->maxlen"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_trim",
          "args": [
            "args",
            "fbno",
            "flen",
            "&tbno",
            "&tlen"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "349-536",
          "snippet": "void\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fbno <= args->agbno"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "bno_cur",
            "&fbno",
            "&flen",
            "&i"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_le",
          "args": [
            "bno_cur",
            "args->agbno",
            "args->minlen",
            "&i"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "87-97",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->alignment == 1"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_exact(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;/* by block-number btree cursor */\n\txfs_btree_cur_t\t*cnt_cur;/* by count btree cursor */\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\t/* start block of found extent */\n\txfs_extlen_t\tflen;\t/* length of found extent */\n\txfs_agblock_t\ttbno;\t/* start block of trimmed extent */\n\txfs_extlen_t\ttlen;\t/* length of trimmed extent */\n\txfs_agblock_t\ttend;\t/* end block of trimmed extent */\n\tint\t\ti;\t/* success/failure of operation */\n\n\tASSERT(args->alignment == 1);\n\n\t/*\n\t * Allocate/initialize a cursor for the by-number freespace btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\t  args->agno, XFS_BTNUM_BNO);\n\n\t/*\n\t * Lookup bno and minlen in the btree (minlen is irrelevant, really).\n\t * Look for the closest free block <= bno, it must contain bno\n\t * if any free block does.\n\t */\n\terror = xfs_alloc_lookup_le(bno_cur, args->agbno, args->minlen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (!i)\n\t\tgoto not_found;\n\n\t/*\n\t * Grab the freespace record.\n\t */\n\terror = xfs_alloc_get_rec(bno_cur, &fbno, &flen, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\tASSERT(fbno <= args->agbno);\n\n\t/*\n\t * Check for overlapping busy extents.\n\t */\n\txfs_extent_busy_trim(args, fbno, flen, &tbno, &tlen);\n\n\t/*\n\t * Give up if the start of the extent is busy, or the freespace isn't\n\t * long enough for the minimum request.\n\t */\n\tif (tbno > args->agbno)\n\t\tgoto not_found;\n\tif (tlen < args->minlen)\n\t\tgoto not_found;\n\ttend = tbno + tlen;\n\tif (tend < args->agbno + args->minlen)\n\t\tgoto not_found;\n\n\t/*\n\t * End of extent will be smaller of the freespace end and the\n\t * maximal requested end.\n\t *\n\t * Fix the length according to mod and prod if given.\n\t */\n\targs->len = XFS_AGBLOCK_MIN(tend, args->agbno + args->maxlen)\n\t\t\t\t\t\t- args->agbno;\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto not_found;\n\n\tASSERT(args->agbno + args->len <= tend);\n\n\t/*\n\t * We are allocating agbno for args->len\n\t * Allocate/initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tASSERT(args->agbno + args->len <=\n\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\terror = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen, args->agbno,\n\t\t\t\t      args->len, XFSA_FIXUP_BNO_OK);\n\tif (error) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\t\tgoto error0;\n\t}\n\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\targs->wasfromfl = 0;\n\ttrace_xfs_alloc_exact_done(args);\n\treturn 0;\n\nnot_found:\n\t/* Didn't find it, return null. */\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\targs->agbno = NULLAGBLOCK;\n\ttrace_xfs_alloc_exact_notfound(args);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\ttrace_xfs_alloc_exact_error(args);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_ag_vextent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "579-638",
    "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent(\n\txfs_alloc_arg_t\t*args)\t/* argument structure for allocation */\n{\n\tint\t\terror=0;\n\n\tASSERT(args->minlen > 0);\n\tASSERT(args->maxlen > 0);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->mod < args->prod);\n\tASSERT(args->alignment > 0);\n\t/*\n\t * Branch to correct routine based on the type.\n\t */\n\targs->wasfromfl = 0;\n\tswitch (args->type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\t\terror = xfs_alloc_ag_vextent_size(args);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_alloc_ag_vextent_near(args);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_alloc_ag_vextent_exact(args);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\n\tif (error || args->agbno == NULLAGBLOCK)\n\t\treturn error;\n\n\tASSERT(args->len >= args->minlen);\n\tASSERT(args->len <= args->maxlen);\n\tASSERT(!args->wasfromfl || !args->isfl);\n\tASSERT(args->agbno % args->alignment == 0);\n\n\tif (!args->wasfromfl) {\n\t\terror = xfs_alloc_update_counters(args->tp, args->pag,\n\t\t\t\t\t\t  args->agbp,\n\t\t\t\t\t\t  -((long)(args->len)));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(!xfs_extent_busy_search(args->mp, args->agno,\n\t\t\t\t\t      args->agbno, args->len));\n\t}\n\n\tif (!args->isfl) {\n\t\txfs_trans_mod_sb(args->tp, args->wasdel ?\n\t\t\t\t XFS_TRANS_SB_RES_FDBLOCKS :\n\t\t\t\t XFS_TRANS_SB_FDBLOCKS,\n\t\t\t\t -((long)(args->len)));\n\t}\n\n\tXFS_STATS_INC(xs_allocx);\n\tXFS_STATS_ADD(xs_allocb, args->len);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_allocb",
            "args->len"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_allocx"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "args->tp",
            "args->wasdel ?\n\t\t\t\t XFS_TRANS_SB_RES_FDBLOCKS :\n\t\t\t\t XFS_TRANS_SB_FDBLOCKS",
            "-((long)(args->len))"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_extent_busy_search(args->mp, args->agno,\n\t\t\t\t\t      args->agbno, args->len)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_search",
          "args": [
            "args->mp",
            "args->agno",
            "args->agbno",
            "args->len"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "104-143",
          "snippet": "int\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_update_counters",
          "args": [
            "args->tp",
            "args->pag",
            "args->agbp",
            "-((long)(args->len))"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_update_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "546-565",
          "snippet": "STATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->agbno % args->alignment == 0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!args->wasfromfl || !args->isfl"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->len <= args->maxlen"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->len >= args->minlen"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent_exact",
          "args": [
            "args"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "646-752",
          "snippet": "STATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_exact(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;/* by block-number btree cursor */\n\txfs_btree_cur_t\t*cnt_cur;/* by count btree cursor */\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\t/* start block of found extent */\n\txfs_extlen_t\tflen;\t/* length of found extent */\n\txfs_agblock_t\ttbno;\t/* start block of trimmed extent */\n\txfs_extlen_t\ttlen;\t/* length of trimmed extent */\n\txfs_agblock_t\ttend;\t/* end block of trimmed extent */\n\tint\t\ti;\t/* success/failure of operation */\n\n\tASSERT(args->alignment == 1);\n\n\t/*\n\t * Allocate/initialize a cursor for the by-number freespace btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\t  args->agno, XFS_BTNUM_BNO);\n\n\t/*\n\t * Lookup bno and minlen in the btree (minlen is irrelevant, really).\n\t * Look for the closest free block <= bno, it must contain bno\n\t * if any free block does.\n\t */\n\terror = xfs_alloc_lookup_le(bno_cur, args->agbno, args->minlen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (!i)\n\t\tgoto not_found;\n\n\t/*\n\t * Grab the freespace record.\n\t */\n\terror = xfs_alloc_get_rec(bno_cur, &fbno, &flen, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\tASSERT(fbno <= args->agbno);\n\n\t/*\n\t * Check for overlapping busy extents.\n\t */\n\txfs_extent_busy_trim(args, fbno, flen, &tbno, &tlen);\n\n\t/*\n\t * Give up if the start of the extent is busy, or the freespace isn't\n\t * long enough for the minimum request.\n\t */\n\tif (tbno > args->agbno)\n\t\tgoto not_found;\n\tif (tlen < args->minlen)\n\t\tgoto not_found;\n\ttend = tbno + tlen;\n\tif (tend < args->agbno + args->minlen)\n\t\tgoto not_found;\n\n\t/*\n\t * End of extent will be smaller of the freespace end and the\n\t * maximal requested end.\n\t *\n\t * Fix the length according to mod and prod if given.\n\t */\n\targs->len = XFS_AGBLOCK_MIN(tend, args->agbno + args->maxlen)\n\t\t\t\t\t\t- args->agbno;\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto not_found;\n\n\tASSERT(args->agbno + args->len <= tend);\n\n\t/*\n\t * We are allocating agbno for args->len\n\t * Allocate/initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tASSERT(args->agbno + args->len <=\n\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\terror = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen, args->agbno,\n\t\t\t\t      args->len, XFSA_FIXUP_BNO_OK);\n\tif (error) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\t\tgoto error0;\n\t}\n\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\targs->wasfromfl = 0;\n\ttrace_xfs_alloc_exact_done(args);\n\treturn 0;\n\nnot_found:\n\t/* Didn't find it, return null. */\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\targs->agbno = NULLAGBLOCK;\n\ttrace_xfs_alloc_exact_notfound(args);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\ttrace_xfs_alloc_exact_error(args);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_BNO_OK\t1"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent_exact(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;/* by block-number btree cursor */\n\txfs_btree_cur_t\t*cnt_cur;/* by count btree cursor */\n\tint\t\terror;\n\txfs_agblock_t\tfbno;\t/* start block of found extent */\n\txfs_extlen_t\tflen;\t/* length of found extent */\n\txfs_agblock_t\ttbno;\t/* start block of trimmed extent */\n\txfs_extlen_t\ttlen;\t/* length of trimmed extent */\n\txfs_agblock_t\ttend;\t/* end block of trimmed extent */\n\tint\t\ti;\t/* success/failure of operation */\n\n\tASSERT(args->alignment == 1);\n\n\t/*\n\t * Allocate/initialize a cursor for the by-number freespace btree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\t\t\t\t  args->agno, XFS_BTNUM_BNO);\n\n\t/*\n\t * Lookup bno and minlen in the btree (minlen is irrelevant, really).\n\t * Look for the closest free block <= bno, it must contain bno\n\t * if any free block does.\n\t */\n\terror = xfs_alloc_lookup_le(bno_cur, args->agbno, args->minlen, &i);\n\tif (error)\n\t\tgoto error0;\n\tif (!i)\n\t\tgoto not_found;\n\n\t/*\n\t * Grab the freespace record.\n\t */\n\terror = xfs_alloc_get_rec(bno_cur, &fbno, &flen, &i);\n\tif (error)\n\t\tgoto error0;\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\tASSERT(fbno <= args->agbno);\n\n\t/*\n\t * Check for overlapping busy extents.\n\t */\n\txfs_extent_busy_trim(args, fbno, flen, &tbno, &tlen);\n\n\t/*\n\t * Give up if the start of the extent is busy, or the freespace isn't\n\t * long enough for the minimum request.\n\t */\n\tif (tbno > args->agbno)\n\t\tgoto not_found;\n\tif (tlen < args->minlen)\n\t\tgoto not_found;\n\ttend = tbno + tlen;\n\tif (tend < args->agbno + args->minlen)\n\t\tgoto not_found;\n\n\t/*\n\t * End of extent will be smaller of the freespace end and the\n\t * maximal requested end.\n\t *\n\t * Fix the length according to mod and prod if given.\n\t */\n\targs->len = XFS_AGBLOCK_MIN(tend, args->agbno + args->maxlen)\n\t\t\t\t\t\t- args->agbno;\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto not_found;\n\n\tASSERT(args->agbno + args->len <= tend);\n\n\t/*\n\t * We are allocating agbno for args->len\n\t * Allocate/initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tASSERT(args->agbno + args->len <=\n\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\terror = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen, args->agbno,\n\t\t\t\t      args->len, XFSA_FIXUP_BNO_OK);\n\tif (error) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\t\tgoto error0;\n\t}\n\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\targs->wasfromfl = 0;\n\ttrace_xfs_alloc_exact_done(args);\n\treturn 0;\n\nnot_found:\n\t/* Didn't find it, return null. */\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\targs->agbno = NULLAGBLOCK;\n\ttrace_xfs_alloc_exact_notfound(args);\n\treturn 0;\n\nerror0:\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\ttrace_xfs_alloc_exact_error(args);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent_near",
          "args": [
            "args"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "849-1238",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_near(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur_gt;\t/* cursor for bno btree, right side */\n\txfs_btree_cur_t\t*bno_cur_lt;\t/* cursor for bno btree, left side */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for count btree */\n\txfs_agblock_t\tgtbno;\t\t/* start bno of right side entry */\n\txfs_agblock_t\tgtbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tgtdiff;\t\t/* difference to right side entry */\n\txfs_extlen_t\tgtlen;\t\t/* length of right side entry */\n\txfs_extlen_t\tgtlena;\t\t/* aligned ... */\n\txfs_agblock_t\tgtnew;\t\t/* useful start bno of right side */\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* result code, temporary */\n\tint\t\tj;\t\t/* result code, temporary */\n\txfs_agblock_t\tltbno;\t\t/* start bno of left side entry */\n\txfs_agblock_t\tltbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tltdiff;\t\t/* difference to left side entry */\n\txfs_extlen_t\tltlen;\t\t/* length of left side entry */\n\txfs_extlen_t\tltlena;\t\t/* aligned ... */\n\txfs_agblock_t\tltnew;\t\t/* useful start bno of left side */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n#ifdef DEBUG\n\t/*\n\t * Randomly don't execute the first algorithm.\n\t */\n\tint\t\tdofirst;\t/* set to do first algorithm */\n\n\tdofirst = prandom_u32() & 1;\n#endif\n\nrestart:\n\tbno_cur_lt = NULL;\n\tbno_cur_gt = NULL;\n\tltlen = 0;\n\tgtlena = 0;\n\tltlena = 0;\n\n\t/*\n\t * Get a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * See if there are any free extents as big as maxlen.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0, args->maxlen, &i)))\n\t\tgoto error0;\n\t/*\n\t * If none, then pick up the last entry in the tree unless the\n\t * tree is empty.\n\t */\n\tif (!i) {\n\t\tif ((error = xfs_alloc_ag_vextent_small(args, cnt_cur, &ltbno,\n\t\t\t\t&ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (i == 0 || ltlen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\targs->wasfromfl = 0;\n\n\t/*\n\t * First algorithm.\n\t * If the requested extent is large wrt the freespaces available\n\t * in this a.g., then the cursor will be pointing to a btree entry\n\t * near the right edge of the tree.  If it's in the last btree leaf\n\t * block, then we just examine all the entries in that block\n\t * that are big enough, and pick the best one.\n\t * This is written as a while loop so we can break out of it,\n\t * but we never loop back to the top.\n\t */\n\twhile (xfs_btree_islastblock(cnt_cur, 0)) {\n\t\txfs_extlen_t\tbdiff;\n\t\tint\t\tbesti=0;\n\t\txfs_extlen_t\tblen=0;\n\t\txfs_agblock_t\tbnew=0;\n\n#ifdef DEBUG\n\t\tif (dofirst)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Start from the entry that lookup found, sequence through\n\t\t * all larger free blocks.  If we're actually pointing at a\n\t\t * record smaller than maxlen, go to the start of this block,\n\t\t * and skip all those smaller than minlen.\n\t\t */\n\t\tif (ltlen || args->alignment > 1) {\n\t\t\tcnt_cur->bc_ptrs[0] = 1;\n\t\t\tdo {\n\t\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno,\n\t\t\t\t\t\t&ltlen, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\t\tif (ltlen >= args->minlen)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((error = xfs_btree_increment(cnt_cur, 0, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t} while (i);\n\t\t\tASSERT(ltlen >= args->minlen);\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = cnt_cur->bc_ptrs[0];\n\t\tfor (j = 1, blen = 0, bdiff = 0;\n\t\t     !error && j && (blen < args->maxlen || bdiff > 0);\n\t\t     error = xfs_btree_increment(cnt_cur, 0, &j)) {\n\t\t\t/*\n\t\t\t * For each entry, decide if it's better than\n\t\t\t * the previous best entry.\n\t\t\t */\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena < args->minlen)\n\t\t\t\tcontinue;\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tASSERT(args->len >= args->minlen);\n\t\t\tif (args->len < blen)\n\t\t\t\tcontinue;\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\t\t\tif (ltnew != NULLAGBLOCK &&\n\t\t\t    (args->len > blen || ltdiff < bdiff)) {\n\t\t\t\tbdiff = ltdiff;\n\t\t\t\tbnew = ltnew;\n\t\t\t\tblen = args->len;\n\t\t\t\tbesti = cnt_cur->bc_ptrs[0];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * It didn't work.  We COULD be in a case where\n\t\t * there's a good record somewhere, so try again.\n\t\t */\n\t\tif (blen == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Point at the best entry, and retrieve it again.\n\t\t */\n\t\tcnt_cur->bc_ptrs[0] = besti;\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tASSERT(ltbno + ltlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\t\targs->len = blen;\n\t\tif (!xfs_alloc_fix_minleft(args)) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\t\treturn 0;\n\t\t}\n\t\tblen = args->len;\n\t\t/*\n\t\t * We are allocating starting at bnew for blen blocks.\n\t\t */\n\t\targs->agbno = bnew;\n\t\tASSERT(bnew >= ltbno);\n\t\tASSERT(bnew + blen <= ltbno + ltlen);\n\t\t/*\n\t\t * Set up a cursor for the by-bno tree.\n\t\t */\n\t\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\targs->agbp, args->agno, XFS_BTNUM_BNO);\n\t\t/*\n\t\t * Fix up the btree entries.\n\t\t */\n\t\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno,\n\t\t\t\tltlen, bnew, blen, XFSA_FIXUP_CNT_OK)))\n\t\t\tgoto error0;\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\n\t\ttrace_xfs_alloc_near_first(args);\n\t\treturn 0;\n\t}\n\t/*\n\t * Second algorithm.\n\t * Search in the by-bno tree to the left and to the right\n\t * simultaneously, until in each case we find a space big enough,\n\t * or run into the edge of the tree.  When we run into the edge,\n\t * we deallocate that cursor.\n\t * If both searches succeed, we compare the two spaces and pick\n\t * the better one.\n\t * With alignment, it's possible for both to fail; the upper\n\t * level algorithm that picks allocation groups for allocations\n\t * is not supposed to do this.\n\t */\n\t/*\n\t * Allocate and initialize the cursor for the leftward search.\n\t */\n\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\t/*\n\t * Lookup <= bno to find the leftward search's starting point.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur_lt, args->agbno, args->maxlen, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * Didn't find anything; use this cursor for the rightward\n\t\t * search.\n\t\t */\n\t\tbno_cur_gt = bno_cur_lt;\n\t\tbno_cur_lt = NULL;\n\t}\n\t/*\n\t * Found something.  Duplicate the cursor for the rightward search.\n\t */\n\telse if ((error = xfs_btree_dup_cursor(bno_cur_lt, &bno_cur_gt)))\n\t\tgoto error0;\n\t/*\n\t * Increment the cursor, so we will point at the entry just right\n\t * of the leftward entry if any, or to the leftmost entry.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * It failed, there are no rightward entries.\n\t\t */\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_NOERROR);\n\t\tbno_cur_gt = NULL;\n\t}\n\t/*\n\t * Loop going left with the leftward cursor, right with the\n\t * rightward cursor, until either both directions give up or\n\t * we find an entry at least as big as minlen.\n\t */\n\tdo {\n\t\tif (bno_cur_lt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_lt, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_decrement(bno_cur_lt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_lt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_lt = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bno_cur_gt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_gt, &gtbno, &gtlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, gtbno, gtlen,\n\t\t\t\t\t\t  &gtbnoa, &gtlena);\n\t\t\tif (gtlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_gt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_gt = NULL;\n\t\t\t}\n\t\t}\n\t} while (bno_cur_lt || bno_cur_gt);\n\n\t/*\n\t * Got both cursors still active, need to find better entry.\n\t */\n\tif (bno_cur_lt && bno_cur_gt) {\n\t\tif (ltlena >= args->minlen) {\n\t\t\t/*\n\t\t\t * Left side is good, look for a right side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_lt, &bno_cur_gt,\n\t\t\t\t\t\tltdiff, &gtbno, &gtlen,\n\t\t\t\t\t\t&gtbnoa, &gtlena,\n\t\t\t\t\t\t0 /* search right */);\n\t\t} else {\n\t\t\tASSERT(gtlena >= args->minlen);\n\n\t\t\t/*\n\t\t\t * Right side is good, look for a left side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(gtlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tgtdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, gtbnoa,\n\t\t\t\tgtlena, &gtnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_gt, &bno_cur_lt,\n\t\t\t\t\t\tgtdiff, &ltbno, &ltlen,\n\t\t\t\t\t\t&ltbnoa, &ltlena,\n\t\t\t\t\t\t1 /* search left */);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we couldn't get anything, give up.\n\t */\n\tif (bno_cur_lt == NULL && bno_cur_gt == NULL) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\t\tif (!forced++) {\n\t\t\ttrace_xfs_alloc_near_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\ttrace_xfs_alloc_size_neither(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point we have selected a freespace entry, either to the\n\t * left or to the right.  If it's on the right, copy all the\n\t * useful variables to the \"left\" set so we only have one\n\t * copy of this code.\n\t */\n\tif (bno_cur_gt) {\n\t\tbno_cur_lt = bno_cur_gt;\n\t\tbno_cur_gt = NULL;\n\t\tltbno = gtbno;\n\t\tltbnoa = gtbnoa;\n\t\tltlen = gtlen;\n\t\tltlena = gtlena;\n\t\tj = 1;\n\t} else\n\t\tj = 0;\n\n\t/*\n\t * Fix up the length and compute the useful address.\n\t */\n\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args)) {\n\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\treturn 0;\n\t}\n\trlen = args->len;\n\t(void)xfs_alloc_compute_diff(args->agbno, rlen, args->alignment,\n\t\t\t\t     args->userdata, ltbnoa, ltlena, &ltnew);\n\tASSERT(ltnew >= ltbno);\n\tASSERT(ltnew + rlen <= ltbnoa + ltlena);\n\tASSERT(ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\targs->agbno = ltnew;\n\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno, ltlen,\n\t\t\tltnew, rlen, XFSA_FIXUP_BNO_OK)))\n\t\tgoto error0;\n\n\tif (j)\n\t\ttrace_xfs_alloc_near_greater(args);\n\telse\n\t\ttrace_xfs_alloc_near_lesser(args);\n\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\treturn 0;\n\n error0:\n\ttrace_xfs_alloc_near_error(args);\n\tif (cnt_cur != NULL)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur_lt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_ERROR);\n\tif (bno_cur_gt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2",
            "#define\tXFSA_FIXUP_BNO_OK\t1"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_near(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur_gt;\t/* cursor for bno btree, right side */\n\txfs_btree_cur_t\t*bno_cur_lt;\t/* cursor for bno btree, left side */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for count btree */\n\txfs_agblock_t\tgtbno;\t\t/* start bno of right side entry */\n\txfs_agblock_t\tgtbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tgtdiff;\t\t/* difference to right side entry */\n\txfs_extlen_t\tgtlen;\t\t/* length of right side entry */\n\txfs_extlen_t\tgtlena;\t\t/* aligned ... */\n\txfs_agblock_t\tgtnew;\t\t/* useful start bno of right side */\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* result code, temporary */\n\tint\t\tj;\t\t/* result code, temporary */\n\txfs_agblock_t\tltbno;\t\t/* start bno of left side entry */\n\txfs_agblock_t\tltbnoa;\t\t/* aligned ... */\n\txfs_extlen_t\tltdiff;\t\t/* difference to left side entry */\n\txfs_extlen_t\tltlen;\t\t/* length of left side entry */\n\txfs_extlen_t\tltlena;\t\t/* aligned ... */\n\txfs_agblock_t\tltnew;\t\t/* useful start bno of left side */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n#ifdef DEBUG\n\t/*\n\t * Randomly don't execute the first algorithm.\n\t */\n\tint\t\tdofirst;\t/* set to do first algorithm */\n\n\tdofirst = prandom_u32() & 1;\n#endif\n\nrestart:\n\tbno_cur_lt = NULL;\n\tbno_cur_gt = NULL;\n\tltlen = 0;\n\tgtlena = 0;\n\tltlena = 0;\n\n\t/*\n\t * Get a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\n\t/*\n\t * See if there are any free extents as big as maxlen.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0, args->maxlen, &i)))\n\t\tgoto error0;\n\t/*\n\t * If none, then pick up the last entry in the tree unless the\n\t * tree is empty.\n\t */\n\tif (!i) {\n\t\tif ((error = xfs_alloc_ag_vextent_small(args, cnt_cur, &ltbno,\n\t\t\t\t&ltlen, &i)))\n\t\t\tgoto error0;\n\t\tif (i == 0 || ltlen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t}\n\targs->wasfromfl = 0;\n\n\t/*\n\t * First algorithm.\n\t * If the requested extent is large wrt the freespaces available\n\t * in this a.g., then the cursor will be pointing to a btree entry\n\t * near the right edge of the tree.  If it's in the last btree leaf\n\t * block, then we just examine all the entries in that block\n\t * that are big enough, and pick the best one.\n\t * This is written as a while loop so we can break out of it,\n\t * but we never loop back to the top.\n\t */\n\twhile (xfs_btree_islastblock(cnt_cur, 0)) {\n\t\txfs_extlen_t\tbdiff;\n\t\tint\t\tbesti=0;\n\t\txfs_extlen_t\tblen=0;\n\t\txfs_agblock_t\tbnew=0;\n\n#ifdef DEBUG\n\t\tif (dofirst)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Start from the entry that lookup found, sequence through\n\t\t * all larger free blocks.  If we're actually pointing at a\n\t\t * record smaller than maxlen, go to the start of this block,\n\t\t * and skip all those smaller than minlen.\n\t\t */\n\t\tif (ltlen || args->alignment > 1) {\n\t\t\tcnt_cur->bc_ptrs[0] = 1;\n\t\t\tdo {\n\t\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno,\n\t\t\t\t\t\t&ltlen, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\t\tif (ltlen >= args->minlen)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((error = xfs_btree_increment(cnt_cur, 0, &i)))\n\t\t\t\t\tgoto error0;\n\t\t\t} while (i);\n\t\t\tASSERT(ltlen >= args->minlen);\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t}\n\t\ti = cnt_cur->bc_ptrs[0];\n\t\tfor (j = 1, blen = 0, bdiff = 0;\n\t\t     !error && j && (blen < args->maxlen || bdiff > 0);\n\t\t     error = xfs_btree_increment(cnt_cur, 0, &j)) {\n\t\t\t/*\n\t\t\t * For each entry, decide if it's better than\n\t\t\t * the previous best entry.\n\t\t\t */\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena < args->minlen)\n\t\t\t\tcontinue;\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tASSERT(args->len >= args->minlen);\n\t\t\tif (args->len < blen)\n\t\t\t\tcontinue;\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\t\t\tif (ltnew != NULLAGBLOCK &&\n\t\t\t    (args->len > blen || ltdiff < bdiff)) {\n\t\t\t\tbdiff = ltdiff;\n\t\t\t\tbnew = ltnew;\n\t\t\t\tblen = args->len;\n\t\t\t\tbesti = cnt_cur->bc_ptrs[0];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * It didn't work.  We COULD be in a case where\n\t\t * there's a good record somewhere, so try again.\n\t\t */\n\t\tif (blen == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Point at the best entry, and retrieve it again.\n\t\t */\n\t\tcnt_cur->bc_ptrs[0] = besti;\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &ltbno, &ltlen, &i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tASSERT(ltbno + ltlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\t\targs->len = blen;\n\t\tif (!xfs_alloc_fix_minleft(args)) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\t\treturn 0;\n\t\t}\n\t\tblen = args->len;\n\t\t/*\n\t\t * We are allocating starting at bnew for blen blocks.\n\t\t */\n\t\targs->agbno = bnew;\n\t\tASSERT(bnew >= ltbno);\n\t\tASSERT(bnew + blen <= ltbno + ltlen);\n\t\t/*\n\t\t * Set up a cursor for the by-bno tree.\n\t\t */\n\t\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp,\n\t\t\targs->agbp, args->agno, XFS_BTNUM_BNO);\n\t\t/*\n\t\t * Fix up the btree entries.\n\t\t */\n\t\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno,\n\t\t\t\tltlen, bnew, blen, XFSA_FIXUP_CNT_OK)))\n\t\t\tgoto error0;\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\n\t\ttrace_xfs_alloc_near_first(args);\n\t\treturn 0;\n\t}\n\t/*\n\t * Second algorithm.\n\t * Search in the by-bno tree to the left and to the right\n\t * simultaneously, until in each case we find a space big enough,\n\t * or run into the edge of the tree.  When we run into the edge,\n\t * we deallocate that cursor.\n\t * If both searches succeed, we compare the two spaces and pick\n\t * the better one.\n\t * With alignment, it's possible for both to fail; the upper\n\t * level algorithm that picks allocation groups for allocations\n\t * is not supposed to do this.\n\t */\n\t/*\n\t * Allocate and initialize the cursor for the leftward search.\n\t */\n\tbno_cur_lt = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\t/*\n\t * Lookup <= bno to find the leftward search's starting point.\n\t */\n\tif ((error = xfs_alloc_lookup_le(bno_cur_lt, args->agbno, args->maxlen, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * Didn't find anything; use this cursor for the rightward\n\t\t * search.\n\t\t */\n\t\tbno_cur_gt = bno_cur_lt;\n\t\tbno_cur_lt = NULL;\n\t}\n\t/*\n\t * Found something.  Duplicate the cursor for the rightward search.\n\t */\n\telse if ((error = xfs_btree_dup_cursor(bno_cur_lt, &bno_cur_gt)))\n\t\tgoto error0;\n\t/*\n\t * Increment the cursor, so we will point at the entry just right\n\t * of the leftward entry if any, or to the leftmost entry.\n\t */\n\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\tgoto error0;\n\tif (!i) {\n\t\t/*\n\t\t * It failed, there are no rightward entries.\n\t\t */\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_NOERROR);\n\t\tbno_cur_gt = NULL;\n\t}\n\t/*\n\t * Loop going left with the leftward cursor, right with the\n\t * rightward cursor, until either both directions give up or\n\t * we find an entry at least as big as minlen.\n\t */\n\tdo {\n\t\tif (bno_cur_lt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_lt, &ltbno, &ltlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, ltbno, ltlen,\n\t\t\t\t\t\t  &ltbnoa, &ltlena);\n\t\t\tif (ltlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_decrement(bno_cur_lt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_lt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_lt = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bno_cur_gt) {\n\t\t\tif ((error = xfs_alloc_get_rec(bno_cur_gt, &gtbno, &gtlen, &i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\txfs_alloc_compute_aligned(args, gtbno, gtlen,\n\t\t\t\t\t\t  &gtbnoa, &gtlena);\n\t\t\tif (gtlena >= args->minlen)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_btree_increment(bno_cur_gt, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (!i) {\n\t\t\t\txfs_btree_del_cursor(bno_cur_gt,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\tbno_cur_gt = NULL;\n\t\t\t}\n\t\t}\n\t} while (bno_cur_lt || bno_cur_gt);\n\n\t/*\n\t * Got both cursors still active, need to find better entry.\n\t */\n\tif (bno_cur_lt && bno_cur_gt) {\n\t\tif (ltlena >= args->minlen) {\n\t\t\t/*\n\t\t\t * Left side is good, look for a right side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tltdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, ltbnoa,\n\t\t\t\tltlena, &ltnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_lt, &bno_cur_gt,\n\t\t\t\t\t\tltdiff, &gtbno, &gtlen,\n\t\t\t\t\t\t&gtbnoa, &gtlena,\n\t\t\t\t\t\t0 /* search right */);\n\t\t} else {\n\t\t\tASSERT(gtlena >= args->minlen);\n\n\t\t\t/*\n\t\t\t * Right side is good, look for a left side entry.\n\t\t\t */\n\t\t\targs->len = XFS_EXTLEN_MIN(gtlena, args->maxlen);\n\t\t\txfs_alloc_fix_len(args);\n\t\t\tgtdiff = xfs_alloc_compute_diff(args->agbno, args->len,\n\t\t\t\targs->alignment, args->userdata, gtbnoa,\n\t\t\t\tgtlena, &gtnew);\n\n\t\t\terror = xfs_alloc_find_best_extent(args,\n\t\t\t\t\t\t&bno_cur_gt, &bno_cur_lt,\n\t\t\t\t\t\tgtdiff, &ltbno, &ltlen,\n\t\t\t\t\t\t&ltbnoa, &ltlena,\n\t\t\t\t\t\t1 /* search left */);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we couldn't get anything, give up.\n\t */\n\tif (bno_cur_lt == NULL && bno_cur_gt == NULL) {\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\n\t\tif (!forced++) {\n\t\t\ttrace_xfs_alloc_near_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\ttrace_xfs_alloc_size_neither(args);\n\t\targs->agbno = NULLAGBLOCK;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point we have selected a freespace entry, either to the\n\t * left or to the right.  If it's on the right, copy all the\n\t * useful variables to the \"left\" set so we only have one\n\t * copy of this code.\n\t */\n\tif (bno_cur_gt) {\n\t\tbno_cur_lt = bno_cur_gt;\n\t\tbno_cur_gt = NULL;\n\t\tltbno = gtbno;\n\t\tltbnoa = gtbnoa;\n\t\tltlen = gtlen;\n\t\tltlena = gtlena;\n\t\tj = 1;\n\t} else\n\t\tj = 0;\n\n\t/*\n\t * Fix up the length and compute the useful address.\n\t */\n\targs->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);\n\txfs_alloc_fix_len(args);\n\tif (!xfs_alloc_fix_minleft(args)) {\n\t\ttrace_xfs_alloc_near_nominleft(args);\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\treturn 0;\n\t}\n\trlen = args->len;\n\t(void)xfs_alloc_compute_diff(args->agbno, rlen, args->alignment,\n\t\t\t\t     args->userdata, ltbnoa, ltlena, &ltnew);\n\tASSERT(ltnew >= ltbno);\n\tASSERT(ltnew + rlen <= ltbnoa + ltlena);\n\tASSERT(ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));\n\targs->agbno = ltnew;\n\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur_lt, ltbno, ltlen,\n\t\t\tltnew, rlen, XFSA_FIXUP_BNO_OK)))\n\t\tgoto error0;\n\n\tif (j)\n\t\ttrace_xfs_alloc_near_greater(args);\n\telse\n\t\ttrace_xfs_alloc_near_lesser(args);\n\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_NOERROR);\n\treturn 0;\n\n error0:\n\ttrace_xfs_alloc_near_error(args);\n\tif (cnt_cur != NULL)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur_lt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_lt, XFS_BTREE_ERROR);\n\tif (bno_cur_gt != NULL)\n\t\txfs_btree_del_cursor(bno_cur_gt, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ag_vextent_size",
          "args": [
            "args"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ag_vextent_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1246-1445",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tXFSA_FIXUP_CNT_OK\t2"
          ],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_ag_vextent_size(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_btree_cur_t\t*bno_cur;\t/* cursor for bno btree */\n\txfs_btree_cur_t\t*cnt_cur;\t/* cursor for cnt btree */\n\tint\t\terror;\t\t/* error result */\n\txfs_agblock_t\tfbno;\t\t/* start of found freespace */\n\txfs_extlen_t\tflen;\t\t/* length of found freespace */\n\tint\t\ti;\t\t/* temp status variable */\n\txfs_agblock_t\trbno;\t\t/* returned block number */\n\txfs_extlen_t\trlen;\t\t/* length of returned extent */\n\tint\t\tforced = 0;\n\nrestart:\n\t/*\n\t * Allocate and initialize a cursor for the by-size btree.\n\t */\n\tcnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_CNT);\n\tbno_cur = NULL;\n\n\t/*\n\t * Look for an entry >= maxlen+alignment-1 blocks.\n\t */\n\tif ((error = xfs_alloc_lookup_ge(cnt_cur, 0,\n\t\t\targs->maxlen + args->alignment - 1, &i)))\n\t\tgoto error0;\n\n\t/*\n\t * If none or we have busy extents that we cannot allocate from, then\n\t * we have to settle for a smaller extent. In the case that there are\n\t * no large extents, this will return the last entry in the tree unless\n\t * the tree is empty. In the case that there are only busy large\n\t * extents, this will return the largest small extent unless there\n\t * are no smaller extents available.\n\t */\n\tif (!i || forced > 1) {\n\t\terror = xfs_alloc_ag_vextent_small(args, cnt_cur,\n\t\t\t\t\t\t   &fbno, &flen, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tif (i == 0 || flen == 0) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_noentry(args);\n\t\t\treturn 0;\n\t\t}\n\t\tASSERT(i == 1);\n\t\txfs_alloc_compute_aligned(args, fbno, flen, &rbno, &rlen);\n\t} else {\n\t\t/*\n\t\t * Search for a non-busy extent that is large enough.\n\t\t * If we are at low space, don't check, or if we fall of\n\t\t * the end of the btree, turn off the busy check and\n\t\t * restart.\n\t\t */\n\t\tfor (;;) {\n\t\t\terror = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\n\t\t\tif (rlen >= args->maxlen)\n\t\t\t\tbreak;\n\n\t\t\terror = xfs_btree_increment(cnt_cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our only valid extents must have been busy.\n\t\t\t\t * Make it unbusy by forcing the log out and\n\t\t\t\t * retrying. If we've been here before, forcing\n\t\t\t\t * the log isn't making the extents available,\n\t\t\t\t * which means they have probably been freed in\n\t\t\t\t * this transaction.  In that case, we have to\n\t\t\t\t * give up on them and we'll attempt a minlen\n\t\t\t\t * allocation the next time around.\n\t\t\t\t */\n\t\t\t\txfs_btree_del_cursor(cnt_cur,\n\t\t\t\t\t\t     XFS_BTREE_NOERROR);\n\t\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\t\tif (!forced++)\n\t\t\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * In the first case above, we got the last entry in the\n\t * by-size btree.  Now we check to see if the space hits maxlen\n\t * once aligned; if not, we search left for something better.\n\t * This can't happen in the second case above.\n\t */\n\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen), error0);\n\tif (rlen < args->maxlen) {\n\t\txfs_agblock_t\tbestfbno;\n\t\txfs_extlen_t\tbestflen;\n\t\txfs_agblock_t\tbestrbno;\n\t\txfs_extlen_t\tbestrlen;\n\n\t\tbestrlen = rlen;\n\t\tbestrbno = rbno;\n\t\tbestflen = flen;\n\t\tbestfbno = fbno;\n\t\tfor (;;) {\n\t\t\tif ((error = xfs_btree_decrement(cnt_cur, 0, &i)))\n\t\t\t\tgoto error0;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t\tif (flen < bestrlen)\n\t\t\t\tbreak;\n\t\t\txfs_alloc_compute_aligned(args, fbno, flen,\n\t\t\t\t\t\t  &rbno, &rlen);\n\t\t\trlen = XFS_EXTLEN_MIN(args->maxlen, rlen);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(rlen == 0 ||\n\t\t\t\t(rlen <= flen && rbno + rlen <= fbno + flen),\n\t\t\t\terror0);\n\t\t\tif (rlen > bestrlen) {\n\t\t\t\tbestrlen = rlen;\n\t\t\t\tbestrbno = rbno;\n\t\t\t\tbestflen = flen;\n\t\t\t\tbestfbno = fbno;\n\t\t\t\tif (rlen == args->maxlen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, bestfbno, bestflen,\n\t\t\t\t&i)))\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\trlen = bestrlen;\n\t\trbno = bestrbno;\n\t\tflen = bestflen;\n\t\tfbno = bestfbno;\n\t}\n\targs->wasfromfl = 0;\n\t/*\n\t * Fix up the length.\n\t */\n\targs->len = rlen;\n\tif (rlen < args->minlen) {\n\t\tif (!forced++) {\n\t\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\t\t\ttrace_xfs_alloc_size_busy(args);\n\t\t\txfs_log_force(args->mp, XFS_LOG_SYNC);\n\t\t\tgoto restart;\n\t\t}\n\t\tgoto out_nominleft;\n\t}\n\txfs_alloc_fix_len(args);\n\n\tif (!xfs_alloc_fix_minleft(args))\n\t\tgoto out_nominleft;\n\trlen = args->len;\n\tXFS_WANT_CORRUPTED_GOTO(rlen <= flen, error0);\n\t/*\n\t * Allocate and initialize a cursor for the by-block tree.\n\t */\n\tbno_cur = xfs_allocbt_init_cursor(args->mp, args->tp, args->agbp,\n\t\targs->agno, XFS_BTNUM_BNO);\n\tif ((error = xfs_alloc_fixup_trees(cnt_cur, bno_cur, fbno, flen,\n\t\t\trbno, rlen, XFSA_FIXUP_CNT_OK)))\n\t\tgoto error0;\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\txfs_btree_del_cursor(bno_cur, XFS_BTREE_NOERROR);\n\tcnt_cur = bno_cur = NULL;\n\targs->len = rlen;\n\targs->agbno = rbno;\n\tXFS_WANT_CORRUPTED_GOTO(\n\t\targs->agbno + args->len <=\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length),\n\t\terror0);\n\ttrace_xfs_alloc_size_done(args);\n\treturn 0;\n\nerror0:\n\ttrace_xfs_alloc_size_error(args);\n\tif (cnt_cur)\n\t\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_ERROR);\n\tif (bno_cur)\n\t\txfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);\n\treturn error;\n\nout_nominleft:\n\txfs_btree_del_cursor(cnt_cur, XFS_BTREE_NOERROR);\n\ttrace_xfs_alloc_size_nominleft(args);\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->alignment > 0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->mod < args->prod"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->minlen <= args->maxlen"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->maxlen > 0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->minlen > 0"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\n\nSTATIC int\t\t\t/* error */\nxfs_alloc_ag_vextent(\n\txfs_alloc_arg_t\t*args)\t/* argument structure for allocation */\n{\n\tint\t\terror=0;\n\n\tASSERT(args->minlen > 0);\n\tASSERT(args->maxlen > 0);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->mod < args->prod);\n\tASSERT(args->alignment > 0);\n\t/*\n\t * Branch to correct routine based on the type.\n\t */\n\targs->wasfromfl = 0;\n\tswitch (args->type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\t\terror = xfs_alloc_ag_vextent_size(args);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_alloc_ag_vextent_near(args);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_alloc_ag_vextent_exact(args);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\n\tif (error || args->agbno == NULLAGBLOCK)\n\t\treturn error;\n\n\tASSERT(args->len >= args->minlen);\n\tASSERT(args->len <= args->maxlen);\n\tASSERT(!args->wasfromfl || !args->isfl);\n\tASSERT(args->agbno % args->alignment == 0);\n\n\tif (!args->wasfromfl) {\n\t\terror = xfs_alloc_update_counters(args->tp, args->pag,\n\t\t\t\t\t\t  args->agbp,\n\t\t\t\t\t\t  -((long)(args->len)));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(!xfs_extent_busy_search(args->mp, args->agno,\n\t\t\t\t\t      args->agbno, args->len));\n\t}\n\n\tif (!args->isfl) {\n\t\txfs_trans_mod_sb(args->tp, args->wasdel ?\n\t\t\t\t XFS_TRANS_SB_RES_FDBLOCKS :\n\t\t\t\t XFS_TRANS_SB_FDBLOCKS,\n\t\t\t\t -((long)(args->len)));\n\t}\n\n\tXFS_STATS_INC(xs_allocx);\n\tXFS_STATS_ADD(xs_allocb, args->len);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_update_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "546-565",
    "snippet": "STATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_log_agf",
          "args": [
            "tp",
            "agbp",
            "XFS_AGF_FREEBLKS"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_log_agf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2079-2110",
          "snippet": "void\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alloc_log_agf(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t/* buffer for a.g. freelist header */\n\tint\t\tfields)\t/* mask of fields to be logged (XFS_AGF_...) */\n{\n\tint\tfirst;\t\t/* first byte offset */\n\tint\tlast;\t\t/* last byte offset */\n\tstatic const short\toffsets[] = {\n\t\toffsetof(xfs_agf_t, agf_magicnum),\n\t\toffsetof(xfs_agf_t, agf_versionnum),\n\t\toffsetof(xfs_agf_t, agf_seqno),\n\t\toffsetof(xfs_agf_t, agf_length),\n\t\toffsetof(xfs_agf_t, agf_roots[0]),\n\t\toffsetof(xfs_agf_t, agf_levels[0]),\n\t\toffsetof(xfs_agf_t, agf_flfirst),\n\t\toffsetof(xfs_agf_t, agf_fllast),\n\t\toffsetof(xfs_agf_t, agf_flcount),\n\t\toffsetof(xfs_agf_t, agf_freeblks),\n\t\toffsetof(xfs_agf_t, agf_longest),\n\t\toffsetof(xfs_agf_t, agf_btreeblks),\n\t\toffsetof(xfs_agf_t, agf_uuid),\n\t\tsizeof(xfs_agf_t)\n\t};\n\n\ttrace_xfs_agf(tp->t_mountp, XFS_BUF_TO_AGF(bp), fields, _RET_IP_);\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGF_BUF);\n\n\txfs_btree_offsets(fields, offsets, XFS_AGF_NUM_BITS, &first, &last);\n\txfs_trans_log_buf(tp, bp, (uint)first, (uint)last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_agblocks_delta",
          "args": [
            "tp",
            "len"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agf->agf_freeblks",
            "len"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alloc_update_counters(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_buf\t\t*agbp,\n\tlong\t\t\tlen)\n{\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(agbp);\n\n\tpag->pagf_freeblks += len;\n\tbe32_add_cpu(&agf->agf_freeblks, len);\n\n\txfs_trans_agblocks_delta(tp, len);\n\tif (unlikely(be32_to_cpu(agf->agf_freeblks) >\n\t\t     be32_to_cpu(agf->agf_length)))\n\t\treturn -EFSCORRUPTED;\n\n\txfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_read_agfl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "524-544",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "XFS_AGFL_REF"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "XFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp))",
            "XFS_FSS_TO_BB(mp, 1)",
            "0",
            "&bp",
            "&xfs_agfl_buf_ops"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSS_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AG_DADDR",
          "args": [
            "mp",
            "agno",
            "XFS_AGFL_DADDR(mp)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_DADDR",
          "args": [
            "mp"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_agfl_buf_ops = {\n\t.verify_read = xfs_agfl_read_verify,\n\t.verify_write = xfs_agfl_write_verify,\n};\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_read_agfl(\n\txfs_mount_t\t*mp,\t\t/* mount point structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_buf_t\t**bpp)\t\t/* buffer for the ag free block array */\n{\n\txfs_buf_t\t*bp;\t\t/* return value */\n\tint\t\terror;\n\n\tASSERT(agno != NULLAGNUMBER);\n\terror = xfs_trans_read_buf(\n\t\t\tmp, tp, mp->m_ddev_targp,\n\t\t\tXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\n\t\t\tXFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_agfl_buf_ops);\n\tif (error)\n\t\treturn error;\n\txfs_buf_set_ref(bp, XFS_AGFL_REF);\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_agfl_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "493-514",
    "snippet": "static void\nxfs_agfl_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\t/* no verification of non-crc AGFLs */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (!xfs_agfl_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGFL(bp)->agfl_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGFL_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_AGFL_CRC_OFF"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL",
          "args": [
            "bp"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_agfl_verify",
          "args": [
            "bp"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agfl_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "440-467",
          "snippet": "static bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agfl_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\t/* no verification of non-crc AGFLs */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (!xfs_agfl_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (bip)\n\t\tXFS_BUF_TO_AGFL(bp)->agfl_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_AGFL_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_agfl_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "469-491",
    "snippet": "static void\nxfs_agfl_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t/*\n\t * There is no verification of non-crc AGFLs because mkfs does not\n\t * initialise the AGFL to zero or NULL. Hence the only valid part of the\n\t * AGFL is what the AGF says is active. We can't get to the AGF, so we\n\t * can't verify just those entries are valid.\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (!xfs_buf_verify_cksum(bp, XFS_AGFL_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_agfl_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_agfl_verify",
          "args": [
            "bp"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_agfl_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "440-467",
          "snippet": "static bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_AGFL_CRC_OFF"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_agfl_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t/*\n\t * There is no verification of non-crc AGFLs because mkfs does not\n\t * initialise the AGFL to zero or NULL. Hence the only valid part of the\n\t * AGFL is what the AGF says is active. We can't get to the AGF, so we\n\t * can't verify just those entries are valid.\n\t */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (!xfs_buf_verify_cksum(bp, XFS_AGFL_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_agfl_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_agfl_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "440-467",
    "snippet": "static bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfl->agfl_bno[i]"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfl->agfl_bno[i]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGFL_SIZE",
          "args": [
            "mp"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfl->agfl_seqno"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agfl->agfl_magicnum"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&agfl->agfl_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGFL",
          "args": [
            "bp"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_agfl_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_agfl\t*agfl = XFS_BUF_TO_AGFL(bp);\n\tint\t\ti;\n\n\tif (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)\n\t\treturn false;\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agfl->agfl_seqno) != bp->b_pag->pag_agno)\n\t\treturn false;\n\n\tfor (i = 0; i < XFS_AGFL_SIZE(mp); i++) {\n\t\tif (be32_to_cpu(agfl->agfl_bno[i]) != NULLAGBLOCK &&\n\t\t    be32_to_cpu(agfl->agfl_bno[i]) >= mp->m_sb.sb_agblocks)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_alloc_fixup_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "302-438",
    "snippet": "STATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tXFSA_FIXUP_CNT_OK\t2",
      "#define\tXFSA_FIXUP_BNO_OK\t1"
    ],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "bno_cur",
            "&i"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 0"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_lookup_eq",
          "args": [
            "bno_cur",
            "nfbno2",
            "nflen2",
            "&i"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "55-65",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_update",
          "args": [
            "bno_cur",
            "nfbno1",
            "nflen1"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "104-115",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "bno_cur",
            "&i"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 0"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "bnoblock->bb_numrecs == cntblock->bb_numrecs"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "cnt_cur->bc_bufs[0]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bno_cur->bc_bufs[0]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1 && nfbno1 == fbno && nflen1 == flen"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_get_rec",
          "args": [
            "bno_cur",
            "&nfbno1",
            "&nflen1",
            "&i"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "120-136",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1 && nfbno1 == fbno && nflen1 == flen"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tXFSA_FIXUP_CNT_OK\t2\n#define\tXFSA_FIXUP_BNO_OK\t1\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error code */\nxfs_alloc_fixup_trees(\n\txfs_btree_cur_t\t*cnt_cur,\t/* cursor for by-size btree */\n\txfs_btree_cur_t\t*bno_cur,\t/* cursor for by-block btree */\n\txfs_agblock_t\tfbno,\t\t/* starting block of free extent */\n\txfs_extlen_t\tflen,\t\t/* length of free extent */\n\txfs_agblock_t\trbno,\t\t/* starting block of returned extent */\n\txfs_extlen_t\trlen,\t\t/* length of returned extent */\n\tint\t\tflags)\t\t/* flags, XFSA_FIXUP_... */\n{\n\tint\t\terror;\t\t/* error code */\n\tint\t\ti;\t\t/* operation results */\n\txfs_agblock_t\tnfbno1;\t\t/* first new free startblock */\n\txfs_agblock_t\tnfbno2;\t\t/* second new free startblock */\n\txfs_extlen_t\tnflen1=0;\t/* first new free length */\n\txfs_extlen_t\tnflen2=0;\t/* second new free length */\n\n\t/*\n\t * Look up the record in the by-size tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_CNT_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(cnt_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Look up the record in the by-block tree if necessary.\n\t */\n\tif (flags & XFSA_FIXUP_BNO_OK) {\n#ifdef DEBUG\n\t\tif ((error = xfs_alloc_get_rec(bno_cur, &nfbno1, &nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\ti == 1 && nfbno1 == fbno && nflen1 == flen);\n#endif\n\t} else {\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, fbno, flen, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\n#ifdef DEBUG\n\tif (bno_cur->bc_nlevels == 1 && cnt_cur->bc_nlevels == 1) {\n\t\tstruct xfs_btree_block\t*bnoblock;\n\t\tstruct xfs_btree_block\t*cntblock;\n\n\t\tbnoblock = XFS_BUF_TO_BLOCK(bno_cur->bc_bufs[0]);\n\t\tcntblock = XFS_BUF_TO_BLOCK(cnt_cur->bc_bufs[0]);\n\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbnoblock->bb_numrecs == cntblock->bb_numrecs);\n\t}\n#endif\n\n\t/*\n\t * Deal with all four cases: the allocated record is contained\n\t * within the freespace record, so we can have new freespace\n\t * at either (or both) end, or no freespace remaining.\n\t */\n\tif (rbno == fbno && rlen == flen)\n\t\tnfbno1 = nfbno2 = NULLAGBLOCK;\n\telse if (rbno == fbno) {\n\t\tnfbno1 = rbno + rlen;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else if (rbno + rlen == fbno + flen) {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = flen - rlen;\n\t\tnfbno2 = NULLAGBLOCK;\n\t} else {\n\t\tnfbno1 = fbno;\n\t\tnflen1 = rbno - fbno;\n\t\tnfbno2 = rbno + rlen;\n\t\tnflen2 = (fbno + flen) - nfbno2;\n\t}\n\t/*\n\t * Delete the entry from the by-size btree.\n\t */\n\tif ((error = xfs_btree_delete(cnt_cur, &i)))\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t/*\n\t * Add new by-size btree entry(s).\n\t */\n\tif (nfbno1 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno1, nflen1, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\tif ((error = xfs_alloc_lookup_eq(cnt_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(cnt_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\t/*\n\t * Fix up the by-block btree entry(s).\n\t */\n\tif (nfbno1 == NULLAGBLOCK) {\n\t\t/*\n\t\t * No remaining freespace, just delete the by-block tree entry.\n\t\t */\n\t\tif ((error = xfs_btree_delete(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t} else {\n\t\t/*\n\t\t * Update the by-block entry to start later|be shorter.\n\t\t */\n\t\tif ((error = xfs_alloc_update(bno_cur, nfbno1, nflen1)))\n\t\t\treturn error;\n\t}\n\tif (nfbno2 != NULLAGBLOCK) {\n\t\t/*\n\t\t * 2 resulting free entries, need to add one.\n\t\t */\n\t\tif ((error = xfs_alloc_lookup_eq(bno_cur, nfbno2, nflen2, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 0);\n\t\tif ((error = xfs_btree_insert(bno_cur, &i)))\n\t\t\treturn error;\n\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_fix_minleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "274-293",
    "snippet": "STATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_freeblks"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "args->agbp"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\n\nSTATIC int\nxfs_alloc_fix_minleft(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_agf_t\t*agf;\t\t/* a.g. freelist header */\n\tint\t\tdiff;\t\t/* free space difference */\n\n\tif (args->minleft == 0)\n\t\treturn 1;\n\tagf = XFS_BUF_TO_AGF(args->agbp);\n\tdiff = be32_to_cpu(agf->agf_freeblks)\n\t\t- args->len - args->minleft;\n\tif (diff >= 0)\n\t\treturn 1;\n\targs->len += diff;\t\t/* shrink the allocated space */\n\tif (args->len >= args->minlen)\n\t\treturn 1;\n\targs->agbno = NULLAGBLOCK;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_fix_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "242-268",
    "snippet": "STATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rlen % args->prod == args->mod"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rlen >= args->minlen && rlen <= args->maxlen"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rlen <= args->maxlen"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rlen >= args->minlen"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->mod < args->prod"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_fix_len(\n\txfs_alloc_arg_t\t*args)\t\t/* allocation argument structure */\n{\n\txfs_extlen_t\tk;\n\txfs_extlen_t\trlen;\n\n\tASSERT(args->mod < args->prod);\n\trlen = args->len;\n\tASSERT(rlen >= args->minlen);\n\tASSERT(rlen <= args->maxlen);\n\tif (args->prod <= 1 || rlen < args->mod || rlen == args->maxlen ||\n\t    (args->mod == 0 && rlen < args->prod))\n\t\treturn;\n\tk = rlen % args->prod;\n\tif (k == args->mod)\n\t\treturn;\n\tif (k > args->mod)\n\t\trlen = rlen - (k - args->mod);\n\telse\n\t\trlen = rlen - args->prod + (args->mod - k);\n\tif ((int)rlen < (int)args->minlen)\n\t\treturn;\n\tASSERT(rlen >= args->minlen && rlen <= args->maxlen);\n\tASSERT(rlen % args->prod == args->mod);\n\targs->len = rlen;\n}"
  },
  {
    "function_name": "xfs_alloc_compute_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "172-234",
    "snippet": "STATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ABSDIFF",
          "args": [
            "newbno1",
            "wantbno"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "freeend - wantlen",
            "alignment"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ABSDIFF",
          "args": [
            "newbno2",
            "wantbno"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ABSDIFF",
          "args": [
            "newbno1",
            "wantbno"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "wantlen",
            "freeend - newbno2"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTLEN_MIN",
          "args": [
            "wantlen",
            "freeend - newbno1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "freelen >= wantlen"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC xfs_extlen_t\t\t\t/* difference value (absolute) */\nxfs_alloc_compute_diff(\n\txfs_agblock_t\twantbno,\t/* target starting block */\n\txfs_extlen_t\twantlen,\t/* target length */\n\txfs_extlen_t\talignment,\t/* target alignment */\n\tchar\t\tuserdata,\t/* are we allocating data? */\n\txfs_agblock_t\tfreebno,\t/* freespace's starting block */\n\txfs_extlen_t\tfreelen,\t/* freespace's length */\n\txfs_agblock_t\t*newbnop)\t/* result: best start block from free */\n{\n\txfs_agblock_t\tfreeend;\t/* end of freespace extent */\n\txfs_agblock_t\tnewbno1;\t/* return block number */\n\txfs_agblock_t\tnewbno2;\t/* other new block number */\n\txfs_extlen_t\tnewlen1=0;\t/* length with newbno1 */\n\txfs_extlen_t\tnewlen2=0;\t/* length with newbno2 */\n\txfs_agblock_t\twantend;\t/* end of target extent */\n\n\tASSERT(freelen >= wantlen);\n\tfreeend = freebno + freelen;\n\twantend = wantbno + wantlen;\n\t/*\n\t * We want to allocate from the start of a free extent if it is past\n\t * the desired block or if we are allocating user data and the free\n\t * extent is before desired block. The second case is there to allow\n\t * for contiguous allocation from the remaining free space if the file\n\t * grows in the short term.\n\t */\n\tif (freebno >= wantbno || (userdata && freeend < wantend)) {\n\t\tif ((newbno1 = roundup(freebno, alignment)) >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else if (freeend >= wantend && alignment > 1) {\n\t\tnewbno1 = roundup(wantbno, alignment);\n\t\tnewbno2 = newbno1 - alignment;\n\t\tif (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen1 = XFS_EXTLEN_MIN(wantlen, freeend - newbno1);\n\t\tif (newbno2 < freebno)\n\t\t\tnewbno2 = NULLAGBLOCK;\n\t\telse\n\t\t\tnewlen2 = XFS_EXTLEN_MIN(wantlen, freeend - newbno2);\n\t\tif (newbno1 != NULLAGBLOCK && newbno2 != NULLAGBLOCK) {\n\t\t\tif (newlen1 < newlen2 ||\n\t\t\t    (newlen1 == newlen2 &&\n\t\t\t     XFS_ABSDIFF(newbno1, wantbno) >\n\t\t\t     XFS_ABSDIFF(newbno2, wantbno)))\n\t\t\t\tnewbno1 = newbno2;\n\t\t} else if (newbno2 != NULLAGBLOCK)\n\t\t\tnewbno1 = newbno2;\n\t} else if (freeend >= wantend) {\n\t\tnewbno1 = wantbno;\n\t} else if (alignment > 1) {\n\t\tnewbno1 = roundup(freeend - wantlen, alignment);\n\t\tif (newbno1 > freeend - wantlen &&\n\t\t    newbno1 - alignment >= freebno)\n\t\t\tnewbno1 -= alignment;\n\t\telse if (newbno1 >= freeend)\n\t\t\tnewbno1 = NULLAGBLOCK;\n\t} else\n\t\tnewbno1 = freeend - wantlen;\n\t*newbnop = newbno1;\n\treturn newbno1 == NULLAGBLOCK ? 0 : XFS_ABSDIFF(newbno1, wantbno);\n}"
  },
  {
    "function_name": "xfs_alloc_compute_aligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "142-166",
    "snippet": "STATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "bno",
            "args->alignment"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_trim",
          "args": [
            "args",
            "foundbno",
            "foundlen",
            "&bno",
            "&len"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "349-536",
          "snippet": "void\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC void\nxfs_alloc_compute_aligned(\n\txfs_alloc_arg_t\t*args,\t\t/* allocation argument structure */\n\txfs_agblock_t\tfoundbno,\t/* starting block in found extent */\n\txfs_extlen_t\tfoundlen,\t/* length in found extent */\n\txfs_agblock_t\t*resbno,\t/* result block number */\n\txfs_extlen_t\t*reslen)\t/* result length */\n{\n\txfs_agblock_t\tbno;\n\txfs_extlen_t\tlen;\n\n\t/* Trim busy sections out of found extent */\n\txfs_extent_busy_trim(args, foundbno, foundlen, &bno, &len);\n\n\tif (args->alignment > 1 && len >= args->minlen) {\n\t\txfs_agblock_t\taligned_bno = roundup(bno, args->alignment);\n\t\txfs_extlen_t\tdiff = aligned_bno - bno;\n\n\t\t*resbno = aligned_bno;\n\t\t*reslen = diff >= len ? 0 : len - diff;\n\t} else {\n\t\t*resbno = bno;\n\t\t*reslen = len;\n\t}\n}"
  },
  {
    "function_name": "xfs_alloc_get_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "120-136",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->alloc.ar_blockcount"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->alloc.ar_startblock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_rec",
          "args": [
            "cur",
            "&rec",
            "stat"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3914-3950",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\t*bno,\t/* output: starting block of extent */\n\txfs_extlen_t\t\t*len,\t/* output: length of extent */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\t*bno = be32_to_cpu(rec->alloc.ar_startblock);\n\t\t*len = be32_to_cpu(rec->alloc.ar_blockcount);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "104-115",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1904-1959",
          "snippet": "int\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bno"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_update(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen)\t/* length of extent */\n{\n\tunion xfs_btree_rec\trec;\n\n\trec.alloc.ar_startblock = cpu_to_be32(bno);\n\trec.alloc.ar_blockcount = cpu_to_be32(len);\n\treturn xfs_btree_update(cur, &rec);\n}"
  },
  {
    "function_name": "xfs_alloc_lookup_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "87-97",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "XFS_LOOKUP_LE",
            "stat"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t\t/* error */\nxfs_alloc_lookup_le(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\n}"
  },
  {
    "function_name": "xfs_alloc_lookup_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "71-81",
    "snippet": "int\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "XFS_LOOKUP_GE",
            "stat"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
  },
  {
    "function_name": "xfs_alloc_lookup_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
    "lines": "55-65",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "XFS_LOOKUP_EQ",
            "stat"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nSTATIC int\t\t\t\t/* error */\nxfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* starting block of extent */\n\txfs_extlen_t\t\tlen,\t/* length of extent */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
  }
]