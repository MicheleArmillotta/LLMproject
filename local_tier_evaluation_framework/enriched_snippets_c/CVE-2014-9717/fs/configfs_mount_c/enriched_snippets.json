[
  {
    "function_name": "configfs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "163-169",
    "snippet": "static void __exit configfs_exit(void)\n{\n\tunregister_filesystem(&configfs_fs_type);\n\tkobject_put(config_kobj);\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *configfs_dir_cachep;",
      "static struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "static struct kobject *config_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "configfs_dir_cachep"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "config_kobj"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&configfs_fs_type"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *configfs_dir_cachep;\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstatic struct kobject *config_kobj;\n\nstatic void __exit configfs_exit(void)\n{\n\tunregister_filesystem(&configfs_fs_type);\n\tkobject_put(config_kobj);\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\n}"
  },
  {
    "function_name": "configfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "134-161",
    "snippet": "static int __init configfs_init(void)\n{\n\tint err = -ENOMEM;\n\n\tconfigfs_dir_cachep = kmem_cache_create(\"configfs_dir_cache\",\n\t\t\t\t\t\tsizeof(struct configfs_dirent),\n\t\t\t\t\t\t0, 0, NULL);\n\tif (!configfs_dir_cachep)\n\t\tgoto out;\n\n\tconfig_kobj = kobject_create_and_add(\"config\", kernel_kobj);\n\tif (!config_kobj)\n\t\tgoto out2;\n\n\terr = register_filesystem(&configfs_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\nout3:\n\tpr_err(\"Unable to register filesystem!\\n\");\n\tkobject_put(config_kobj);\nout2:\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *configfs_dir_cachep;",
      "static struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "static struct kobject *config_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "configfs_dir_cachep"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "config_kobj"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to register filesystem!\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&configfs_fs_type"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"config\"",
            "kernel_kobj"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"configfs_dir_cache\"",
            "sizeof(struct configfs_dirent)",
            "0",
            "0",
            "NULL"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *configfs_dir_cachep;\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstatic struct kobject *config_kobj;\n\nstatic int __init configfs_init(void)\n{\n\tint err = -ENOMEM;\n\n\tconfigfs_dir_cachep = kmem_cache_create(\"configfs_dir_cache\",\n\t\t\t\t\t\tsizeof(struct configfs_dirent),\n\t\t\t\t\t\t0, 0, NULL);\n\tif (!configfs_dir_cachep)\n\t\tgoto out;\n\n\tconfig_kobj = kobject_create_and_add(\"config\", kernel_kobj);\n\tif (!config_kobj)\n\t\tgoto out2;\n\n\terr = register_filesystem(&configfs_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\nout3:\n\tpr_err(\"Unable to register filesystem!\\n\");\n\tkobject_put(config_kobj);\nout2:\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "configfs_release_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "126-129",
    "snippet": "void configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *configfs_mount = NULL;",
      "static int configfs_mnt_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&configfs_mount",
            "&configfs_mnt_count"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "564-573",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\n\nvoid configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}"
  },
  {
    "function_name": "configfs_pin_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "119-124",
    "snippet": "struct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *configfs_mount = NULL;",
      "static int configfs_mnt_count = 0;",
      "static struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&configfs_fs_type",
            "&configfs_mount",
            "&configfs_mnt_count"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "simple_pin_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "543-561",
          "snippet": "int simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *configfs_mount = NULL;\nstatic int configfs_mnt_count = 0;\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.mount\t\t= configfs_do_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstruct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}"
  },
  {
    "function_name": "configfs_do_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "105-109",
    "snippet": "static struct dentry *configfs_do_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, configfs_fill_super);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "configfs_fill_super"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct dentry *configfs_do_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, configfs_fill_super);\n}"
  },
  {
    "function_name": "configfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "69-103",
    "snippet": "static int configfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = CONFIGFS_MAGIC;\n\tsb->s_op = &configfs_ops;\n\tsb->s_time_gran = 1;\n\n\tinode = configfs_new_inode(S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,\n\t\t\t\t   &configfs_root, sb);\n\tif (inode) {\n\t\tinode->i_op = &configfs_root_inode_operations;\n\t\tinode->i_fop = &configfs_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t} else {\n\t\tpr_debug(\"could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\",__func__);\n\t\treturn -ENOMEM;\n\t}\n\tconfig_group_init(&configfs_root_group);\n\tconfigfs_root_group.cg_item.ci_dentry = root;\n\troot->d_fsdata = &configfs_root;\n\tsb->s_root = root;\n\tsb->s_d_op = &configfs_dentry_ops; /* the rest get that */\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CONFIGFS_MAGIC 0x62656570"
    ],
    "globals_used": [
      "static const struct super_operations configfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n};",
      "static struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};",
      "static struct configfs_dirent configfs_root = {\n\t.s_sibling\t= LIST_HEAD_INIT(configfs_root.s_sibling),\n\t.s_children\t= LIST_HEAD_INIT(configfs_root.s_children),\n\t.s_element\t= &configfs_root_group.cg_item,\n\t.s_type\t\t= CONFIGFS_ROOT,\n\t.s_iattr\t= NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_group_init",
          "args": [
            "&configfs_root_group"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "config_group_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "182-186",
          "snippet": "void config_group_init(struct config_group *group)\n{\n\tconfig_item_init(&group->cg_item);\n\tINIT_LIST_HEAD(&group->cg_children);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_group_init(struct config_group *group)\n{\n\tconfig_item_init(&group->cg_item);\n\tINIT_LIST_HEAD(&group->cg_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: could not get root dentry!\\n\"",
            "__func__"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"could not get root inode\\n\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_new_inode",
          "args": [
            "S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO",
            "&configfs_root",
            "sb"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "127-146",
          "snippet": "struct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};",
            "static const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};\nstatic const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};\n\nstruct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define CONFIGFS_MAGIC 0x62656570\n\nstatic const struct super_operations configfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n};\nstatic struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};\nstatic struct configfs_dirent configfs_root = {\n\t.s_sibling\t= LIST_HEAD_INIT(configfs_root.s_sibling),\n\t.s_children\t= LIST_HEAD_INIT(configfs_root.s_children),\n\t.s_element\t= &configfs_root_group.cg_item,\n\t.s_type\t\t= CONFIGFS_ROOT,\n\t.s_iattr\t= NULL,\n};\n\nstatic int configfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = CONFIGFS_MAGIC;\n\tsb->s_op = &configfs_ops;\n\tsb->s_time_gran = 1;\n\n\tinode = configfs_new_inode(S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,\n\t\t\t\t   &configfs_root, sb);\n\tif (inode) {\n\t\tinode->i_op = &configfs_root_inode_operations;\n\t\tinode->i_fop = &configfs_dir_operations;\n\t\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t} else {\n\t\tpr_debug(\"could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\",__func__);\n\t\treturn -ENOMEM;\n\t}\n\tconfig_group_init(&configfs_root_group);\n\tconfigfs_root_group.cg_item.ci_dentry = root;\n\troot->d_fsdata = &configfs_root;\n\tsb->s_root = root;\n\tsb->s_d_op = &configfs_dentry_ops; /* the rest get that */\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_is_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/mount.c",
    "lines": "56-59",
    "snippet": "int configfs_is_root(struct config_item *item)\n{\n\treturn item == &configfs_root_group.cg_item;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};\n\nint configfs_is_root(struct config_item *item)\n{\n\treturn item == &configfs_root_group.cg_item;\n}"
  }
]