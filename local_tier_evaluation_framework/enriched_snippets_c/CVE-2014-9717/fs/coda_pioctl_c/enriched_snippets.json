[
  {
    "function_name": "coda_pioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/pioctl.c",
    "lines": "49-90",
    "snippet": "static long coda_pioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long user_data)\n{\n\tstruct path path;\n\tint error;\n\tstruct PioctlData data;\n\tstruct inode *inode = file_inode(filp);\n\tstruct inode *target_inode = NULL;\n\tstruct coda_inode_info *cnp;\n\n\t/* get the Pioctl data arguments from user space */\n\tif (copy_from_user(&data, (void __user *)user_data, sizeof(data)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Look up the pathname. Note that the pathname is in\n\t * user memory, and namei takes care of this\n\t */\n\tif (data.follow)\n\t\terror = user_path(data.path, &path);\n\telse\n\t\terror = user_lpath(data.path, &path);\n\n\tif (error)\n\t\treturn error;\n\n\ttarget_inode = path.dentry->d_inode;\n\n\t/* return if it is not a Coda inode */\n\tif (target_inode->i_sb != inode->i_sb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* now proceed to make the upcall */\n\tcnp = ITOC(target_inode);\n\n\terror = venus_pioctl(inode->i_sb, &(cnp->c_fid), cmd, &data);\nout:\n\tpath_put(&path);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long coda_pioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long user_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_pioctl",
          "args": [
            "inode->i_sb",
            "&(cnp->c_fid)",
            "cmd",
            "&data"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "venus_pioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "475-548",
          "snippet": "int venus_pioctl(struct super_block *sb, struct CodaFid *fid,\n\t\t unsigned int cmd, struct PioctlData *data)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;  \n\tint insize, outsize, error;\n\tint iocsize;\n\n\tinsize = VC_MAXMSGSIZE;\n\tUPARG(CODA_IOCTL);\n\n        /* build packet for Venus */\n        if (data->vi.in_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n        if (data->vi.out_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n        inp->coda_ioctl.VFid = *fid;\n    \n        /* the cmd field was mutated by increasing its size field to\n         * reflect the path and follow args. We need to subtract that\n         * out before sending the command to Venus.  */\n        inp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\t\n        iocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\n        inp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) <<\t16;\t\n    \n        /* in->coda_ioctl.rwflag = flag; */\n        inp->coda_ioctl.len = data->vi.in_size;\n        inp->coda_ioctl.data = (char *)(INSIZE(ioctl));\n     \n        /* get the data out of user space */\n\tif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\n\t\t\t   data->vi.in, data->vi.in_size)) {\n\t\terror = -EINVAL;\n\t        goto exit;\n\t}\n\n\terror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\n\t\t\t    &outsize, inp);\n\n        if (error) {\n\t\tpr_warn(\"%s: Venus returns: %d for %s\\n\",\n\t\t\t__func__, error, coda_f2s(fid));\n\t\tgoto exit; \n\t}\n\n\tif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n        \n\t/* Copy out the OUT buffer. */\n        if (outp->coda_ioctl.len > data->vi.out_size) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n\t/* Copy out the OUT buffer. */\n\tif (copy_to_user(data->vi.out,\n\t\t\t (char *)outp + (long)outp->coda_ioctl.data,\n\t\t\t outp->coda_ioctl.len)) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n exit:\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nint venus_pioctl(struct super_block *sb, struct CodaFid *fid,\n\t\t unsigned int cmd, struct PioctlData *data)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;  \n\tint insize, outsize, error;\n\tint iocsize;\n\n\tinsize = VC_MAXMSGSIZE;\n\tUPARG(CODA_IOCTL);\n\n        /* build packet for Venus */\n        if (data->vi.in_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n        if (data->vi.out_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n        inp->coda_ioctl.VFid = *fid;\n    \n        /* the cmd field was mutated by increasing its size field to\n         * reflect the path and follow args. We need to subtract that\n         * out before sending the command to Venus.  */\n        inp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\t\n        iocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\n        inp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) <<\t16;\t\n    \n        /* in->coda_ioctl.rwflag = flag; */\n        inp->coda_ioctl.len = data->vi.in_size;\n        inp->coda_ioctl.data = (char *)(INSIZE(ioctl));\n     \n        /* get the data out of user space */\n\tif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\n\t\t\t   data->vi.in, data->vi.in_size)) {\n\t\terror = -EINVAL;\n\t        goto exit;\n\t}\n\n\terror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\n\t\t\t    &outsize, inp);\n\n        if (error) {\n\t\tpr_warn(\"%s: Venus returns: %d for %s\\n\",\n\t\t\t__func__, error, coda_f2s(fid));\n\t\tgoto exit; \n\t}\n\n\tif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n        \n\t/* Copy out the OUT buffer. */\n        if (outp->coda_ioctl.len > data->vi.out_size) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n\t/* Copy out the OUT buffer. */\n\tif (copy_to_user(data->vi.out,\n\t\t\t (char *)outp + (long)outp->coda_ioctl.data,\n\t\t\t outp->coda_ioctl.len)) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n exit:\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "target_inode"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_lpath",
          "args": [
            "data.path",
            "&path"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path",
          "args": [
            "data.path",
            "&path"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&data",
            "(void __user *)user_data",
            "sizeof(data)"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long coda_pioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long user_data);\n\nstatic long coda_pioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long user_data)\n{\n\tstruct path path;\n\tint error;\n\tstruct PioctlData data;\n\tstruct inode *inode = file_inode(filp);\n\tstruct inode *target_inode = NULL;\n\tstruct coda_inode_info *cnp;\n\n\t/* get the Pioctl data arguments from user space */\n\tif (copy_from_user(&data, (void __user *)user_data, sizeof(data)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Look up the pathname. Note that the pathname is in\n\t * user memory, and namei takes care of this\n\t */\n\tif (data.follow)\n\t\terror = user_path(data.path, &path);\n\telse\n\t\terror = user_lpath(data.path, &path);\n\n\tif (error)\n\t\treturn error;\n\n\ttarget_inode = path.dentry->d_inode;\n\n\t/* return if it is not a Coda inode */\n\tif (target_inode->i_sb != inode->i_sb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* now proceed to make the upcall */\n\tcnp = ITOC(target_inode);\n\n\terror = venus_pioctl(inode->i_sb, &(cnp->c_fid), cmd, &data);\nout:\n\tpath_put(&path);\n\treturn error;\n}"
  },
  {
    "function_name": "coda_ioctl_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/pioctl.c",
    "lines": "44-47",
    "snippet": "static int coda_ioctl_permission(struct inode *inode, int mask)\n{\n\treturn (mask & MAY_EXEC) ? -EACCES : 0;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int coda_ioctl_permission(struct inode *inode, int mask);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_ioctl_permission(struct inode *inode, int mask);\n\nstatic int coda_ioctl_permission(struct inode *inode, int mask)\n{\n\treturn (mask & MAY_EXEC) ? -EACCES : 0;\n}"
  }
]