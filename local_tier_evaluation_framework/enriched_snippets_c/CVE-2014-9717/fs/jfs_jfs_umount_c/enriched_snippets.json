[
  {
    "function_name": "jfs_umount_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_umount.c",
    "lines": "136-168",
    "snippet": "int jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmLogClose",
          "args": [
            "sb"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1458-1519",
          "snippet": "int lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct jfs_log *dummy_log;",
            "static DEFINE_MUTEX(jfs_log_mutex);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_CLEAN"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->direct_inode->i_mapping"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diSync",
          "args": [
            "sbi->ipimap"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "diSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "219-268",
          "snippet": "int diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbSync",
          "args": [
            "sbi->ipbmap"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dbSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "263-311",
          "snippet": "int dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "2"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/fs.h>\n\nint jfs_umount_rw(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\n\tif (!log)\n\t\treturn 0;\n\n\t/*\n\t * close log:\n\t *\n\t * remove file system from log active file system list.\n\t */\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * Make sure all metadata makes it to disk\n\t */\n\tdbSync(sbi->ipbmap);\n\tdiSync(sbi->ipimap);\n\n\t/*\n\t * Note that we have to do this even if sync_blockdev() will\n\t * do exactly the same a few instructions later:  We can't\n\t * mark the superblock clean before everything is flushed to\n\t * disk.\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\tupdateSuper(sb, FM_CLEAN);\n\n\treturn lmLogClose(sb);\n}"
  },
  {
    "function_name": "jfs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_umount.c",
    "lines": "50-133",
    "snippet": "int jfs_umount(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct inode *ipaimap = sbi->ipaimap;\n\tstruct inode *ipaimap2 = sbi->ipaimap2;\n\tstruct jfs_log *log;\n\tint rc = 0;\n\n\tjfs_info(\"UnMount JFS: sb:0x%p\", sb);\n\n\t/*\n\t *\tupdate superblock and close log\n\t *\n\t * if mounted read-write and log based recovery was enabled\n\t */\n\tif ((log = sbi->log))\n\t\t/*\n\t\t * Wait for outstanding transactions to be written to log:\n\t\t */\n\t\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * close fileset inode allocation map (aka fileset inode)\n\t */\n\tdiUnmount(ipimap, 0);\n\n\tdiFreeSpecial(ipimap);\n\tsbi->ipimap = NULL;\n\n\t/*\n\t * close secondary aggregate inode allocation map\n\t */\n\tipaimap2 = sbi->ipaimap2;\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 0);\n\t\tdiFreeSpecial(ipaimap2);\n\t\tsbi->ipaimap2 = NULL;\n\t}\n\n\t/*\n\t * close aggregate inode allocation map\n\t */\n\tipaimap = sbi->ipaimap;\n\tdiUnmount(ipaimap, 0);\n\tdiFreeSpecial(ipaimap);\n\tsbi->ipaimap = NULL;\n\n\t/*\n\t * close aggregate block allocation map\n\t */\n\tdbUnmount(ipbmap, 0);\n\n\tdiFreeSpecial(ipbmap);\n\tsbi->ipimap = NULL;\n\n\t/*\n\t * Make sure all metadata makes it to disk before we mark\n\t * the superblock as clean\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\t/*\n\t * ensure all file system file pages are propagated to their\n\t * home blocks on disk (and their in-memory buffer pages are\n\t * invalidated) BEFORE updating file system superblock state\n\t * (to signify file system is unmounted cleanly, and thus in\n\t * consistent state) and log superblock active file system\n\t * list (to signify skip logredo()).\n\t */\n\tif (log) {\t\t/* log = NULL if read-only mount */\n\t\tupdateSuper(sb, FM_CLEAN);\n\n\t\t/*\n\t\t * close log:\n\t\t *\n\t\t * remove file system from log active file system list.\n\t\t */\n\t\trc = lmLogClose(sb);\n\t}\n\tjfs_info(\"UnMount JFS Complete: rc = %d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"UnMount JFS Complete: rc = %d\"",
            "rc"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogClose",
          "args": [
            "sb"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1458-1519",
          "snippet": "int lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct jfs_log *dummy_log;",
            "static DEFINE_MUTEX(jfs_log_mutex);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_CLEAN"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->direct_inode->i_mapping"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diFreeSpecial",
          "args": [
            "ipbmap"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "diFreeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "562-571",
          "snippet": "void diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbUnmount",
          "args": [
            "ipbmap",
            "0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "dbUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "242-258",
          "snippet": "int dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diUnmount",
          "args": [
            "ipaimap",
            "0"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "diUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "191-213",
          "snippet": "int diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "2"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"UnMount JFS: sb:0x%p\"",
            "sb"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/fs.h>\n\nint jfs_umount(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct inode *ipimap = sbi->ipimap;\n\tstruct inode *ipaimap = sbi->ipaimap;\n\tstruct inode *ipaimap2 = sbi->ipaimap2;\n\tstruct jfs_log *log;\n\tint rc = 0;\n\n\tjfs_info(\"UnMount JFS: sb:0x%p\", sb);\n\n\t/*\n\t *\tupdate superblock and close log\n\t *\n\t * if mounted read-write and log based recovery was enabled\n\t */\n\tif ((log = sbi->log))\n\t\t/*\n\t\t * Wait for outstanding transactions to be written to log:\n\t\t */\n\t\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * close fileset inode allocation map (aka fileset inode)\n\t */\n\tdiUnmount(ipimap, 0);\n\n\tdiFreeSpecial(ipimap);\n\tsbi->ipimap = NULL;\n\n\t/*\n\t * close secondary aggregate inode allocation map\n\t */\n\tipaimap2 = sbi->ipaimap2;\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 0);\n\t\tdiFreeSpecial(ipaimap2);\n\t\tsbi->ipaimap2 = NULL;\n\t}\n\n\t/*\n\t * close aggregate inode allocation map\n\t */\n\tipaimap = sbi->ipaimap;\n\tdiUnmount(ipaimap, 0);\n\tdiFreeSpecial(ipaimap);\n\tsbi->ipaimap = NULL;\n\n\t/*\n\t * close aggregate block allocation map\n\t */\n\tdbUnmount(ipbmap, 0);\n\n\tdiFreeSpecial(ipbmap);\n\tsbi->ipimap = NULL;\n\n\t/*\n\t * Make sure all metadata makes it to disk before we mark\n\t * the superblock as clean\n\t */\n\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);\n\n\t/*\n\t * ensure all file system file pages are propagated to their\n\t * home blocks on disk (and their in-memory buffer pages are\n\t * invalidated) BEFORE updating file system superblock state\n\t * (to signify file system is unmounted cleanly, and thus in\n\t * consistent state) and log superblock active file system\n\t * list (to signify skip logredo()).\n\t */\n\tif (log) {\t\t/* log = NULL if read-only mount */\n\t\tupdateSuper(sb, FM_CLEAN);\n\n\t\t/*\n\t\t * close log:\n\t\t *\n\t\t * remove file system from log active file system list.\n\t\t */\n\t\trc = lmLogClose(sb);\n\t}\n\tjfs_info(\"UnMount JFS Complete: rc = %d\", rc);\n\treturn rc;\n}"
  }
]