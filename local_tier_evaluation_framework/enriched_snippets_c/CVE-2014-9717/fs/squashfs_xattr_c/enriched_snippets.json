[
  {
    "function_name": "squashfs_xattr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "299-316",
    "snippet": "static const struct xattr_handler *squashfs_xattr_handler(int type)\n{\n\tif (type & ~(SQUASHFS_XATTR_PREFIX_MASK | SQUASHFS_XATTR_VALUE_OOL))\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\n\tswitch (type & SQUASHFS_XATTR_PREFIX_MASK) {\n\tcase SQUASHFS_XATTR_USER:\n\t\treturn &squashfs_xattr_user_handler;\n\tcase SQUASHFS_XATTR_TRUSTED:\n\t\treturn &squashfs_xattr_trusted_handler;\n\tcase SQUASHFS_XATTR_SECURITY:\n\t\treturn &squashfs_xattr_security_handler;\n\tdefault:\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *squashfs_xattr_handler(int);",
      "static const struct xattr_handler squashfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.list\t= squashfs_user_list,\n\t.get\t= squashfs_user_get\n};",
      "static const struct xattr_handler squashfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.list\t= squashfs_trusted_list,\n\t.get\t= squashfs_trusted_get\n};",
      "static const struct xattr_handler squashfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.list\t= squashfs_security_list,\n\t.get\t= squashfs_security_get\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int);\nstatic const struct xattr_handler squashfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.list\t= squashfs_user_list,\n\t.get\t= squashfs_user_get\n};\nstatic const struct xattr_handler squashfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.list\t= squashfs_trusted_list,\n\t.get\t= squashfs_trusted_get\n};\nstatic const struct xattr_handler squashfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.list\t= squashfs_security_list,\n\t.get\t= squashfs_security_get\n};\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int type)\n{\n\tif (type & ~(SQUASHFS_XATTR_PREFIX_MASK | SQUASHFS_XATTR_VALUE_OOL))\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\n\tswitch (type & SQUASHFS_XATTR_PREFIX_MASK) {\n\tcase SQUASHFS_XATTR_USER:\n\t\treturn &squashfs_xattr_user_handler;\n\tcase SQUASHFS_XATTR_TRUSTED:\n\t\treturn &squashfs_xattr_trusted_handler;\n\tcase SQUASHFS_XATTR_SECURITY:\n\t\treturn &squashfs_xattr_security_handler;\n\tdefault:\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "squashfs_security_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "283-291",
    "snippet": "static int squashfs_security_get(struct dentry *d, const char *name,\n\tvoid *buffer, size_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_SECURITY, name,\n\t\tbuffer, size);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_xattr_get",
          "args": [
            "d->d_inode",
            "SQUASHFS_XATTR_SECURITY",
            "name",
            "buffer",
            "size"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
          "lines": "117-212",
          "snippet": "static int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_security_get(struct dentry *d, const char *name,\n\tvoid *buffer, size_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_SECURITY, name,\n\t\tbuffer, size);\n}"
  },
  {
    "function_name": "squashfs_security_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "275-281",
    "snippet": "static size_t squashfs_security_list(struct dentry *d, char *list,\n\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tif (list && XATTR_SECURITY_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN);\n\treturn XATTR_SECURITY_PREFIX_LEN;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic size_t squashfs_security_list(struct dentry *d, char *list,\n\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tif (list && XATTR_SECURITY_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN);\n\treturn XATTR_SECURITY_PREFIX_LEN;\n}"
  },
  {
    "function_name": "squashfs_trusted_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "256-264",
    "snippet": "static int squashfs_trusted_get(struct dentry *d, const char *name,\n\tvoid *buffer, size_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_TRUSTED, name,\n\t\tbuffer, size);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_xattr_get",
          "args": [
            "d->d_inode",
            "SQUASHFS_XATTR_TRUSTED",
            "name",
            "buffer",
            "size"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
          "lines": "117-212",
          "snippet": "static int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_trusted_get(struct dentry *d, const char *name,\n\tvoid *buffer, size_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_TRUSTED, name,\n\t\tbuffer, size);\n}"
  },
  {
    "function_name": "squashfs_trusted_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "245-254",
    "snippet": "static size_t squashfs_trusted_list(struct dentry *d, char *list,\n\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tif (list && XATTR_TRUSTED_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n\treturn XATTR_TRUSTED_PREFIX_LEN;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic size_t squashfs_trusted_list(struct dentry *d, char *list,\n\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tif (list && XATTR_TRUSTED_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n\treturn XATTR_TRUSTED_PREFIX_LEN;\n}"
  },
  {
    "function_name": "squashfs_user_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "226-234",
    "snippet": "static int squashfs_user_get(struct dentry *d, const char *name, void *buffer,\n\tsize_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_USER, name,\n\t\tbuffer, size);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_xattr_get",
          "args": [
            "d->d_inode",
            "SQUASHFS_XATTR_USER",
            "name",
            "buffer",
            "size"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
          "lines": "117-212",
          "snippet": "static int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_user_get(struct dentry *d, const char *name, void *buffer,\n\tsize_t size, int type)\n{\n\tif (name[0] == '\\0')\n\t\treturn  -EINVAL;\n\n\treturn squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_USER, name,\n\t\tbuffer, size);\n}"
  },
  {
    "function_name": "squashfs_user_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "218-224",
    "snippet": "static size_t squashfs_user_list(struct dentry *d, char *list, size_t list_size,\n\tconst char *name, size_t name_len, int type)\n{\n\tif (list && XATTR_USER_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\treturn XATTR_USER_PREFIX_LEN;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic size_t squashfs_user_list(struct dentry *d, char *list, size_t list_size,\n\tconst char *name, size_t name_len, int type)\n{\n\tif (list && XATTR_USER_PREFIX_LEN <= list_size)\n\t\tmemcpy(list, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\treturn XATTR_USER_PREFIX_LEN;\n}"
  },
  {
    "function_name": "squashfs_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "117-212",
    "snippet": "static int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "target"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "NULL",
            "&start",
            "&offset",
            "le32_to_cpu(val.vsize)"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "val.vsize"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_OFFSET",
          "args": [
            "xattr"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLK",
          "args": [
            "xattr"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xattr_val"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "target",
            "name",
            "name_size"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "name_len",
            "GFP_KERNEL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_OFFSET",
          "args": [
            "squashfs_i(inode)->xattr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLK",
          "args": [
            "squashfs_i(inode)->xattr"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t/* loop reading each xattr name */\n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t/* found xattr */\n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t/* val is a reference to the real location */\n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t/* read xattr value */\n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* no match, skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}"
  },
  {
    "function_name": "squashfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
    "lines": "39-114",
    "snippet": "ssize_t squashfs_listxattr(struct dentry *d, char *buffer,\n\tsize_t buffer_size)\n{\n\tstruct inode *inode = d->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tsize_t rest = buffer_size;\n\tint err;\n\n\t/* check that the file system has xattrs */\n\tif (msblk->xattr_id_table == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* loop reading each xattr name */\n\twhile (count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tconst struct xattr_handler *handler;\n\t\tint name_size, prefix_size = 0;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\thandler = squashfs_xattr_handler(le16_to_cpu(entry.type));\n\t\tif (handler)\n\t\t\tprefix_size = handler->list(d, buffer, rest, NULL,\n\t\t\t\tname_size, handler->flags);\n\t\tif (prefix_size) {\n\t\t\tif (buffer) {\n\t\t\t\tif (prefix_size + name_size + 1 > rest) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tbuffer += prefix_size;\n\t\t\t}\n\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t\tif (buffer) {\n\t\t\t\tbuffer[name_size] = '\\0';\n\t\t\t\tbuffer += name_size + 1;\n\t\t\t}\n\t\t\trest -= prefix_size + name_size + 1;\n\t\t} else  {\n\t\t\t/* no handler or insuffficient privileges, so skip */\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\n\n\t\t/* skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = buffer_size - rest;\n\nfailed:\n\treturn err;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *squashfs_xattr_handler(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "NULL",
            "&start",
            "&offset",
            "le32_to_cpu(val.vsize)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "val.vsize"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "d",
            "buffer",
            "rest",
            "NULL",
            "name_size",
            "handler->flags"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_xattr_handler",
          "args": [
            "le16_to_cpu(entry.type)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_xattr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr.c",
          "lines": "299-316",
          "snippet": "static const struct xattr_handler *squashfs_xattr_handler(int type)\n{\n\tif (type & ~(SQUASHFS_XATTR_PREFIX_MASK | SQUASHFS_XATTR_VALUE_OOL))\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\n\tswitch (type & SQUASHFS_XATTR_PREFIX_MASK) {\n\tcase SQUASHFS_XATTR_USER:\n\t\treturn &squashfs_xattr_user_handler;\n\tcase SQUASHFS_XATTR_TRUSTED:\n\t\treturn &squashfs_xattr_trusted_handler;\n\tcase SQUASHFS_XATTR_SECURITY:\n\t\treturn &squashfs_xattr_security_handler;\n\tdefault:\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *squashfs_xattr_handler(int);",
            "static const struct xattr_handler squashfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.list\t= squashfs_user_list,\n\t.get\t= squashfs_user_get\n};",
            "static const struct xattr_handler squashfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.list\t= squashfs_trusted_list,\n\t.get\t= squashfs_trusted_get\n};",
            "static const struct xattr_handler squashfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.list\t= squashfs_security_list,\n\t.get\t= squashfs_security_get\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int);\nstatic const struct xattr_handler squashfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.list\t= squashfs_user_list,\n\t.get\t= squashfs_user_get\n};\nstatic const struct xattr_handler squashfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.list\t= squashfs_trusted_list,\n\t.get\t= squashfs_trusted_get\n};\nstatic const struct xattr_handler squashfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.list\t= squashfs_security_list,\n\t.get\t= squashfs_security_get\n};\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int type)\n{\n\tif (type & ~(SQUASHFS_XATTR_PREFIX_MASK | SQUASHFS_XATTR_VALUE_OOL))\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\n\tswitch (type & SQUASHFS_XATTR_PREFIX_MASK) {\n\tcase SQUASHFS_XATTR_USER:\n\t\treturn &squashfs_xattr_user_handler;\n\tcase SQUASHFS_XATTR_TRUSTED:\n\t\treturn &squashfs_xattr_trusted_handler;\n\tcase SQUASHFS_XATTR_SECURITY:\n\t\treturn &squashfs_xattr_security_handler;\n\tdefault:\n\t\t/* ignore unrecognised type */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_OFFSET",
          "args": [
            "squashfs_i(inode)->xattr"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLK",
          "args": [
            "squashfs_i(inode)->xattr"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int);\n\nssize_t squashfs_listxattr(struct dentry *d, char *buffer,\n\tsize_t buffer_size)\n{\n\tstruct inode *inode = d->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tsize_t rest = buffer_size;\n\tint err;\n\n\t/* check that the file system has xattrs */\n\tif (msblk->xattr_id_table == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* loop reading each xattr name */\n\twhile (count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tconst struct xattr_handler *handler;\n\t\tint name_size, prefix_size = 0;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\thandler = squashfs_xattr_handler(le16_to_cpu(entry.type));\n\t\tif (handler)\n\t\t\tprefix_size = handler->list(d, buffer, rest, NULL,\n\t\t\t\tname_size, handler->flags);\n\t\tif (prefix_size) {\n\t\t\tif (buffer) {\n\t\t\t\tif (prefix_size + name_size + 1 > rest) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tbuffer += prefix_size;\n\t\t\t}\n\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t\tif (buffer) {\n\t\t\t\tbuffer[name_size] = '\\0';\n\t\t\t\tbuffer += name_size + 1;\n\t\t\t}\n\t\t\trest -= prefix_size + name_size + 1;\n\t\t} else  {\n\t\t\t/* no handler or insuffficient privileges, so skip */\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\n\n\t\t/* skip remaining xattr entry */\n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = buffer_size - rest;\n\nfailed:\n\treturn err;\n}"
  }
]