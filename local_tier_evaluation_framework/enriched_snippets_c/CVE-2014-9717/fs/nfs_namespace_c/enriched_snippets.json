[
  {
    "function_name": "nfs_submount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "275-288",
    "snippet": "struct vfsmount *nfs_submount(struct nfs_server *server, struct dentry *dentry,\n\t\t\t      struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tint err;\n\tstruct dentry *parent = dget_parent(dentry);\n\n\t/* Look it up again to get its attributes */\n\terr = server->nfs_client->rpc_ops->lookup(parent->d_inode, &dentry->d_name, fh, fattr, NULL);\n\tdput(parent);\n\tif (err != 0)\n\t\treturn ERR_PTR(err);\n\n\treturn nfs_do_submount(dentry, fh, fattr, server->client->cl_auth->au_flavor);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_do_submount",
          "args": [
            "dentry",
            "fh",
            "fattr",
            "server->client->cl_auth->au_flavor"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_submount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
          "lines": "240-272",
          "snippet": "struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstruct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->nfs_client->rpc_ops->lookup",
          "args": [
            "parent->d_inode",
            "&dentry->d_name",
            "fh",
            "fattr",
            "NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstruct vfsmount *nfs_submount(struct nfs_server *server, struct dentry *dentry,\n\t\t\t      struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tint err;\n\tstruct dentry *parent = dget_parent(dentry);\n\n\t/* Look it up again to get its attributes */\n\terr = server->nfs_client->rpc_ops->lookup(parent->d_inode, &dentry->d_name, fh, fattr, NULL);\n\tdput(parent);\n\tif (err != 0)\n\t\treturn ERR_PTR(err);\n\n\treturn nfs_do_submount(dentry, fh, fattr, server->client->cl_auth->au_flavor);\n}"
  },
  {
    "function_name": "nfs_do_submount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "240-272",
    "snippet": "struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- nfs_do_submount() = %p\\n\"",
            "mnt"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done\\n\"",
            "__func__"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_clone_mount",
          "args": [
            "NFS_SB(dentry->d_sb)",
            "devname",
            "&mountdata"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_clone_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
          "lines": "225-230",
          "snippet": "static struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\n\t\t\t\t\t   const char *devname,\n\t\t\t\t\t   struct nfs_clone_mount *mountdata)\n{\n\treturn vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\n\t\t\t\t\t   const char *devname,\n\t\t\t\t\t   struct nfs_clone_mount *mountdata)\n{\n\treturn vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "devname"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_devname",
          "args": [
            "dentry",
            "page",
            "PAGE_SIZE"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_devname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "540-545",
          "snippet": "static inline char *nfs_devname(struct dentry *dentry,\n\t\t\t\tchar *buffer, ssize_t buflen)\n{\n\tchar *dummy;\n\treturn nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [
            "#define NFS_PATH_CANONICAL 1"
          ],
          "globals_used": [
            "struct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);",
            "int nfs_rmdir(struct inode *, struct dentry *);",
            "int nfs_unlink(struct inode *, struct dentry *);",
            "int nfs_symlink(struct inode *, struct dentry *, const char *);",
            "int nfs_link(struct dentry *, struct inode *, struct dentry *);",
            "int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);",
            "int  nfs_show_options(struct seq_file *, struct dentry *);",
            "int  nfs_show_devname(struct seq_file *, struct dentry *);",
            "int  nfs_show_path(struct seq_file *, struct dentry *);",
            "int  nfs_show_stats(struct seq_file *, struct dentry *);",
            "extern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\n#define NFS_PATH_CANONICAL 1\n\nstruct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);\nint nfs_rmdir(struct inode *, struct dentry *);\nint nfs_unlink(struct inode *, struct dentry *);\nint nfs_symlink(struct inode *, struct dentry *, const char *);\nint nfs_link(struct dentry *, struct inode *, struct dentry *);\nint nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);\nint  nfs_show_options(struct seq_file *, struct dentry *);\nint  nfs_show_devname(struct seq_file *, struct dentry *);\nint  nfs_show_path(struct seq_file *, struct dentry *);\nint  nfs_show_stats(struct seq_file *, struct dentry *);\nextern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);\n\nstatic inline char *nfs_devname(struct dentry *dentry,\n\t\t\t\tchar *buffer, ssize_t buflen)\n{\n\tchar *dummy;\n\treturn nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: submounting on %pd2\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> nfs_do_submount()\\n\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_USER"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstruct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}"
  },
  {
    "function_name": "nfs_do_clone_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "225-230",
    "snippet": "static struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\n\t\t\t\t\t   const char *devname,\n\t\t\t\t\t   struct nfs_clone_mount *mountdata)\n{\n\treturn vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "&nfs_xdev_fs_type",
            "0",
            "devname",
            "mountdata"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\n\t\t\t\t\t   const char *devname,\n\t\t\t\t\t   struct nfs_clone_mount *mountdata)\n{\n\treturn vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);\n}"
  },
  {
    "function_name": "nfs_release_automount_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "216-220",
    "snippet": "void nfs_release_automount_timer(void)\n{\n\tif (list_empty(&nfs_automount_list))\n\t\tcancel_delayed_work(&nfs_automount_task);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nfs_automount_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&nfs_automount_task"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nfs_automount_list"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nfs_automount_list);\n\nvoid nfs_release_automount_timer(void)\n{\n\tif (list_empty(&nfs_automount_list))\n\t\tcancel_delayed_work(&nfs_automount_task);\n}"
  },
  {
    "function_name": "nfs_expire_automounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "207-214",
    "snippet": "static void nfs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &nfs_automount_list;\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list))\n\t\tschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_expire_automounts(struct work_struct *work);",
      "static LIST_HEAD(nfs_automount_list);",
      "static DECLARE_DELAYED_WORK(nfs_automount_task, nfs_expire_automounts);",
      "int nfs_mountpoint_expiry_timeout = 500 * HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&nfs_automount_task",
            "nfs_mountpoint_expiry_timeout"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mounts_for_expiry",
          "args": [
            "list"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mounts_for_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2406-2436",
          "snippet": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic void nfs_expire_automounts(struct work_struct *work);\nstatic LIST_HEAD(nfs_automount_list);\nstatic DECLARE_DELAYED_WORK(nfs_automount_task, nfs_expire_automounts);\nint nfs_mountpoint_expiry_timeout = 500 * HZ;\n\nstatic void nfs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &nfs_automount_list;\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list))\n\t\tschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\n}"
  },
  {
    "function_name": "nfs_namespace_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "189-195",
    "snippet": "static int\nnfs_namespace_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tif (NFS_FH(dentry->d_inode)->size != 0)\n\t\treturn nfs_setattr(dentry, attr);\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_setattr",
          "args": [
            "dentry",
            "attr"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "495-548",
          "snippet": "int\nnfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct nfs_fattr *fattr;\n\tint error = -ENOMEM;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tloff_t i_size;\n\n\t\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\t\ti_size = i_size_read(inode);\n\t\tif (attr->ia_size == i_size)\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\telse if (attr->ia_size < i_size && IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tattr->ia_valid &= NFS_VALID_ATTRS;\n\tif ((attr->ia_valid & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\ttrace_nfs_setattr_enter(inode);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tnfs_inode_dio_wait(inode);\n\t\tnfs_wb_all(inode);\n\t}\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\t/*\n\t * Return any delegations if we're going to change ACLs\n\t */\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\terror = NFS_PROTO(inode)->setattr(dentry, fattr, attr);\n\tif (error == 0)\n\t\terror = nfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\ttrace_nfs_setattr_exit(inode, error);\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)"
          ],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint\nnfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct nfs_fattr *fattr;\n\tint error = -ENOMEM;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tloff_t i_size;\n\n\t\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\t\ti_size = i_size_read(inode);\n\t\tif (attr->ia_size == i_size)\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\telse if (attr->ia_size < i_size && IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tattr->ia_valid &= NFS_VALID_ATTRS;\n\tif ((attr->ia_valid & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\ttrace_nfs_setattr_enter(inode);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tnfs_inode_dio_wait(inode);\n\t\tnfs_wb_all(inode);\n\t}\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\t/*\n\t * Return any delegations if we're going to change ACLs\n\t */\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\terror = NFS_PROTO(inode)->setattr(dentry, fattr, attr);\n\tif (error == 0)\n\t\terror = nfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\ttrace_nfs_setattr_exit(inode, error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "dentry->d_inode"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic int\nnfs_namespace_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tif (NFS_FH(dentry->d_inode)->size != 0)\n\t\treturn nfs_setattr(dentry, attr);\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "nfs_namespace_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "180-187",
    "snippet": "static int\nnfs_namespace_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tif (NFS_FH(dentry->d_inode)->size != 0)\n\t\treturn nfs_getattr(mnt, dentry, stat);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_getattr",
          "args": [
            "mnt",
            "dentry",
            "stat"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "638-680",
          "snippet": "int nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;\n\tint err = 0;\n\n\ttrace_nfs_getattr_enter(inode);\n\t/* Flush out writes to the server in order to update c/mtime.  */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tnfs_inode_dio_wait(inode);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets MS_NOATIME or MS_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n \tif ((mnt->mnt_flags & MNT_NOATIME) ||\n \t    ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\tneed_atime = 0;\n\n\tif (need_atime || nfs_need_revalidate_inode(inode)) {\n\t\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\t\tif (server->caps & NFS_CAP_READDIRPLUS)\n\t\t\tnfs_request_parent_use_readdirplus(dentry);\n\t\terr = __nfs_revalidate_inode(server, inode);\n\t}\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\t}\nout:\n\ttrace_nfs_getattr_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;\n\tint err = 0;\n\n\ttrace_nfs_getattr_enter(inode);\n\t/* Flush out writes to the server in order to update c/mtime.  */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tnfs_inode_dio_wait(inode);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets MS_NOATIME or MS_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n \tif ((mnt->mnt_flags & MNT_NOATIME) ||\n \t    ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\tneed_atime = 0;\n\n\tif (need_atime || nfs_need_revalidate_inode(inode)) {\n\t\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\t\tif (server->caps & NFS_CAP_READDIRPLUS)\n\t\t\tnfs_request_parent_use_readdirplus(dentry);\n\t\terr = __nfs_revalidate_inode(server, inode);\n\t}\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\t}\nout:\n\ttrace_nfs_getattr_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "dentry->d_inode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic int\nnfs_namespace_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tif (NFS_FH(dentry->d_inode)->size != 0)\n\t\treturn nfs_getattr(mnt, dentry, stat);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_d_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "139-178",
    "snippet": "struct vfsmount *nfs_d_automount(struct path *path)\n{\n\tstruct vfsmount *mnt;\n\tstruct nfs_server *server = NFS_SERVER(path->dentry->d_inode);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\n\tdprintk(\"--> nfs_d_automount()\\n\");\n\n\tmnt = ERR_PTR(-ESTALE);\n\tif (IS_ROOT(path->dentry))\n\t\tgoto out_nofree;\n\n\tmnt = ERR_PTR(-ENOMEM);\n\tfh = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fh == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tmnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);\n\tif (IS_ERR(mnt))\n\t\tgoto out;\n\n\tdprintk(\"%s: done, success\\n\", __func__);\n\tmntget(mnt); /* prevent immediate expiration */\n\tmnt_set_expiry(mnt, &nfs_automount_list);\n\tschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\n\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fh);\nout_nofree:\n\tif (IS_ERR(mnt))\n\t\tdprintk(\"<-- %s(): error %ld\\n\", __func__, PTR_ERR(mnt));\n\telse\n\t\tdprintk(\"<-- %s() = %p\\n\", __func__, mnt);\n\treturn mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nfs_automount_list);",
      "int nfs_mountpoint_expiry_timeout = 500 * HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s() = %p\\n\"",
            "__func__",
            "mnt"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s(): error %ld\\n\"",
            "__func__",
            "PTR_ERR(mnt)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "fh"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&nfs_automount_task",
            "nfs_mountpoint_expiry_timeout"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_set_expiry",
          "args": [
            "mnt",
            "&nfs_automount_list"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2391-2398",
          "snippet": "void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "mnt"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done, success\\n\"",
            "__func__"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->nfs_client->rpc_ops->submount",
          "args": [
            "server",
            "path->dentry",
            "fh",
            "fattr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: enter\\n\"",
            "__func__"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fhandle",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1323-1331",
          "snippet": "struct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> nfs_d_automount()\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "path->dentry->d_inode"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nfs_automount_list);\nint nfs_mountpoint_expiry_timeout = 500 * HZ;\n\nstruct vfsmount *nfs_d_automount(struct path *path)\n{\n\tstruct vfsmount *mnt;\n\tstruct nfs_server *server = NFS_SERVER(path->dentry->d_inode);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\n\tdprintk(\"--> nfs_d_automount()\\n\");\n\n\tmnt = ERR_PTR(-ESTALE);\n\tif (IS_ROOT(path->dentry))\n\t\tgoto out_nofree;\n\n\tmnt = ERR_PTR(-ENOMEM);\n\tfh = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fh == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tmnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);\n\tif (IS_ERR(mnt))\n\t\tgoto out;\n\n\tdprintk(\"%s: done, success\\n\", __func__);\n\tmntget(mnt); /* prevent immediate expiration */\n\tmnt_set_expiry(mnt, &nfs_automount_list);\n\tschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\n\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fh);\nout_nofree:\n\tif (IS_ERR(mnt))\n\t\tdprintk(\"<-- %s(): error %ld\\n\", __func__, PTR_ERR(mnt));\n\telse\n\t\tdprintk(\"<-- %s() = %p\\n\", __func__, mnt);\n\treturn mnt;\n}"
  },
  {
    "function_name": "nfs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
    "lines": "50-124",
    "snippet": "char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "end",
            "base",
            "namelen"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "end",
            "dentry->d_name.name",
            "namelen"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nchar *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
  }
]