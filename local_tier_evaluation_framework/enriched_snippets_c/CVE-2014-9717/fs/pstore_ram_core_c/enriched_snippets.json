[
  {
    "function_name": "persistent_ram_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "514-539",
    "snippet": "struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_free",
          "args": [
            "prz"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "496-512",
          "snippet": "void persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_post_init",
          "args": [
            "prz",
            "sig",
            "ecc_info"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_post_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "463-494",
          "snippet": "static int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\n\t\t\t\t    struct persistent_ram_ecc_info *ecc_info)\n{\n\tint ret;\n\n\tret = persistent_ram_init_ecc(prz, ecc_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsig ^= PERSISTENT_RAM_SIG;\n\n\tif (prz->buffer->sig == sig) {\n\t\tif (buffer_size(prz) > prz->buffer_size ||\n\t\t    buffer_start(prz) > buffer_size(prz))\n\t\t\tpr_info(\"found existing invalid buffer, size %zu, start %zu\\n\",\n\t\t\t\tbuffer_size(prz), buffer_start(prz));\n\t\telse {\n\t\t\tpr_debug(\"found existing buffer, size %zu, start %zu\\n\",\n\t\t\t\t buffer_size(prz), buffer_start(prz));\n\t\t\tpersistent_ram_save_old(prz);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tpr_debug(\"no valid data in buffer (sig = 0x%08x)\\n\",\n\t\t\t prz->buffer->sig);\n\t}\n\n\tprz->buffer->sig = sig;\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define PERSISTENT_RAM_SIG (0x43474244) /* DBGC */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\n#define PERSISTENT_RAM_SIG (0x43474244) /* DBGC */\n\nstatic int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\n\t\t\t\t    struct persistent_ram_ecc_info *ecc_info)\n{\n\tint ret;\n\n\tret = persistent_ram_init_ecc(prz, ecc_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsig ^= PERSISTENT_RAM_SIG;\n\n\tif (prz->buffer->sig == sig) {\n\t\tif (buffer_size(prz) > prz->buffer_size ||\n\t\t    buffer_start(prz) > buffer_size(prz))\n\t\t\tpr_info(\"found existing invalid buffer, size %zu, start %zu\\n\",\n\t\t\t\tbuffer_size(prz), buffer_start(prz));\n\t\telse {\n\t\t\tpr_debug(\"found existing buffer, size %zu, start %zu\\n\",\n\t\t\t\t buffer_size(prz), buffer_start(prz));\n\t\t\tpersistent_ram_save_old(prz);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tpr_debug(\"no valid data in buffer (sig = 0x%08x)\\n\",\n\t\t\t prz->buffer->sig);\n\t}\n\n\tprz->buffer->sig = sig;\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_buffer_map",
          "args": [
            "start",
            "size",
            "prz",
            "memtype"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_buffer_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "440-461",
          "snippet": "static int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\n\t\tstruct persistent_ram_zone *prz, int memtype)\n{\n\tprz->paddr = start;\n\tprz->size = size;\n\n\tif (pfn_valid(start >> PAGE_SHIFT))\n\t\tprz->vaddr = persistent_ram_vmap(start, size, memtype);\n\telse\n\t\tprz->vaddr = persistent_ram_iomap(start, size, memtype);\n\n\tif (!prz->vaddr) {\n\t\tpr_err(\"%s: Failed to map 0x%llx pages at 0x%llx\\n\", __func__,\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->buffer = prz->vaddr + offset_in_page(start);\n\tprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\n\t\tstruct persistent_ram_zone *prz, int memtype)\n{\n\tprz->paddr = start;\n\tprz->size = size;\n\n\tif (pfn_valid(start >> PAGE_SHIFT))\n\t\tprz->vaddr = persistent_ram_vmap(start, size, memtype);\n\telse\n\t\tprz->vaddr = persistent_ram_iomap(start, size, memtype);\n\n\tif (!prz->vaddr) {\n\t\tpr_err(\"%s: Failed to map 0x%llx pages at 0x%llx\\n\", __func__,\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->buffer = prz->vaddr + offset_in_page(start);\n\tprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to allocate persistent ram zone\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct persistent_ram_zone)",
            "GFP_KERNEL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstruct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "persistent_ram_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "496-512",
    "snippet": "void persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prz"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_free_old",
          "args": [
            "prz"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_free_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "369-374",
          "snippet": "void persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_mem_region",
          "args": [
            "prz->paddr",
            "prz->size"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "prz->vaddr"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "prz->vaddr"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "prz->paddr >> PAGE_SHIFT"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}"
  },
  {
    "function_name": "persistent_ram_post_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "463-494",
    "snippet": "static int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\n\t\t\t\t    struct persistent_ram_ecc_info *ecc_info)\n{\n\tint ret;\n\n\tret = persistent_ram_init_ecc(prz, ecc_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsig ^= PERSISTENT_RAM_SIG;\n\n\tif (prz->buffer->sig == sig) {\n\t\tif (buffer_size(prz) > prz->buffer_size ||\n\t\t    buffer_start(prz) > buffer_size(prz))\n\t\t\tpr_info(\"found existing invalid buffer, size %zu, start %zu\\n\",\n\t\t\t\tbuffer_size(prz), buffer_start(prz));\n\t\telse {\n\t\t\tpr_debug(\"found existing buffer, size %zu, start %zu\\n\",\n\t\t\t\t buffer_size(prz), buffer_start(prz));\n\t\t\tpersistent_ram_save_old(prz);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tpr_debug(\"no valid data in buffer (sig = 0x%08x)\\n\",\n\t\t\t prz->buffer->sig);\n\t}\n\n\tprz->buffer->sig = sig;\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define PERSISTENT_RAM_SIG (0x43474244) /* DBGC */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_zap",
          "args": [
            "prz"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "376-381",
          "snippet": "void persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"no valid data in buffer (sig = 0x%08x)\\n\"",
            "prz->buffer->sig"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_save_old",
          "args": [
            "prz"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_save_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "306-327",
          "snippet": "void persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nvoid persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"found existing buffer, size %zu, start %zu\\n\"",
            "buffer_size(prz)",
            "buffer_start(prz)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_start",
          "args": [
            "prz"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "45-48",
          "snippet": "static inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_size",
          "args": [
            "prz"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "40-43",
          "snippet": "static inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"found existing invalid buffer, size %zu, start %zu\\n\"",
            "buffer_size(prz)",
            "buffer_start(prz)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_init_ecc",
          "args": [
            "prz",
            "ecc_info"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_init_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "221-278",
          "snippet": "static int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\n\t\t\t\t   struct persistent_ram_ecc_info *ecc_info)\n{\n\tint numerr;\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tint ecc_blocks;\n\tsize_t ecc_total;\n\n\tif (!ecc_info || !ecc_info->ecc_size)\n\t\treturn 0;\n\n\tprz->ecc_info.block_size = ecc_info->block_size ?: 128;\n\tprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\n\tprz->ecc_info.symsize = ecc_info->symsize ?: 8;\n\tprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\n\n\tecc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\n\t\t\t\t  prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size);\n\tecc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\n\tif (ecc_total >= prz->buffer_size) {\n\t\tpr_err(\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\",\n\t\t       __func__, prz->ecc_info.ecc_size,\n\t\t       ecc_total, prz->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprz->buffer_size -= ecc_total;\n\tprz->par_buffer = buffer->data + prz->buffer_size;\n\tprz->par_header = prz->par_buffer +\n\t\t\t  ecc_blocks * prz->ecc_info.ecc_size;\n\n\t/*\n\t * first consecutive root is 0\n\t * primitive element to generate roots = 1\n\t */\n\tprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\n\t\t\t\t  0, 1, prz->ecc_info.ecc_size);\n\tif (prz->rs_decoder == NULL) {\n\t\tpr_info(\"init_rs failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprz->corrected_bytes = 0;\n\tprz->bad_blocks = 0;\n\n\tnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\n\t\t\t\t\t   prz->par_header);\n\tif (numerr > 0) {\n\t\tpr_info(\"error in header, %d\\n\", numerr);\n\t\tprz->corrected_bytes += numerr;\n\t} else if (numerr < 0) {\n\t\tpr_info(\"uncorrectable error in header\\n\");\n\t\tprz->bad_blocks++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\n\t\t\t\t   struct persistent_ram_ecc_info *ecc_info)\n{\n\tint numerr;\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tint ecc_blocks;\n\tsize_t ecc_total;\n\n\tif (!ecc_info || !ecc_info->ecc_size)\n\t\treturn 0;\n\n\tprz->ecc_info.block_size = ecc_info->block_size ?: 128;\n\tprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\n\tprz->ecc_info.symsize = ecc_info->symsize ?: 8;\n\tprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\n\n\tecc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\n\t\t\t\t  prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size);\n\tecc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\n\tif (ecc_total >= prz->buffer_size) {\n\t\tpr_err(\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\",\n\t\t       __func__, prz->ecc_info.ecc_size,\n\t\t       ecc_total, prz->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprz->buffer_size -= ecc_total;\n\tprz->par_buffer = buffer->data + prz->buffer_size;\n\tprz->par_header = prz->par_buffer +\n\t\t\t  ecc_blocks * prz->ecc_info.ecc_size;\n\n\t/*\n\t * first consecutive root is 0\n\t * primitive element to generate roots = 1\n\t */\n\tprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\n\t\t\t\t  0, 1, prz->ecc_info.ecc_size);\n\tif (prz->rs_decoder == NULL) {\n\t\tpr_info(\"init_rs failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprz->corrected_bytes = 0;\n\tprz->bad_blocks = 0;\n\n\tnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\n\t\t\t\t\t   prz->par_header);\n\tif (numerr > 0) {\n\t\tpr_info(\"error in header, %d\\n\", numerr);\n\t\tprz->corrected_bytes += numerr;\n\t} else if (numerr < 0) {\n\t\tpr_info(\"uncorrectable error in header\\n\");\n\t\tprz->bad_blocks++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\n#define PERSISTENT_RAM_SIG (0x43474244) /* DBGC */\n\nstatic int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\n\t\t\t\t    struct persistent_ram_ecc_info *ecc_info)\n{\n\tint ret;\n\n\tret = persistent_ram_init_ecc(prz, ecc_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsig ^= PERSISTENT_RAM_SIG;\n\n\tif (prz->buffer->sig == sig) {\n\t\tif (buffer_size(prz) > prz->buffer_size ||\n\t\t    buffer_start(prz) > buffer_size(prz))\n\t\t\tpr_info(\"found existing invalid buffer, size %zu, start %zu\\n\",\n\t\t\t\tbuffer_size(prz), buffer_start(prz));\n\t\telse {\n\t\t\tpr_debug(\"found existing buffer, size %zu, start %zu\\n\",\n\t\t\t\t buffer_size(prz), buffer_start(prz));\n\t\t\tpersistent_ram_save_old(prz);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tpr_debug(\"no valid data in buffer (sig = 0x%08x)\\n\",\n\t\t\t prz->buffer->sig);\n\t}\n\n\tprz->buffer->sig = sig;\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "persistent_ram_buffer_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "440-461",
    "snippet": "static int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\n\t\tstruct persistent_ram_zone *prz, int memtype)\n{\n\tprz->paddr = start;\n\tprz->size = size;\n\n\tif (pfn_valid(start >> PAGE_SHIFT))\n\t\tprz->vaddr = persistent_ram_vmap(start, size, memtype);\n\telse\n\t\tprz->vaddr = persistent_ram_iomap(start, size, memtype);\n\n\tif (!prz->vaddr) {\n\t\tpr_err(\"%s: Failed to map 0x%llx pages at 0x%llx\\n\", __func__,\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->buffer = prz->vaddr + offset_in_page(start);\n\tprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed to map 0x%llx pages at 0x%llx\\n\"",
            "__func__",
            "(unsigned long long)size",
            "(unsigned long long)start"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_iomap",
          "args": [
            "start",
            "size",
            "memtype"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_iomap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "418-438",
          "snippet": "static void *persistent_ram_iomap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tvoid *va;\n\n\tif (!request_mem_region(start, size, \"persistent_ram\")) {\n\t\tpr_err(\"request mem region (0x%llx@0x%llx) failed\\n\",\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn NULL;\n\t}\n\n\tbuffer_start_add = buffer_start_add_locked;\n\tbuffer_size_add = buffer_size_add_locked;\n\n\tif (memtype)\n\t\tva = ioremap(start, size);\n\telse\n\t\tva = ioremap_wc(start, size);\n\n\treturn va;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void *persistent_ram_iomap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tvoid *va;\n\n\tif (!request_mem_region(start, size, \"persistent_ram\")) {\n\t\tpr_err(\"request mem region (0x%llx@0x%llx) failed\\n\",\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn NULL;\n\t}\n\n\tbuffer_start_add = buffer_start_add_locked;\n\tbuffer_size_add = buffer_size_add_locked;\n\n\tif (memtype)\n\t\tva = ioremap(start, size);\n\telse\n\t\tva = ioremap_wc(start, size);\n\n\treturn va;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_vmap",
          "args": [
            "start",
            "size",
            "memtype"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_vmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "383-416",
          "snippet": "static void *persistent_ram_vmap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tstruct page **pages;\n\tphys_addr_t page_start;\n\tunsigned int page_count;\n\tpgprot_t prot;\n\tunsigned int i;\n\tvoid *vaddr;\n\n\tpage_start = start - offset_in_page(start);\n\tpage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\n\n\tif (memtype)\n\t\tprot = pgprot_noncached(PAGE_KERNEL);\n\telse\n\t\tprot = pgprot_writecombine(PAGE_KERNEL);\n\n\tpages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_err(\"%s: Failed to allocate array for %u pages\\n\",\n\t\t       __func__, page_count);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tphys_addr_t addr = page_start + i * PAGE_SIZE;\n\t\tpages[i] = pfn_to_page(addr >> PAGE_SHIFT);\n\t}\n\tvaddr = vmap(pages, page_count, VM_MAP, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void *persistent_ram_vmap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tstruct page **pages;\n\tphys_addr_t page_start;\n\tunsigned int page_count;\n\tpgprot_t prot;\n\tunsigned int i;\n\tvoid *vaddr;\n\n\tpage_start = start - offset_in_page(start);\n\tpage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\n\n\tif (memtype)\n\t\tprot = pgprot_noncached(PAGE_KERNEL);\n\telse\n\t\tprot = pgprot_writecombine(PAGE_KERNEL);\n\n\tpages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_err(\"%s: Failed to allocate array for %u pages\\n\",\n\t\t       __func__, page_count);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tphys_addr_t addr = page_start + i * PAGE_SIZE;\n\t\tpages[i] = pfn_to_page(addr >> PAGE_SHIFT);\n\t}\n\tvaddr = vmap(pages, page_count, VM_MAP, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "start >> PAGE_SHIFT"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\n\t\tstruct persistent_ram_zone *prz, int memtype)\n{\n\tprz->paddr = start;\n\tprz->size = size;\n\n\tif (pfn_valid(start >> PAGE_SHIFT))\n\t\tprz->vaddr = persistent_ram_vmap(start, size, memtype);\n\telse\n\t\tprz->vaddr = persistent_ram_iomap(start, size, memtype);\n\n\tif (!prz->vaddr) {\n\t\tpr_err(\"%s: Failed to map 0x%llx pages at 0x%llx\\n\", __func__,\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn -ENOMEM;\n\t}\n\n\tprz->buffer = prz->vaddr + offset_in_page(start);\n\tprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "persistent_ram_iomap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "418-438",
    "snippet": "static void *persistent_ram_iomap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tvoid *va;\n\n\tif (!request_mem_region(start, size, \"persistent_ram\")) {\n\t\tpr_err(\"request mem region (0x%llx@0x%llx) failed\\n\",\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn NULL;\n\t}\n\n\tbuffer_start_add = buffer_start_add_locked;\n\tbuffer_size_add = buffer_size_add_locked;\n\n\tif (memtype)\n\t\tva = ioremap(start, size);\n\telse\n\t\tva = ioremap_wc(start, size);\n\n\treturn va;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioremap_wc",
          "args": [
            "start",
            "size"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "start",
            "size"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"request mem region (0x%llx@0x%llx) failed\\n\"",
            "(unsigned long long)size",
            "(unsigned long long)start"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_mem_region",
          "args": [
            "start",
            "size",
            "\"persistent_ram\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void *persistent_ram_iomap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tvoid *va;\n\n\tif (!request_mem_region(start, size, \"persistent_ram\")) {\n\t\tpr_err(\"request mem region (0x%llx@0x%llx) failed\\n\",\n\t\t\t(unsigned long long)size, (unsigned long long)start);\n\t\treturn NULL;\n\t}\n\n\tbuffer_start_add = buffer_start_add_locked;\n\tbuffer_size_add = buffer_size_add_locked;\n\n\tif (memtype)\n\t\tva = ioremap(start, size);\n\telse\n\t\tva = ioremap_wc(start, size);\n\n\treturn va;\n}"
  },
  {
    "function_name": "persistent_ram_vmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "383-416",
    "snippet": "static void *persistent_ram_vmap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tstruct page **pages;\n\tphys_addr_t page_start;\n\tunsigned int page_count;\n\tpgprot_t prot;\n\tunsigned int i;\n\tvoid *vaddr;\n\n\tpage_start = start - offset_in_page(start);\n\tpage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\n\n\tif (memtype)\n\t\tprot = pgprot_noncached(PAGE_KERNEL);\n\telse\n\t\tprot = pgprot_writecombine(PAGE_KERNEL);\n\n\tpages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_err(\"%s: Failed to allocate array for %u pages\\n\",\n\t\t       __func__, page_count);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tphys_addr_t addr = page_start + i * PAGE_SIZE;\n\t\tpages[i] = pfn_to_page(addr >> PAGE_SHIFT);\n\t}\n\tvaddr = vmap(pages, page_count, VM_MAP, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap",
          "args": [
            "pages",
            "page_count",
            "VM_MAP",
            "prot"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "addr >> PAGE_SHIFT"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed to allocate array for %u pages\\n\"",
            "__func__",
            "page_count"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "page_count",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_writecombine",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "size + offset_in_page(start)",
            "PAGE_SIZE"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void *persistent_ram_vmap(phys_addr_t start, size_t size,\n\t\tunsigned int memtype)\n{\n\tstruct page **pages;\n\tphys_addr_t page_start;\n\tunsigned int page_count;\n\tpgprot_t prot;\n\tunsigned int i;\n\tvoid *vaddr;\n\n\tpage_start = start - offset_in_page(start);\n\tpage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\n\n\tif (memtype)\n\t\tprot = pgprot_noncached(PAGE_KERNEL);\n\telse\n\t\tprot = pgprot_writecombine(PAGE_KERNEL);\n\n\tpages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_err(\"%s: Failed to allocate array for %u pages\\n\",\n\t\t       __func__, page_count);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tphys_addr_t addr = page_start + i * PAGE_SIZE;\n\t\tpages[i] = pfn_to_page(addr >> PAGE_SHIFT);\n\t}\n\tvaddr = vmap(pages, page_count, VM_MAP, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "persistent_ram_zap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "376-381",
    "snippet": "void persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_update_header_ecc",
          "args": [
            "prz"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_update_header_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "181-190",
          "snippet": "static void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&prz->buffer->size",
            "0"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&prz->buffer->start",
            "0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}"
  },
  {
    "function_name": "persistent_ram_free_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "369-374",
    "snippet": "void persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prz->old_log"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}"
  },
  {
    "function_name": "persistent_ram_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "364-367",
    "snippet": "void *persistent_ram_old(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid *persistent_ram_old(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log;\n}"
  },
  {
    "function_name": "persistent_ram_old_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "359-362",
    "snippet": "size_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}"
  },
  {
    "function_name": "persistent_ram_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "329-357",
    "snippet": "int notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_update_header_ecc",
          "args": [
            "prz"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_update_header_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "181-190",
          "snippet": "static void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_update",
          "args": [
            "prz",
            "s",
            "start",
            "c"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "298-304",
          "snippet": "static void notrace persistent_ram_update(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tmemcpy(buffer->data + start, s, count);\n\tpersistent_ram_update_ecc(prz, start, count);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void notrace persistent_ram_update(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tmemcpy(buffer->data + start, s, count);\n\tpersistent_ram_update_ecc(prz, start, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rem < c"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_start_add",
          "args": [
            "prz",
            "c"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_start_add_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "86-103",
          "snippet": "static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->start);\n\tnew = old + a;\n\twhile (unlikely(new >= prz->buffer_size))\n\t\tnew -= prz->buffer_size;\n\tatomic_set(&prz->buffer->start, new);\n\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n\n\treturn old;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(buffer_lock);",
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic DEFINE_RAW_SPINLOCK(buffer_lock);\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->start);\n\tnew = old + a;\n\twhile (unlikely(new >= prz->buffer_size))\n\t\tnew -= prz->buffer_size;\n\tatomic_set(&prz->buffer->start, new);\n\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_size_add",
          "args": [
            "prz",
            "c"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_size_add_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "106-125",
          "snippet": "static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->size);\n\tif (old == prz->buffer_size)\n\t\tgoto exit;\n\n\tnew = old + a;\n\tif (new > prz->buffer_size)\n\t\tnew = prz->buffer_size;\n\tatomic_set(&prz->buffer->size, new);\n\nexit:\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(buffer_lock);",
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic DEFINE_RAW_SPINLOCK(buffer_lock);\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->size);\n\tif (old == prz->buffer_size)\n\t\tgoto exit;\n\n\tnew = old + a;\n\tif (new > prz->buffer_size)\n\t\tnew = prz->buffer_size;\n\tatomic_set(&prz->buffer->size, new);\n\nexit:\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "c > prz->buffer_size"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nint notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}"
  },
  {
    "function_name": "persistent_ram_save_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "306-327",
    "snippet": "void persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prz->old_log + size - start",
            "&buffer->data[0]",
            "start"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prz->old_log",
            "&buffer->data[start]",
            "size - start"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to allocate buffer\\n\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_ecc_old",
          "args": [
            "prz"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_ecc_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "192-219",
          "snippet": "static void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *block;\n\tuint8_t *par;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tblock = buffer->data;\n\tpar = prz->par_buffer;\n\twhile (block < buffer->data + buffer_size(prz)) {\n\t\tint numerr;\n\t\tint size = prz->ecc_info.block_size;\n\t\tif (block + size > buffer->data + prz->buffer_size)\n\t\t\tsize = buffer->data + prz->buffer_size - block;\n\t\tnumerr = persistent_ram_decode_rs8(prz, block, size, par);\n\t\tif (numerr > 0) {\n\t\t\tpr_devel(\"error in block %p, %d\\n\", block, numerr);\n\t\t\tprz->corrected_bytes += numerr;\n\t\t} else if (numerr < 0) {\n\t\t\tpr_devel(\"uncorrectable error in block %p\\n\", block);\n\t\t\tprz->bad_blocks++;\n\t\t}\n\t\tblock += prz->ecc_info.block_size;\n\t\tpar += prz->ecc_info.ecc_size;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *block;\n\tuint8_t *par;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tblock = buffer->data;\n\tpar = prz->par_buffer;\n\twhile (block < buffer->data + buffer_size(prz)) {\n\t\tint numerr;\n\t\tint size = prz->ecc_info.block_size;\n\t\tif (block + size > buffer->data + prz->buffer_size)\n\t\t\tsize = buffer->data + prz->buffer_size - block;\n\t\tnumerr = persistent_ram_decode_rs8(prz, block, size, par);\n\t\tif (numerr > 0) {\n\t\t\tpr_devel(\"error in block %p, %d\\n\", block, numerr);\n\t\t\tprz->corrected_bytes += numerr;\n\t\t} else if (numerr < 0) {\n\t\t\tpr_devel(\"uncorrectable error in block %p\\n\", block);\n\t\t\tprz->bad_blocks++;\n\t\t}\n\t\tblock += prz->ecc_info.block_size;\n\t\tpar += prz->ecc_info.ecc_size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_start",
          "args": [
            "prz"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "45-48",
          "snippet": "static inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_size",
          "args": [
            "prz"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "40-43",
          "snippet": "static inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nvoid persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}"
  },
  {
    "function_name": "persistent_ram_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "298-304",
    "snippet": "static void notrace persistent_ram_update(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tmemcpy(buffer->data + start, s, count);\n\tpersistent_ram_update_ecc(prz, start, count);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_update_ecc",
          "args": [
            "prz",
            "start",
            "count"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_update_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "155-179",
          "snippet": "static void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\n\tunsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *buffer_end = buffer->data + prz->buffer_size;\n\tuint8_t *block;\n\tuint8_t *par;\n\tint ecc_block_size = prz->ecc_info.block_size;\n\tint ecc_size = prz->ecc_info.ecc_size;\n\tint size = ecc_block_size;\n\n\tif (!ecc_size)\n\t\treturn;\n\n\tblock = buffer->data + (start & ~(ecc_block_size - 1));\n\tpar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\n\n\tdo {\n\t\tif (block + ecc_block_size > buffer_end)\n\t\t\tsize = buffer_end - block;\n\t\tpersistent_ram_encode_rs8(prz, block, size, par);\n\t\tblock += ecc_block_size;\n\t\tpar += ecc_size;\n\t} while (block < buffer->data + start + count);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\n\tunsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *buffer_end = buffer->data + prz->buffer_size;\n\tuint8_t *block;\n\tuint8_t *par;\n\tint ecc_block_size = prz->ecc_info.block_size;\n\tint ecc_size = prz->ecc_info.ecc_size;\n\tint size = ecc_block_size;\n\n\tif (!ecc_size)\n\t\treturn;\n\n\tblock = buffer->data + (start & ~(ecc_block_size - 1));\n\tpar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\n\n\tdo {\n\t\tif (block + ecc_block_size > buffer_end)\n\t\t\tsize = buffer_end - block;\n\t\tpersistent_ram_encode_rs8(prz, block, size, par);\n\t\tblock += ecc_block_size;\n\t\tpar += ecc_size;\n\t} while (block < buffer->data + start + count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer->data + start",
            "s",
            "count"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void notrace persistent_ram_update(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tmemcpy(buffer->data + start, s, count);\n\tpersistent_ram_update_ecc(prz, start, count);\n}"
  },
  {
    "function_name": "persistent_ram_ecc_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "280-296",
    "snippet": "ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "len",
            "\"\\nNo errors detected\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "len",
            "\"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\"",
            "prz->corrected_bytes",
            "prz->bad_blocks"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "persistent_ram_init_ecc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "221-278",
    "snippet": "static int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\n\t\t\t\t   struct persistent_ram_ecc_info *ecc_info)\n{\n\tint numerr;\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tint ecc_blocks;\n\tsize_t ecc_total;\n\n\tif (!ecc_info || !ecc_info->ecc_size)\n\t\treturn 0;\n\n\tprz->ecc_info.block_size = ecc_info->block_size ?: 128;\n\tprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\n\tprz->ecc_info.symsize = ecc_info->symsize ?: 8;\n\tprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\n\n\tecc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\n\t\t\t\t  prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size);\n\tecc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\n\tif (ecc_total >= prz->buffer_size) {\n\t\tpr_err(\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\",\n\t\t       __func__, prz->ecc_info.ecc_size,\n\t\t       ecc_total, prz->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprz->buffer_size -= ecc_total;\n\tprz->par_buffer = buffer->data + prz->buffer_size;\n\tprz->par_header = prz->par_buffer +\n\t\t\t  ecc_blocks * prz->ecc_info.ecc_size;\n\n\t/*\n\t * first consecutive root is 0\n\t * primitive element to generate roots = 1\n\t */\n\tprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\n\t\t\t\t  0, 1, prz->ecc_info.ecc_size);\n\tif (prz->rs_decoder == NULL) {\n\t\tpr_info(\"init_rs failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprz->corrected_bytes = 0;\n\tprz->bad_blocks = 0;\n\n\tnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\n\t\t\t\t\t   prz->par_header);\n\tif (numerr > 0) {\n\t\tpr_info(\"error in header, %d\\n\", numerr);\n\t\tprz->corrected_bytes += numerr;\n\t} else if (numerr < 0) {\n\t\tpr_info(\"uncorrectable error in header\\n\");\n\t\tprz->bad_blocks++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"uncorrectable error in header\\n\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"error in header, %d\\n\"",
            "numerr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_decode_rs8",
          "args": [
            "prz",
            "buffer",
            "sizeof(*buffer)",
            "prz->par_header"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_decode_rs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "143-153",
          "snippet": "static int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"init_rs failed\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rs",
          "args": [
            "prz->ecc_info.symsize",
            "prz->ecc_info.poly",
            "0",
            "1",
            "prz->ecc_info.ecc_size"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\"",
            "__func__",
            "prz->ecc_info.ecc_size",
            "ecc_total",
            "prz->buffer_size"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "prz->buffer_size - prz->ecc_info.ecc_size",
            "prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\n\t\t\t\t   struct persistent_ram_ecc_info *ecc_info)\n{\n\tint numerr;\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tint ecc_blocks;\n\tsize_t ecc_total;\n\n\tif (!ecc_info || !ecc_info->ecc_size)\n\t\treturn 0;\n\n\tprz->ecc_info.block_size = ecc_info->block_size ?: 128;\n\tprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\n\tprz->ecc_info.symsize = ecc_info->symsize ?: 8;\n\tprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\n\n\tecc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\n\t\t\t\t  prz->ecc_info.block_size +\n\t\t\t\t  prz->ecc_info.ecc_size);\n\tecc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\n\tif (ecc_total >= prz->buffer_size) {\n\t\tpr_err(\"%s: invalid ecc_size %u (total %zu, buffer size %zu)\\n\",\n\t\t       __func__, prz->ecc_info.ecc_size,\n\t\t       ecc_total, prz->buffer_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprz->buffer_size -= ecc_total;\n\tprz->par_buffer = buffer->data + prz->buffer_size;\n\tprz->par_header = prz->par_buffer +\n\t\t\t  ecc_blocks * prz->ecc_info.ecc_size;\n\n\t/*\n\t * first consecutive root is 0\n\t * primitive element to generate roots = 1\n\t */\n\tprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\n\t\t\t\t  0, 1, prz->ecc_info.ecc_size);\n\tif (prz->rs_decoder == NULL) {\n\t\tpr_info(\"init_rs failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprz->corrected_bytes = 0;\n\tprz->bad_blocks = 0;\n\n\tnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\n\t\t\t\t\t   prz->par_header);\n\tif (numerr > 0) {\n\t\tpr_info(\"error in header, %d\\n\", numerr);\n\t\tprz->corrected_bytes += numerr;\n\t} else if (numerr < 0) {\n\t\tpr_info(\"uncorrectable error in header\\n\");\n\t\tprz->bad_blocks++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "persistent_ram_ecc_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "192-219",
    "snippet": "static void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *block;\n\tuint8_t *par;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tblock = buffer->data;\n\tpar = prz->par_buffer;\n\twhile (block < buffer->data + buffer_size(prz)) {\n\t\tint numerr;\n\t\tint size = prz->ecc_info.block_size;\n\t\tif (block + size > buffer->data + prz->buffer_size)\n\t\t\tsize = buffer->data + prz->buffer_size - block;\n\t\tnumerr = persistent_ram_decode_rs8(prz, block, size, par);\n\t\tif (numerr > 0) {\n\t\t\tpr_devel(\"error in block %p, %d\\n\", block, numerr);\n\t\t\tprz->corrected_bytes += numerr;\n\t\t} else if (numerr < 0) {\n\t\t\tpr_devel(\"uncorrectable error in block %p\\n\", block);\n\t\t\tprz->bad_blocks++;\n\t\t}\n\t\tblock += prz->ecc_info.block_size;\n\t\tpar += prz->ecc_info.ecc_size;\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"uncorrectable error in block %p\\n\"",
            "block"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"error in block %p, %d\\n\"",
            "block",
            "numerr"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_decode_rs8",
          "args": [
            "prz",
            "block",
            "size",
            "par"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_decode_rs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "143-153",
          "snippet": "static int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_size",
          "args": [
            "prz"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "40-43",
          "snippet": "static inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *block;\n\tuint8_t *par;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tblock = buffer->data;\n\tpar = prz->par_buffer;\n\twhile (block < buffer->data + buffer_size(prz)) {\n\t\tint numerr;\n\t\tint size = prz->ecc_info.block_size;\n\t\tif (block + size > buffer->data + prz->buffer_size)\n\t\t\tsize = buffer->data + prz->buffer_size - block;\n\t\tnumerr = persistent_ram_decode_rs8(prz, block, size, par);\n\t\tif (numerr > 0) {\n\t\t\tpr_devel(\"error in block %p, %d\\n\", block, numerr);\n\t\t\tprz->corrected_bytes += numerr;\n\t\t} else if (numerr < 0) {\n\t\t\tpr_devel(\"uncorrectable error in block %p\\n\", block);\n\t\t\tprz->bad_blocks++;\n\t\t}\n\t\tblock += prz->ecc_info.block_size;\n\t\tpar += prz->ecc_info.ecc_size;\n\t}\n}"
  },
  {
    "function_name": "persistent_ram_update_header_ecc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "181-190",
    "snippet": "static void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_encode_rs8",
          "args": [
            "prz",
            "(uint8_t *)buffer",
            "sizeof(*buffer)",
            "prz->par_header"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_encode_rs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "130-141",
          "snippet": "static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn;\n\n\tpersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\n\t\t\t\t  prz->par_header);\n}"
  },
  {
    "function_name": "persistent_ram_update_ecc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "155-179",
    "snippet": "static void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\n\tunsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *buffer_end = buffer->data + prz->buffer_size;\n\tuint8_t *block;\n\tuint8_t *par;\n\tint ecc_block_size = prz->ecc_info.block_size;\n\tint ecc_size = prz->ecc_info.ecc_size;\n\tint size = ecc_block_size;\n\n\tif (!ecc_size)\n\t\treturn;\n\n\tblock = buffer->data + (start & ~(ecc_block_size - 1));\n\tpar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\n\n\tdo {\n\t\tif (block + ecc_block_size > buffer_end)\n\t\t\tsize = buffer_end - block;\n\t\tpersistent_ram_encode_rs8(prz, block, size, par);\n\t\tblock += ecc_block_size;\n\t\tpar += ecc_size;\n\t} while (block < buffer->data + start + count);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_encode_rs8",
          "args": [
            "prz",
            "block",
            "size",
            "par"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_encode_rs8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "130-141",
          "snippet": "static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\n\tunsigned int start, unsigned int count)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tuint8_t *buffer_end = buffer->data + prz->buffer_size;\n\tuint8_t *block;\n\tuint8_t *par;\n\tint ecc_block_size = prz->ecc_info.block_size;\n\tint ecc_size = prz->ecc_info.ecc_size;\n\tint size = ecc_block_size;\n\n\tif (!ecc_size)\n\t\treturn;\n\n\tblock = buffer->data + (start & ~(ecc_block_size - 1));\n\tpar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\n\n\tdo {\n\t\tif (block + ecc_block_size > buffer_end)\n\t\t\tsize = buffer_end - block;\n\t\tpersistent_ram_encode_rs8(prz, block, size, par);\n\t\tblock += ecc_block_size;\n\t\tpar += ecc_size;\n\t} while (block < buffer->data + start + count);\n}"
  },
  {
    "function_name": "persistent_ram_decode_rs8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "143-153",
    "snippet": "static int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_rs8",
          "args": [
            "prz->rs_decoder",
            "data",
            "par",
            "len",
            "NULL",
            "0",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\n\tvoid *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tpar[i] = ecc[i];\n\treturn decode_rs8(prz->rs_decoder, data, par, len,\n\t\t\t\tNULL, 0, NULL, 0, NULL);\n}"
  },
  {
    "function_name": "persistent_ram_encode_rs8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "130-141",
    "snippet": "static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_rs8",
          "args": [
            "prz->rs_decoder",
            "data",
            "len",
            "par",
            "0"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "par",
            "0",
            "sizeof(par)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\n\tuint8_t *data, size_t len, uint8_t *ecc)\n{\n\tint i;\n\tuint16_t par[prz->ecc_info.ecc_size];\n\n\t/* Initialize the parity buffer */\n\tmemset(par, 0, sizeof(par));\n\tencode_rs8(prz->rs_decoder, data, len, par, 0);\n\tfor (i = 0; i < prz->ecc_info.ecc_size; i++)\n\t\tecc[i] = par[i];\n}"
  },
  {
    "function_name": "buffer_size_add_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "106-125",
    "snippet": "static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->size);\n\tif (old == prz->buffer_size)\n\t\tgoto exit;\n\n\tnew = old + a;\n\tif (new > prz->buffer_size)\n\t\tnew = prz->buffer_size;\n\tatomic_set(&prz->buffer->size, new);\n\nexit:\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(buffer_lock);",
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&buffer_lock",
            "flags"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&prz->buffer->size",
            "new"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&buffer_lock",
            "flags"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic DEFINE_RAW_SPINLOCK(buffer_lock);\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->size);\n\tif (old == prz->buffer_size)\n\t\tgoto exit;\n\n\tnew = old + a;\n\tif (new > prz->buffer_size)\n\t\tnew = prz->buffer_size;\n\tatomic_set(&prz->buffer->size, new);\n\nexit:\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n}"
  },
  {
    "function_name": "buffer_start_add_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "86-103",
    "snippet": "static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->start);\n\tnew = old + a;\n\twhile (unlikely(new >= prz->buffer_size))\n\t\tnew -= prz->buffer_size;\n\tatomic_set(&prz->buffer->start, new);\n\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n\n\treturn old;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(buffer_lock);",
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&buffer_lock",
            "flags"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&prz->buffer->start",
            "new"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new >= prz->buffer_size"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->start"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&buffer_lock",
            "flags"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic DEFINE_RAW_SPINLOCK(buffer_lock);\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&buffer_lock, flags);\n\n\told = atomic_read(&prz->buffer->start);\n\tnew = old + a;\n\twhile (unlikely(new >= prz->buffer_size))\n\t\tnew -= prz->buffer_size;\n\tatomic_set(&prz->buffer->start, new);\n\n\traw_spin_unlock_irqrestore(&buffer_lock, flags);\n\n\treturn old;\n}"
  },
  {
    "function_name": "buffer_size_add_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "67-81",
    "snippet": "static void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\n\tif (atomic_read(&prz->buffer->size) == prz->buffer_size)\n\t\treturn;\n\n\tdo {\n\t\told = atomic_read(&prz->buffer->size);\n\t\tnew = old + a;\n\t\tif (new > prz->buffer_size)\n\t\t\tnew = prz->buffer_size;\n\t} while (atomic_cmpxchg(&prz->buffer->size, old, new) != old);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&prz->buffer->size",
            "old",
            "new"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->size"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->size"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)\n{\n\tsize_t old;\n\tsize_t new;\n\n\tif (atomic_read(&prz->buffer->size) == prz->buffer_size)\n\t\treturn;\n\n\tdo {\n\t\told = atomic_read(&prz->buffer->size);\n\t\tnew = old + a;\n\t\tif (new > prz->buffer_size)\n\t\t\tnew = prz->buffer_size;\n\t} while (atomic_cmpxchg(&prz->buffer->size, old, new) != old);\n}"
  },
  {
    "function_name": "buffer_start_add_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "51-64",
    "snippet": "static size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\n\tdo {\n\t\told = atomic_read(&prz->buffer->start);\n\t\tnew = old + a;\n\t\twhile (unlikely(new >= prz->buffer_size))\n\t\t\tnew -= prz->buffer_size;\n\t} while (atomic_cmpxchg(&prz->buffer->start, old, new) != old);\n\n\treturn old;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&prz->buffer->start",
            "old",
            "new"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new >= prz->buffer_size"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->start"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)\n{\n\tint old;\n\tint new;\n\n\tdo {\n\t\told = atomic_read(&prz->buffer->start);\n\t\tnew = old + a;\n\t\twhile (unlikely(new >= prz->buffer_size))\n\t\t\tnew -= prz->buffer_size;\n\t} while (atomic_cmpxchg(&prz->buffer->start, old, new) != old);\n\n\treturn old;\n}"
  },
  {
    "function_name": "buffer_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "45-48",
    "snippet": "static inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->start"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_start(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->start);\n}"
  },
  {
    "function_name": "buffer_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
    "lines": "40-43",
    "snippet": "static inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/pstore_ram.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/rslib.h>",
      "#include <linux/memblock.h>",
      "#include <linux/list.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
      "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&prz->buffer->size"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstatic inline size_t buffer_size(struct persistent_ram_zone *prz)\n{\n\treturn atomic_read(&prz->buffer->size);\n}"
  }
]