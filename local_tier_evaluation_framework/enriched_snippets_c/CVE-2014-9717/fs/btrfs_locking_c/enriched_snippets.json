[
  {
    "function_name": "btrfs_assert_tree_read_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "297-300",
    "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&eb->read_locks)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->read_locks"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
  },
  {
    "function_name": "btrfs_assert_tree_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "292-295",
    "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&eb->write_locks)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->write_locks"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
  },
  {
    "function_name": "btrfs_tree_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "269-290",
    "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_writers) != 1"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&eb->write_lock_wq"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&eb->write_lock_wq"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_writers)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->write_locks"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "eb"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blockers > 1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
  },
  {
    "function_name": "btrfs_tree_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "242-264",
    "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->write_locks"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_writers)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "eb->write_lock_wq",
            "atomic_read(&eb->blocking_writers) == 0"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "eb->read_lock_wq",
            "atomic_read(&eb->blocking_readers) == 0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "175-191",
          "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "eb->write_lock_wq",
            "atomic_read(&eb->blocking_writers) == 0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "eb->read_lock_wq",
            "atomic_read(&eb->blocking_readers) == 0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
  },
  {
    "function_name": "btrfs_tree_read_unlock_blocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "218-236",
    "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->read_locks"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&eb->read_lock_wq"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&eb->read_lock_wq"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->blocking_readers) == 0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_read_locked",
          "args": [
            "eb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
  },
  {
    "function_name": "btrfs_tree_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "196-213",
    "snippet": "void btrfs_tree_read_unlock(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\tatomic_dec(&eb->spinning_readers);\n\tatomic_dec(&eb->read_locks);\n\tread_unlock(&eb->lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->read_locks"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_readers) == 0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_read_locked",
          "args": [
            "eb"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\tatomic_dec(&eb->spinning_readers);\n\tatomic_dec(&eb->read_locks);\n\tread_unlock(&eb->lock);\n}"
  },
  {
    "function_name": "btrfs_try_tree_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "175-191",
    "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->write_locks"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "175-191",
          "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_try_tree_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "154-169",
    "snippet": "int btrfs_try_tree_read_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tif (!read_trylock(&eb->lock))\n\t\treturn 0;\n\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->read_locks"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_trylock",
          "args": [
            "&eb->lock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_read_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tif (!read_trylock(&eb->lock))\n\t\treturn 0;\n\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_tree_read_lock_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "135-148",
    "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->read_locks"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_tree_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "100-128",
    "snippet": "void btrfs_tree_read_lock(struct extent_buffer *eb)\n{\nagain:\n\tBUG_ON(!atomic_read(&eb->blocking_writers) &&\n\t       current->pid == eb->lock_owner);\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) &&\n\t    current->pid == eb->lock_owner) {\n\t\t/*\n\t\t * This extent is already write-locked by our thread. We allow\n\t\t * an additional read lock to be added because it's for the same\n\t\t * thread. btrfs_find_all_roots() depends on this as it may be\n\t\t * called on a partly (write-)locked tree.\n\t\t */\n\t\tBUG_ON(eb->lock_nested);\n\t\teb->lock_nested = 1;\n\t\tread_unlock(&eb->lock);\n\t\treturn;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->read_locks"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "eb->write_lock_wq",
            "atomic_read(&eb->blocking_writers) == 0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "eb->lock_nested"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&eb->blocking_writers) &&\n\t       current->pid == eb->lock_owner"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_lock(struct extent_buffer *eb)\n{\nagain:\n\tBUG_ON(!atomic_read(&eb->blocking_writers) &&\n\t       current->pid == eb->lock_owner);\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) &&\n\t    current->pid == eb->lock_owner) {\n\t\t/*\n\t\t * This extent is already write-locked by our thread. We allow\n\t\t * an additional read lock to be added because it's for the same\n\t\t * thread. btrfs_find_all_roots() depends on this as it may be\n\t\t * called on a partly (write-)locked tree.\n\t\t */\n\t\tBUG_ON(eb->lock_nested);\n\t\teb->lock_nested = 1;\n\t\tread_unlock(&eb->lock);\n\t\treturn;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n}"
  },
  {
    "function_name": "btrfs_clear_lock_blocking_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "66-94",
    "snippet": "void btrfs_clear_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\n\tif (rw == BTRFS_WRITE_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_writers) != 1);\n\t\twrite_lock(&eb->lock);\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_inc(&eb->spinning_writers);\n\t\tif (atomic_dec_and_test(&eb->blocking_writers) &&\n\t\t    waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else if (rw == BTRFS_READ_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_readers) == 0);\n\t\tread_lock(&eb->lock);\n\t\tatomic_inc(&eb->spinning_readers);\n\t\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t\t    waitqueue_active(&eb->read_lock_wq))\n\t\t\twake_up(&eb->read_lock_wq);\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&eb->read_lock_wq"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&eb->read_lock_wq"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&eb->blocking_readers) == 0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&eb->write_lock_wq"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_writers)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&eb->lock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "175-191",
          "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&eb->blocking_writers) != 1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_clear_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\n\tif (rw == BTRFS_WRITE_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_writers) != 1);\n\t\twrite_lock(&eb->lock);\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_inc(&eb->spinning_writers);\n\t\tif (atomic_dec_and_test(&eb->blocking_writers) &&\n\t\t    waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else if (rw == BTRFS_READ_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_readers) == 0);\n\t\tread_lock(&eb->lock);\n\t\tatomic_inc(&eb->spinning_readers);\n\t\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t\t    waitqueue_active(&eb->read_lock_wq))\n\t\t\twake_up(&eb->read_lock_wq);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "btrfs_set_lock_blocking_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
    "lines": "34-60",
    "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"extent_io.h\"",
      "#include \"ctree.h\"",
      "#include <asm/bug.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_readers) == 0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_readers"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->blocking_readers"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_read_locked",
          "args": [
            "eb"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_read_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "297-300",
          "snippet": "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->read_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&eb->lock"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "eb"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->spinning_writers) != 1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->spinning_writers"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->blocking_writers"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
  }
]