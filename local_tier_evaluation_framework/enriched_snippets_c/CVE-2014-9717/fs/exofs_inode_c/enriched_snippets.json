[
  {
    "function_name": "exofs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1478-1524",
    "snippet": "void exofs_evict_inode(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/* TODO: should do better here */\n\tif (inode->i_nlink || is_bad_inode(inode))\n\t\tgoto no_delete;\n\n\tinode->i_size = 0;\n\tclear_inode(inode);\n\n\t/* if we are deleting an obj that hasn't been created yet, wait.\n\t * This also makes sure that create_done cannot be called with an\n\t * already evicted inode.\n\t */\n\twait_obj_created(oi);\n\t/* ignore the error, attempt a remove anyway */\n\n\t/* Now Remove the OSD objects */\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tios->done = delete_done;\n\tios->private = sbi;\n\n\tret = ore_remove(ios);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: ore_remove failed\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t\treturn;\n\t}\n\tatomic_inc(&sbi->s_curr_pending);\n\n\treturn;\n\nno_delete:\n\tclear_inode(inode);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_remove failed\\n\"",
            "__func__"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_remove",
          "args": [
            "ios"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_get_io_state failed\\n\"",
            "__func__"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&oi->oc",
            "&ios"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_obj_created",
          "args": [
            "oi"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nvoid exofs_evict_inode(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/* TODO: should do better here */\n\tif (inode->i_nlink || is_bad_inode(inode))\n\t\tgoto no_delete;\n\n\tinode->i_size = 0;\n\tclear_inode(inode);\n\n\t/* if we are deleting an obj that hasn't been created yet, wait.\n\t * This also makes sure that create_done cannot be called with an\n\t * already evicted inode.\n\t */\n\twait_obj_created(oi);\n\t/* ignore the error, attempt a remove anyway */\n\n\t/* Now Remove the OSD objects */\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tios->done = delete_done;\n\tios->private = sbi;\n\n\tret = ore_remove(ios);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: ore_remove failed\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t\treturn;\n\t}\n\tatomic_inc(&sbi->s_curr_pending);\n\n\treturn;\n\nno_delete:\n\tclear_inode(inode);\n}"
  },
  {
    "function_name": "delete_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1464-1471",
    "snippet": "static void delete_done(struct ore_io_state *ios, void *p)\n{\n\tstruct exofs_sb_info *sbi = p;\n\n\tore_put_io_state(ios);\n\n\tatomic_dec(&sbi->s_curr_pending);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void delete_done(struct ore_io_state *ios, void *p)\n{\n\tstruct exofs_sb_info *sbi = p;\n\n\tore_put_io_state(ios);\n\n\tatomic_dec(&sbi->s_curr_pending);\n}"
  },
  {
    "function_name": "exofs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1454-1458",
    "snippet": "int exofs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\t/* FIXME: fix fsync and use wbc->sync_mode == WB_SYNC_ALL */\n\treturn exofs_update_inode(inode, 1);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_update_inode",
          "args": [
            "inode",
            "1"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1376-1452",
          "snippet": "static int exofs_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attr;\n\tstruct exofs_fcb *fcb;\n\tstruct updatei_args *args;\n\tint ret;\n\n\targs = kzalloc(sizeof(*args), GFP_KERNEL);\n\tif (!args) {\n\t\tEXOFS_DBGMSG(\"Failed kzalloc of args\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfcb = &args->fcb;\n\n\tfcb->i_mode = cpu_to_le16(inode->i_mode);\n\tfcb->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfcb->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfcb->i_links_count = cpu_to_le16(inode->i_nlink);\n\tfcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\tfcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tfcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\toi->i_commit_size = i_size_read(inode);\n\tfcb->i_size = cpu_to_le64(oi->i_commit_size);\n\tfcb->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tfcb->i_data[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[1] = 0;\n\t\t} else {\n\t\t\tfcb->i_data[0] = 0;\n\t\t\tfcb->i_data[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[2] = 0;\n\t\t}\n\t} else\n\t\tmemcpy(fcb->i_data, oi->i_data, sizeof(fcb->i_data));\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\tgoto free_args;\n\t}\n\n\tattr = g_attr_inode_data;\n\tattr.val_ptr = fcb;\n\tios->out_attr_len = 1;\n\tios->out_attr = &attr;\n\n\twait_obj_created(oi);\n\n\tif (!do_sync) {\n\t\targs->sbi = sbi;\n\t\tios->done = updatei_done;\n\t\tios->private = args;\n\t}\n\n\tret = ore_write(ios);\n\tif (!do_sync && !ret) {\n\t\tatomic_inc(&sbi->s_curr_pending);\n\t\tgoto out; /* deallocation in updatei_done */\n\t}\n\n\tore_put_io_state(ios);\nfree_args:\n\tkfree(args);\nout:\n\tEXOFS_DBGMSG(\"(0x%lx) do_sync=%d ret=>%d\\n\",\n\t\t     inode->i_ino, do_sync, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attr;\n\tstruct exofs_fcb *fcb;\n\tstruct updatei_args *args;\n\tint ret;\n\n\targs = kzalloc(sizeof(*args), GFP_KERNEL);\n\tif (!args) {\n\t\tEXOFS_DBGMSG(\"Failed kzalloc of args\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfcb = &args->fcb;\n\n\tfcb->i_mode = cpu_to_le16(inode->i_mode);\n\tfcb->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfcb->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfcb->i_links_count = cpu_to_le16(inode->i_nlink);\n\tfcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\tfcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tfcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\toi->i_commit_size = i_size_read(inode);\n\tfcb->i_size = cpu_to_le64(oi->i_commit_size);\n\tfcb->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tfcb->i_data[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[1] = 0;\n\t\t} else {\n\t\t\tfcb->i_data[0] = 0;\n\t\t\tfcb->i_data[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[2] = 0;\n\t\t}\n\t} else\n\t\tmemcpy(fcb->i_data, oi->i_data, sizeof(fcb->i_data));\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\tgoto free_args;\n\t}\n\n\tattr = g_attr_inode_data;\n\tattr.val_ptr = fcb;\n\tios->out_attr_len = 1;\n\tios->out_attr = &attr;\n\n\twait_obj_created(oi);\n\n\tif (!do_sync) {\n\t\targs->sbi = sbi;\n\t\tios->done = updatei_done;\n\t\tios->private = args;\n\t}\n\n\tret = ore_write(ios);\n\tif (!do_sync && !ret) {\n\t\tatomic_inc(&sbi->s_curr_pending);\n\t\tgoto out; /* deallocation in updatei_done */\n\t}\n\n\tore_put_io_state(ios);\nfree_args:\n\tkfree(args);\nout:\n\tEXOFS_DBGMSG(\"(0x%lx) do_sync=%d ret=>%d\\n\",\n\t\t     inode->i_ino, do_sync, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint exofs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\t/* FIXME: fix fsync and use wbc->sync_mode == WB_SYNC_ALL */\n\treturn exofs_update_inode(inode, 1);\n}"
  },
  {
    "function_name": "exofs_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1376-1452",
    "snippet": "static int exofs_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attr;\n\tstruct exofs_fcb *fcb;\n\tstruct updatei_args *args;\n\tint ret;\n\n\targs = kzalloc(sizeof(*args), GFP_KERNEL);\n\tif (!args) {\n\t\tEXOFS_DBGMSG(\"Failed kzalloc of args\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfcb = &args->fcb;\n\n\tfcb->i_mode = cpu_to_le16(inode->i_mode);\n\tfcb->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfcb->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfcb->i_links_count = cpu_to_le16(inode->i_nlink);\n\tfcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\tfcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tfcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\toi->i_commit_size = i_size_read(inode);\n\tfcb->i_size = cpu_to_le64(oi->i_commit_size);\n\tfcb->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tfcb->i_data[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[1] = 0;\n\t\t} else {\n\t\t\tfcb->i_data[0] = 0;\n\t\t\tfcb->i_data[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[2] = 0;\n\t\t}\n\t} else\n\t\tmemcpy(fcb->i_data, oi->i_data, sizeof(fcb->i_data));\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\tgoto free_args;\n\t}\n\n\tattr = g_attr_inode_data;\n\tattr.val_ptr = fcb;\n\tios->out_attr_len = 1;\n\tios->out_attr = &attr;\n\n\twait_obj_created(oi);\n\n\tif (!do_sync) {\n\t\targs->sbi = sbi;\n\t\tios->done = updatei_done;\n\t\tios->private = args;\n\t}\n\n\tret = ore_write(ios);\n\tif (!do_sync && !ret) {\n\t\tatomic_inc(&sbi->s_curr_pending);\n\t\tgoto out; /* deallocation in updatei_done */\n\t}\n\n\tore_put_io_state(ios);\nfree_args:\n\tkfree(args);\nout:\n\tEXOFS_DBGMSG(\"(0x%lx) do_sync=%d ret=>%d\\n\",\n\t\t     inode->i_ino, do_sync, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"(0x%lx) do_sync=%d ret=>%d\\n\"",
            "inode->i_ino",
            "do_sync",
            "ret"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_write",
          "args": [
            "ios"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_obj_created",
          "args": [
            "oi"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_get_io_state failed.\\n\"",
            "__func__"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&oi->oc",
            "&ios"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fcb->i_data",
            "oi->i_data",
            "sizeof(fcb->i_data)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_encode_dev(inode->i_rdev)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "oi->i_commit_size"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"Failed kzalloc of args\\n\""
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*args)",
            "GFP_KERNEL"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attr;\n\tstruct exofs_fcb *fcb;\n\tstruct updatei_args *args;\n\tint ret;\n\n\targs = kzalloc(sizeof(*args), GFP_KERNEL);\n\tif (!args) {\n\t\tEXOFS_DBGMSG(\"Failed kzalloc of args\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfcb = &args->fcb;\n\n\tfcb->i_mode = cpu_to_le16(inode->i_mode);\n\tfcb->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfcb->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfcb->i_links_count = cpu_to_le16(inode->i_nlink);\n\tfcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n\tfcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tfcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\toi->i_commit_size = i_size_read(inode);\n\tfcb->i_size = cpu_to_le64(oi->i_commit_size);\n\tfcb->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tfcb->i_data[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[1] = 0;\n\t\t} else {\n\t\t\tfcb->i_data[0] = 0;\n\t\t\tfcb->i_data[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tfcb->i_data[2] = 0;\n\t\t}\n\t} else\n\t\tmemcpy(fcb->i_data, oi->i_data, sizeof(fcb->i_data));\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\tgoto free_args;\n\t}\n\n\tattr = g_attr_inode_data;\n\tattr.val_ptr = fcb;\n\tios->out_attr_len = 1;\n\tios->out_attr = &attr;\n\n\twait_obj_created(oi);\n\n\tif (!do_sync) {\n\t\targs->sbi = sbi;\n\t\tios->done = updatei_done;\n\t\tios->private = args;\n\t}\n\n\tret = ore_write(ios);\n\tif (!do_sync && !ret) {\n\t\tatomic_inc(&sbi->s_curr_pending);\n\t\tgoto out; /* deallocation in updatei_done */\n\t}\n\n\tore_put_io_state(ios);\nfree_args:\n\tkfree(args);\nout:\n\tEXOFS_DBGMSG(\"(0x%lx) do_sync=%d ret=>%d\\n\",\n\t\t     inode->i_ino, do_sync, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "updatei_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1361-1370",
    "snippet": "static void updatei_done(struct ore_io_state *ios, void *p)\n{\n\tstruct updatei_args *args = p;\n\n\tore_put_io_state(ios);\n\n\tatomic_dec(&args->sbi->s_curr_pending);\n\n\tkfree(args);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&args->sbi->s_curr_pending"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void updatei_done(struct ore_io_state *ios, void *p)\n{\n\tstruct updatei_args *args = p;\n\n\tore_put_io_state(ios);\n\n\tatomic_dec(&args->sbi->s_curr_pending);\n\n\tkfree(args);\n}"
  },
  {
    "function_name": "exofs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1297-1348",
    "snippet": "struct inode *exofs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct exofs_i_info *oi;\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\n\tset_obj_2bcreated(oi);\n\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = sbi->s_nextid++;\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\toi->i_commit_size = inode->i_size = 0;\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tinsert_inode_hash(inode);\n\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\texofs_sbi_write_stats(sbi); /* Make sure new sbi->s_nextid is on disk */\n\n\tmark_inode_dirty(inode);\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"exofs_new_inode: ore_get_io_state failed\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tios->done = create_done;\n\tios->private = inode;\n\n\tret = ore_create(ios);\n\tif (ret) {\n\t\tore_put_io_state(ios);\n\t\treturn ERR_PTR(ret);\n\t}\n\tatomic_inc(&sbi->s_curr_pending);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_create",
          "args": [
            "ios"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"exofs_new_inode: ore_get_io_state failed\\n\""
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&oi->oc",
            "&ios"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_sbi_write_stats",
          "args": [
            "sbi"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sbi_write_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "321-352",
          "snippet": "int exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));\n\nint exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_init_comps",
          "args": [
            "&oi->oc",
            "&oi->one_comp",
            "sb->s_fs_info",
            "exofs_oi_objno(oi)"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_init_comps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "224-243",
          "snippet": "static inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_oi_objno",
          "args": [
            "oi"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_oi_objno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "96-99",
          "snippet": "static inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_obj_2bcreated",
          "args": [
            "oi"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "set_obj_2bcreated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "112-115",
          "snippet": "static inline void set_obj_2bcreated(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_2BCREATED, &oi->i_flags);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OBJ_2BCREATED\t0\t/* object will be created soon*/"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define OBJ_2BCREATED\t0\t/* object will be created soon*/\n\nstatic inline void set_obj_2bcreated(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_2BCREATED, &oi->i_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__oi_init",
          "args": [
            "oi"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "__oi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1151-1155",
          "snippet": "static void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstruct inode *exofs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct exofs_i_info *oi;\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\n\tset_obj_2bcreated(oi);\n\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = sbi->s_nextid++;\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\toi->i_commit_size = inode->i_size = 0;\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tinsert_inode_hash(inode);\n\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\texofs_sbi_write_stats(sbi); /* Make sure new sbi->s_nextid is on disk */\n\n\tmark_inode_dirty(inode);\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"exofs_new_inode: ore_get_io_state failed\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tios->done = create_done;\n\tios->private = inode;\n\n\tret = ore_create(ios);\n\tif (ret) {\n\t\tore_put_io_state(ios);\n\t\treturn ERR_PTR(ret);\n\t}\n\tatomic_inc(&sbi->s_curr_pending);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "create_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1265-1292",
    "snippet": "static void create_done(struct ore_io_state *ios, void *p)\n{\n\tstruct inode *inode = p;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tret = ore_check_io(ios, NULL);\n\tore_put_io_state(ios);\n\n\tatomic_dec(&sbi->s_curr_pending);\n\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object=0x%llx creation failed in pid=0x%llx\",\n\t\t\t  _LLU(exofs_oi_objno(oi)),\n\t\t\t  _LLU(oi->one_comp.obj.partition));\n\t\t/*TODO: When FS is corrupted creation can fail, object already\n\t\t * exist. Get rid of this asynchronous creation, if exist\n\t\t * increment the obj counter and try the next object. Until we\n\t\t * succeed. All these dangling objects will be made into lost\n\t\t * files by chkfs.exofs\n\t\t */\n\t}\n\n\tset_obj_created(oi);\n\n\twake_up(&oi->i_wq);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&oi->i_wq"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_obj_created",
          "args": [
            "oi"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "set_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "122-125",
          "snippet": "static inline void set_obj_created(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_CREATED, &oi->i_flags);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OBJ_CREATED\t1\t/* object has been created on the osd*/"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define OBJ_CREATED\t1\t/* object has been created on the osd*/\n\nstatic inline void set_obj_created(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_CREATED, &oi->i_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"object=0x%llx creation failed in pid=0x%llx\"",
            "_LLU(exofs_oi_objno(oi))",
            "_LLU(oi->one_comp.obj.partition)"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "oi->one_comp.obj.partition"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "exofs_oi_objno(oi)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_oi_objno",
          "args": [
            "oi"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_oi_objno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "96-99",
          "snippet": "static inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "ios",
            "NULL"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void create_done(struct ore_io_state *ios, void *p)\n{\n\tstruct inode *inode = p;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tret = ore_check_io(ios, NULL);\n\tore_put_io_state(ios);\n\n\tatomic_dec(&sbi->s_curr_pending);\n\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object=0x%llx creation failed in pid=0x%llx\",\n\t\t\t  _LLU(exofs_oi_objno(oi)),\n\t\t\t  _LLU(oi->one_comp.obj.partition));\n\t\t/*TODO: When FS is corrupted creation can fail, object already\n\t\t * exist. Get rid of this asynchronous creation, if exist\n\t\t * increment the obj counter and try the next object. Until we\n\t\t * succeed. All these dangling objects will be made into lost\n\t\t * files by chkfs.exofs\n\t\t */\n\t}\n\n\tset_obj_created(oi);\n\n\twake_up(&oi->i_wq);\n}"
  },
  {
    "function_name": "__exofs_wait_obj_created",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1249-1258",
    "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_bad_inode(&oi->vfs_inode)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "&oi->vfs_inode"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"wait_event done\\n\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "oi->i_wq",
            "obj_created(oi)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_created",
          "args": [
            "oi"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!obj_2bcreated(oi)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_2bcreated",
          "args": [
            "oi"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "set_obj_2bcreated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "112-115",
          "snippet": "static inline void set_obj_2bcreated(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_2BCREATED, &oi->i_flags);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OBJ_2BCREATED\t0\t/* object will be created soon*/"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define OBJ_2BCREATED\t0\t/* object will be created soon*/\n\nstatic inline void set_obj_2bcreated(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_2BCREATED, &oi->i_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"!obj_created\\n\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
  },
  {
    "function_name": "exofs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1159-1247",
    "snippet": "struct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(le32_to_cpu(fcb.i_data[1]))"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(fcb.i_data[1])"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fcb.i_data[1]"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(fcb.i_data[0])"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oi->i_data",
            "fcb.i_data",
            "sizeof(fcb.i_data)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(fcb.i_data[1])"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(fcb.i_data[0])"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "oi->i_commit_size"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fcb.i_size"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(fcb.i_links_count)"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fcb.i_links_count"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(fcb.i_gid)"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(fcb.i_uid)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_obj_created",
          "args": [
            "oi"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "set_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "122-125",
          "snippet": "static inline void set_obj_created(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_CREATED, &oi->i_flags);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OBJ_CREATED\t1\t/* object has been created on the osd*/"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define OBJ_CREATED\t1\t/* object has been created on the osd*/\n\nstatic inline void set_obj_created(struct exofs_i_info *oi)\n{\n\tset_bit(OBJ_CREATED, &oi->i_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_get_inode",
          "args": [
            "sb",
            "oi",
            "&fcb"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1070-1149",
          "snippet": "static int exofs_get_inode(struct super_block *sb, struct exofs_i_info *oi,\n\t\t    struct exofs_fcb *inode)\n{\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_inode_data,\n\t\t[1] = g_attr_inode_file_layout,\n\t\t[2] = g_attr_inode_dir_layout,\n\t};\n\tstruct ore_io_state *ios;\n\tstruct exofs_on_disk_inode_layout *layout;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tattrs[1].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\tattrs[2].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object(0x%llx) corrupted, return empty file=>%d\\n\",\n\t\t\t  _LLU(oi->one_comp.obj.id), ret);\n\t\tmemset(inode, 0, sizeof(*inode));\n\t\tinode->i_mode = 0040000 | (0777 & ~022);\n\t\t/* If object is lost on target we might as well enable it's\n\t\t * delete.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 0 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tWARN_ON(attrs[0].len != EXOFS_INO_ATTR_SIZE);\n\tmemcpy(inode, attrs[0].val_ptr, EXOFS_INO_ATTR_SIZE);\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 1 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[1].len) {\n\t\tlayout = attrs[1].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported files layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[2]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 2 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[2].len) {\n\t\tlayout = attrs[2].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported meta-data layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct osd_attr g_attr_inode_file_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_FILE_LAYOUT,\n\t0);",
            "static const struct osd_attr g_attr_inode_dir_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_DIR_LAYOUT,\n\t0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic const struct osd_attr g_attr_inode_file_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_FILE_LAYOUT,\n\t0);\nstatic const struct osd_attr g_attr_inode_dir_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_DIR_LAYOUT,\n\t0);\n\nstatic int exofs_get_inode(struct super_block *sb, struct exofs_i_info *oi,\n\t\t    struct exofs_fcb *inode)\n{\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_inode_data,\n\t\t[1] = g_attr_inode_file_layout,\n\t\t[2] = g_attr_inode_dir_layout,\n\t};\n\tstruct ore_io_state *ios;\n\tstruct exofs_on_disk_inode_layout *layout;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tattrs[1].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\tattrs[2].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object(0x%llx) corrupted, return empty file=>%d\\n\",\n\t\t\t  _LLU(oi->one_comp.obj.id), ret);\n\t\tmemset(inode, 0, sizeof(*inode));\n\t\tinode->i_mode = 0040000 | (0777 & ~022);\n\t\t/* If object is lost on target we might as well enable it's\n\t\t * delete.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 0 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tWARN_ON(attrs[0].len != EXOFS_INO_ATTR_SIZE);\n\tmemcpy(inode, attrs[0].val_ptr, EXOFS_INO_ATTR_SIZE);\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 1 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[1].len) {\n\t\tlayout = attrs[1].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported files layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[2]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 2 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[2].len) {\n\t\tlayout = attrs[2].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported meta-data layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_init_comps",
          "args": [
            "&oi->oc",
            "&oi->one_comp",
            "sb->s_fs_info",
            "exofs_oi_objno(oi)"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_init_comps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "224-243",
          "snippet": "static inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_oi_objno",
          "args": [
            "oi"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_oi_objno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "96-99",
          "snippet": "static inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline osd_id exofs_oi_objno(struct exofs_i_info *oi)\n{\n\treturn oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__oi_init",
          "args": [
            "oi"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "__oi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1151-1155",
          "snippet": "static void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nconst struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};\n\nstruct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "__oi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1151-1155",
    "snippet": "static void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&oi->i_wq"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void __oi_init(struct exofs_i_info *oi)\n{\n\tinit_waitqueue_head(&oi->i_wq);\n\toi->i_flags = 0;\n}"
  },
  {
    "function_name": "exofs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1070-1149",
    "snippet": "static int exofs_get_inode(struct super_block *sb, struct exofs_i_info *oi,\n\t\t    struct exofs_fcb *inode)\n{\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_inode_data,\n\t\t[1] = g_attr_inode_file_layout,\n\t\t[2] = g_attr_inode_dir_layout,\n\t};\n\tstruct ore_io_state *ios;\n\tstruct exofs_on_disk_inode_layout *layout;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tattrs[1].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\tattrs[2].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object(0x%llx) corrupted, return empty file=>%d\\n\",\n\t\t\t  _LLU(oi->one_comp.obj.id), ret);\n\t\tmemset(inode, 0, sizeof(*inode));\n\t\tinode->i_mode = 0040000 | (0777 & ~022);\n\t\t/* If object is lost on target we might as well enable it's\n\t\t * delete.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 0 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tWARN_ON(attrs[0].len != EXOFS_INO_ATTR_SIZE);\n\tmemcpy(inode, attrs[0].val_ptr, EXOFS_INO_ATTR_SIZE);\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 1 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[1].len) {\n\t\tlayout = attrs[1].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported files layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[2]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 2 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[2].len) {\n\t\tlayout = attrs[2].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported meta-data layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct osd_attr g_attr_inode_file_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_FILE_LAYOUT,\n\t0);",
      "static const struct osd_attr g_attr_inode_dir_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_DIR_LAYOUT,\n\t0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: unsupported meta-data layout %d\\n\"",
            "__func__",
            "layout->gen_func"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LAYOUT_MOVING_WINDOW"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: extract_attr 2 of inode failed\\n\"",
            "__func__"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[2]"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: unsupported files layout %d\\n\"",
            "__func__",
            "layout->gen_func"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LAYOUT_MOVING_WINDOW"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: extract_attr 1 of inode failed\\n\"",
            "__func__"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[1]"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "inode",
            "attrs[0].val_ptr",
            "EXOFS_INO_ATTR_SIZE"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "attrs[0].len != EXOFS_INO_ATTR_SIZE"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: extract_attr 0 of inode failed\\n\"",
            "__func__"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[0]"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inode",
            "0",
            "sizeof(*inode)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"object(0x%llx) corrupted, return empty file=>%d\\n\"",
            "_LLU(oi->one_comp.obj.id)",
            "ret"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "oi->one_comp.obj.id"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "ios"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attrs"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_on_disk_inode_layout_size",
          "args": [
            "sbi->oc.numdevs"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_on_disk_inode_layout_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/common.h",
          "lines": "256-260",
          "snippet": "static inline size_t exofs_on_disk_inode_layout_size(unsigned max_devs)\n{\n\treturn sizeof(struct exofs_on_disk_inode_layout) +\n\t\tmax_devs * sizeof(__le32);\n}",
          "includes": [
            "#include <scsi/osd_sec.h>",
            "#include <scsi/osd_initiator.h>",
            "#include <scsi/osd_attributes.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/osd_sec.h>\n#include <scsi/osd_initiator.h>\n#include <scsi/osd_attributes.h>\n#include <linux/types.h>\n\nstatic inline size_t exofs_on_disk_inode_layout_size(unsigned max_devs)\n{\n\treturn sizeof(struct exofs_on_disk_inode_layout) +\n\t\tmax_devs * sizeof(__le32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_get_io_state failed.\\n\"",
            "__func__"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&oi->oc",
            "&ios"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic const struct osd_attr g_attr_inode_file_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_FILE_LAYOUT,\n\t0);\nstatic const struct osd_attr g_attr_inode_dir_layout = ATTR_DEF(\n\tEXOFS_APAGE_FS_DATA,\n\tEXOFS_ATTR_INODE_DIR_LAYOUT,\n\t0);\n\nstatic int exofs_get_inode(struct super_block *sb, struct exofs_i_info *oi,\n\t\t    struct exofs_fcb *inode)\n{\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_inode_data,\n\t\t[1] = g_attr_inode_file_layout,\n\t\t[2] = g_attr_inode_dir_layout,\n\t};\n\tstruct ore_io_state *ios;\n\tstruct exofs_on_disk_inode_layout *layout;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tattrs[1].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\tattrs[2].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"object(0x%llx) corrupted, return empty file=>%d\\n\",\n\t\t\t  _LLU(oi->one_comp.obj.id), ret);\n\t\tmemset(inode, 0, sizeof(*inode));\n\t\tinode->i_mode = 0040000 | (0777 & ~022);\n\t\t/* If object is lost on target we might as well enable it's\n\t\t * delete.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 0 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tWARN_ON(attrs[0].len != EXOFS_INO_ATTR_SIZE);\n\tmemcpy(inode, attrs[0].val_ptr, EXOFS_INO_ATTR_SIZE);\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 1 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[1].len) {\n\t\tlayout = attrs[1].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported files layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[2]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr 2 of inode failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[2].len) {\n\t\tlayout = attrs[2].val_ptr;\n\t\tif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\n\t\t\tEXOFS_ERR(\"%s: unsupported meta-data layout %d\\n\",\n\t\t\t\t__func__, layout->gen_func);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1029-1055",
    "snippet": "int exofs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\t/* if we are about to modify an object, and it hasn't been\n\t * created yet, wait\n\t */\n\terror = wait_obj_created(exofs_i(inode));\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\terror = _do_truncate(inode, iattr->ia_size);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_do_truncate",
          "args": [
            "inode",
            "iattr->ia_size"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "_do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1008-1023",
          "snippet": "static int _do_truncate(struct inode *inode, loff_t newsize)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tret = ore_truncate(&sbi->layout, &oi->oc, (u64)newsize);\n\tif (likely(!ret))\n\t\ttruncate_setsize(inode, newsize);\n\n\tEXOFS_DBGMSG2(\"(0x%lx) size=0x%llx ret=>%d\\n\",\n\t\t     inode->i_ino, newsize, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _do_truncate(struct inode *inode, loff_t newsize)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tret = ore_truncate(&sbi->layout, &oi->oc, (u64)newsize);\n\tif (likely(!ret))\n\t\ttruncate_setsize(inode, newsize);\n\n\tEXOFS_DBGMSG2(\"(0x%lx) size=0x%llx ret=>%d\\n\",\n\t\t     inode->i_ino, newsize, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_obj_created",
          "args": [
            "exofs_i(inode)"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint exofs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\t/* if we are about to modify an object, and it hasn't been\n\t * created yet, wait\n\t */\n\terror = wait_obj_created(exofs_i(inode));\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\terror = _do_truncate(inode, iattr->ia_size);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "_do_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1008-1023",
    "snippet": "static int _do_truncate(struct inode *inode, loff_t newsize)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tret = ore_truncate(&sbi->layout, &oi->oc, (u64)newsize);\n\tif (likely(!ret))\n\t\ttruncate_setsize(inode, newsize);\n\n\tEXOFS_DBGMSG2(\"(0x%lx) size=0x%llx ret=>%d\\n\",\n\t\t     inode->i_ino, newsize, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"(0x%lx) size=0x%llx ret=>%d\\n\"",
            "inode->i_ino",
            "newsize",
            "ret"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_truncate",
          "args": [
            "&sbi->layout",
            "&oi->oc",
            "(u64)newsize"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _do_truncate(struct inode *inode, loff_t newsize)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tint ret;\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tret = ore_truncate(&sbi->layout, &oi->oc, (u64)newsize);\n\tif (likely(!ret))\n\t\ttruncate_setsize(inode, newsize);\n\n\tEXOFS_DBGMSG2(\"(0x%lx) size=0x%llx ret=>%d\\n\",\n\t\t     inode->i_ino, newsize, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_inode_is_fast_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "1001-1006",
    "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
  },
  {
    "function_name": "exofs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "966-970",
    "snippet": "static ssize_t exofs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic ssize_t exofs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "956-962",
    "snippet": "static void exofs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tEXOFS_DBGMSG(\"page 0x%lx offset 0x%x length 0x%x\\n\",\n\t\t     page->index, offset, length);\n\tWARN_ON(1);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"page 0x%lx offset 0x%x length 0x%x\\n\"",
            "page->index",
            "offset",
            "length"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void exofs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tEXOFS_DBGMSG(\"page 0x%lx offset 0x%x length 0x%x\\n\",\n\t\t     page->index, offset, length);\n\tWARN_ON(1);\n}"
  },
  {
    "function_name": "exofs_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "949-954",
    "snippet": "static int exofs_releasepage(struct page *page, gfp_t gfp)\n{\n\tEXOFS_DBGMSG(\"page 0x%lx\\n\", page->index);\n\tWARN_ON(1);\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"page 0x%lx\\n\"",
            "page->index"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_releasepage(struct page *page, gfp_t gfp)\n{\n\tEXOFS_DBGMSG(\"page 0x%lx\\n\", page->index);\n\tWARN_ON(1);\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "930-947",
    "snippet": "static int exofs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\t/* According to comment in simple_write_end i_mutex is held */\n\tloff_t i_size = inode->i_size;\n\tint ret;\n\n\tret = simple_write_end(file, mapping,pos, len, copied, page, fsdata);\n\tif (unlikely(ret))\n\t\t_write_failed(inode, pos + len);\n\n\t/* TODO: once simple_write_end marks inode dirty remove */\n\tif (i_size != inode->i_size)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_write_failed",
          "args": [
            "inode",
            "pos + len"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "861-865",
          "snippet": "static void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "simple_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "441-469",
          "snippet": "int simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (copied < len) {\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user(page, from + copied, len - copied);\n\t}\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (copied < len) {\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user(page, from + copied, len - copied);\n\t}\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\t/* According to comment in simple_write_end i_mutex is held */\n\tloff_t i_size = inode->i_size;\n\tint ret;\n\n\tret = simple_write_end(file, mapping,pos, len, copied, page, fsdata);\n\tif (unlikely(ret))\n\t\t_write_failed(inode, pos + len);\n\n\t/* TODO: once simple_write_end marks inode dirty remove */\n\tif (i_size != inode->i_size)\n\t\tmark_inode_dirty(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_write_begin_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "919-928",
    "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_write_begin_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "919-928",
          "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}"
  },
  {
    "function_name": "exofs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "867-917",
    "snippet": "int exofs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret = 0;\n\tstruct page *page;\n\n\tpage = *pagep;\n\tif (page == NULL) {\n\t\tret = simple_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\t fsdata);\n\t\tif (ret) {\n\t\t\tEXOFS_DBGMSG(\"simple_write_begin failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = *pagep;\n\t}\n\n\t /* read modify write */\n\tif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\n\t\tloff_t i_size = i_size_read(mapping->host);\n\t\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\t\tsize_t rlen;\n\n\t\tif (page->index < end_index)\n\t\t\trlen = PAGE_CACHE_SIZE;\n\t\telse if (page->index == end_index)\n\t\t\trlen = i_size & ~PAGE_CACHE_MASK;\n\t\telse\n\t\t\trlen = 0;\n\n\t\tif (!rlen) {\n\t\t\tclear_highpage(page);\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = _readpage(page, true);\n\t\tif (ret) {\n\t\t\t/*SetPageError was done by _readpage. Is it ok?*/\n\t\t\tunlock_page(page);\n\t\t\tEXOFS_DBGMSG(\"__readpage failed\\n\");\n\t\t}\n\t}\nout:\n\tif (unlikely(ret))\n\t\t_write_failed(mapping->host, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_write_failed",
          "args": [
            "mapping->host",
            "pos + len"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "861-865",
          "snippet": "static void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"__readpage failed\\n\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_readpage",
          "args": [
            "page",
            "true"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "514-517",
          "snippet": "static int exofs_readpage(struct file *file, struct page *page)\n{\n\treturn _readpage(page, false);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_readpage(struct file *file, struct page *page)\n{\n\treturn _readpage(page, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"simple_write_begin failed\\n\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "simple_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "396-417",
          "snippet": "int simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user_segments(page, 0, from, from + len, PAGE_CACHE_SIZE);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user_segments(page, 0, from, from + len, PAGE_CACHE_SIZE);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint exofs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret = 0;\n\tstruct page *page;\n\n\tpage = *pagep;\n\tif (page == NULL) {\n\t\tret = simple_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\t fsdata);\n\t\tif (ret) {\n\t\t\tEXOFS_DBGMSG(\"simple_write_begin failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = *pagep;\n\t}\n\n\t /* read modify write */\n\tif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\n\t\tloff_t i_size = i_size_read(mapping->host);\n\t\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\t\tsize_t rlen;\n\n\t\tif (page->index < end_index)\n\t\t\trlen = PAGE_CACHE_SIZE;\n\t\telse if (page->index == end_index)\n\t\t\trlen = i_size & ~PAGE_CACHE_MASK;\n\t\telse\n\t\t\trlen = 0;\n\n\t\tif (!rlen) {\n\t\t\tclear_highpage(page);\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = _readpage(page, true);\n\t\tif (ret) {\n\t\t\t/*SetPageError was done by _readpage. Is it ok?*/\n\t\t\tunlock_page(page);\n\t\t\tEXOFS_DBGMSG(\"__readpage failed\\n\");\n\t\t}\n\t}\nout:\n\tif (unlikely(ret))\n\t\t_write_failed(mapping->host, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "861-865",
    "snippet": "static void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _write_failed(struct inode *inode, loff_t to)\n{\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
  },
  {
    "function_name": "exofs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "789-841",
    "snippet": "static int exofs_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct page_collect pcol;\n\tlong start, end, expected_pages;\n\tint ret;\n\n\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\tend = (wbc->range_end == LLONG_MAX) ?\n\t\t\tstart + mapping->nrpages :\n\t\t\twbc->range_end >> PAGE_CACHE_SHIFT;\n\n\tif (start || end)\n\t\texpected_pages = end - start + 1;\n\telse\n\t\texpected_pages = mapping->nrpages;\n\n\tif (expected_pages < 32L)\n\t\texpected_pages = 32L;\n\n\tEXOFS_DBGMSG2(\"inode(0x%lx) wbc->start=0x%llx wbc->end=0x%llx \"\n\t\t     \"nrpages=%lu start=0x%lx end=0x%lx expected_pages=%ld\\n\",\n\t\t     mapping->host->i_ino, wbc->range_start, wbc->range_end,\n\t\t     mapping->nrpages, start, end, expected_pages);\n\n\t_pcol_init(&pcol, expected_pages, mapping->host);\n\n\tret = write_cache_pages(mapping, wbc, writepage_strip, &pcol);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_cache_pages => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = write_exec(&pcol);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\treturn write_exec(&pcol); /* pump the last reminder */\n\t} else if (pcol.nr_pages) {\n\t\t/* not SYNC let the reminder join the next writeout */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < pcol.nr_pages; i++) {\n\t\t\tstruct page *page = pcol.pages[i];\n\n\t\t\tend_page_writeback(page);\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "223-257",
          "snippet": "static int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_exec",
          "args": [
            "&pcol"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "write_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "627-686",
          "snippet": "static int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};\n\nstatic int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"write_cache_pages => %d\\n\"",
            "ret"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "writepage_strip",
            "&pcol"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pcol_init",
          "args": [
            "&pcol",
            "expected_pages",
            "mapping->host"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "_pcol_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "66-83",
          "snippet": "static void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"inode(0x%lx) wbc->start=0x%llx wbc->end=0x%llx \"\n\t\t     \"nrpages=%lu start=0x%lx end=0x%lx expected_pages=%ld\\n\"",
            "mapping->host->i_ino",
            "wbc->range_start",
            "wbc->range_end",
            "mapping->nrpages",
            "start",
            "end",
            "expected_pages"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct page_collect pcol;\n\tlong start, end, expected_pages;\n\tint ret;\n\n\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\tend = (wbc->range_end == LLONG_MAX) ?\n\t\t\tstart + mapping->nrpages :\n\t\t\twbc->range_end >> PAGE_CACHE_SHIFT;\n\n\tif (start || end)\n\t\texpected_pages = end - start + 1;\n\telse\n\t\texpected_pages = mapping->nrpages;\n\n\tif (expected_pages < 32L)\n\t\texpected_pages = 32L;\n\n\tEXOFS_DBGMSG2(\"inode(0x%lx) wbc->start=0x%llx wbc->end=0x%llx \"\n\t\t     \"nrpages=%lu start=0x%lx end=0x%lx expected_pages=%ld\\n\",\n\t\t     mapping->host->i_ino, wbc->range_start, wbc->range_end,\n\t\t     mapping->nrpages, start, end, expected_pages);\n\n\t_pcol_init(&pcol, expected_pages, mapping->host);\n\n\tret = write_cache_pages(mapping, wbc, writepage_strip, &pcol);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_cache_pages => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = write_exec(&pcol);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\treturn write_exec(&pcol); /* pump the last reminder */\n\t} else if (pcol.nr_pages) {\n\t\t/* not SYNC let the reminder join the next writeout */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < pcol.nr_pages; i++) {\n\t\t\tstruct page *page = pcol.pages[i];\n\n\t\t\tend_page_writeback(page);\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "writepage_strip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "695-787",
    "snippet": "static int writepage_strip(struct page *page,\n\t\t\t   struct writeback_control *wbc_unused, void *data)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = wait_obj_created(oi);\n\tif (unlikely(ret))\n\t\tgoto fail;\n\n\tif (page->index < end_index)\n\t\t/* in this case, the page is within the limits of the file */\n\t\tlen = PAGE_CACHE_SIZE;\n\telse {\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\n\t\tif (page->index > end_index || !len) {\n\t\t\t/* in this case, the page is outside the limits\n\t\t\t * (truncate in progress)\n\t\t\t */\n\t\t\tret = write_exec(pcol);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto fail;\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t\tunlock_page(page);\n\t\t\tEXOFS_DBGMSG(\"writepage_strip(0x%lx, 0x%lx) \"\n\t\t\t\t     \"outside the limits\\n\",\n\t\t\t\t     inode->i_ino, page->index);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = write_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tEXOFS_DBGMSG(\"writepage_strip(0x%lx, 0x%lx) Discontinuity\\n\",\n\t\t\t     inode->i_ino, page->index);\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tEXOFS_DBGMSG2(\"    writepage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page \"\n\t\t\t     \"nr_pages=%u total_length=0x%lx\\n\",\n\t\t\t     pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, next loop will start again */\n\t\tret = write_exec(pcol);\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_DBGMSG(\"write_exec failed => %d\", ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tgoto try_again;\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\treturn 0;\n\nfail:\n\tEXOFS_DBGMSG(\"Error: writepage_strip(0x%lx, 0x%lx)=>%d\\n\",\n\t\t     inode->i_ino, page->index, ret);\n\tset_bit(AS_EIO, &page->mapping->flags);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&page->mapping->flags"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"Error: writepage_strip(0x%lx, 0x%lx)=>%d\\n\"",
            "inode->i_ino",
            "page->index",
            "ret"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"write_exec failed => %d\"",
            "ret"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_exec",
          "args": [
            "pcol"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "write_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "627-686",
          "snippet": "static int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};\n\nstatic int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"Failed pcol_add_page \"\n\t\t\t     \"nr_pages=%u total_length=0x%lx\\n\"",
            "pcol->nr_pages",
            "pcol->length"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_add_page",
          "args": [
            "pcol",
            "page",
            "len"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_add_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "137-146",
          "snippet": "static int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"    writepage_strip(0x%lx, 0x%lx) len=0x%zx\\n\"",
            "inode->i_ino",
            "page->index",
            "len"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_try_alloc",
          "args": [
            "pcol"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_try_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "105-124",
          "snippet": "static int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"writepage_strip(0x%lx, 0x%lx) Discontinuity\\n\"",
            "inode->i_ino",
            "page->index"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pcol->pg_first == -1"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"writepage_strip(0x%lx, 0x%lx) \"\n\t\t\t\t     \"outside the limits\\n\"",
            "inode->i_ino",
            "page->index"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_obj_created",
          "args": [
            "oi"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int writepage_strip(struct page *page,\n\t\t\t   struct writeback_control *wbc_unused, void *data)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = wait_obj_created(oi);\n\tif (unlikely(ret))\n\t\tgoto fail;\n\n\tif (page->index < end_index)\n\t\t/* in this case, the page is within the limits of the file */\n\t\tlen = PAGE_CACHE_SIZE;\n\telse {\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\n\t\tif (page->index > end_index || !len) {\n\t\t\t/* in this case, the page is outside the limits\n\t\t\t * (truncate in progress)\n\t\t\t */\n\t\t\tret = write_exec(pcol);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto fail;\n\t\t\tif (PageError(page))\n\t\t\t\tClearPageError(page);\n\t\t\tunlock_page(page);\n\t\t\tEXOFS_DBGMSG(\"writepage_strip(0x%lx, 0x%lx) \"\n\t\t\t\t     \"outside the limits\\n\",\n\t\t\t\t     inode->i_ino, page->index);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = write_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tEXOFS_DBGMSG(\"writepage_strip(0x%lx, 0x%lx) Discontinuity\\n\",\n\t\t\t     inode->i_ino, page->index);\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tEXOFS_DBGMSG2(\"    writepage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page \"\n\t\t\t     \"nr_pages=%u total_length=0x%lx\\n\",\n\t\t\t     pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, next loop will start again */\n\t\tret = write_exec(pcol);\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_DBGMSG(\"write_exec failed => %d\", ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tgoto try_again;\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\treturn 0;\n\nfail:\n\tEXOFS_DBGMSG(\"Error: writepage_strip(0x%lx, 0x%lx)=>%d\\n\",\n\t\t     inode->i_ino, page->index, ret);\n\tset_bit(AS_EIO, &page->mapping->flags);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "write_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "627-686",
    "snippet": "static int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcol_copy"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_free",
          "args": [
            "pcol_copy"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "126-135",
          "snippet": "static void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unlock_pcol_pages",
          "args": [
            "pcol_copy",
            "ret",
            "WRITE"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "_unlock_pcol_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "252-266",
          "snippet": "static void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pcol->sbi->s_curr_pending"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"write_exec: ore_write() Failed\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_write",
          "args": [
            "ios"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\"",
            "pcol->inode->i_ino",
            "_LLU(ios->offset)",
            "_LLU(ios->length)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "ios->length"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "ios->offset"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_maybe_not_all_in_one_io",
          "args": [
            "ios",
            "pcol_copy",
            "pcol"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "_maybe_not_all_in_one_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "268-306",
          "snippet": "static int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pcol_reset",
          "args": [
            "pcol"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "_pcol_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "85-103",
          "snippet": "static void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"write_exec: Failed to kmalloc(pcol)\\n\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pcol_copy)",
            "GFP_KERNEL"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_rw_state",
          "args": [
            "&pcol->sbi->layout",
            "&oi->oc",
            "false",
            "pcol->pg_first << PAGE_CACHE_SHIFT",
            "pcol->length",
            "&pcol->ios"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_rw_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "242-301",
          "snippet": "int  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pcol->ios"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "pcol->inode"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};\n\nstatic int write_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tBUG_ON(pcol->ios);\n\tret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\n\t\t\t\t pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t pcol->length, &pcol->ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tEXOFS_ERR(\"write_exec: Failed to kmalloc(pcol)\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\n\tios = pcol->ios;\n\tios->pages = pcol_copy->pages;\n\tios->done = writepages_done;\n\tios->r4w = &_r4w_op;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"write_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"write_exec: ore_write() Failed\\n\");\n\t\tgoto err;\n\t}\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, WRITE);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__r4w_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "609-620",
    "snippet": "static void __r4w_put_page(void *priv, struct page *page)\n{\n\tstruct page_collect *pcol = priv;\n\n\tif ((pcol->that_locked_page != page) && (ZERO_PAGE(0) != page)) {\n\t\tEXOFS_DBGMSG2(\"index=0x%lx\\n\", page->index);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\tEXOFS_DBGMSG2(\"that_locked_page index=0x%lx\\n\",\n\t\t     ZERO_PAGE(0) == page ? -1 : page->index);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"that_locked_page index=0x%lx\\n\"",
            "ZERO_PAGE(0) == page ? -1 : page->index"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"index=0x%lx\\n\"",
            "page->index"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void __r4w_put_page(void *priv, struct page *page)\n{\n\tstruct page_collect *pcol = priv;\n\n\tif ((pcol->that_locked_page != page) && (ZERO_PAGE(0) != page)) {\n\t\tEXOFS_DBGMSG2(\"index=0x%lx\\n\", page->index);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\tEXOFS_DBGMSG2(\"that_locked_page index=0x%lx\\n\",\n\t\t     ZERO_PAGE(0) == page ? -1 : page->index);\n}"
  },
  {
    "function_name": "__r4w_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "568-607",
    "snippet": "static struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\n{\n\tstruct page_collect *pcol = priv;\n\tpgoff_t index = offset / PAGE_SIZE;\n\n\tif (!pcol->that_locked_page ||\n\t    (pcol->that_locked_page->index != index)) {\n\t\tstruct page *page;\n\t\tloff_t i_size = i_size_read(pcol->inode);\n\n\t\tif (offset >= i_size) {\n\t\t\t*uptodate = true;\n\t\t\tEXOFS_DBGMSG2(\"offset >= i_size index=0x%lx\\n\", index);\n\t\t\treturn ZERO_PAGE(0);\n\t\t}\n\n\t\tpage =  find_get_page(pcol->inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage = find_or_create_page(pcol->inode->i_mapping,\n\t\t\t\t\t\t   index, GFP_NOFS);\n\t\t\tif (unlikely(!page)) {\n\t\t\t\tEXOFS_DBGMSG(\"grab_cache_page Failed \"\n\t\t\t\t\t\"index=0x%llx\\n\", _LLU(index));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t*uptodate = true;\n\t\telse\n\t\t\t*uptodate = PageUptodate(page);\n\t\tEXOFS_DBGMSG2(\"index=0x%lx uptodate=%d\\n\", index, *uptodate);\n\t\treturn page;\n\t} else {\n\t\tEXOFS_DBGMSG2(\"YES that_locked_page index=0x%lx\\n\",\n\t\t\t     pcol->that_locked_page->index);\n\t\t*uptodate = true;\n\t\treturn pcol->that_locked_page;\n\t}\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"YES that_locked_page index=0x%lx\\n\"",
            "pcol->that_locked_page->index"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"index=0x%lx uptodate=%d\\n\"",
            "index",
            "*uptodate"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"grab_cache_page Failed \"\n\t\t\t\t\t\"index=0x%llx\\n\"",
            "_LLU(index)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "index"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "pcol->inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "pcol->inode->i_mapping",
            "index"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"offset >= i_size index=0x%lx\\n\"",
            "index"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "pcol->inode"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\n{\n\tstruct page_collect *pcol = priv;\n\tpgoff_t index = offset / PAGE_SIZE;\n\n\tif (!pcol->that_locked_page ||\n\t    (pcol->that_locked_page->index != index)) {\n\t\tstruct page *page;\n\t\tloff_t i_size = i_size_read(pcol->inode);\n\n\t\tif (offset >= i_size) {\n\t\t\t*uptodate = true;\n\t\t\tEXOFS_DBGMSG2(\"offset >= i_size index=0x%lx\\n\", index);\n\t\t\treturn ZERO_PAGE(0);\n\t\t}\n\n\t\tpage =  find_get_page(pcol->inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage = find_or_create_page(pcol->inode->i_mapping,\n\t\t\t\t\t\t   index, GFP_NOFS);\n\t\t\tif (unlikely(!page)) {\n\t\t\t\tEXOFS_DBGMSG(\"grab_cache_page Failed \"\n\t\t\t\t\t\"index=0x%llx\\n\", _LLU(index));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t*uptodate = true;\n\t\telse\n\t\t\t*uptodate = PageUptodate(page);\n\t\tEXOFS_DBGMSG2(\"index=0x%lx uptodate=%d\\n\", index, *uptodate);\n\t\treturn page;\n\t} else {\n\t\tEXOFS_DBGMSG2(\"YES that_locked_page index=0x%lx\\n\",\n\t\t\t     pcol->that_locked_page->index);\n\t\t*uptodate = true;\n\t\treturn pcol->that_locked_page;\n\t}\n}"
  },
  {
    "function_name": "writepages_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "520-566",
    "snippet": "static void writepages_done(struct ore_io_state *ios, void *p)\n{\n\tstruct page_collect *pcol = p;\n\tint i;\n\tu64  good_bytes;\n\tu64  length = 0;\n\tint ret = ore_check_io(ios, NULL);\n\n\tatomic_dec(&pcol->sbi->s_curr_pending);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"writepages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages to a bio */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tupdate_write_page(page, page_stat);\n\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG2(\"    writepages_done(0x%lx, 0x%lx) status=%d\\n\",\n\t\t\t     inode->i_ino, page->index, page_stat);\n\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tkfree(pcol);\n\tEXOFS_DBGMSG2(\"writepages_done END\\n\");\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"writepages_done END\\n\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcol"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_free",
          "args": [
            "pcol"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "126-135",
          "snippet": "static void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"    writepages_done(0x%lx, 0x%lx) status=%d\\n\"",
            "inode->i_ino",
            "page->index",
            "page_stat"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_write_page",
          "args": [
            "page",
            "page_stat"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "update_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "180-190",
          "snippet": "static void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "length < good_bytes"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"writepages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\"",
            "pcol->inode->i_ino",
            "_LLU(good_bytes)",
            "pcol->length",
            "pcol->nr_pages"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "good_bytes"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pcol->sbi->s_curr_pending"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "ios",
            "NULL"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void writepages_done(struct ore_io_state *ios, void *p)\n{\n\tstruct page_collect *pcol = p;\n\tint i;\n\tu64  good_bytes;\n\tu64  length = 0;\n\tint ret = ore_check_io(ios, NULL);\n\n\tatomic_dec(&pcol->sbi->s_curr_pending);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"writepages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages to a bio */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tupdate_write_page(page, page_stat);\n\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG2(\"    writepages_done(0x%lx, 0x%lx) status=%d\\n\",\n\t\t\t     inode->i_ino, page->index, page_stat);\n\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tkfree(pcol);\n\tEXOFS_DBGMSG2(\"writepages_done END\\n\");\n}"
  },
  {
    "function_name": "exofs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "514-517",
    "snippet": "static int exofs_readpage(struct file *file, struct page *page)\n{\n\treturn _readpage(page, false);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_readpage",
          "args": [
            "page",
            "false"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "514-517",
          "snippet": "static int exofs_readpage(struct file *file, struct page *page)\n{\n\treturn _readpage(page, false);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_readpage(struct file *file, struct page *page)\n{\n\treturn _readpage(page, false);\n}"
  },
  {
    "function_name": "_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "494-509",
    "snippet": "static int _readpage(struct page *page, bool read_4_write)\n{\n\tstruct page_collect pcol;\n\tint ret;\n\n\t_pcol_init(&pcol, 1, page->mapping->host);\n\n\tpcol.read_4_write = read_4_write;\n\tret = readpage_strip(&pcol, page);\n\tif (ret) {\n\t\tEXOFS_ERR(\"_readpage => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn read_exec(&pcol);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_exec",
          "args": [
            "&pcol"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "read_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "308-371",
          "snippet": "static int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"_readpage => %d\\n\"",
            "ret"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readpage_strip",
          "args": [
            "&pcol",
            "page"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "readpage_strip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "380-471",
          "snippet": "static int readpage_strip(void *data, struct page *page)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* FIXME: Just for debugging, will be removed */\n\tif (PageUptodate(page))\n\t\tEXOFS_ERR(\"PageUptodate(0x%lx, 0x%lx)\\n\", pcol->inode->i_ino,\n\t\t\t  page->index);\n\n\tpcol->that_locked_page = page;\n\n\tif (page->index < end_index)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse if (page->index == end_index)\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = 0;\n\n\tif (!len || !obj_created(oi)) {\n\t\t/* this will be out of bounds, or doesn't exist yet.\n\t\t * Current page is cleared and the request is split\n\t\t */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG(\"readpage_strip(0x%lx) empty page len=%zx \"\n\t\t\t     \"read_4_write=%d index=0x%lx end_index=0x%lx \"\n\t\t\t     \"splitting\\n\", inode->i_ino, len,\n\t\t\t     pcol->read_4_write, page->index, end_index);\n\n\t\treturn read_exec(pcol);\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tif (len != PAGE_CACHE_SIZE)\n\t\tzero_user(page, len, PAGE_CACHE_SIZE - len);\n\n\tEXOFS_DBGMSG2(\"    readpage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (ret) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page pages[i]=%p \"\n\t\t\t  \"this_len=0x%zx nr_pages=%u length=0x%lx\\n\",\n\t\t\t  page, len, pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, and start again with current page */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tgoto try_again;\n\t}\n\n\treturn 0;\n\nfail:\n\t/* SetPageError(page); ??? */\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int readpage_strip(void *data, struct page *page)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* FIXME: Just for debugging, will be removed */\n\tif (PageUptodate(page))\n\t\tEXOFS_ERR(\"PageUptodate(0x%lx, 0x%lx)\\n\", pcol->inode->i_ino,\n\t\t\t  page->index);\n\n\tpcol->that_locked_page = page;\n\n\tif (page->index < end_index)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse if (page->index == end_index)\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = 0;\n\n\tif (!len || !obj_created(oi)) {\n\t\t/* this will be out of bounds, or doesn't exist yet.\n\t\t * Current page is cleared and the request is split\n\t\t */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG(\"readpage_strip(0x%lx) empty page len=%zx \"\n\t\t\t     \"read_4_write=%d index=0x%lx end_index=0x%lx \"\n\t\t\t     \"splitting\\n\", inode->i_ino, len,\n\t\t\t     pcol->read_4_write, page->index, end_index);\n\n\t\treturn read_exec(pcol);\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tif (len != PAGE_CACHE_SIZE)\n\t\tzero_user(page, len, PAGE_CACHE_SIZE - len);\n\n\tEXOFS_DBGMSG2(\"    readpage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (ret) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page pages[i]=%p \"\n\t\t\t  \"this_len=0x%zx nr_pages=%u length=0x%lx\\n\",\n\t\t\t  page, len, pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, and start again with current page */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tgoto try_again;\n\t}\n\n\treturn 0;\n\nfail:\n\t/* SetPageError(page); ??? */\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pcol_init",
          "args": [
            "&pcol",
            "1",
            "page->mapping->host"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "_pcol_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "66-83",
          "snippet": "static void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _readpage(struct page *page, bool read_4_write)\n{\n\tstruct page_collect pcol;\n\tint ret;\n\n\t_pcol_init(&pcol, 1, page->mapping->host);\n\n\tpcol.read_4_write = read_4_write;\n\tret = readpage_strip(&pcol, page);\n\tif (ret) {\n\t\tEXOFS_ERR(\"_readpage => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn read_exec(&pcol);\n}"
  },
  {
    "function_name": "exofs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "473-492",
    "snippet": "static int exofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\tstruct page_collect pcol;\n\tint ret;\n\n\t_pcol_init(&pcol, nr_pages, mapping->host);\n\n\tret = read_cache_pages(mapping, pages, readpage_strip, &pcol);\n\tif (ret) {\n\t\tEXOFS_ERR(\"read_cache_pages => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = read_exec(&pcol);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn read_exec(&pcol);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_exec",
          "args": [
            "&pcol"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "read_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "308-371",
          "snippet": "static int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"read_cache_pages => %d\\n\"",
            "ret"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_pages",
          "args": [
            "mapping",
            "pages",
            "readpage_strip",
            "&pcol"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pcol_init",
          "args": [
            "&pcol",
            "nr_pages",
            "mapping->host"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "_pcol_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "66-83",
          "snippet": "static void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\tstruct page_collect pcol;\n\tint ret;\n\n\t_pcol_init(&pcol, nr_pages, mapping->host);\n\n\tret = read_cache_pages(mapping, pages, readpage_strip, &pcol);\n\tif (ret) {\n\t\tEXOFS_ERR(\"read_cache_pages => %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = read_exec(&pcol);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn read_exec(&pcol);\n}"
  },
  {
    "function_name": "readpage_strip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "380-471",
    "snippet": "static int readpage_strip(void *data, struct page *page)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* FIXME: Just for debugging, will be removed */\n\tif (PageUptodate(page))\n\t\tEXOFS_ERR(\"PageUptodate(0x%lx, 0x%lx)\\n\", pcol->inode->i_ino,\n\t\t\t  page->index);\n\n\tpcol->that_locked_page = page;\n\n\tif (page->index < end_index)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse if (page->index == end_index)\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = 0;\n\n\tif (!len || !obj_created(oi)) {\n\t\t/* this will be out of bounds, or doesn't exist yet.\n\t\t * Current page is cleared and the request is split\n\t\t */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG(\"readpage_strip(0x%lx) empty page len=%zx \"\n\t\t\t     \"read_4_write=%d index=0x%lx end_index=0x%lx \"\n\t\t\t     \"splitting\\n\", inode->i_ino, len,\n\t\t\t     pcol->read_4_write, page->index, end_index);\n\n\t\treturn read_exec(pcol);\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tif (len != PAGE_CACHE_SIZE)\n\t\tzero_user(page, len, PAGE_CACHE_SIZE - len);\n\n\tEXOFS_DBGMSG2(\"    readpage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (ret) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page pages[i]=%p \"\n\t\t\t  \"this_len=0x%zx nr_pages=%u length=0x%lx\\n\",\n\t\t\t  page, len, pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, and start again with current page */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tgoto try_again;\n\t}\n\n\treturn 0;\n\nfail:\n\t/* SetPageError(page); ??? */\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_exec",
          "args": [
            "pcol"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "read_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "308-371",
          "snippet": "static int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"Failed pcol_add_page pages[i]=%p \"\n\t\t\t  \"this_len=0x%zx nr_pages=%u length=0x%lx\\n\"",
            "page",
            "len",
            "pcol->nr_pages",
            "pcol->length"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_add_page",
          "args": [
            "pcol",
            "page",
            "len"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_add_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "137-146",
          "snippet": "static int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"    readpage_strip(0x%lx, 0x%lx) len=0x%zx\\n\"",
            "inode->i_ino",
            "page->index",
            "len"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "len",
            "PAGE_CACHE_SIZE - len"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_try_alloc",
          "args": [
            "pcol"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_try_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "105-124",
          "snippet": "static int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pcol->pg_first == -1"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"readpage_strip(0x%lx) empty page len=%zx \"\n\t\t\t     \"read_4_write=%d index=0x%lx end_index=0x%lx \"\n\t\t\t     \"splitting\\n\"",
            "inode->i_ino",
            "len",
            "pcol->read_4_write",
            "page->index",
            "end_index"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_created",
          "args": [
            "oi"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__exofs_wait_obj_created",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1249-1258",
          "snippet": "int __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\n{\n\tif (!obj_created(oi)) {\n\t\tEXOFS_DBGMSG(\"!obj_created\\n\");\n\t\tBUG_ON(!obj_2bcreated(oi));\n\t\twait_event(oi->i_wq, obj_created(oi));\n\t\tEXOFS_DBGMSG(\"wait_event done\\n\");\n\t}\n\treturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"PageUptodate(0x%lx, 0x%lx)\\n\"",
            "pcol->inode->i_ino",
            "page->index"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int readpage_strip(void *data, struct page *page)\n{\n\tstruct page_collect *pcol = data;\n\tstruct inode *inode = pcol->inode;\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize_t len;\n\tint ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* FIXME: Just for debugging, will be removed */\n\tif (PageUptodate(page))\n\t\tEXOFS_ERR(\"PageUptodate(0x%lx, 0x%lx)\\n\", pcol->inode->i_ino,\n\t\t\t  page->index);\n\n\tpcol->that_locked_page = page;\n\n\tif (page->index < end_index)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse if (page->index == end_index)\n\t\tlen = i_size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = 0;\n\n\tif (!len || !obj_created(oi)) {\n\t\t/* this will be out of bounds, or doesn't exist yet.\n\t\t * Current page is cleared and the request is split\n\t\t */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tEXOFS_DBGMSG(\"readpage_strip(0x%lx) empty page len=%zx \"\n\t\t\t     \"read_4_write=%d index=0x%lx end_index=0x%lx \"\n\t\t\t     \"splitting\\n\", inode->i_ino, len,\n\t\t\t     pcol->read_4_write, page->index, end_index);\n\n\t\treturn read_exec(pcol);\n\t}\n\ntry_again:\n\n\tif (unlikely(pcol->pg_first == -1)) {\n\t\tpcol->pg_first = page->index;\n\t} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\n\t\t   page->index)) {\n\t\t/* Discontinuity detected, split the request */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t\tgoto try_again;\n\t}\n\n\tif (!pcol->pages) {\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\t}\n\n\tif (len != PAGE_CACHE_SIZE)\n\t\tzero_user(page, len, PAGE_CACHE_SIZE - len);\n\n\tEXOFS_DBGMSG2(\"    readpage_strip(0x%lx, 0x%lx) len=0x%zx\\n\",\n\t\t     inode->i_ino, page->index, len);\n\n\tret = pcol_add_page(pcol, page, len);\n\tif (ret) {\n\t\tEXOFS_DBGMSG2(\"Failed pcol_add_page pages[i]=%p \"\n\t\t\t  \"this_len=0x%zx nr_pages=%u length=0x%lx\\n\",\n\t\t\t  page, len, pcol->nr_pages, pcol->length);\n\n\t\t/* split the request, and start again with current page */\n\t\tret = read_exec(pcol);\n\t\tif (unlikely(ret))\n\t\t\tgoto fail;\n\n\t\tgoto try_again;\n\t}\n\n\treturn 0;\n\nfail:\n\t/* SetPageError(page); ??? */\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "read_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "308-371",
    "snippet": "static int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcol_copy"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_free",
          "args": [
            "pcol_copy"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "126-135",
          "snippet": "static void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_unlock_pcol_pages",
          "args": [
            "pcol_copy",
            "ret",
            "READ"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "_unlock_pcol_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "252-266",
          "snippet": "static void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pcol->sbi->s_curr_pending"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "ios"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\"",
            "pcol->inode->i_ino",
            "_LLU(ios->offset)",
            "_LLU(ios->length)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "ios->length"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "ios->offset"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_maybe_not_all_in_one_io",
          "args": [
            "ios",
            "pcol_copy",
            "pcol"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "_maybe_not_all_in_one_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "268-306",
          "snippet": "static int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pcol_reset",
          "args": [
            "pcol"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "_pcol_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "85-103",
          "snippet": "static void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pcol_copy)",
            "GFP_KERNEL"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__readpages_done",
          "args": [
            "pcol"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__readpages_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "195-240",
          "snippet": "static int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "pcol->ios"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_rw_state",
          "args": [
            "&pcol->sbi->layout",
            "&oi->oc",
            "true",
            "pcol->pg_first << PAGE_CACHE_SHIFT",
            "pcol->length",
            "&pcol->ios"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_rw_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "242-301",
          "snippet": "int  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "pcol->inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int read_exec(struct page_collect *pcol)\n{\n\tstruct exofs_i_info *oi = exofs_i(pcol->inode);\n\tstruct ore_io_state *ios;\n\tstruct page_collect *pcol_copy = NULL;\n\tint ret;\n\n\tif (!pcol->pages)\n\t\treturn 0;\n\n\tif (!pcol->ios) {\n\t\tint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\n\t\t\t\t\t     pcol->pg_first << PAGE_CACHE_SHIFT,\n\t\t\t\t\t     pcol->length, &pcol->ios);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tios = pcol->ios;\n\tios->pages = pcol->pages;\n\n\tif (pcol->read_4_write) {\n\t\tore_read(pcol->ios);\n\t\treturn __readpages_done(pcol);\n\t}\n\n\tpcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\n\tif (!pcol_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t*pcol_copy = *pcol;\n\tios->done = readpages_done;\n\tios->private = pcol_copy;\n\n\t/* pages ownership was passed to pcol_copy */\n\t_pcol_reset(pcol);\n\n\tret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tEXOFS_DBGMSG2(\"read_exec(0x%lx) offset=0x%llx length=0x%llx\\n\",\n\t\tpcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto err;\n\n\tatomic_inc(&pcol->sbi->s_curr_pending);\n\n\treturn 0;\n\nerr:\n\tif (!pcol_copy) /* Failed before ownership transfer */\n\t\tpcol_copy = pcol;\n\t_unlock_pcol_pages(pcol_copy, ret, READ);\n\tpcol_free(pcol_copy);\n\tkfree(pcol_copy);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "_maybe_not_all_in_one_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "268-306",
    "snippet": "static int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\"",
            "pcol_src->nr_pages",
            "pages_less",
            "pcol->expected_pages",
            "pcol->pg_first * PAGE_SIZE",
            "pcol->length"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_try_alloc",
          "args": [
            "pcol"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_try_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "105-124",
          "snippet": "static int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pcol_src->nr_pages < ios->nr_pages"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int _maybe_not_all_in_one_io(struct ore_io_state *ios,\n\tstruct page_collect *pcol_src, struct page_collect *pcol)\n{\n\t/* length was wrong or offset was not page aligned */\n\tBUG_ON(pcol_src->nr_pages < ios->nr_pages);\n\n\tif (pcol_src->nr_pages > ios->nr_pages) {\n\t\tstruct page **src_page;\n\t\tunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\n\t\tunsigned long len_less = pcol_src->length - ios->length;\n\t\tunsigned i;\n\t\tint ret;\n\n\t\t/* This IO was trimmed */\n\t\tpcol_src->nr_pages = ios->nr_pages;\n\t\tpcol_src->length = ios->length;\n\n\t\t/* Left over pages are passed to the next io */\n\t\tpcol->expected_pages += pages_less;\n\t\tpcol->nr_pages = pages_less;\n\t\tpcol->length = len_less;\n\t\tsrc_page = pcol_src->pages + pcol_src->nr_pages;\n\t\tpcol->pg_first = (*src_page)->index;\n\n\t\tret = pcol_try_alloc(pcol);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pages_less; ++i)\n\t\t\tpcol->pages[i] = *src_page++;\n\n\t\tEXOFS_DBGMSG(\"Length was adjusted nr_pages=0x%x \"\n\t\t\t\"pages_less=0x%x expected_pages=0x%x \"\n\t\t\t\"next_offset=0x%llx next_len=0x%lx\\n\",\n\t\t\tpcol_src->nr_pages, pages_less, pcol->expected_pages,\n\t\t\tpcol->pg_first * PAGE_SIZE, pcol->length);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "_unlock_pcol_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "252-266",
    "snippet": "static void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_write_page",
          "args": [
            "page",
            "ret"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "update_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "180-190",
          "snippet": "static void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_read_page",
          "args": [
            "page",
            "ret"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "update_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "149-178",
          "snippet": "static int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\n{\n\tint i;\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\n\t\tif (rw == READ)\n\t\t\tupdate_read_page(page, ret);\n\t\telse\n\t\t\tupdate_write_page(page, ret);\n\n\t\tunlock_page(page);\n\t}\n}"
  },
  {
    "function_name": "readpages_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "243-250",
    "snippet": "static void readpages_done(struct ore_io_state *ios, void *p)\n{\n\tstruct page_collect *pcol = p;\n\n\t__readpages_done(pcol);\n\tatomic_dec(&pcol->sbi->s_curr_pending);\n\tkfree(pcol);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcol"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pcol->sbi->s_curr_pending"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__readpages_done",
          "args": [
            "pcol"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__readpages_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "195-240",
          "snippet": "static int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void readpages_done(struct ore_io_state *ios, void *p)\n{\n\tstruct page_collect *pcol = p;\n\n\t__readpages_done(pcol);\n\tatomic_dec(&pcol->sbi->s_curr_pending);\n\tkfree(pcol);\n}"
  },
  {
    "function_name": "__readpages_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "195-240",
    "snippet": "static int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"readpages_done END\\n\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcol_free",
          "args": [
            "pcol"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "pcol_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "126-135",
          "snippet": "static void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_read_page",
          "args": [
            "page",
            "page_stat"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "update_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "149-178",
          "snippet": "static int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"    readpages_done(0x%lx, 0x%lx) %s\\n\"",
            "inode->i_ino",
            "page->index",
            "page_stat ? \"bad_bytes\" : \"good_bytes\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "length < good_bytes"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\"",
            "pcol->inode->i_ino",
            "_LLU(good_bytes)",
            "pcol->length",
            "pcol->nr_pages"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "good_bytes"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "pcol->ios",
            "NULL"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int __readpages_done(struct page_collect *pcol)\n{\n\tint i;\n\tu64 good_bytes;\n\tu64 length = 0;\n\tint ret = ore_check_io(pcol->ios, NULL);\n\n\tif (likely(!ret)) {\n\t\tgood_bytes = pcol->length;\n\t\tret = PAGE_WAS_NOT_IN_IO;\n\t} else {\n\t\tgood_bytes = 0;\n\t}\n\n\tEXOFS_DBGMSG2(\"readpages_done(0x%lx) good_bytes=0x%llx\"\n\t\t     \" length=0x%lx nr_pages=%u\\n\",\n\t\t     pcol->inode->i_ino, _LLU(good_bytes), pcol->length,\n\t\t     pcol->nr_pages);\n\n\tfor (i = 0; i < pcol->nr_pages; i++) {\n\t\tstruct page *page = pcol->pages[i];\n\t\tstruct inode *inode = page->mapping->host;\n\t\tint page_stat;\n\n\t\tif (inode != pcol->inode)\n\t\t\tcontinue; /* osd might add more pages at end */\n\n\t\tif (likely(length < good_bytes))\n\t\t\tpage_stat = 0;\n\t\telse\n\t\t\tpage_stat = ret;\n\n\t\tEXOFS_DBGMSG2(\"    readpages_done(0x%lx, 0x%lx) %s\\n\",\n\t\t\t  inode->i_ino, page->index,\n\t\t\t  page_stat ? \"bad_bytes\" : \"good_bytes\");\n\n\t\tret = update_read_page(page, page_stat);\n\t\tif (!pcol->read_4_write)\n\t\t\tunlock_page(page);\n\t\tlength += PAGE_SIZE;\n\t}\n\n\tpcol_free(pcol);\n\tEXOFS_DBGMSG2(\"readpages_done END\\n\");\n\treturn ret;\n}"
  },
  {
    "function_name": "update_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "180-190",
    "snippet": "static void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "page->mapping",
            "ret"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == PAGE_WAS_NOT_IN_IO"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void update_write_page(struct page *page, int ret)\n{\n\tif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\n\t\treturn; /* don't pass start don't collect $200 */\n\n\tif (ret) {\n\t\tmapping_set_error(page->mapping, ret);\n\t\tSetPageError(page);\n\t}\n\tend_page_writeback(page);\n}"
  },
  {
    "function_name": "update_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "149-178",
    "snippet": "static int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"recovered read error\\n\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int update_read_page(struct page *page, int ret)\n{\n\tswitch (ret) {\n\tcase 0:\n\t\t/* Everything is OK */\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tbreak;\n\tcase -EFAULT:\n\t\t/* In this case we were trying to read something that wasn't on\n\t\t * disk yet - return a page full of zeroes.  This should be OK,\n\t\t * because the object should be empty (if there was a write\n\t\t * before this read, the read would be waiting with the page\n\t\t * locked */\n\t\tclear_highpage(page);\n\n\t\tSetPageUptodate(page);\n\t\tif (PageError(page))\n\t\t\tClearPageError(page);\n\t\tEXOFS_DBGMSG(\"recovered read error\\n\");\n\t\t/* fall through */\n\tcase PAGE_WAS_NOT_IN_IO:\n\t\tret = 0; /* recovered error */\n\t\tbreak;\n\tdefault:\n\t\tSetPageError(page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pcol_add_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "137-146",
    "snippet": "static int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pcol->nr_pages >= pcol->alloc_pages"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_add_page(struct page_collect *pcol, struct page *page,\n\t\t\t unsigned len)\n{\n\tif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\n\t\treturn -ENOMEM;\n\n\tpcol->pages[pcol->nr_pages++] = page;\n\tpcol->length += len;\n\treturn 0;\n}"
  },
  {
    "function_name": "pcol_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "126-135",
    "snippet": "static void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "pcol->ios"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcol->pages"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void pcol_free(struct page_collect *pcol)\n{\n\tkfree(pcol->pages);\n\tpcol->pages = NULL;\n\n\tif (pcol->ios) {\n\t\tore_put_io_state(pcol->ios);\n\t\tpcol->ios = NULL;\n\t}\n}"
  },
  {
    "function_name": "pcol_try_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "105-124",
    "snippet": "static int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Failed to kmalloc expected_pages=%u\\n\"",
            "pcol->expected_pages"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pcol->pages"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pages * sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_max_io_pages",
          "args": [
            "&pcol->sbi->layout",
            "pcol->expected_pages"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_max_io_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "40-47",
          "snippet": "unsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nunsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int pcol_try_alloc(struct page_collect *pcol)\n{\n\tunsigned pages;\n\n\t/* TODO: easily support bio chaining */\n\tpages =  exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\n\n\tfor (; pages; pages >>= 1) {\n\t\tpcol->pages = kmalloc(pages * sizeof(struct page *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (likely(pcol->pages)) {\n\t\t\tpcol->alloc_pages = pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tEXOFS_ERR(\"Failed to kmalloc expected_pages=%u\\n\",\n\t\t  pcol->expected_pages);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "_pcol_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "85-103",
    "snippet": "static void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_max_io_pages",
          "args": [
            "&pcol->sbi->layout",
            "~0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_max_io_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "40-47",
          "snippet": "unsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nunsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pcol->nr_pages",
            "pcol->expected_pages"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_reset(struct page_collect *pcol)\n{\n\tpcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\n\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->ios = NULL;\n\tpcol->that_locked_page = NULL;\n\n\t/* this is probably the end of the loop but in writes\n\t * it might not end here. don't be left with nothing\n\t */\n\tif (!pcol->expected_pages)\n\t\tpcol->expected_pages =\n\t\t\t\texofs_max_io_pages(&pcol->sbi->layout, ~0);\n}"
  },
  {
    "function_name": "_pcol_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "66-83",
    "snippet": "static void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\n\t\t       struct inode *inode)\n{\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\n\tpcol->sbi = sbi;\n\tpcol->inode = inode;\n\tpcol->expected_pages = expected_pages;\n\n\tpcol->ios = NULL;\n\tpcol->pages = NULL;\n\tpcol->alloc_pages = 0;\n\tpcol->nr_pages = 0;\n\tpcol->length = 0;\n\tpcol->pg_first = -1;\n\tpcol->read_4_write = false;\n\tpcol->that_locked_page = NULL;\n}"
  },
  {
    "function_name": "exofs_max_io_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
    "lines": "40-47",
    "snippet": "unsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "expected_pages",
            "layout->max_io_length / PAGE_SIZE"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nunsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}"
  }
]