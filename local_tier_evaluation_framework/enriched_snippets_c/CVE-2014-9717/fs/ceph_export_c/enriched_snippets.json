[
  {
    "function_name": "ceph_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "205-242",
    "snippet": "static int ceph_get_name(struct dentry *parent, char *name,\n\t\t\t struct dentry *child)\n{\n\tstruct ceph_mds_client *mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tmdsc = ceph_inode_to_client(child->d_inode)->mdsc;\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPNAME,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\treq->r_inode = child->d_inode;\n\tihold(child->d_inode);\n\treq->r_ino2 = ceph_vino(parent->d_inode);\n\treq->r_locked_dir = parent->d_inode;\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\n\tif (!err) {\n\t\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\t\tmemcpy(name, rinfo->dname, rinfo->dname_len);\n\t\tname[rinfo->dname_len] = 0;\n\t\tdout(\"get_name %p ino %llx.%llx name %s\\n\",\n\t\t     child, ceph_vinop(child->d_inode), name);\n\t} else {\n\t\tdout(\"get_name %p ino %llx.%llx err %d\\n\",\n\t\t     child, ceph_vinop(child->d_inode), err);\n\t}\n\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_name %p ino %llx.%llx err %d\\n\"",
            "child",
            "ceph_vinop(child->d_inode)",
            "err"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "child->d_inode"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_name %p ino %llx.%llx name %s\\n\"",
            "child",
            "ceph_vinop(child->d_inode)",
            "name"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "child->d_inode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "rinfo->dname",
            "rinfo->dname_len"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "parent->d_inode"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "child->d_inode"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_LOOKUPNAME",
            "USE_ANY_MDS"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "child->d_inode"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_get_name(struct dentry *parent, char *name,\n\t\t\t struct dentry *child)\n{\n\tstruct ceph_mds_client *mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tmdsc = ceph_inode_to_client(child->d_inode)->mdsc;\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPNAME,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\treq->r_inode = child->d_inode;\n\tihold(child->d_inode);\n\treq->r_ino2 = ceph_vino(parent->d_inode);\n\treq->r_locked_dir = parent->d_inode;\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\n\tif (!err) {\n\t\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\t\tmemcpy(name, rinfo->dname, rinfo->dname_len);\n\t\tname[rinfo->dname_len] = 0;\n\t\tdout(\"get_name %p ino %llx.%llx name %s\\n\",\n\t\t     child, ceph_vinop(child->d_inode), name);\n\t} else {\n\t\tdout(\"get_name %p ino %llx.%llx err %d\\n\",\n\t\t     child, ceph_vinop(child->d_inode), err);\n\t}\n\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "186-203",
    "snippet": "static struct dentry *ceph_fh_to_parent(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_confh *cfh = (void *)fid->raw;\n\tstruct dentry *dentry;\n\n\tif (fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*cfh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_parent %llx\\n\", cfh->parent_ino);\n\tdentry = __get_parent(sb, NULL, cfh->ino);\n\tif (IS_ERR(dentry) && PTR_ERR(dentry) == -ENOENT)\n\t\tdentry = __fh_to_dentry(sb, cfh->parent_ino);\n\treturn dentry;\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fh_to_dentry",
          "args": [
            "sb",
            "cfh->parent_ino"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
          "lines": "61-103",
          "snippet": "static struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_parent",
          "args": [
            "sb",
            "NULL",
            "cfh->ino"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
          "lines": "124-170",
          "snippet": "static struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fh_to_parent %llx\\n\"",
            "cfh->parent_ino"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_fh_to_parent(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_confh *cfh = (void *)fid->raw;\n\tstruct dentry *dentry;\n\n\tif (fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*cfh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_parent %llx\\n\", cfh->parent_ino);\n\tdentry = __get_parent(sb, NULL, cfh->ino);\n\tif (IS_ERR(dentry) && PTR_ERR(dentry) == -ENOENT)\n\t\tdentry = __fh_to_dentry(sb, cfh->parent_ino);\n\treturn dentry;\n}"
  },
  {
    "function_name": "ceph_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "172-181",
    "snippet": "static struct dentry *ceph_get_parent(struct dentry *child)\n{\n\t/* don't re-export snaps */\n\tif (ceph_snap(child->d_inode) != CEPH_NOSNAP)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdout(\"get_parent %p ino %llx.%llx\\n\",\n\t     child, ceph_vinop(child->d_inode));\n\treturn __get_parent(child->d_sb, child, 0);\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_parent",
          "args": [
            "child->d_sb",
            "child",
            "0"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
          "lines": "124-170",
          "snippet": "static struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_parent %p ino %llx.%llx\\n\"",
            "child",
            "ceph_vinop(child->d_inode)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "child->d_inode"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "child->d_inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_get_parent(struct dentry *child)\n{\n\t/* don't re-export snaps */\n\tif (ceph_snap(child->d_inode) != CEPH_NOSNAP)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdout(\"get_parent %p ino %llx.%llx\\n\",\n\t     child, ceph_vinop(child->d_inode));\n\treturn __get_parent(child->d_sb, child, 0);\n}"
  },
  {
    "function_name": "__get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "124-170",
    "snippet": "static struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__get_parent ino %llx parent %p ino %llx.%llx\\n\"",
            "child ? ceph_ino(child->d_inode) : ino",
            "dentry",
            "ceph_vinop(inode)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "child->d_inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "dentry"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "req"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_LOOKUPPARENT",
            "USE_ANY_MDS"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__get_parent(struct super_block *sb,\n\t\t\t\t   struct dentry *child, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPPARENT,\n\t\t\t\t       USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (child) {\n\t\treq->r_inode = child->d_inode;\n\t\tihold(child->d_inode);\n\t} else {\n\t\treq->r_ino1 = (struct ceph_vino) {\n\t\t\t.ino = ino,\n\t\t\t.snap = CEPH_NOSNAP,\n\t\t};\n\t}\n\treq->r_num_caps = 1;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tinode = req->r_target_inode;\n\tif (inode)\n\t\tihold(inode);\n\tceph_mdsc_put_request(req);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__get_parent ino %llx parent %p ino %llx.%llx\\n\",\n\t     child ? ceph_ino(child->d_inode) : ino,\n\t     dentry, ceph_vinop(inode));\n\treturn dentry;\n}"
  },
  {
    "function_name": "ceph_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "108-122",
    "snippet": "static struct dentry *ceph_fh_to_dentry(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_fh *fh = (void *)fid->raw;\n\n\tif (fh_type != FILEID_INO32_GEN  &&\n\t    fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*fh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_dentry %llx\\n\", fh->ino);\n\treturn __fh_to_dentry(sb, fh->ino);\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fh_to_dentry",
          "args": [
            "sb",
            "fh->ino"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
          "lines": "61-103",
          "snippet": "static struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fh_to_dentry %llx\\n\"",
            "fh->ino"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_fh_to_dentry(struct super_block *sb,\n\t\t\t\t\tstruct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\tstruct ceph_nfs_fh *fh = (void *)fid->raw;\n\n\tif (fh_type != FILEID_INO32_GEN  &&\n\t    fh_type != FILEID_INO32_GEN_PARENT)\n\t\treturn NULL;\n\tif (fh_len < sizeof(*fh) / 4)\n\t\treturn NULL;\n\n\tdout(\"fh_to_dentry %llx\\n\", fh->ino);\n\treturn __fh_to_dentry(sb, fh->ino);\n}"
  },
  {
    "function_name": "__fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "61-103",
    "snippet": "static struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__fh_to_dentry %llx %p dentry %p\\n\"",
            "ino",
            "inode",
            "dentry"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "dentry"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "req"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_LOOKUPINO",
            "USE_ANY_MDS"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_find_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "429-434",
          "snippet": "static inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *__fh_to_dentry(struct super_block *sb, u64 ino)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(sb)->mdsc;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct ceph_vino vino;\n\tint err;\n\n\tvino.ino = ino;\n\tvino.snap = CEPH_NOSNAP;\n\tinode = ceph_find_inode(sb, vino);\n\tif (!inode) {\n\t\tstruct ceph_mds_request *req;\n\n\t\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_LOOKUPINO,\n\t\t\t\t\t       USE_ANY_MDS);\n\t\tif (IS_ERR(req))\n\t\t\treturn ERR_CAST(req);\n\n\t\treq->r_ino1 = vino;\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t\tinode = req->r_target_inode;\n\t\tif (inode)\n\t\t\tihold(inode);\n\t\tceph_mdsc_put_request(req);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tdentry = d_obtain_alias(inode);\n\tif (IS_ERR(dentry)) {\n\t\tiput(inode);\n\t\treturn dentry;\n\t}\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(err);\n\t}\n\tdout(\"__fh_to_dentry %llx %p dentry %p\\n\", ino, inode, dentry);\n\treturn dentry;\n}"
  },
  {
    "function_name": "ceph_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/export.c",
    "lines": "24-59",
    "snippet": "static int ceph_encode_fh(struct inode *inode, u32 *rawfh, int *max_len,\n\t\t\t  struct inode *parent_inode)\n{\n\tint type;\n\tstruct ceph_nfs_fh *fh = (void *)rawfh;\n\tstruct ceph_nfs_confh *cfh = (void *)rawfh;\n\tint connected_handle_length = sizeof(*cfh)/4;\n\tint handle_length = sizeof(*fh)/4;\n\n\t/* don't re-export snaps */\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EINVAL;\n\n\tif (parent_inode && (*max_len < connected_handle_length)) {\n\t\t*max_len = connected_handle_length;\n\t\treturn FILEID_INVALID;\n\t} else if (*max_len < handle_length) {\n\t\t*max_len = handle_length;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tif (parent_inode) {\n\t\tdout(\"encode_fh %llx with parent %llx\\n\",\n\t\t     ceph_ino(inode), ceph_ino(parent_inode));\n\t\tcfh->ino = ceph_ino(inode);\n\t\tcfh->parent_ino = ceph_ino(parent_inode);\n\t\t*max_len = connected_handle_length;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t} else {\n\t\tdout(\"encode_fh %llx\\n\", ceph_ino(inode));\n\t\tfh->ino = ceph_ino(inode);\n\t\t*max_len = handle_length;\n\t\ttype = FILEID_INO32_GEN;\n\t}\n\treturn type;\n}",
    "includes": [
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_fh %llx\\n\"",
            "ceph_ino(inode)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_fh %llx with parent %llx\\n\"",
            "ceph_ino(inode)",
            "ceph_ino(parent_inode)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_encode_fh(struct inode *inode, u32 *rawfh, int *max_len,\n\t\t\t  struct inode *parent_inode)\n{\n\tint type;\n\tstruct ceph_nfs_fh *fh = (void *)rawfh;\n\tstruct ceph_nfs_confh *cfh = (void *)rawfh;\n\tint connected_handle_length = sizeof(*cfh)/4;\n\tint handle_length = sizeof(*fh)/4;\n\n\t/* don't re-export snaps */\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EINVAL;\n\n\tif (parent_inode && (*max_len < connected_handle_length)) {\n\t\t*max_len = connected_handle_length;\n\t\treturn FILEID_INVALID;\n\t} else if (*max_len < handle_length) {\n\t\t*max_len = handle_length;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tif (parent_inode) {\n\t\tdout(\"encode_fh %llx with parent %llx\\n\",\n\t\t     ceph_ino(inode), ceph_ino(parent_inode));\n\t\tcfh->ino = ceph_ino(inode);\n\t\tcfh->parent_ino = ceph_ino(parent_inode);\n\t\t*max_len = connected_handle_length;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t} else {\n\t\tdout(\"encode_fh %llx\\n\", ceph_ino(inode));\n\t\tfh->ino = ceph_ino(inode);\n\t\t*max_len = handle_length;\n\t\ttype = FILEID_INO32_GEN;\n\t}\n\treturn type;\n}"
  }
]