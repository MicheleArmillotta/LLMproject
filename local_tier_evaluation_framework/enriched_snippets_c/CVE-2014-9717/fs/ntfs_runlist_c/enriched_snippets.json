[
  {
    "function_name": "ntfs_rl_punch_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1644-1905",
    "snippet": "int ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst VCN start, const s64 length)\n{\n\tconst VCN end = start + length;\n\ts64 delta;\n\trunlist_element *rl, *rl_end, *rl_real_end, *trl;\n\tint old_size;\n\tbool lcn_fixup = false;\n\n\tntfs_debug(\"Entering for start 0x%llx, length 0x%llx.\",\n\t\t\t(long long)start, (long long)length);\n\tBUG_ON(!runlist);\n\tBUG_ON(start < 0);\n\tBUG_ON(length < 0);\n\tBUG_ON(end < 0);\n\trl = runlist->rl;\n\tif (unlikely(!rl)) {\n\t\tif (likely(!start && !length))\n\t\t\treturn 0;\n\t\treturn -ENOENT;\n\t}\n\t/* Find @start in the runlist. */\n\twhile (likely(rl->length && start >= rl[1].vcn))\n\t\trl++;\n\trl_end = rl;\n\t/* Find @end in the runlist. */\n\twhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\n\t\t/* Verify there are no unmapped or error elements. */\n\t\tif (unlikely(rl_end->lcn < LCN_HOLE))\n\t\t\treturn -EINVAL;\n\t\trl_end++;\n\t}\n\t/* Check the last element. */\n\tif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\n\t\treturn -EINVAL;\n\t/* This covers @start being out of bounds, too. */\n\tif (!rl_end->length && end > rl_end->vcn)\n\t\treturn -ENOENT;\n\tif (!length)\n\t\treturn 0;\n\tif (!rl->length)\n\t\treturn -ENOENT;\n\trl_real_end = rl_end;\n\t/* Determine the runlist size. */\n\twhile (likely(rl_real_end->length))\n\t\trl_real_end++;\n\told_size = rl_real_end - runlist->rl + 1;\n\t/* If @start is in a hole simply extend the hole. */\n\tif (rl->lcn == LCN_HOLE) {\n\t\t/*\n\t\t * If both @start and @end are in the same sparse run, we are\n\t\t * done.\n\t\t */\n\t\tif (end <= rl[1].vcn) {\n\t\t\tntfs_debug(\"Done (requested hole is already sparse).\");\n\t\t\treturn 0;\n\t\t}\nextend_hole:\n\t\t/* Extend the hole. */\n\t\trl->length = end - rl->vcn;\n\t\t/* If @end is in a hole, merge it with the current one. */\n\t\tif (rl_end->lcn == LCN_HOLE) {\n\t\t\trl_end++;\n\t\t\trl->length = rl_end->vcn - rl->vcn;\n\t\t}\n\t\t/* We have done the hole.  Now deal with the remaining tail. */\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Adjust the beginning of the tail if necessary. */\n\t\tif (end > rl->vcn) {\n\t\t\tdelta = end - rl->vcn;\n\t\t\trl->vcn = end;\n\t\t\trl->length -= delta;\n\t\t\t/* Only adjust the lcn if it is real. */\n\t\t\tif (rl->lcn >= 0)\n\t\t\t\trl->lcn += delta;\n\t\t}\nshrink_allocation:\n\t\t/* Reallocate memory if the allocation changed. */\n\t\tif (rl < rl_end) {\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size - (rl_end - rl));\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t\tntfs_debug(\"Done (extend hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * If @start is at the beginning of a run things are easier as there is\n\t * no need to split the first run.\n\t */\n\tif (start == rl->vcn) {\n\t\t/*\n\t\t * @start is at the beginning of a run.\n\t\t *\n\t\t * If the previous run is sparse, extend its hole.\n\t\t *\n\t\t * If @end is not in the same run, switch the run to be sparse\n\t\t * and extend the newly created hole.\n\t\t *\n\t\t * Thus both of these cases reduce the problem to the above\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\n\t\t\trl--;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\tif (end >= rl[1].vcn) {\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\t/*\n\t\t * The final case is when @end is in the same run as @start.\n\t\t * For this need to split the run into two.  One run for the\n\t\t * sparse region between the beginning of the old run, i.e.\n\t\t * @start, and @end and one for the remaining non-sparse\n\t\t * region, i.e. between @end and the end of the old run.\n\t\t */\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\nsplit_end:\n\t\t/* Shift all the runs up by one. */\n\t\tmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t\t/* Finally, setup the two split runs. */\n\t\trl->lcn = LCN_HOLE;\n\t\trl->length = length;\n\t\trl++;\n\t\trl->vcn += length;\n\t\t/* Only adjust the lcn if it is real. */\n\t\tif (rl->lcn >= 0 || lcn_fixup)\n\t\t\trl->lcn += length;\n\t\trl->length -= length;\n\t\tntfs_debug(\"Done (split one).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * @start is neither in a hole nor at the beginning of a run.\n\t *\n\t * If @end is in a hole, things are easier as simply truncating the run\n\t * @start is in to end at @start - 1, deleting all runs after that up\n\t * to @end, and finally extending the beginning of the run @end is in\n\t * to be @start is all that is needed.\n\t */\n\tif (rl_end->lcn == LCN_HOLE) {\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Extend the beginning of the run @end is in to be @start. */\n\t\trl->vcn = start;\n\t\trl->length = rl[1].vcn - start;\n\t\tgoto shrink_allocation;\n\t}\n\t/* \n\t * If @end is not in a hole there are still two cases to distinguish.\n\t * Either @end is or is not in the same run as @start.\n\t *\n\t * The second case is easier as it can be reduced to an already solved\n\t * problem by truncating the run @start is in to end at @start - 1.\n\t * Then, if @end is in the next run need to split the run into a sparse\n\t * run followed by a non-sparse run (already covered above) and if @end\n\t * is not in the next run switching it to be sparse, again reduces the\n\t * problem to the already covered case of \"@start is in a hole\".\n\t */\n\tif (end >= rl[1].vcn) {\n\t\t/*\n\t\t * If @end is not in the next run, reduce the problem to the\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl[1].length && end >= rl[2].vcn) {\n\t\t\t/* Truncate the run containing @start. */\n\t\t\trl->length = start - rl->vcn;\n\t\t\trl++;\n\t\t\trl->vcn = start;\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/*\n\t\t * @end is in the next run, reduce the problem to the case\n\t\t * where \"@start is at the beginning of a run and @end is in\n\t\t * the same run as @start\".\n\t\t */\n\t\tdelta = rl->vcn - start;\n\t\trl->vcn = start;\n\t\tif (rl->lcn >= 0) {\n\t\t\trl->lcn -= delta;\n\t\t\t/* Need this in case the lcn just became negative. */\n\t\t\tlcn_fixup = true;\n\t\t}\n\t\trl->length += delta;\n\t\tgoto split_end;\n\t}\n\t/*\n\t * The first case from above, i.e. @end is in the same run as @start.\n\t * We need to split the run into three.  One run for the non-sparse\n\t * region between the beginning of the old run and @start, one for the\n\t * sparse region between @start and @end, and one for the remaining\n\t * non-sparse region, i.e. between @end and the end of the old run.\n\t */\n\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\n\tif (IS_ERR(trl))\n\t\tgoto enomem_out;\n\told_size += 2;\n\tif (runlist->rl != trl) {\n\t\trl = trl + (rl - runlist->rl);\n\t\trl_end = trl + (rl_end - runlist->rl);\n\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\trunlist->rl = trl;\n\t}\n\t/* Shift all the runs up by two. */\n\tmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t/* Finally, setup the three split runs. */\n\trl->length = start - rl->vcn;\n\trl++;\n\trl->vcn = start;\n\trl->lcn = LCN_HOLE;\n\trl->length = length;\n\trl++;\n\tdelta = end - rl->vcn;\n\trl->vcn = end;\n\trl->lcn += delta;\n\trl->length -= delta;\n\tntfs_debug(\"Done (split both).\");\n\treturn 0;\nenomem_out:\n\tntfs_error(vol->sb, \"Not enough memory to extend runlist buffer.\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough memory to extend runlist buffer.\""
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done (split both).\""
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rl + 2",
            "rl",
            "(rl_real_end - rl + 1) * sizeof(*rl)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trl"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "runlist->rl",
            "old_size",
            "old_size + 2"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trl"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rl",
            "rl_end",
            "(rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl)"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rl + 1",
            "rl",
            "(rl_real_end - rl + 1) * sizeof(*rl)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trl"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\""
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rl",
            "rl_end",
            "(rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl_real_end->length"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl_end->length && rl_end->lcn < LCN_HOLE"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl_end->lcn < LCN_HOLE"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl_end->length && end >= rl_end[1].vcn"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->length && start >= rl[1].vcn"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!start && !length"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < 0"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "length < 0"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start < 0"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!runlist"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for start 0x%llx, length 0x%llx.\"",
            "(long long)start",
            "(long long)length"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst VCN start, const s64 length)\n{\n\tconst VCN end = start + length;\n\ts64 delta;\n\trunlist_element *rl, *rl_end, *rl_real_end, *trl;\n\tint old_size;\n\tbool lcn_fixup = false;\n\n\tntfs_debug(\"Entering for start 0x%llx, length 0x%llx.\",\n\t\t\t(long long)start, (long long)length);\n\tBUG_ON(!runlist);\n\tBUG_ON(start < 0);\n\tBUG_ON(length < 0);\n\tBUG_ON(end < 0);\n\trl = runlist->rl;\n\tif (unlikely(!rl)) {\n\t\tif (likely(!start && !length))\n\t\t\treturn 0;\n\t\treturn -ENOENT;\n\t}\n\t/* Find @start in the runlist. */\n\twhile (likely(rl->length && start >= rl[1].vcn))\n\t\trl++;\n\trl_end = rl;\n\t/* Find @end in the runlist. */\n\twhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\n\t\t/* Verify there are no unmapped or error elements. */\n\t\tif (unlikely(rl_end->lcn < LCN_HOLE))\n\t\t\treturn -EINVAL;\n\t\trl_end++;\n\t}\n\t/* Check the last element. */\n\tif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\n\t\treturn -EINVAL;\n\t/* This covers @start being out of bounds, too. */\n\tif (!rl_end->length && end > rl_end->vcn)\n\t\treturn -ENOENT;\n\tif (!length)\n\t\treturn 0;\n\tif (!rl->length)\n\t\treturn -ENOENT;\n\trl_real_end = rl_end;\n\t/* Determine the runlist size. */\n\twhile (likely(rl_real_end->length))\n\t\trl_real_end++;\n\told_size = rl_real_end - runlist->rl + 1;\n\t/* If @start is in a hole simply extend the hole. */\n\tif (rl->lcn == LCN_HOLE) {\n\t\t/*\n\t\t * If both @start and @end are in the same sparse run, we are\n\t\t * done.\n\t\t */\n\t\tif (end <= rl[1].vcn) {\n\t\t\tntfs_debug(\"Done (requested hole is already sparse).\");\n\t\t\treturn 0;\n\t\t}\nextend_hole:\n\t\t/* Extend the hole. */\n\t\trl->length = end - rl->vcn;\n\t\t/* If @end is in a hole, merge it with the current one. */\n\t\tif (rl_end->lcn == LCN_HOLE) {\n\t\t\trl_end++;\n\t\t\trl->length = rl_end->vcn - rl->vcn;\n\t\t}\n\t\t/* We have done the hole.  Now deal with the remaining tail. */\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Adjust the beginning of the tail if necessary. */\n\t\tif (end > rl->vcn) {\n\t\t\tdelta = end - rl->vcn;\n\t\t\trl->vcn = end;\n\t\t\trl->length -= delta;\n\t\t\t/* Only adjust the lcn if it is real. */\n\t\t\tif (rl->lcn >= 0)\n\t\t\t\trl->lcn += delta;\n\t\t}\nshrink_allocation:\n\t\t/* Reallocate memory if the allocation changed. */\n\t\tif (rl < rl_end) {\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size - (rl_end - rl));\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t\tntfs_debug(\"Done (extend hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * If @start is at the beginning of a run things are easier as there is\n\t * no need to split the first run.\n\t */\n\tif (start == rl->vcn) {\n\t\t/*\n\t\t * @start is at the beginning of a run.\n\t\t *\n\t\t * If the previous run is sparse, extend its hole.\n\t\t *\n\t\t * If @end is not in the same run, switch the run to be sparse\n\t\t * and extend the newly created hole.\n\t\t *\n\t\t * Thus both of these cases reduce the problem to the above\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\n\t\t\trl--;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\tif (end >= rl[1].vcn) {\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\t/*\n\t\t * The final case is when @end is in the same run as @start.\n\t\t * For this need to split the run into two.  One run for the\n\t\t * sparse region between the beginning of the old run, i.e.\n\t\t * @start, and @end and one for the remaining non-sparse\n\t\t * region, i.e. between @end and the end of the old run.\n\t\t */\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\nsplit_end:\n\t\t/* Shift all the runs up by one. */\n\t\tmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t\t/* Finally, setup the two split runs. */\n\t\trl->lcn = LCN_HOLE;\n\t\trl->length = length;\n\t\trl++;\n\t\trl->vcn += length;\n\t\t/* Only adjust the lcn if it is real. */\n\t\tif (rl->lcn >= 0 || lcn_fixup)\n\t\t\trl->lcn += length;\n\t\trl->length -= length;\n\t\tntfs_debug(\"Done (split one).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * @start is neither in a hole nor at the beginning of a run.\n\t *\n\t * If @end is in a hole, things are easier as simply truncating the run\n\t * @start is in to end at @start - 1, deleting all runs after that up\n\t * to @end, and finally extending the beginning of the run @end is in\n\t * to be @start is all that is needed.\n\t */\n\tif (rl_end->lcn == LCN_HOLE) {\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Extend the beginning of the run @end is in to be @start. */\n\t\trl->vcn = start;\n\t\trl->length = rl[1].vcn - start;\n\t\tgoto shrink_allocation;\n\t}\n\t/* \n\t * If @end is not in a hole there are still two cases to distinguish.\n\t * Either @end is or is not in the same run as @start.\n\t *\n\t * The second case is easier as it can be reduced to an already solved\n\t * problem by truncating the run @start is in to end at @start - 1.\n\t * Then, if @end is in the next run need to split the run into a sparse\n\t * run followed by a non-sparse run (already covered above) and if @end\n\t * is not in the next run switching it to be sparse, again reduces the\n\t * problem to the already covered case of \"@start is in a hole\".\n\t */\n\tif (end >= rl[1].vcn) {\n\t\t/*\n\t\t * If @end is not in the next run, reduce the problem to the\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl[1].length && end >= rl[2].vcn) {\n\t\t\t/* Truncate the run containing @start. */\n\t\t\trl->length = start - rl->vcn;\n\t\t\trl++;\n\t\t\trl->vcn = start;\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/*\n\t\t * @end is in the next run, reduce the problem to the case\n\t\t * where \"@start is at the beginning of a run and @end is in\n\t\t * the same run as @start\".\n\t\t */\n\t\tdelta = rl->vcn - start;\n\t\trl->vcn = start;\n\t\tif (rl->lcn >= 0) {\n\t\t\trl->lcn -= delta;\n\t\t\t/* Need this in case the lcn just became negative. */\n\t\t\tlcn_fixup = true;\n\t\t}\n\t\trl->length += delta;\n\t\tgoto split_end;\n\t}\n\t/*\n\t * The first case from above, i.e. @end is in the same run as @start.\n\t * We need to split the run into three.  One run for the non-sparse\n\t * region between the beginning of the old run and @start, one for the\n\t * sparse region between @start and @end, and one for the remaining\n\t * non-sparse region, i.e. between @end and the end of the old run.\n\t */\n\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\n\tif (IS_ERR(trl))\n\t\tgoto enomem_out;\n\told_size += 2;\n\tif (runlist->rl != trl) {\n\t\trl = trl + (rl - runlist->rl);\n\t\trl_end = trl + (rl_end - runlist->rl);\n\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\trunlist->rl = trl;\n\t}\n\t/* Shift all the runs up by two. */\n\tmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t/* Finally, setup the three split runs. */\n\trl->length = start - rl->vcn;\n\trl++;\n\trl->vcn = start;\n\trl->lcn = LCN_HOLE;\n\trl->length = length;\n\trl++;\n\tdelta = end - rl->vcn;\n\trl->vcn = end;\n\trl->lcn += delta;\n\trl->length -= delta;\n\tntfs_debug(\"Done (split both).\");\n\treturn 0;\nenomem_out:\n\tntfs_error(vol->sb, \"Not enough memory to extend runlist buffer.\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ntfs_rl_truncate_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1499-1621",
    "snippet": "int ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\""
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "runlist->rl",
            "old_size",
            "old_size + 1"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "/* !rl->length && */new_length > rl->vcn"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\""
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "trl->length"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->length && new_length >= rl[1].vcn"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_length < rl->vcn"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\""
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_length < 0"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!runlist"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for new_length 0x%llx.\"",
            "(long long)new_length"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_mapping_pairs_build",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1323-1473",
    "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dst_next > dst_max"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn_len < 0"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_write_significant_bytes",
          "args": [
            "dst + 1 +\n\t\t\t\t\tlen_len",
            "dst_max",
            "rl->lcn - prev_lcn"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_significant_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1252-1283",
          "snippet": "static inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\n\t\tconst s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\t*dst++ = l & 0xffll;\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif (n < 0 && j >= 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)-1;\n\t} else if (n > 0 && j < 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)0;\n\t}\n\treturn i;\nerr_out:\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\n\t\tconst s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\t*dst++ = l & 0xffll;\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif (n < 0 && j >= 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)-1;\n\t} else if (n > 0 && j < 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)0;\n\t}\n\treturn i;\nerr_out:\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0 || vol->major_ver < 3"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "len_len < 0"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl[1].vcn > s1"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "last_vcn >= 0 && rl[1].vcn > last_vcn"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length < 0 || rl->lcn < LCN_HOLE"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dst_next > dst_max"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn_len < 0"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0 || vol->major_ver < 3"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "len_len < 0"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl[1].vcn > s1"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "last_vcn >= 0 && rl[1].vcn > last_vcn"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length < 0 || rl->lcn < LCN_HOLE"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn > 0"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "first_vcn"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dst_len < 1"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn >= 0 && first_vcn > last_vcn"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn < -1"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "first_vcn < 0"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_write_significant_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1252-1283",
    "snippet": "static inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\n\t\tconst s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\t*dst++ = l & 0xffll;\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif (n < 0 && j >= 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)-1;\n\t} else if (n > 0 && j < 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)0;\n\t}\n\treturn i;\nerr_out:\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dst > dst_max"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dst > dst_max"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dst > dst_max"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\n\t\tconst s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\t*dst++ = l & 0xffll;\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif (n < 0 && j >= 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)-1;\n\t} else if (n > 0 && j < 0) {\n\t\tif (unlikely(dst > dst_max))\n\t\t\tgoto err_out;\n\t\ti++;\n\t\t*dst = (s8)0;\n\t}\n\treturn i;\nerr_out:\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "ntfs_get_size_for_mapping_pairs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1131-1232",
    "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_get_nr_significant_bytes",
          "args": [
            "rl->lcn -\n\t\t\t\t\tprev_lcn"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_nr_significant_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1084-1100",
          "snippet": "static inline int ntfs_get_nr_significant_bytes(const s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif ((n < 0 && j >= 0) || (n > 0 && j < 0))\n\t\ti++;\n\treturn i;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline int ntfs_get_nr_significant_bytes(const s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif ((n < 0 && j >= 0) || (n > 0 && j < 0))\n\t\ti++;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0 || vol->major_ver < 3"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl[1].vcn > s1"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "last_vcn >= 0 && rl[1].vcn > last_vcn"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length < 0 || rl->lcn < LCN_HOLE"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0 || vol->major_ver < 3"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl[1].vcn > s1"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "last_vcn >= 0 && rl[1].vcn > last_vcn"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length < 0 || rl->lcn < LCN_HOLE"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn > 0"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "first_vcn"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn >= 0 && first_vcn > last_vcn"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last_vcn < -1"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "first_vcn < 0"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
  },
  {
    "function_name": "ntfs_get_nr_significant_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1084-1100",
    "snippet": "static inline int ntfs_get_nr_significant_bytes(const s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif ((n < 0 && j >= 0) || (n > 0 && j < 0))\n\t\ti++;\n\treturn i;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline int ntfs_get_nr_significant_bytes(const s64 n)\n{\n\ts64 l = n;\n\tint i;\n\ts8 j;\n\n\ti = 0;\n\tdo {\n\t\tl >>= 8;\n\t\ti++;\n\t} while (l != 0 && l != -1);\n\tj = (n >> 8 * (i - 1)) & 0xff;\n\t/* If the sign bit is wrong, we need an extra byte. */\n\tif ((n < 0 && j >= 0) || (n > 0 && j < 0))\n\t\ti++;\n\treturn i;\n}"
  },
  {
    "function_name": "ntfs_rl_find_vcn_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1053-1069",
    "snippet": "runlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn == LCN_ENOENT"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= LCN_HOLE"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcn < rl[1].vcn"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->length"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl || vcn < rl[0].vcn"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcn < 0"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}"
  },
  {
    "function_name": "ntfs_rl_vcn_to_lcn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "1004-1036",
    "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl[i].lcn < (LCN)0"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl[i].lcn >= (LCN)0"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcn < rl[i+1].vcn"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl[i].length"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcn < rl[0].vcn"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcn < 0"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
  },
  {
    "function_name": "ntfs_mapping_pairs_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "749-978",
    "snippet": "runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Corrupt attribute.\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to merge runlists.\""
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!IS_ERR(old_rl)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old_rl"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_runlists_merge",
          "args": [
            "old_rl",
            "rl"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_runlists_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "531-719",
          "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug_dump_runlist",
          "args": [
            "rl"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\"",
            "(unsigned long long)deltaxcn",
            "(unsigned long long)\n\t\t\t\t\t\tmax_cluster"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "deltaxcn > max_cluster"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\"",
            "(unsigned long long)deltaxcn",
            "(unsigned long long)\n\t\t\t\t\t\tmax_cluster"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "attr->data.non_resident.allocated_size"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\""
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "deltaxcn && vcn - 1 != deltaxcn"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buf >= attr_end"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn < (LCN)-1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"lcn == -1\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn == (LCN)-1"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"lcn delta == -1\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "deltaxcn == (LCN)-1"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "deltaxcn < 0"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buf + b > attr_end"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rl2",
            "rl",
            "rlsize"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl2"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "rlsize + (int)PAGE_SIZE"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Corrupt attribute.\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buf < (u8*)attr || buf > attr_end"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "attr->length"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "attr->data.non_resident.mapping_pairs_offset"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid arguments.\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "ntfs_runlists_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "531-719",
    "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug_dump_runlist",
          "args": [
            "drl"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc_nofail",
          "args": [
            "drl",
            "ds",
            "ds + 1"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\"",
            "(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "srl"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "NULL",
            "\"Merge failed.\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "drl"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_split",
          "args": [
            "drl",
            "ds",
            "srl + sstart",
            "ss",
            "dins"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "470-495",
          "snippet": "static inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\n\t\trunlist_element *src, int ssize, int loc)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* Space required: @dst size + @src size + one new hole. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the holes either size of @src. */\n\tdst[loc].length\t\t= dst[loc+1].vcn       - dst[loc].vcn;\n\tdst[loc+ssize+1].vcn    = dst[loc+ssize].vcn   + dst[loc+ssize].length;\n\tdst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\n\n\treturn dst;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\n\t\trunlist_element *src, int ssize, int loc)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* Space required: @dst size + @src size + one new hole. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the holes either size of @src. */\n\tdst[loc].length\t\t= dst[loc+1].vcn       - dst[loc].vcn;\n\tdst[loc+ssize+1].vcn    = dst[loc+ssize].vcn   + dst[loc+ssize].length;\n\tdst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_append",
          "args": [
            "drl",
            "ds",
            "srl + sstart",
            "ss",
            "dins"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "218-259",
          "snippet": "static inline runlist_element *ntfs_rl_append(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, check if the right hand end needs merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\n\t/* Space required: @dst size + @src size, less one if we merged. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the right hand end, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\n\t/* First run after the @src runs that have been inserted. */\n\tmarker = loc + ssize + 1;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the preceding hole. */\n\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\n\t/* We may have changed the length of the file, so fix the end marker */\n\tif (dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\n\treturn dst;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_append(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, check if the right hand end needs merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\n\t/* Space required: @dst size + @src size, less one if we merged. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the right hand end, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\n\t/* First run after the @src runs that have been inserted. */\n\tmarker = loc + ssize + 1;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the preceding hole. */\n\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\n\t/* We may have changed the length of the file, so fix the end marker */\n\tif (dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_insert",
          "args": [
            "drl",
            "ds",
            "srl + sstart",
            "ss",
            "dins"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "285-356",
          "snippet": "static inline runlist_element *ntfs_rl_insert(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool disc = false;\t/* Discontinuity between @dst and @src. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/*\n\t * disc => Discontinuity between the end of @dst and the start of @src.\n\t *\t   This means we might need to insert a \"not mapped\" run.\n\t */\n\tif (loc == 0)\n\t\tdisc = (src[0].vcn > 0);\n\telse {\n\t\ts64 merged_length;\n\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\n\t\tmerged_length = dst[loc - 1].length;\n\t\tif (left)\n\t\t\tmerged_length += src->length;\n\n\t\tdisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\n\t}\n\t/*\n\t * Space required: @dst size + @src size, less one if we merged, plus\n\t * one if there was a discontinuity.\n\t */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlist.\n\t */\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * First run after the @src runs that have been inserted.\n\t * Nominally,  @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.  And if @disc, then @dst and @src do\n\t * not meet and we need an extra run to fill the gap.\n\t */\n\tmarker = loc + ssize - left + disc;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\n\n\t/* Adjust the VCN of the first run after the insertion... */\n\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\t/* ... and the length. */\n\tif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\n\t\tdst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\n\n\t/* Writing beyond the end of the file and there is a discontinuity. */\n\tif (disc) {\n\t\tif (loc > 0) {\n\t\t\tdst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\n\t\t\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\t\t} else {\n\t\t\tdst[loc].vcn = 0;\n\t\t\tdst[loc].length = dst[loc + 1].vcn;\n\t\t}\n\t\tdst[loc].lcn = LCN_RL_NOT_MAPPED;\n\t}\n\treturn dst;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_insert(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool disc = false;\t/* Discontinuity between @dst and @src. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/*\n\t * disc => Discontinuity between the end of @dst and the start of @src.\n\t *\t   This means we might need to insert a \"not mapped\" run.\n\t */\n\tif (loc == 0)\n\t\tdisc = (src[0].vcn > 0);\n\telse {\n\t\ts64 merged_length;\n\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\n\t\tmerged_length = dst[loc - 1].length;\n\t\tif (left)\n\t\t\tmerged_length += src->length;\n\n\t\tdisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\n\t}\n\t/*\n\t * Space required: @dst size + @src size, less one if we merged, plus\n\t * one if there was a discontinuity.\n\t */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlist.\n\t */\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * First run after the @src runs that have been inserted.\n\t * Nominally,  @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.  And if @disc, then @dst and @src do\n\t * not meet and we need an extra run to fill the gap.\n\t */\n\tmarker = loc + ssize - left + disc;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\n\n\t/* Adjust the VCN of the first run after the insertion... */\n\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\t/* ... and the length. */\n\tif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\n\t\tdst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\n\n\t/* Writing beyond the end of the file and there is a discontinuity. */\n\tif (disc) {\n\t\tif (loc > 0) {\n\t\t\tdst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\n\t\t\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\t\t} else {\n\t\t\tdst[loc].vcn = 0;\n\t\t\tdst[loc].length = dst[loc + 1].vcn;\n\t\t}\n\t\tdst[loc].lcn = LCN_RL_NOT_MAPPED;\n\t}\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_replace",
          "args": [
            "drl",
            "ds",
            "srl + sstart",
            "ss",
            "dins"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "381-444",
          "snippet": "static inline runlist_element *ntfs_rl_replace(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tsigned delta;\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint tail;\t\t/* Start of tail of @dst. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, see if the left and right ends need merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\tif (loc > 0)\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\t/*\n\t * Allocate some space.  We will need less if the left, right, or both\n\t * ends get merged.  The -1 accounts for the run being replaced.\n\t */\n\tdelta = ssize - 1 - left - right;\n\tif (delta > 0) {\n\t\tdst = ntfs_rl_realloc(dst, dsize, dsize + delta);\n\t\tif (IS_ERR(dst))\n\t\t\treturn dst;\n\t}\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the left and right ends, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * Offset of the tail of @dst.  This needs to be moved out of the way\n\t * to make space for the runs to be copied from @src, i.e. the first\n\t * run of the tail of @dst.\n\t * Nominally, @tail equals @loc + 1, i.e. location, skipping the\n\t * replaced run.  However, if @right, then one of @dst's runs is\n\t * already merged into @src.\n\t */\n\ttail = loc + right + 1;\n\t/*\n\t * First run after the @src runs that have been inserted, i.e. where\n\t * the tail of @dst needs to be moved to.\n\t * Nominally, @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.\n\t */\n\tmarker = loc + ssize - left;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, tail, dsize - tail);\n\tntfs_rl_mc(dst, loc, src, left, ssize - left);\n\n\t/* We may have changed the length of the file, so fix the end marker. */\n\tif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\treturn dst;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_replace(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tsigned delta;\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint tail;\t\t/* Start of tail of @dst. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, see if the left and right ends need merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\tif (loc > 0)\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\t/*\n\t * Allocate some space.  We will need less if the left, right, or both\n\t * ends get merged.  The -1 accounts for the run being replaced.\n\t */\n\tdelta = ssize - 1 - left - right;\n\tif (delta > 0) {\n\t\tdst = ntfs_rl_realloc(dst, dsize, dsize + delta);\n\t\tif (IS_ERR(dst))\n\t\t\treturn dst;\n\t}\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the left and right ends, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * Offset of the tail of @dst.  This needs to be moved out of the way\n\t * to make space for the runs to be copied from @src, i.e. the first\n\t * run of the tail of @dst.\n\t * Nominally, @tail equals @loc + 1, i.e. location, skipping the\n\t * replaced run.  However, if @right, then one of @dst's runs is\n\t * already merged into @src.\n\t */\n\ttail = loc + right + 1;\n\t/*\n\t * First run after the @src runs that have been inserted, i.e. where\n\t * the tail of @dst needs to be moved to.\n\t * Nominally, @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.\n\t */\n\tmarker = loc + ssize - left;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, tail, dsize - tail);\n\tntfs_rl_mc(dst, loc, src, left, ssize - left);\n\n\t/* We may have changed the length of the file, so fix the end marker. */\n\tif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"ds = %i, ss = %i, dins = %i\"",
            "ds",
            "ss",
            "dins"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"start = %i, finish = %i\"",
            "start",
            "finish"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"dfinal = %i, dend = %i\"",
            "dfinal",
            "dend"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ERANGE"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "NULL",
            "\"Run lists overlap. Cannot merge!\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!srl[si].length"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_mm",
          "args": [
            "drl",
            "1",
            "0",
            "dend"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "34-39",
          "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "drl"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "drl[dend].length"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "drl[0].vcn"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!drl"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "drl"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "srl"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!srl"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
  },
  {
    "function_name": "ntfs_rl_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "470-495",
    "snippet": "static inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\n\t\trunlist_element *src, int ssize, int loc)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* Space required: @dst size + @src size + one new hole. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the holes either size of @src. */\n\tdst[loc].length\t\t= dst[loc+1].vcn       - dst[loc].vcn;\n\tdst[loc+ssize+1].vcn    = dst[loc+ssize].vcn   + dst[loc+ssize].length;\n\tdst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\n\n\treturn dst;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_rl_mc",
          "args": [
            "dst",
            "loc + 1",
            "src",
            "0",
            "ssize"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "47-52",
          "snippet": "static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_mm",
          "args": [
            "dst",
            "loc + 1 + ssize",
            "loc",
            "dsize - loc"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "34-39",
          "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "dst",
            "dsize",
            "dsize + ssize + 1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!src"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dst"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\n\t\trunlist_element *src, int ssize, int loc)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* Space required: @dst size + @src size + one new hole. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the holes either size of @src. */\n\tdst[loc].length\t\t= dst[loc+1].vcn       - dst[loc].vcn;\n\tdst[loc+ssize+1].vcn    = dst[loc+ssize].vcn   + dst[loc+ssize].length;\n\tdst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\n\n\treturn dst;\n}"
  },
  {
    "function_name": "ntfs_rl_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "381-444",
    "snippet": "static inline runlist_element *ntfs_rl_replace(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tsigned delta;\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint tail;\t\t/* Start of tail of @dst. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, see if the left and right ends need merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\tif (loc > 0)\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\t/*\n\t * Allocate some space.  We will need less if the left, right, or both\n\t * ends get merged.  The -1 accounts for the run being replaced.\n\t */\n\tdelta = ssize - 1 - left - right;\n\tif (delta > 0) {\n\t\tdst = ntfs_rl_realloc(dst, dsize, dsize + delta);\n\t\tif (IS_ERR(dst))\n\t\t\treturn dst;\n\t}\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the left and right ends, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * Offset of the tail of @dst.  This needs to be moved out of the way\n\t * to make space for the runs to be copied from @src, i.e. the first\n\t * run of the tail of @dst.\n\t * Nominally, @tail equals @loc + 1, i.e. location, skipping the\n\t * replaced run.  However, if @right, then one of @dst's runs is\n\t * already merged into @src.\n\t */\n\ttail = loc + right + 1;\n\t/*\n\t * First run after the @src runs that have been inserted, i.e. where\n\t * the tail of @dst needs to be moved to.\n\t * Nominally, @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.\n\t */\n\tmarker = loc + ssize - left;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, tail, dsize - tail);\n\tntfs_rl_mc(dst, loc, src, left, ssize - left);\n\n\t/* We may have changed the length of the file, so fix the end marker. */\n\tif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\treturn dst;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_rl_mc",
          "args": [
            "dst",
            "loc",
            "src",
            "left",
            "ssize - left"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "47-52",
          "snippet": "static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_mm",
          "args": [
            "dst",
            "marker",
            "tail",
            "dsize - tail"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "34-39",
          "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_rl_merge",
          "args": [
            "dst + loc - 1",
            "src"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_rl_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "189-192",
          "snippet": "static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "dst",
            "dsize",
            "dsize + delta"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_are_rl_mergeable",
          "args": [
            "dst + loc - 1",
            "src"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_rl_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "155-176",
          "snippet": "static inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!src"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dst"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_replace(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tsigned delta;\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint tail;\t\t/* Start of tail of @dst. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, see if the left and right ends need merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\tif (loc > 0)\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\t/*\n\t * Allocate some space.  We will need less if the left, right, or both\n\t * ends get merged.  The -1 accounts for the run being replaced.\n\t */\n\tdelta = ssize - 1 - left - right;\n\tif (delta > 0) {\n\t\tdst = ntfs_rl_realloc(dst, dsize, dsize + delta);\n\t\tif (IS_ERR(dst))\n\t\t\treturn dst;\n\t}\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the left and right ends, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * Offset of the tail of @dst.  This needs to be moved out of the way\n\t * to make space for the runs to be copied from @src, i.e. the first\n\t * run of the tail of @dst.\n\t * Nominally, @tail equals @loc + 1, i.e. location, skipping the\n\t * replaced run.  However, if @right, then one of @dst's runs is\n\t * already merged into @src.\n\t */\n\ttail = loc + right + 1;\n\t/*\n\t * First run after the @src runs that have been inserted, i.e. where\n\t * the tail of @dst needs to be moved to.\n\t * Nominally, @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.\n\t */\n\tmarker = loc + ssize - left;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, tail, dsize - tail);\n\tntfs_rl_mc(dst, loc, src, left, ssize - left);\n\n\t/* We may have changed the length of the file, so fix the end marker. */\n\tif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\treturn dst;\n}"
  },
  {
    "function_name": "ntfs_rl_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "285-356",
    "snippet": "static inline runlist_element *ntfs_rl_insert(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool disc = false;\t/* Discontinuity between @dst and @src. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/*\n\t * disc => Discontinuity between the end of @dst and the start of @src.\n\t *\t   This means we might need to insert a \"not mapped\" run.\n\t */\n\tif (loc == 0)\n\t\tdisc = (src[0].vcn > 0);\n\telse {\n\t\ts64 merged_length;\n\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\n\t\tmerged_length = dst[loc - 1].length;\n\t\tif (left)\n\t\t\tmerged_length += src->length;\n\n\t\tdisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\n\t}\n\t/*\n\t * Space required: @dst size + @src size, less one if we merged, plus\n\t * one if there was a discontinuity.\n\t */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlist.\n\t */\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * First run after the @src runs that have been inserted.\n\t * Nominally,  @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.  And if @disc, then @dst and @src do\n\t * not meet and we need an extra run to fill the gap.\n\t */\n\tmarker = loc + ssize - left + disc;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\n\n\t/* Adjust the VCN of the first run after the insertion... */\n\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\t/* ... and the length. */\n\tif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\n\t\tdst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\n\n\t/* Writing beyond the end of the file and there is a discontinuity. */\n\tif (disc) {\n\t\tif (loc > 0) {\n\t\t\tdst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\n\t\t\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\t\t} else {\n\t\t\tdst[loc].vcn = 0;\n\t\t\tdst[loc].length = dst[loc + 1].vcn;\n\t\t}\n\t\tdst[loc].lcn = LCN_RL_NOT_MAPPED;\n\t}\n\treturn dst;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_rl_mc",
          "args": [
            "dst",
            "loc + disc",
            "src",
            "left",
            "ssize - left"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "47-52",
          "snippet": "static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_mm",
          "args": [
            "dst",
            "marker",
            "loc",
            "dsize - loc"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "34-39",
          "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_rl_merge",
          "args": [
            "dst + loc - 1",
            "src"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_rl_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "189-192",
          "snippet": "static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "dst",
            "dsize",
            "dsize + ssize - left + disc"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_are_rl_mergeable",
          "args": [
            "dst + loc - 1",
            "src"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_rl_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "155-176",
          "snippet": "static inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!src"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dst"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_insert(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool left = false;\t/* Left end of @src needs merging. */\n\tbool disc = false;\t/* Discontinuity between @dst and @src. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/*\n\t * disc => Discontinuity between the end of @dst and the start of @src.\n\t *\t   This means we might need to insert a \"not mapped\" run.\n\t */\n\tif (loc == 0)\n\t\tdisc = (src[0].vcn > 0);\n\telse {\n\t\ts64 merged_length;\n\n\t\tleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\n\n\t\tmerged_length = dst[loc - 1].length;\n\t\tif (left)\n\t\t\tmerged_length += src->length;\n\n\t\tdisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\n\t}\n\t/*\n\t * Space required: @dst size + @src size, less one if we merged, plus\n\t * one if there was a discontinuity.\n\t */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlist.\n\t */\n\tif (left)\n\t\t__ntfs_rl_merge(dst + loc - 1, src);\n\t/*\n\t * First run after the @src runs that have been inserted.\n\t * Nominally,  @marker equals @loc + @ssize, i.e. location + number of\n\t * runs in @src.  However, if @left, then the first run in @src has\n\t * been merged with one in @dst.  And if @disc, then @dst and @src do\n\t * not meet and we need an extra run to fill the gap.\n\t */\n\tmarker = loc + ssize - left + disc;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc, dsize - loc);\n\tntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\n\n\t/* Adjust the VCN of the first run after the insertion... */\n\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\t/* ... and the length. */\n\tif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\n\t\tdst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\n\n\t/* Writing beyond the end of the file and there is a discontinuity. */\n\tif (disc) {\n\t\tif (loc > 0) {\n\t\t\tdst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\n\t\t\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\t\t} else {\n\t\t\tdst[loc].vcn = 0;\n\t\t\tdst[loc].length = dst[loc + 1].vcn;\n\t\t}\n\t\tdst[loc].lcn = LCN_RL_NOT_MAPPED;\n\t}\n\treturn dst;\n}"
  },
  {
    "function_name": "ntfs_rl_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "218-259",
    "snippet": "static inline runlist_element *ntfs_rl_append(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, check if the right hand end needs merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\n\t/* Space required: @dst size + @src size, less one if we merged. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the right hand end, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\n\t/* First run after the @src runs that have been inserted. */\n\tmarker = loc + ssize + 1;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the preceding hole. */\n\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\n\t/* We may have changed the length of the file, so fix the end marker */\n\tif (dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\n\treturn dst;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_rl_mc",
          "args": [
            "dst",
            "loc + 1",
            "src",
            "0",
            "ssize"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "47-52",
          "snippet": "static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_rl_mm",
          "args": [
            "dst",
            "marker",
            "loc + 1 + right",
            "dsize - (loc + 1 + right)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "34-39",
          "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_rl_merge",
          "args": [
            "src + ssize - 1",
            "dst + loc + 1"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_rl_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "189-192",
          "snippet": "static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_realloc",
          "args": [
            "dst",
            "dsize",
            "dsize + ssize - right"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_realloc_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "120-140",
          "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_are_rl_mergeable",
          "args": [
            "src + ssize - 1",
            "dst + loc + 1"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_rl_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "155-176",
          "snippet": "static inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!src"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dst"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_append(runlist_element *dst,\n\t\tint dsize, runlist_element *src, int ssize, int loc)\n{\n\tbool right = false;\t/* Right end of @src needs merging. */\n\tint marker;\t\t/* End of the inserted runs. */\n\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* First, check if the right hand end needs merging. */\n\tif ((loc + 1) < dsize)\n\t\tright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\n\n\t/* Space required: @dst size + @src size, less one if we merged. */\n\tdst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\n\tif (IS_ERR(dst))\n\t\treturn dst;\n\t/*\n\t * We are guaranteed to succeed from here so can start modifying the\n\t * original runlists.\n\t */\n\n\t/* First, merge the right hand end, if necessary. */\n\tif (right)\n\t\t__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\n\n\t/* First run after the @src runs that have been inserted. */\n\tmarker = loc + ssize + 1;\n\n\t/* Move the tail of @dst out of the way, then copy in @src. */\n\tntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\n\tntfs_rl_mc(dst, loc + 1, src, 0, ssize);\n\n\t/* Adjust the size of the preceding hole. */\n\tdst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\n\n\t/* We may have changed the length of the file, so fix the end marker */\n\tif (dst[marker].lcn == LCN_ENOENT)\n\t\tdst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\n\n\treturn dst;\n}"
  },
  {
    "function_name": "__ntfs_rl_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "189-192",
    "snippet": "static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\n{\n\tdst->length += src->length;\n}"
  },
  {
    "function_name": "ntfs_are_rl_mergeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "155-176",
    "snippet": "static inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!src"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dst"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\n\t\trunlist_element *src)\n{\n\tBUG_ON(!dst);\n\tBUG_ON(!src);\n\n\t/* We can merge unmapped regions even if they are misaligned. */\n\tif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\n\t\treturn true;\n\t/* If the runs are misaligned, we cannot merge them. */\n\tif ((dst->vcn + dst->length) != src->vcn)\n\t\treturn false;\n\t/* If both runs are non-sparse and contiguous, we can merge them. */\n\tif ((dst->lcn >= 0) && (src->lcn >= 0) &&\n\t\t\t((dst->lcn + dst->length) == src->lcn))\n\t\treturn true;\n\t/* If we are merging two holes, we can merge them. */\n\tif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\n\t\treturn true;\n\t/* Cannot merge. */\n\treturn false;\n}"
  },
  {
    "function_name": "ntfs_rl_realloc_nofail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "120-140",
    "snippet": "static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_rl",
            "rl",
            "old_size"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old_size > new_size"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!new_rl"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs_nofail",
          "args": [
            "new_size"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "new_size * sizeof(*rl)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "old_size * sizeof(*rl)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs_nofail(new_size);\n\tBUG_ON(!new_rl);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
  },
  {
    "function_name": "ntfs_rl_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "74-95",
    "snippet": "static inline runlist_element *ntfs_rl_realloc(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs(new_size);\n\tif (unlikely(!new_rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_rl",
            "rl",
            "old_size"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old_size > new_size"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_rl"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "new_size"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "new_size * sizeof(*rl)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "old_size * sizeof(*rl)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline runlist_element *ntfs_rl_realloc(runlist_element *rl,\n\t\tint old_size, int new_size)\n{\n\trunlist_element *new_rl;\n\n\told_size = PAGE_ALIGN(old_size * sizeof(*rl));\n\tnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\n\tif (old_size == new_size)\n\t\treturn rl;\n\n\tnew_rl = ntfs_malloc_nofs(new_size);\n\tif (unlikely(!new_rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (likely(rl != NULL)) {\n\t\tif (unlikely(old_size > new_size))\n\t\t\told_size = new_size;\n\t\tmemcpy(new_rl, rl, old_size);\n\t\tntfs_free(rl);\n\t}\n\treturn new_rl;\n}"
  },
  {
    "function_name": "ntfs_rl_mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "47-52",
    "snippet": "static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dstbase + dst",
            "srcbase + src",
            "size * sizeof(*dstbase)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "size > 0"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\n\t\trunlist_element *srcbase, int src, int size)\n{\n\tif (likely(size > 0))\n\t\tmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\n}"
  },
  {
    "function_name": "ntfs_rl_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
    "lines": "34-39",
    "snippet": "static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"endian.h\"",
      "#include \"dir.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "base + dst",
            "base + src",
            "size * sizeof(*base)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(dst != src) && (size > 0)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nstatic inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\n\t\tint size)\n{\n\tif (likely((dst != src) && (size > 0)))\n\t\tmemmove(base + dst, base + src, size * sizeof(*base));\n}"
  }
]