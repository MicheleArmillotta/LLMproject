[
  {
    "function_name": "init_devpts_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "673-688",
    "snippet": "static int __init init_devpts_fs(void)\n{\n\tint err = register_filesystem(&devpts_fs_type);\n\tstruct ctl_table_header *table;\n\n\tif (!err) {\n\t\ttable = register_sysctl_table(pty_root_table);\n\t\tdevpts_mnt = kern_mount(&devpts_fs_type);\n\t\tif (IS_ERR(devpts_mnt)) {\n\t\t\terr = PTR_ERR(devpts_mnt);\n\t\t\tunregister_filesystem(&devpts_fs_type);\n\t\t\tunregister_sysctl_table(table);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table pty_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= pty_kern_table,\n\t},\n\t{}\n};",
      "static struct vfsmount *devpts_mnt;",
      "static struct file_system_type devpts_fs_type = {\n\t.name\t\t= \"devpts\",\n\t.mount\t\t= devpts_mount,\n\t.kill_sb\t= devpts_kill_sb,\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t.fs_flags\t= FS_USERNS_MOUNT | FS_USERNS_DEV_MOUNT,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "table"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1528-1555",
          "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&devpts_fs_type"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "devpts_mnt"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "devpts_mnt"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&devpts_fs_type"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct ctl_table pty_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= pty_kern_table,\n\t},\n\t{}\n};\nstatic struct vfsmount *devpts_mnt;\nstatic struct file_system_type devpts_fs_type = {\n\t.name\t\t= \"devpts\",\n\t.mount\t\t= devpts_mount,\n\t.kill_sb\t= devpts_kill_sb,\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t.fs_flags\t= FS_USERNS_MOUNT | FS_USERNS_DEV_MOUNT,\n#endif\n};\n\nstatic int __init init_devpts_fs(void)\n{\n\tint err = register_filesystem(&devpts_fs_type);\n\tstruct ctl_table_header *table;\n\n\tif (!err) {\n\t\ttable = register_sysctl_table(pty_root_table);\n\t\tdevpts_mnt = kern_mount(&devpts_fs_type);\n\t\tif (IS_ERR(devpts_mnt)) {\n\t\t\terr = PTR_ERR(devpts_mnt);\n\t\t\tunregister_filesystem(&devpts_fs_type);\n\t\t\tunregister_sysctl_table(table);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "devpts_pty_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "653-671",
    "snippet": "void devpts_pty_kill(struct inode *inode)\n{\n\tstruct super_block *sb = pts_sb_from_inode(inode);\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\n\tBUG_ON(inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_find_alias(inode);\n\n\tdrop_nlink(inode);\n\td_delete(dentry);\n\tdput(dentry);\t/* d_alloc_name() in devpts_pty_new() */\n\tdput(dentry);\t\t/* d_find_alias above */\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PTMX_MINOR\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "TTYAUX_MAJOR",
            "PTMX_MINOR"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pts_sb_from_inode",
          "args": [
            "inode"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "pts_sb_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "139-146",
          "snippet": "static inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *devpts_mnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PTMX_MINOR\t2\n\nvoid devpts_pty_kill(struct inode *inode)\n{\n\tstruct super_block *sb = pts_sb_from_inode(inode);\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\n\tBUG_ON(inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_find_alias(inode);\n\n\tdrop_nlink(inode);\n\td_delete(dentry);\n\tdput(dentry);\t/* d_alloc_name() in devpts_pty_new() */\n\tdput(dentry);\t\t/* d_find_alias above */\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n}"
  },
  {
    "function_name": "devpts_get_priv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "627-645",
    "snippet": "void *devpts_get_priv(struct inode *pts_inode)\n{\n\tstruct dentry *dentry;\n\tvoid *priv = NULL;\n\n\tBUG_ON(pts_inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));\n\n\t/* Ensure dentry has not been deleted by devpts_pty_kill() */\n\tdentry = d_find_alias(pts_inode);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tif (pts_inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\tpriv = pts_inode->i_private;\n\n\tdput(dentry);\n\n\treturn priv;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PTMX_MINOR\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "pts_inode"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pts_inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "TTYAUX_MAJOR",
            "PTMX_MINOR"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PTMX_MINOR\t2\n\nvoid *devpts_get_priv(struct inode *pts_inode)\n{\n\tstruct dentry *dentry;\n\tvoid *priv = NULL;\n\n\tBUG_ON(pts_inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));\n\n\t/* Ensure dentry has not been deleted by devpts_pty_kill() */\n\tdentry = d_find_alias(pts_inode);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tif (pts_inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\tpriv = pts_inode->i_private;\n\n\tdput(dentry);\n\n\treturn priv;\n}"
  },
  {
    "function_name": "devpts_pty_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "581-619",
    "snippet": "struct inode *devpts_pty_new(struct inode *ptmx_inode, dev_t device, int index,\n\t\tvoid *priv)\n{\n\tstruct dentry *dentry;\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tchar s[12];\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = index + 3;\n\tinode->i_uid = opts->setuid ? opts->uid : current_fsuid();\n\tinode->i_gid = opts->setgid ? opts->gid : current_fsgid();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinit_special_inode(inode, S_IFCHR|opts->mode, device);\n\tinode->i_private = priv;\n\n\tsprintf(s, \"%d\", index);\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, s);\n\tif (dentry) {\n\t\td_add(dentry, inode);\n\t\tfsnotify_create(root->d_inode, dentry);\n\t} else {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_create",
          "args": [
            "root->d_inode",
            "dentry"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "root",
            "s"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "index"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "S_IFCHR|opts->mode",
            "device"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pts_sb_from_inode",
          "args": [
            "ptmx_inode"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "pts_sb_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "139-146",
          "snippet": "static inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *devpts_mnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *devpts_pty_new(struct inode *ptmx_inode, dev_t device, int index,\n\t\tvoid *priv)\n{\n\tstruct dentry *dentry;\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tchar s[12];\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = index + 3;\n\tinode->i_uid = opts->setuid ? opts->uid : current_fsuid();\n\tinode->i_gid = opts->setgid ? opts->gid : current_fsgid();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinit_special_inode(inode, S_IFCHR|opts->mode, device);\n\tinode->i_private = priv;\n\n\tsprintf(s, \"%d\", index);\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, s);\n\tif (dentry) {\n\t\td_add(dentry, inode);\n\t\tfsnotify_create(root->d_inode, dentry);\n\t} else {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "devpts_kill_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "561-570",
    "snippet": "void devpts_kill_index(struct inode *ptmx_inode, int idx)\n{\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\n\tmutex_lock(&allocated_ptys_lock);\n\tida_remove(&fsi->allocated_ptys, idx);\n\tpty_count--;\n\tmutex_unlock(&allocated_ptys_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pty_count;",
      "static DEFINE_MUTEX(allocated_ptys_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_remove",
          "args": [
            "&fsi->allocated_ptys",
            "idx"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pts_sb_from_inode",
          "args": [
            "ptmx_inode"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "pts_sb_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "139-146",
          "snippet": "static inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *devpts_mnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int pty_count;\nstatic DEFINE_MUTEX(allocated_ptys_lock);\n\nvoid devpts_kill_index(struct inode *ptmx_inode, int idx)\n{\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\n\tmutex_lock(&allocated_ptys_lock);\n\tida_remove(&fsi->allocated_ptys, idx);\n\tpty_count--;\n\tmutex_unlock(&allocated_ptys_lock);\n}"
  },
  {
    "function_name": "devpts_new_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "525-559",
    "snippet": "int devpts_new_index(struct inode *ptmx_inode)\n{\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tint index;\n\tint ida_ret;\n\nretry:\n\tif (!ida_pre_get(&fsi->allocated_ptys, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&allocated_ptys_lock);\n\tif (pty_count >= pty_limit -\n\t\t\t(fsi->mount_opts.newinstance ? pty_reserve : 0)) {\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tida_ret = ida_get_new(&fsi->allocated_ptys, &index);\n\tif (ida_ret < 0) {\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\tif (ida_ret == -EAGAIN)\n\t\t\tgoto retry;\n\t\treturn -EIO;\n\t}\n\n\tif (index >= fsi->mount_opts.max) {\n\t\tida_remove(&fsi->allocated_ptys, index);\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\treturn -ENOSPC;\n\t}\n\tpty_count++;\n\tmutex_unlock(&allocated_ptys_lock);\n\treturn index;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pty_limit = NR_UNIX98_PTY_DEFAULT;",
      "static int pty_reserve = NR_UNIX98_PTY_RESERVE;",
      "static int pty_count;",
      "static DEFINE_MUTEX(allocated_ptys_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_remove",
          "args": [
            "&fsi->allocated_ptys",
            "index"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_get_new",
          "args": [
            "&fsi->allocated_ptys",
            "&index"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&allocated_ptys_lock"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_pre_get",
          "args": [
            "&fsi->allocated_ptys",
            "GFP_KERNEL"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pts_sb_from_inode",
          "args": [
            "ptmx_inode"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "pts_sb_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "139-146",
          "snippet": "static inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *devpts_mnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int pty_limit = NR_UNIX98_PTY_DEFAULT;\nstatic int pty_reserve = NR_UNIX98_PTY_RESERVE;\nstatic int pty_count;\nstatic DEFINE_MUTEX(allocated_ptys_lock);\n\nint devpts_new_index(struct inode *ptmx_inode)\n{\n\tstruct super_block *sb = pts_sb_from_inode(ptmx_inode);\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tint index;\n\tint ida_ret;\n\nretry:\n\tif (!ida_pre_get(&fsi->allocated_ptys, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&allocated_ptys_lock);\n\tif (pty_count >= pty_limit -\n\t\t\t(fsi->mount_opts.newinstance ? pty_reserve : 0)) {\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tida_ret = ida_get_new(&fsi->allocated_ptys, &index);\n\tif (ida_ret < 0) {\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\tif (ida_ret == -EAGAIN)\n\t\t\tgoto retry;\n\t\treturn -EIO;\n\t}\n\n\tif (index >= fsi->mount_opts.max) {\n\t\tida_remove(&fsi->allocated_ptys, index);\n\t\tmutex_unlock(&allocated_ptys_lock);\n\t\treturn -ENOSPC;\n\t}\n\tpty_count++;\n\tmutex_unlock(&allocated_ptys_lock);\n\treturn index;\n}"
  },
  {
    "function_name": "devpts_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "502-509",
    "snippet": "static void devpts_kill_sb(struct super_block *sb)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\n\tida_destroy(&fsi->allocated_ptys);\n\tkfree(fsi);\n\tkill_litter_super(sb);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsi"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_destroy",
          "args": [
            "&fsi->allocated_ptys"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void devpts_kill_sb(struct super_block *sb)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\n\tida_destroy(&fsi->allocated_ptys);\n\tkfree(fsi);\n\tkill_litter_super(sb);\n}"
  },
  {
    "function_name": "devpts_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "495-499",
    "snippet": "static struct dentry *devpts_mount(struct file_system_type *fs_type, int flags,\n\t\tconst char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, devpts_fill_super);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "devpts_fill_super"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *devpts_mount(struct file_system_type *fs_type, int flags,\n\t\tconst char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, devpts_fill_super);\n}"
  },
  {
    "function_name": "devpts_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "444-488",
    "snippet": "static struct dentry *devpts_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint error;\n\tstruct pts_mount_opts opts;\n\tstruct super_block *s;\n\n\terror = parse_mount_options(data, PARSE_MOUNT, &opts);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* Require newinstance for all user namespace mounts to ensure\n\t * the mount options are not changed.\n\t */\n\tif ((current_user_ns() != &init_user_ns) && !opts.newinstance)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (opts.newinstance)\n\t\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\telse\n\t\ts = sget(fs_type, compare_init_pts_sb, set_anon_super, flags,\n\t\t\t NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\tif (!s->s_root) {\n\t\terror = devpts_fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error)\n\t\t\tgoto out_undo_sget;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\n\tmemcpy(&(DEVPTS_SB(s))->mount_opts, &opts, sizeof(opts));\n\n\terror = mknod_ptmx(s);\n\tif (error)\n\t\tgoto out_undo_sget;\n\n\treturn dget(s->s_root);\n\nout_undo_sget:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PARSE_MOUNT\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mknod_ptmx",
          "args": [
            "s"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "mknod_ptmx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "239-295",
          "snippet": "static int mknod_ptmx(struct super_block *sb)\n{\n\tint mode;\n\tint rc = -ENOMEM;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\troot_uid = make_kuid(current_user_ns(), 0);\n\troot_gid = make_kgid(current_user_ns(), 0);\n\tif (!uid_valid(root_uid) || !gid_valid(root_gid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\t/* If we have already created ptmx node, return */\n\tif (fsi->ptmx_dentry) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdentry = d_alloc_name(root, \"ptmx\");\n\tif (!dentry) {\n\t\tpr_err(\"Unable to alloc dentry for ptmx node\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create a new 'ptmx' node in this mount of devpts.\n\t */\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_err(\"Unable to alloc inode for ptmx node\\n\");\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = 2;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tmode = S_IFCHR|opts->ptmxmode;\n\tinit_special_inode(inode, mode, MKDEV(TTYAUX_MAJOR, 2));\n\tinode->i_uid = root_uid;\n\tinode->i_gid = root_gid;\n\n\td_add(dentry, inode);\n\n\tfsi->ptmx_dentry = dentry;\n\trc = 0;\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int mknod_ptmx(struct super_block *sb)\n{\n\tint mode;\n\tint rc = -ENOMEM;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\troot_uid = make_kuid(current_user_ns(), 0);\n\troot_gid = make_kgid(current_user_ns(), 0);\n\tif (!uid_valid(root_uid) || !gid_valid(root_gid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\t/* If we have already created ptmx node, return */\n\tif (fsi->ptmx_dentry) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdentry = d_alloc_name(root, \"ptmx\");\n\tif (!dentry) {\n\t\tpr_err(\"Unable to alloc dentry for ptmx node\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create a new 'ptmx' node in this mount of devpts.\n\t */\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_err(\"Unable to alloc inode for ptmx node\\n\");\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = 2;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tmode = S_IFCHR|opts->ptmxmode;\n\tinit_special_inode(inode, mode, MKDEV(TTYAUX_MAJOR, 2));\n\tinode->i_uid = root_uid;\n\tinode->i_gid = root_gid;\n\n\td_add(dentry, inode);\n\n\tfsi->ptmx_dentry = dentry;\n\trc = 0;\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(DEVPTS_SB(s))->mount_opts",
            "&opts",
            "sizeof(opts)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "s"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devpts_fill_super",
          "args": [
            "s",
            "data",
            "flags & MS_SILENT ? 1 : 0"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "devpts_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "374-407",
          "snippet": "static int\ndevpts_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_time_gran = 1;\n\n\ts->s_fs_info = new_pts_fs_info();\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\n\ts->s_root = d_make_root(inode);\n\tif (s->s_root)\n\t\treturn 0;\n\n\tpr_err(\"get root dentry failed\\n\");\n\nfail:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations devpts_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= devpts_remount,\n\t.show_options\t= devpts_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct super_operations devpts_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= devpts_remount,\n\t.show_options\t= devpts_show_options,\n};\n\nstatic int\ndevpts_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_time_gran = 1;\n\n\ts->s_fs_info = new_pts_fs_info();\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\n\ts->s_root = d_make_root(inode);\n\tif (s->s_root)\n\t\treturn 0;\n\n\tpr_err(\"get root dentry failed\\n\");\n\nfail:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "s"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "compare_init_pts_sb",
            "set_anon_super",
            "flags",
            "NULL"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "NULL",
            "set_anon_super",
            "flags",
            "NULL"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mount_options",
          "args": [
            "data",
            "PARSE_MOUNT",
            "&opts"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "160-236",
          "snippet": "static int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define PARSE_MOUNT\t0",
            "#define DEVPTS_DEFAULT_PTMX_MODE 0000",
            "#define DEVPTS_DEFAULT_MODE 0600"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PARSE_MOUNT\t0\n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define DEVPTS_DEFAULT_MODE 0600\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};\n\nstatic int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PARSE_MOUNT\t0\n\nstatic struct dentry *devpts_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint error;\n\tstruct pts_mount_opts opts;\n\tstruct super_block *s;\n\n\terror = parse_mount_options(data, PARSE_MOUNT, &opts);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* Require newinstance for all user namespace mounts to ensure\n\t * the mount options are not changed.\n\t */\n\tif ((current_user_ns() != &init_user_ns) && !opts.newinstance)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (opts.newinstance)\n\t\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\telse\n\t\ts = sget(fs_type, compare_init_pts_sb, set_anon_super, flags,\n\t\t\t NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\tif (!s->s_root) {\n\t\terror = devpts_fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error)\n\t\t\tgoto out_undo_sget;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\n\tmemcpy(&(DEVPTS_SB(s))->mount_opts, &opts, sizeof(opts));\n\n\terror = mknod_ptmx(s);\n\tif (error)\n\t\tgoto out_undo_sget;\n\n\treturn dget(s->s_root);\n\nout_undo_sget:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "compare_init_pts_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "410-415",
    "snippet": "static int compare_init_pts_sb(struct super_block *s, void *p)\n{\n\tif (devpts_mnt)\n\t\treturn devpts_mnt->mnt_sb == s;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *devpts_mnt;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic int compare_init_pts_sb(struct super_block *s, void *p)\n{\n\tif (devpts_mnt)\n\t\treturn devpts_mnt->mnt_sb == s;\n\treturn 0;\n}"
  },
  {
    "function_name": "devpts_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "374-407",
    "snippet": "static int\ndevpts_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_time_gran = 1;\n\n\ts->s_fs_info = new_pts_fs_info();\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\n\ts->s_root = d_make_root(inode);\n\tif (s->s_root)\n\t\treturn 0;\n\n\tpr_err(\"get root dentry failed\\n\");\n\nfail:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations devpts_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= devpts_remount,\n\t.show_options\t= devpts_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"get root dentry failed\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_pts_fs_info",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "new_pts_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "359-372",
          "snippet": "static void *new_pts_fs_info(void)\n{\n\tstruct pts_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(struct pts_fs_info), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn NULL;\n\n\tida_init(&fsi->allocated_ptys);\n\tfsi->mount_opts.mode = DEVPTS_DEFAULT_MODE;\n\tfsi->mount_opts.ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\n\treturn fsi;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DEVPTS_DEFAULT_PTMX_MODE 0000",
            "#define DEVPTS_DEFAULT_MODE 0600"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define DEVPTS_DEFAULT_MODE 0600\n\nstatic void *new_pts_fs_info(void)\n{\n\tstruct pts_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(struct pts_fs_info), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn NULL;\n\n\tida_init(&fsi->allocated_ptys);\n\tfsi->mount_opts.mode = DEVPTS_DEFAULT_MODE;\n\tfsi->mount_opts.ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\n\treturn fsi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct super_operations devpts_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= devpts_remount,\n\t.show_options\t= devpts_show_options,\n};\n\nstatic int\ndevpts_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_time_gran = 1;\n\n\ts->s_fs_info = new_pts_fs_info();\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\n\ts->s_root = d_make_root(inode);\n\tif (s->s_root)\n\t\treturn 0;\n\n\tpr_err(\"get root dentry failed\\n\");\n\nfail:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "new_pts_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "359-372",
    "snippet": "static void *new_pts_fs_info(void)\n{\n\tstruct pts_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(struct pts_fs_info), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn NULL;\n\n\tida_init(&fsi->allocated_ptys);\n\tfsi->mount_opts.mode = DEVPTS_DEFAULT_MODE;\n\tfsi->mount_opts.ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\n\treturn fsi;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEVPTS_DEFAULT_PTMX_MODE 0000",
      "#define DEVPTS_DEFAULT_MODE 0600"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_init",
          "args": [
            "&fsi->allocated_ptys"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pts_fs_info)",
            "GFP_KERNEL"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define DEVPTS_DEFAULT_MODE 0600\n\nstatic void *new_pts_fs_info(void)\n{\n\tstruct pts_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(struct pts_fs_info), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn NULL;\n\n\tida_init(&fsi->allocated_ptys);\n\tfsi->mount_opts.mode = DEVPTS_DEFAULT_MODE;\n\tfsi->mount_opts.ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\n\treturn fsi;\n}"
  },
  {
    "function_name": "devpts_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "332-351",
    "snippet": "static int devpts_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(root->d_sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\tif (opts->setuid)\n\t\tseq_printf(seq, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (opts->setgid)\n\t\tseq_printf(seq, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tseq_printf(seq, \",mode=%03o\", opts->mode);\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tseq_printf(seq, \",ptmxmode=%03o\", opts->ptmxmode);\n\tif (opts->max < NR_UNIX98_PTY_MAX)\n\t\tseq_printf(seq, \",max=%d\", opts->max);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",max=%d\"",
            "opts->max"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "opts->gid"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "opts->uid"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int devpts_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(root->d_sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\tif (opts->setuid)\n\t\tseq_printf(seq, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (opts->setgid)\n\t\tseq_printf(seq, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tseq_printf(seq, \",mode=%03o\", opts->mode);\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tseq_printf(seq, \",ptmxmode=%03o\", opts->ptmxmode);\n\tif (opts->max < NR_UNIX98_PTY_MAX)\n\t\tseq_printf(seq, \",max=%d\", opts->max);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "devpts_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "312-330",
    "snippet": "static int devpts_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\tsync_filesystem(sb);\n\terr = parse_mount_options(data, PARSE_REMOUNT, opts);\n\n\t/*\n\t * parse_mount_options() restores options to default values\n\t * before parsing and may have changed ptmxmode. So, update the\n\t * mode in the inode too. Bogus options don't fail the remount,\n\t * so do this even on error return.\n\t */\n\tupdate_ptmx_mode(fsi);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PARSE_REMOUNT\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ptmx_mode",
          "args": [
            "fsi"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "update_ptmx_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "306-309",
          "snippet": "static inline void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mount_options",
          "args": [
            "data",
            "PARSE_REMOUNT",
            "opts"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "160-236",
          "snippet": "static int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define PARSE_MOUNT\t0",
            "#define DEVPTS_DEFAULT_PTMX_MODE 0000",
            "#define DEVPTS_DEFAULT_MODE 0600"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PARSE_MOUNT\t0\n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define DEVPTS_DEFAULT_MODE 0600\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};\n\nstatic int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PARSE_REMOUNT\t1\n\nstatic int devpts_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\tsync_filesystem(sb);\n\terr = parse_mount_options(data, PARSE_REMOUNT, opts);\n\n\t/*\n\t * parse_mount_options() restores options to default values\n\t * before parsing and may have changed ptmxmode. So, update the\n\t * mode in the inode too. Bogus options don't fail the remount,\n\t * so do this even on error return.\n\t */\n\tupdate_ptmx_mode(fsi);\n\n\treturn err;\n}"
  },
  {
    "function_name": "update_ptmx_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "306-309",
    "snippet": "static inline void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\treturn;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\treturn;\n}"
  },
  {
    "function_name": "update_ptmx_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "297-304",
    "snippet": "static void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\tstruct inode *inode;\n\tif (fsi->ptmx_dentry) {\n\t\tinode = fsi->ptmx_dentry->d_inode;\n\t\tinode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\tstruct inode *inode;\n\tif (fsi->ptmx_dentry) {\n\t\tinode = fsi->ptmx_dentry->d_inode;\n\t\tinode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;\n\t}\n}"
  },
  {
    "function_name": "mknod_ptmx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "239-295",
    "snippet": "static int mknod_ptmx(struct super_block *sb)\n{\n\tint mode;\n\tint rc = -ENOMEM;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\troot_uid = make_kuid(current_user_ns(), 0);\n\troot_gid = make_kgid(current_user_ns(), 0);\n\tif (!uid_valid(root_uid) || !gid_valid(root_gid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\t/* If we have already created ptmx node, return */\n\tif (fsi->ptmx_dentry) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdentry = d_alloc_name(root, \"ptmx\");\n\tif (!dentry) {\n\t\tpr_err(\"Unable to alloc dentry for ptmx node\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create a new 'ptmx' node in this mount of devpts.\n\t */\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_err(\"Unable to alloc inode for ptmx node\\n\");\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = 2;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tmode = S_IFCHR|opts->ptmxmode;\n\tinit_special_inode(inode, mode, MKDEV(TTYAUX_MAJOR, 2));\n\tinode->i_uid = root_uid;\n\tinode->i_gid = root_gid;\n\n\td_add(dentry, inode);\n\n\tfsi->ptmx_dentry = dentry;\n\trc = 0;\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "MKDEV(TTYAUX_MAJOR, 2)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "TTYAUX_MAJOR",
            "2"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to alloc inode for ptmx node\\n\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to alloc dentry for ptmx node\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "root",
            "\"ptmx\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "root_gid"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "root_uid"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEVPTS_SB",
          "args": [
            "sb"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "DEVPTS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
          "lines": "134-137",
          "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/parser.h>",
            "#include <linux/devpts_fs.h>",
            "#include <linux/idr.h>",
            "#include <linux/magic.h>",
            "#include <linux/mutex.h>",
            "#include <linux/tty.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int mknod_ptmx(struct super_block *sb)\n{\n\tint mode;\n\tint rc = -ENOMEM;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\troot_uid = make_kuid(current_user_ns(), 0);\n\troot_gid = make_kgid(current_user_ns(), 0);\n\tif (!uid_valid(root_uid) || !gid_valid(root_gid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\t/* If we have already created ptmx node, return */\n\tif (fsi->ptmx_dentry) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdentry = d_alloc_name(root, \"ptmx\");\n\tif (!dentry) {\n\t\tpr_err(\"Unable to alloc dentry for ptmx node\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create a new 'ptmx' node in this mount of devpts.\n\t */\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_err(\"Unable to alloc inode for ptmx node\\n\");\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = 2;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\tmode = S_IFCHR|opts->ptmxmode;\n\tinit_special_inode(inode, mode, MKDEV(TTYAUX_MAJOR, 2));\n\tinode->i_uid = root_uid;\n\tinode->i_gid = root_gid;\n\n\td_add(dentry, inode);\n\n\tfsi->ptmx_dentry = dentry;\n\trc = 0;\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "160-236",
    "snippet": "static int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PARSE_MOUNT\t0",
      "#define DEVPTS_DEFAULT_PTMX_MODE 0000",
      "#define DEVPTS_DEFAULT_MODE 0600"
    ],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"called with bogus options\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&data",
            "\",\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define PARSE_MOUNT\t0\n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define DEVPTS_DEFAULT_MODE 0600\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n#endif\n\t{Opt_err, NULL}\n};\n\nstatic int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t/* newinstance makes sense only on initial mount */\n\tif (op == PARSE_MOUNT)\n\t\topts->newinstance = 0;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\t/* newinstance makes sense only on initial mount */\n\t\t\tif (op == PARSE_MOUNT)\n\t\t\t\topts->newinstance = 1;\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pts_sb_from_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "139-146",
    "snippet": "static inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *devpts_mnt;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *devpts_mnt;\n\nstatic inline struct super_block *pts_sb_from_inode(struct inode *inode)\n{\n#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES\n\tif (inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)\n\t\treturn inode->i_sb;\n#endif\n\treturn devpts_mnt->mnt_sb;\n}"
  },
  {
    "function_name": "DEVPTS_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/devpts/inode.c",
    "lines": "134-137",
    "snippet": "static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/parser.h>",
      "#include <linux/devpts_fs.h>",
      "#include <linux/idr.h>",
      "#include <linux/magic.h>",
      "#include <linux/mutex.h>",
      "#include <linux/tty.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/fsnotify.h>\n#include <linux/parser.h>\n#include <linux/devpts_fs.h>\n#include <linux/idr.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  }
]