[
  {
    "function_name": "ntfs_bitmap_clear_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
    "lines": "111-114",
    "snippet": "static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_run",
          "args": [
            "vi",
            "bit",
            "1"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "82-86",
          "snippet": "static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}"
  },
  {
    "function_name": "ntfs_bitmap_set_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
    "lines": "97-100",
    "snippet": "static inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_bitmap_set_run",
          "args": [
            "vi",
            "bit",
            "1"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "65-69",
          "snippet": "static inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}"
  },
  {
    "function_name": "ntfs_bitmap_clear_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
    "lines": "82-86",
    "snippet": "static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_bitmap_set_bits_in_run",
          "args": [
            "vi",
            "start_bit",
            "count",
            "0"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_bits_in_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "47-52",
          "snippet": "static inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}"
  },
  {
    "function_name": "ntfs_bitmap_set_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
    "lines": "65-69",
    "snippet": "static inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_bitmap_set_bits_in_run",
          "args": [
            "vi",
            "start_bit",
            "count",
            "1"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_bits_in_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "47-52",
          "snippet": "static inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 1);\n}"
  },
  {
    "function_name": "ntfs_bitmap_set_bits_in_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
    "lines": "47-52",
    "snippet": "static inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ntfs_bitmap_set_bits_in_run",
          "args": [
            "vi",
            "start_bit",
            "count",
            "value",
            "false"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_bitmap_set_bits_in_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.c",
          "lines": "47-191",
          "snippet": "int __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t/*\n\t * Calculate the indices for the pages containing the first and last\n\t * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.\n\t */\n\tindex = start_bit >> (3 + PAGE_CACHE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_CACHE_SHIFT);\n\n\t/* Get the page containing the first bit (@start_bit). */\n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t/* Set @pos to the position of the byte containing @start_bit. */\n\tpos = (start_bit >> 3) & ~PAGE_CACHE_MASK;\n\n\t/* Calculate the position of @start_bit in the first byte. */\n\tbit = start_bit & 7;\n\n\t/* If the first byte is partial, modify the appropriate bits in it. */\n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t/* If we are done, unmap the page and return success. */\n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t/* Update @pos to the new position. */\n\t\tpos++;\n\t}\n\t/*\n\t * Depending on @value, modify all remaining whole bytes in the page up\n\t * to @cnt.\n\t */\n\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t/* Update @len to point to the first not-done byte in the page. */\n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t/* If we are not in the last page, deal with all subsequent pages. */\n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t/* Update @index and get the next page. */\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t/*\n\t\t * Depending on @value, modify all remaining whole bytes in the\n\t\t * page up to @cnt.\n\t\t */\n\t\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t/*\n\t * The currently mapped page is the last one.  If the last byte is\n\t * partial, modify the appropriate bits in it.  Note, @len is the\n\t * position of the last byte inside the page.\n\t */\n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t/* We are done.  Unmap the page and return success. */\n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t/*\n\t * Current state:\n\t *\t- no pages are mapped\n\t *\t- @count - @cnt is the number of bits that have been modified\n\t */\n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t/* Rollback was successful. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t/* Rollback failed. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include <linux/pagemap.h>\n\nint __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t/*\n\t * Calculate the indices for the pages containing the first and last\n\t * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.\n\t */\n\tindex = start_bit >> (3 + PAGE_CACHE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_CACHE_SHIFT);\n\n\t/* Get the page containing the first bit (@start_bit). */\n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t/* Set @pos to the position of the byte containing @start_bit. */\n\tpos = (start_bit >> 3) & ~PAGE_CACHE_MASK;\n\n\t/* Calculate the position of @start_bit in the first byte. */\n\tbit = start_bit & 7;\n\n\t/* If the first byte is partial, modify the appropriate bits in it. */\n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t/* If we are done, unmap the page and return success. */\n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t/* Update @pos to the new position. */\n\t\tpos++;\n\t}\n\t/*\n\t * Depending on @value, modify all remaining whole bytes in the page up\n\t * to @cnt.\n\t */\n\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t/* Update @len to point to the first not-done byte in the page. */\n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t/* If we are not in the last page, deal with all subsequent pages. */\n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t/* Update @index and get the next page. */\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t/*\n\t\t * Depending on @value, modify all remaining whole bytes in the\n\t\t * page up to @cnt.\n\t\t */\n\t\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t/*\n\t * The currently mapped page is the last one.  If the last byte is\n\t * partial, modify the appropriate bits in it.  Note, @len is the\n\t * position of the last byte inside the page.\n\t */\n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t/* We are done.  Unmap the page and return success. */\n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t/*\n\t * Current state:\n\t *\t- no pages are mapped\n\t *\t- @count - @cnt is the number of bits that have been modified\n\t */\n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t/* Rollback was successful. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t/* Rollback failed. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}"
  }
]