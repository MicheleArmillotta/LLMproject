[
  {
    "function_name": "ncp_getopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/getopt.c",
    "lines": "28-75",
    "snippet": "int ncp_getopt(const char *caller, char **options, const struct ncp_option *opts,\n\t       char **optopt, char **optarg, unsigned long *value)\n{\n\tchar *token;\n\tchar *val;\n\n\tdo {\n\t\tif ((token = strsep(options, \",\")) == NULL)\n\t\t\treturn 0;\n\t} while (*token == '\\0');\n\tif (optopt)\n\t\t*optopt = token;\n\n\tif ((val = strchr (token, '=')) != NULL) {\n\t\t*val++ = 0;\n\t}\n\t*optarg = val;\n\tfor (; opts->name; opts++) {\n\t\tif (!strcmp(opts->name, token)) {\n\t\t\tif (!val) {\n\t\t\t\tif (opts->has_arg & OPT_NOPARAM) {\n\t\t\t\t\treturn opts->val;\n\t\t\t\t}\n\t\t\t\tpr_info(\"%s: the %s option requires an argument\\n\",\n\t\t\t\t\tcaller, token);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_INT) {\n\t\t\t\tint rc = kstrtoul(val, 0, value);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_info(\"%s: invalid numeric value in %s=%s\\n\",\n\t\t\t\t\t\tcaller, token, val);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_STRING) {\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tpr_info(\"%s: unexpected argument %s to the %s option\\n\",\n\t\t\t\tcaller, val, token);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tpr_info(\"%s: Unrecognized mount option %s\\n\", caller, token);\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include <asm/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Unrecognized mount option %s\\n\"",
            "caller",
            "token"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: unexpected argument %s to the %s option\\n\"",
            "caller",
            "val",
            "token"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: invalid numeric value in %s=%s\\n\"",
            "caller",
            "token",
            "val"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "value"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: the %s option requires an argument\\n\"",
            "caller",
            "token"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->name",
            "token"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "token",
            "'='"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "options",
            "\",\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include <asm/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint ncp_getopt(const char *caller, char **options, const struct ncp_option *opts,\n\t       char **optopt, char **optarg, unsigned long *value)\n{\n\tchar *token;\n\tchar *val;\n\n\tdo {\n\t\tif ((token = strsep(options, \",\")) == NULL)\n\t\t\treturn 0;\n\t} while (*token == '\\0');\n\tif (optopt)\n\t\t*optopt = token;\n\n\tif ((val = strchr (token, '=')) != NULL) {\n\t\t*val++ = 0;\n\t}\n\t*optarg = val;\n\tfor (; opts->name; opts++) {\n\t\tif (!strcmp(opts->name, token)) {\n\t\t\tif (!val) {\n\t\t\t\tif (opts->has_arg & OPT_NOPARAM) {\n\t\t\t\t\treturn opts->val;\n\t\t\t\t}\n\t\t\t\tpr_info(\"%s: the %s option requires an argument\\n\",\n\t\t\t\t\tcaller, token);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_INT) {\n\t\t\t\tint rc = kstrtoul(val, 0, value);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_info(\"%s: invalid numeric value in %s=%s\\n\",\n\t\t\t\t\t\tcaller, token, val);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_STRING) {\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tpr_info(\"%s: unexpected argument %s to the %s option\\n\",\n\t\t\t\tcaller, val, token);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tpr_info(\"%s: Unrecognized mount option %s\\n\", caller, token);\n\treturn -EOPNOTSUPP;\n}"
  }
]