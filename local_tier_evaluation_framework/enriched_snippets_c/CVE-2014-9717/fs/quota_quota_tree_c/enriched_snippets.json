[
  {
    "function_name": "qtree_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "656-662",
    "snippet": "int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\n\t    !(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\n\t\treturn qtree_delete_dquot(info, dquot);\n\treturn 0;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qtree_delete_dquot",
          "args": [
            "info",
            "dquot"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_delete_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "508-515",
          "snippet": "int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tuint tmp = QT_TREEOFF;\n\n\tif (!dquot->dq_off)\t/* Even not allocated? */\n\t\treturn 0;\n\treturn remove_tree(info, dquot, &tmp, 0);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tuint tmp = QT_TREEOFF;\n\n\tif (!dquot->dq_off)\t/* Even not allocated? */\n\t\treturn 0;\n\treturn remove_tree(info, dquot, &tmp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DQ_FAKE_B",
            "&dquot->dq_flags"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\n\t    !(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\n\t\treturn qtree_delete_dquot(info, dquot);\n\treturn 0;\n}"
  },
  {
    "function_name": "qtree_read_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "592-651",
    "snippet": "int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tloff_t offset;\n\tchar *ddquot;\n\tint ret = 0;\n\n#ifdef __QUOTA_QT_PARANOIA\n\t/* Invalidated quota? */\n\tif (!sb_dqopt(dquot->dq_sb)->files[type]) {\n\t\tquota_error(sb, \"Quota invalidated while reading!\");\n\t\treturn -EIO;\n\t}\n#endif\n\t/* Do we know offset of the dquot entry in the quota file? */\n\tif (!dquot->dq_off) {\n\t\toffset = find_dqentry(info, dquot);\n\t\tif (offset <= 0) {\t/* Entry not present? */\n\t\t\tif (offset < 0)\n\t\t\t\tquota_error(sb,\"Can't read quota structure \"\n\t\t\t\t\t    \"for id %u\",\n\t\t\t\t\t    from_kqid(&init_user_ns,\n\t\t\t\t\t\t      dquot->dq_id));\n\t\t\tdquot->dq_off = 0;\n\t\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\t\tret = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tdquot->dq_off = offset;\n\t}\n\tddquot = getdqbuf(info->dqi_entry_size);\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\tret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t   dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tquota_error(sb, \"Error while reading quota structure for id %u\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\tkfree(ddquot);\n\t\tgoto out;\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dq_data_lock);\n\tkfree(ddquot);\nout:\n\tdqstats_inc(DQST_READS);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define __QUOTA_QT_PARANOIA"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dqstats_inc",
          "args": [
            "DQST_READS"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ddquot"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DQ_FAKE_B",
            "&dquot->dq_flags"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "info->dqi_ops->disk2mem_dqblk",
          "args": [
            "dquot",
            "ddquot"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ddquot"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dquot->dq_dqb",
            "0",
            "sizeof(struct mem_dqblk)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "sb",
            "\"Error while reading quota structure for id %u\"",
            "from_kqid(&init_user_ns, dquot->dq_id)"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_read",
          "args": [
            "sb",
            "type",
            "ddquot",
            "info->dqi_entry_size",
            "dquot->dq_off"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_entry_size"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dquot->dq_dqb",
            "0",
            "sizeof(struct mem_dqblk)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_dqentry",
          "args": [
            "info",
            "dquot"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "find_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "586-590",
          "snippet": "static inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t  struct dquot *dquot)\n{\n\treturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t  struct dquot *dquot)\n{\n\treturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "sb",
            "\"Quota invalidated while reading!\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nint qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tloff_t offset;\n\tchar *ddquot;\n\tint ret = 0;\n\n#ifdef __QUOTA_QT_PARANOIA\n\t/* Invalidated quota? */\n\tif (!sb_dqopt(dquot->dq_sb)->files[type]) {\n\t\tquota_error(sb, \"Quota invalidated while reading!\");\n\t\treturn -EIO;\n\t}\n#endif\n\t/* Do we know offset of the dquot entry in the quota file? */\n\tif (!dquot->dq_off) {\n\t\toffset = find_dqentry(info, dquot);\n\t\tif (offset <= 0) {\t/* Entry not present? */\n\t\t\tif (offset < 0)\n\t\t\t\tquota_error(sb,\"Can't read quota structure \"\n\t\t\t\t\t    \"for id %u\",\n\t\t\t\t\t    from_kqid(&init_user_ns,\n\t\t\t\t\t\t      dquot->dq_id));\n\t\t\tdquot->dq_off = 0;\n\t\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\t\tret = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tdquot->dq_off = offset;\n\t}\n\tddquot = getdqbuf(info->dqi_entry_size);\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\tret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t   dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tquota_error(sb, \"Error while reading quota structure for id %u\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\tkfree(ddquot);\n\t\tgoto out;\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dq_data_lock);\n\tkfree(ddquot);\nout:\n\tdqstats_inc(DQST_READS);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "586-590",
    "snippet": "static inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t  struct dquot *dquot)\n{\n\treturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_tree_dqentry",
          "args": [
            "info",
            "dquot",
            "QT_TREEOFF",
            "0"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "find_tree_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "557-583",
          "snippet": "static loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t/* No reference? */\n\t\tgoto out_buf;\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t/* No reference? */\n\t\tgoto out_buf;\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t  struct dquot *dquot)\n{\n\treturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\n}"
  },
  {
    "function_name": "find_tree_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "557-583",
    "snippet": "static loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t/* No reference? */\n\t\tgoto out_buf;\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_block_dqentry",
          "args": [
            "info",
            "dquot",
            "blk"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "find_block_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "519-554",
          "snippet": "static loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot, uint blk)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\tint i;\n\tchar *ddquot;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree \"\n\t\t\t    \"block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (info->dqi_ops->is_id(ddquot, dquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb,\n\t\t\t    \"Quota for id %u referenced but not present\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t} else {\n\t\tret = (blk << info->dqi_blocksize_bits) + sizeof(struct\n\t\t  qt_disk_dqdbheader) + i * info->dqi_entry_size;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot, uint blk)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\tint i;\n\tchar *ddquot;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree \"\n\t\t\t    \"block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (info->dqi_ops->is_id(ddquot, dquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb,\n\t\t\t    \"Quota for id %u referenced but not present\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t} else {\n\t\tret = (blk << info->dqi_blocksize_bits) + sizeof(struct\n\t\t  qt_disk_dqdbheader) + i * info->dqi_entry_size;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_tree_dqentry",
          "args": [
            "info",
            "dquot",
            "blk",
            "depth+1"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "find_tree_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "557-583",
          "snippet": "static loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t/* No reference? */\n\t\tgoto out_buf;\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ref[get_index(info, dquot->dq_id, depth)]"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_index",
          "args": [
            "info",
            "dquot->dq_id",
            "depth"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "get_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "25-34",
          "snippet": "static int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Can't read quota tree block %u\"",
            "blk"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t/* No reference? */\n\t\tgoto out_buf;\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_block_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "519-554",
    "snippet": "static loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot, uint blk)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\tint i;\n\tchar *ddquot;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree \"\n\t\t\t    \"block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (info->dqi_ops->is_id(ddquot, dquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb,\n\t\t\t    \"Quota for id %u referenced but not present\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t} else {\n\t\tret = (blk << info->dqi_blocksize_bits) + sizeof(struct\n\t\t  qt_disk_dqdbheader) + i * info->dqi_entry_size;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Quota for id %u referenced but not present\"",
            "from_kqid(&init_user_ns, dquot->dq_id)"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_dqstr_in_blk",
          "args": [
            "info"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_dqstr_in_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "37-41",
          "snippet": "static int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "info->dqi_ops->is_id",
          "args": [
            "ddquot",
            "dquot"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot, uint blk)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tloff_t ret = 0;\n\tint i;\n\tchar *ddquot;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree \"\n\t\t\t    \"block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (info->dqi_ops->is_id(ddquot, dquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb,\n\t\t\t    \"Quota for id %u referenced but not present\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t} else {\n\t\tret = (blk << info->dqi_blocksize_bits) + sizeof(struct\n\t\t  qt_disk_dqdbheader) + i * info->dqi_entry_size;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "qtree_delete_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "508-515",
    "snippet": "int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tuint tmp = QT_TREEOFF;\n\n\tif (!dquot->dq_off)\t/* Even not allocated? */\n\t\treturn 0;\n\treturn remove_tree(info, dquot, &tmp, 0);\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_tree",
          "args": [
            "info",
            "dquot",
            "&tmp",
            "0"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "remove_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "460-505",
          "snippet": "static int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t/* Block got empty? */\n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t/* Don't put the root block into the free block list */\n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t/* Block got empty? */\n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t/* Don't put the root block into the free block list */\n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tuint tmp = QT_TREEOFF;\n\n\tif (!dquot->dq_off)\t/* Even not allocated? */\n\t\treturn 0;\n\treturn remove_tree(info, dquot, &tmp, 0);\n}"
  },
  {
    "function_name": "remove_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "460-505",
    "snippet": "static int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t/* Block got empty? */\n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t/* Don't put the root block into the free block list */\n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Can't write quota tree block %u\"",
            "*blk"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "*blk",
            "buf"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_free_dqblk",
          "args": [
            "info",
            "buf",
            "*blk"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "put_free_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "108-122",
          "snippet": "static int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_index",
          "args": [
            "info",
            "dquot->dq_id",
            "depth"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "get_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "25-34",
          "snippet": "static int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_tree",
          "args": [
            "info",
            "dquot",
            "&newblk",
            "depth+1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "remove_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "460-505",
          "snippet": "static int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t/* Block got empty? */\n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t/* Don't put the root block into the free block list */\n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free_dqentry",
          "args": [
            "info",
            "dquot",
            "newblk"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "free_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "399-457",
          "snippet": "static int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\tuint blk)\n{\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\n\t\tquota_error(dquot->dq_sb, \"Quota structure has offset to \"\n\t\t\t\"other block (%u) than it should (%u)\", blk,\n\t\t\t(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\n\t\tgoto out_buf;\n\t}\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tle16_add_cpu(&dh->dqdh_entries, -1);\n\tif (!le16_to_cpu(dh->dqdh_entries)) {\t/* Block got free? */\n\t\tret = remove_free_dqentry(info, buf, blk);\n\t\tif (ret >= 0)\n\t\t\tret = put_free_dqblk(info, buf, blk);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't move quota data block \"\n\t\t\t\t    \"(%u) to free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t} else {\n\t\tmemset(buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\n\t\t       0, info->dqi_entry_size);\n\t\tif (le16_to_cpu(dh->dqdh_entries) ==\n\t\t    qtree_dqstr_in_blk(info) - 1) {\n\t\t\t/* Insert will write block itself */\n\t\t\tret = insert_free_dqentry(info, buf, blk);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't insert quota \"\n\t\t\t\t    \"data block (%u) to free entry list\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = write_blk(info, blk, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't write quota \"\n\t\t\t\t\t    \"data block %u\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t}\n\t}\n\tdquot->dq_off = 0;\t/* Quota is now unattached */\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\tuint blk)\n{\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\n\t\tquota_error(dquot->dq_sb, \"Quota structure has offset to \"\n\t\t\t\"other block (%u) than it should (%u)\", blk,\n\t\t\t(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\n\t\tgoto out_buf;\n\t}\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tle16_add_cpu(&dh->dqdh_entries, -1);\n\tif (!le16_to_cpu(dh->dqdh_entries)) {\t/* Block got free? */\n\t\tret = remove_free_dqentry(info, buf, blk);\n\t\tif (ret >= 0)\n\t\t\tret = put_free_dqblk(info, buf, blk);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't move quota data block \"\n\t\t\t\t    \"(%u) to free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t} else {\n\t\tmemset(buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\n\t\t       0, info->dqi_entry_size);\n\t\tif (le16_to_cpu(dh->dqdh_entries) ==\n\t\t    qtree_dqstr_in_blk(info) - 1) {\n\t\t\t/* Insert will write block itself */\n\t\t\tret = insert_free_dqentry(info, buf, blk);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't insert quota \"\n\t\t\t\t    \"data block (%u) to free entry list\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = write_blk(info, blk, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't write quota \"\n\t\t\t\t\t    \"data block %u\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t}\n\t}\n\tdquot->dq_off = 0;\t/* Quota is now unattached */\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ref[get_index(info, dquot->dq_id, depth)]"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "*blk",
            "buf"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t/* Block got empty? */\n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t/* Don't put the root block into the free block list */\n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "399-457",
    "snippet": "static int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\tuint blk)\n{\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\n\t\tquota_error(dquot->dq_sb, \"Quota structure has offset to \"\n\t\t\t\"other block (%u) than it should (%u)\", blk,\n\t\t\t(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\n\t\tgoto out_buf;\n\t}\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tle16_add_cpu(&dh->dqdh_entries, -1);\n\tif (!le16_to_cpu(dh->dqdh_entries)) {\t/* Block got free? */\n\t\tret = remove_free_dqentry(info, buf, blk);\n\t\tif (ret >= 0)\n\t\t\tret = put_free_dqblk(info, buf, blk);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't move quota data block \"\n\t\t\t\t    \"(%u) to free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t} else {\n\t\tmemset(buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\n\t\t       0, info->dqi_entry_size);\n\t\tif (le16_to_cpu(dh->dqdh_entries) ==\n\t\t    qtree_dqstr_in_blk(info) - 1) {\n\t\t\t/* Insert will write block itself */\n\t\t\tret = insert_free_dqentry(info, buf, blk);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't insert quota \"\n\t\t\t\t    \"data block (%u) to free entry list\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = write_blk(info, blk, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't write quota \"\n\t\t\t\t\t    \"data block %u\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t}\n\t}\n\tdquot->dq_off = 0;\t/* Quota is now unattached */\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Can't write quota \"\n\t\t\t\t\t    \"data block %u\"",
            "blk"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_free_dqentry",
          "args": [
            "info",
            "buf",
            "blk"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "insert_free_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "172-203",
          "snippet": "static int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\tgoto out_buf;\n\tif (info->dqi_free_entry) {\n\t\terr = read_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tcpu_to_le32(blk);\n\t\terr = write_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tkfree(tmpbuf);\n\tinfo->dqi_free_entry = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\tgoto out_buf;\n\tif (info->dqi_free_entry) {\n\t\terr = read_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tcpu_to_le32(blk);\n\t\terr = write_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tkfree(tmpbuf);\n\tinfo->dqi_free_entry = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_dqstr_in_blk",
          "args": [
            "info"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_dqstr_in_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "37-41",
          "snippet": "static int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dh->dqdh_entries"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1))",
            "0",
            "info->dqi_entry_size"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_free_dqblk",
          "args": [
            "info",
            "buf",
            "blk"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "put_free_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "108-122",
          "snippet": "static int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_free_dqentry",
          "args": [
            "info",
            "buf",
            "blk"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "remove_free_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "125-169",
          "snippet": "static int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&dh->dqdh_entries",
            "-1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dquot->dq_off >> info->dqi_blocksize_bits"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\tuint blk)\n{\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\n\t\tquota_error(dquot->dq_sb, \"Quota structure has offset to \"\n\t\t\t\"other block (%u) than it should (%u)\", blk,\n\t\t\t(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\n\t\tgoto out_buf;\n\t}\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tle16_add_cpu(&dh->dqdh_entries, -1);\n\tif (!le16_to_cpu(dh->dqdh_entries)) {\t/* Block got free? */\n\t\tret = remove_free_dqentry(info, buf, blk);\n\t\tif (ret >= 0)\n\t\t\tret = put_free_dqblk(info, buf, blk);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't move quota data block \"\n\t\t\t\t    \"(%u) to free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t} else {\n\t\tmemset(buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\n\t\t       0, info->dqi_entry_size);\n\t\tif (le16_to_cpu(dh->dqdh_entries) ==\n\t\t    qtree_dqstr_in_blk(info) - 1) {\n\t\t\t/* Insert will write block itself */\n\t\t\tret = insert_free_dqentry(info, buf, blk);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't insert quota \"\n\t\t\t\t    \"data block (%u) to free entry list\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = write_blk(info, blk, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't write quota \"\n\t\t\t\t\t    \"data block %u\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t}\n\t}\n\tdquot->dq_off = 0;\t/* Quota is now unattached */\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "qtree_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "359-395",
    "snippet": "int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ddquot"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dqstats_inc",
          "args": [
            "DQST_WRITES"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "sb",
            "\"dquota write failed\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_write",
          "args": [
            "sb",
            "type",
            "ddquot",
            "info->dqi_entry_size",
            "dquot->dq_off"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "info->dqi_ops->mem2disk_dqblk",
          "args": [
            "ddquot",
            "dquot"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ddquot"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "sb",
            "\"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\"",
            "ret"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dq_insert_tree",
          "args": [
            "info",
            "dquot"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "dq_insert_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "348-353",
          "snippet": "static inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot)\n{\n\tint tmp = QT_TREEOFF;\n\treturn do_insert_tree(info, dquot, &tmp, 0);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot)\n{\n\tint tmp = QT_TREEOFF;\n\treturn do_insert_tree(info, dquot, &tmp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_entry_size"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dq_insert_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "348-353",
    "snippet": "static inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot)\n{\n\tint tmp = QT_TREEOFF;\n\treturn do_insert_tree(info, dquot, &tmp, 0);\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_insert_tree",
          "args": [
            "info",
            "dquot",
            "&tmp",
            "0"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "do_insert_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "291-345",
          "snippet": "static int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define __QUOTA_QT_PARANOIA"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nstatic int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot)\n{\n\tint tmp = QT_TREEOFF;\n\treturn do_insert_tree(info, dquot, &tmp, 0);\n}"
  },
  {
    "function_name": "do_insert_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "291-345",
    "snippet": "static int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define __QUOTA_QT_PARANOIA"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_free_dqblk",
          "args": [
            "info",
            "buf",
            "*treeblk"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "put_free_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "108-122",
          "snippet": "static int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "*treeblk",
            "buf"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "newblk"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_index",
          "args": [
            "info",
            "dquot->dq_id",
            "depth"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "25-34",
          "snippet": "static int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_insert_tree",
          "args": [
            "info",
            "dquot",
            "&newblk",
            "depth+1"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "do_insert_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "291-345",
          "snippet": "static int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_free_dqentry",
          "args": [
            "info",
            "dquot",
            "&ret"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "218-288",
          "snippet": "static uint find_free_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t      struct dquot *dquot, int *err)\n{\n\tuint blk, i;\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tchar *ddquot;\n\n\t*err = 0;\n\tif (!buf) {\n\t\t*err = -ENOMEM;\n\t\treturn 0;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tif (info->dqi_free_entry) {\n\t\tblk = info->dqi_free_entry;\n\t\t*err = read_blk(info, blk, buf);\n\t\tif (*err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tblk = get_free_dqblk(info);\n\t\tif ((int)blk < 0) {\n\t\t\t*err = blk;\n\t\t\tkfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* This is enough as the block is already zeroed and the entry\n\t\t * list is empty... */\n\t\tinfo->dqi_free_entry = blk;\n\t\tmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\n\t}\n\t/* Block will be full? */\n\tif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\n\t\t*err = remove_free_dqentry(info, buf, blk);\n\t\tif (*err < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't remove block (%u) \"\n\t\t\t\t    \"from entry free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tle16_add_cpu(&dh->dqdh_entries, 1);\n\t/* Find free structure in block */\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (qtree_entry_unused(info, ddquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n#ifdef __QUOTA_QT_PARANOIA\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb, \"Data block full but it shouldn't\");\n\t\t*err = -EIO;\n\t\tgoto out_buf;\n\t}\n#endif\n\t*err = write_blk(info, blk, buf);\n\tif (*err < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdquot->dq_off = (blk << info->dqi_blocksize_bits) +\n\t\t\tsizeof(struct qt_disk_dqdbheader) +\n\t\t\ti * info->dqi_entry_size;\n\tkfree(buf);\n\treturn blk;\nout_buf:\n\tkfree(buf);\n\treturn 0;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define __QUOTA_QT_PARANOIA"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nstatic uint find_free_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t      struct dquot *dquot, int *err)\n{\n\tuint blk, i;\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tchar *ddquot;\n\n\t*err = 0;\n\tif (!buf) {\n\t\t*err = -ENOMEM;\n\t\treturn 0;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tif (info->dqi_free_entry) {\n\t\tblk = info->dqi_free_entry;\n\t\t*err = read_blk(info, blk, buf);\n\t\tif (*err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tblk = get_free_dqblk(info);\n\t\tif ((int)blk < 0) {\n\t\t\t*err = blk;\n\t\t\tkfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* This is enough as the block is already zeroed and the entry\n\t\t * list is empty... */\n\t\tinfo->dqi_free_entry = blk;\n\t\tmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\n\t}\n\t/* Block will be full? */\n\tif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\n\t\t*err = remove_free_dqentry(info, buf, blk);\n\t\tif (*err < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't remove block (%u) \"\n\t\t\t\t    \"from entry free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tle16_add_cpu(&dh->dqdh_entries, 1);\n\t/* Find free structure in block */\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (qtree_entry_unused(info, ddquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n#ifdef __QUOTA_QT_PARANOIA\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb, \"Data block full but it shouldn't\");\n\t\t*err = -EIO;\n\t\tgoto out_buf;\n\t}\n#endif\n\t*err = write_blk(info, blk, buf);\n\tif (*err < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdquot->dq_off = (blk << info->dqi_blocksize_bits) +\n\t\t\tsizeof(struct qt_disk_dqdbheader) +\n\t\t\ti * info->dqi_entry_size;\n\tkfree(buf);\n\treturn blk;\nout_buf:\n\tkfree(buf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\"",
            "le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)])"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "*treeblk",
            "buf"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "info->dqi_usable_bs"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_free_dqblk",
          "args": [
            "info"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "77-105",
          "snippet": "static int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nstatic int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_free_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "218-288",
    "snippet": "static uint find_free_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t      struct dquot *dquot, int *err)\n{\n\tuint blk, i;\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tchar *ddquot;\n\n\t*err = 0;\n\tif (!buf) {\n\t\t*err = -ENOMEM;\n\t\treturn 0;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tif (info->dqi_free_entry) {\n\t\tblk = info->dqi_free_entry;\n\t\t*err = read_blk(info, blk, buf);\n\t\tif (*err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tblk = get_free_dqblk(info);\n\t\tif ((int)blk < 0) {\n\t\t\t*err = blk;\n\t\t\tkfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* This is enough as the block is already zeroed and the entry\n\t\t * list is empty... */\n\t\tinfo->dqi_free_entry = blk;\n\t\tmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\n\t}\n\t/* Block will be full? */\n\tif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\n\t\t*err = remove_free_dqentry(info, buf, blk);\n\t\tif (*err < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't remove block (%u) \"\n\t\t\t\t    \"from entry free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tle16_add_cpu(&dh->dqdh_entries, 1);\n\t/* Find free structure in block */\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (qtree_entry_unused(info, ddquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n#ifdef __QUOTA_QT_PARANOIA\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb, \"Data block full but it shouldn't\");\n\t\t*err = -EIO;\n\t\tgoto out_buf;\n\t}\n#endif\n\t*err = write_blk(info, blk, buf);\n\tif (*err < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdquot->dq_off = (blk << info->dqi_blocksize_bits) +\n\t\t\tsizeof(struct qt_disk_dqdbheader) +\n\t\t\ti * info->dqi_entry_size;\n\tkfree(buf);\n\treturn blk;\nout_buf:\n\tkfree(buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define __QUOTA_QT_PARANOIA"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Can't write quota data block %u\"",
            "blk"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "dquot->dq_sb",
            "\"Data block full but it shouldn't\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qtree_dqstr_in_blk",
          "args": [
            "info"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_dqstr_in_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "37-41",
          "snippet": "static int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_entry_unused",
          "args": [
            "info",
            "ddquot"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_entry_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "206-214",
          "snippet": "int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&dh->dqdh_entries",
            "1"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_free_dqentry",
          "args": [
            "info",
            "buf",
            "blk"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "remove_free_dqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "125-169",
          "snippet": "static int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dh->dqdh_entries"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_info_dirty",
          "args": [
            "dquot->dq_sb",
            "dquot->dq_id.type"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "mark_info_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "393-396",
          "snippet": "void mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "info->dqi_usable_bs"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_free_dqblk",
          "args": [
            "info"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_dqblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "77-105",
          "snippet": "static int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nstatic uint find_free_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t      struct dquot *dquot, int *err)\n{\n\tuint blk, i;\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tchar *ddquot;\n\n\t*err = 0;\n\tif (!buf) {\n\t\t*err = -ENOMEM;\n\t\treturn 0;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tif (info->dqi_free_entry) {\n\t\tblk = info->dqi_free_entry;\n\t\t*err = read_blk(info, blk, buf);\n\t\tif (*err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tblk = get_free_dqblk(info);\n\t\tif ((int)blk < 0) {\n\t\t\t*err = blk;\n\t\t\tkfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* This is enough as the block is already zeroed and the entry\n\t\t * list is empty... */\n\t\tinfo->dqi_free_entry = blk;\n\t\tmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\n\t}\n\t/* Block will be full? */\n\tif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\n\t\t*err = remove_free_dqentry(info, buf, blk);\n\t\tif (*err < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't remove block (%u) \"\n\t\t\t\t    \"from entry free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tle16_add_cpu(&dh->dqdh_entries, 1);\n\t/* Find free structure in block */\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (qtree_entry_unused(info, ddquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n#ifdef __QUOTA_QT_PARANOIA\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb, \"Data block full but it shouldn't\");\n\t\t*err = -EIO;\n\t\tgoto out_buf;\n\t}\n#endif\n\t*err = write_blk(info, blk, buf);\n\tif (*err < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdquot->dq_off = (blk << info->dqi_blocksize_bits) +\n\t\t\tsizeof(struct qt_disk_dqdbheader) +\n\t\t\ti * info->dqi_entry_size;\n\tkfree(buf);\n\treturn blk;\nout_buf:\n\tkfree(buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "qtree_entry_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "206-214",
    "snippet": "int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "insert_free_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "172-203",
    "snippet": "static int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\tgoto out_buf;\n\tif (info->dqi_free_entry) {\n\t\terr = read_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tcpu_to_le32(blk);\n\t\terr = write_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tkfree(tmpbuf);\n\tinfo->dqi_free_entry = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_info_dirty",
          "args": [
            "info->dqi_sb",
            "info->dqi_type"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "mark_info_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "393-396",
          "snippet": "void mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "info->dqi_free_entry",
            "tmpbuf"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "info->dqi_free_entry",
            "tmpbuf"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->dqi_free_entry"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\tgoto out_buf;\n\tif (info->dqi_free_entry) {\n\t\terr = read_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tcpu_to_le32(blk);\n\t\terr = write_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tkfree(tmpbuf);\n\tinfo->dqi_free_entry = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}"
  },
  {
    "function_name": "remove_free_dqentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "125-169",
    "snippet": "static int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "info->dqi_sb",
            "\"Can't write block (%u) \"\n\t\t\t    \"with free entries\"",
            "blk"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__quota_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "132-149",
          "snippet": "void __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_info_dirty",
          "args": [
            "info->dqi_sb",
            "info->dqi_type"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "mark_info_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "393-396",
          "snippet": "void mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "prevblk",
            "tmpbuf"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dh->dqdh_prev_free"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t/* No matter whether write succeeds block is out of list */\n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}"
  },
  {
    "function_name": "put_free_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "108-122",
    "snippet": "static int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_info_dirty",
          "args": [
            "info->dqi_sb",
            "info->dqi_type"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "mark_info_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "393-396",
          "snippet": "void mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->dqi_free_blk"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_free_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "77-105",
    "snippet": "static int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_info_dirty",
          "args": [
            "info->dqi_sb",
            "info->dqi_type"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "mark_info_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "393-396",
          "snippet": "void mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_blk",
          "args": [
            "info",
            "info->dqi_blocks",
            "buf"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "write_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "61-74",
          "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "info->dqi_usable_bs"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dh->dqdh_next_free"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blk",
          "args": [
            "info",
            "blk",
            "buf"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "read_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "52-59",
          "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getdqbuf",
          "args": [
            "info->dqi_usable_bs"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "getdqbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "43-50",
          "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = getdqbuf(info->dqi_usable_bs);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t/* Assure block allocation... */\n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "write_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "61-74",
    "snippet": "static ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "quota_error",
          "args": [
            "sb",
            "\"dquota write failed\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_write",
          "args": [
            "sb",
            "info->dqi_type",
            "buf",
            "info->dqi_usable_bs",
            "blk << info->dqi_blocksize_bits"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "read_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "52-59",
    "snippet": "static ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb->s_op->quota_read",
          "args": [
            "sb",
            "info->dqi_type",
            "buf",
            "info->dqi_usable_bs",
            "blk << info->dqi_blocksize_bits"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "info->dqi_usable_bs"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, blk << info->dqi_blocksize_bits);\n}"
  },
  {
    "function_name": "getdqbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "43-50",
    "snippet": "static char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\""
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic char *getdqbuf(size_t size)\n{\n\tchar *buf = kmalloc(size, GFP_NOFS);\n\tif (!buf)\n\t\tprintk(KERN_WARNING\n\t\t       \"VFS: Not enough memory for quota buffers.\\n\");\n\treturn buf;\n}"
  },
  {
    "function_name": "qtree_dqstr_in_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "37-41",
    "snippet": "static int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}"
  },
  {
    "function_name": "get_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
    "lines": "25-34",
    "snippet": "static int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}",
    "includes": [
      "#include \"quota_tree.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dqblk_v2.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qid"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}"
  }
]