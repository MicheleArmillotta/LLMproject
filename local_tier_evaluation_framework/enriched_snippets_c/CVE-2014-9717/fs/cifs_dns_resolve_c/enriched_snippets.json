[
  {
    "function_name": "dns_resolve_server_name_to_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dns_resolve.c",
    "lines": "45-99",
    "snippet": "int\ndns_resolve_server_name_to_ip(const char *unc, char **ip_addr)\n{\n\tstruct sockaddr_storage ss;\n\tconst char *hostname, *sep;\n\tchar *name;\n\tint len, rc;\n\n\tif (!ip_addr || !unc)\n\t\treturn -EINVAL;\n\n\tlen = strlen(unc);\n\tif (len < 3) {\n\t\tcifs_dbg(FYI, \"%s: unc is too short: %s\\n\", __func__, unc);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Discount leading slashes for cifs */\n\tlen -= 2;\n\thostname = unc + 2;\n\n\t/* Search for server name delimiter */\n\tsep = memchr(hostname, '/', len);\n\tif (sep)\n\t\tlen = sep - hostname;\n\telse\n\t\tcifs_dbg(FYI, \"%s: probably server name is whole unc: %s\\n\",\n\t\t\t __func__, unc);\n\n\t/* Try to interpret hostname as an IPv4 or IPv6 address */\n\trc = cifs_convert_address((struct sockaddr *)&ss, hostname, len);\n\tif (rc > 0)\n\t\tgoto name_is_IP_address;\n\n\t/* Perform the upcall */\n\trc = dns_query(NULL, hostname, len, NULL, ip_addr, NULL);\n\tif (rc < 0)\n\t\tcifs_dbg(FYI, \"%s: unable to resolve: %*.*s\\n\",\n\t\t\t __func__, len, len, hostname);\n\telse\n\t\tcifs_dbg(FYI, \"%s: resolved: %*.*s to %s\\n\",\n\t\t\t __func__, len, len, hostname, *ip_addr);\n\treturn rc;\n\nname_is_IP_address:\n\tname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tmemcpy(name, hostname, len);\n\tname[len] = 0;\n\tcifs_dbg(FYI, \"%s: unc is IP, skipping dns upcall: %s\\n\",\n\t\t __func__, name);\n\t*ip_addr = name;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"dns_resolve.h\"",
      "#include <linux/dns_resolver.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: unc is IP, skipping dns upcall: %s\\n\"",
            "__func__",
            "name"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "hostname",
            "len"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: resolved: %*.*s to %s\\n\"",
            "__func__",
            "len",
            "len",
            "hostname",
            "*ip_addr"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: unable to resolve: %*.*s\\n\"",
            "__func__",
            "len",
            "len",
            "hostname"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dns_query",
          "args": [
            "NULL",
            "hostname",
            "len",
            "NULL",
            "ip_addr",
            "NULL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_convert_address",
          "args": [
            "(struct sockaddr *)&ss",
            "hostname",
            "len"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "168-205",
          "snippet": "int\ncifs_convert_address(struct sockaddr *dst, const char *src, int len)\n{\n\tint rc, alen, slen;\n\tconst char *pct;\n\tchar scope_id[13];\n\tstruct sockaddr_in *s4 = (struct sockaddr_in *) dst;\n\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) dst;\n\n\t/* IPv4 address */\n\tif (cifs_inet_pton(AF_INET, src, len, &s4->sin_addr.s_addr)) {\n\t\ts4->sin_family = AF_INET;\n\t\treturn 1;\n\t}\n\n\t/* attempt to exclude the scope ID from the address part */\n\tpct = memchr(src, '%', len);\n\talen = pct ? pct - src : len;\n\n\trc = cifs_inet_pton(AF_INET6, src, alen, &s6->sin6_addr.s6_addr);\n\tif (!rc)\n\t\treturn rc;\n\n\ts6->sin6_family = AF_INET6;\n\tif (pct) {\n\t\t/* grab the scope ID */\n\t\tslen = len - (alen + 1);\n\t\tif (slen <= 0 || slen > 12)\n\t\t\treturn 0;\n\t\tmemcpy(scope_id, pct + 1, slen);\n\t\tscope_id[slen] = '\\0';\n\n\t\trc = kstrtouint(scope_id, 0, &s6->sin6_scope_id);\n\t\trc = (rc == 0) ? 1 : 0;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nint\ncifs_convert_address(struct sockaddr *dst, const char *src, int len)\n{\n\tint rc, alen, slen;\n\tconst char *pct;\n\tchar scope_id[13];\n\tstruct sockaddr_in *s4 = (struct sockaddr_in *) dst;\n\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) dst;\n\n\t/* IPv4 address */\n\tif (cifs_inet_pton(AF_INET, src, len, &s4->sin_addr.s_addr)) {\n\t\ts4->sin_family = AF_INET;\n\t\treturn 1;\n\t}\n\n\t/* attempt to exclude the scope ID from the address part */\n\tpct = memchr(src, '%', len);\n\talen = pct ? pct - src : len;\n\n\trc = cifs_inet_pton(AF_INET6, src, alen, &s6->sin6_addr.s6_addr);\n\tif (!rc)\n\t\treturn rc;\n\n\ts6->sin6_family = AF_INET6;\n\tif (pct) {\n\t\t/* grab the scope ID */\n\t\tslen = len - (alen + 1);\n\t\tif (slen <= 0 || slen > 12)\n\t\t\treturn 0;\n\t\tmemcpy(scope_id, pct + 1, slen);\n\t\tscope_id[slen] = '\\0';\n\n\t\trc = kstrtouint(scope_id, 0, &s6->sin6_scope_id);\n\t\trc = (rc == 0) ? 1 : 0;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: probably server name is whole unc: %s\\n\"",
            "__func__",
            "unc"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "hostname",
            "'/'",
            "len"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: unc is too short: %s\\n\"",
            "__func__",
            "unc"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "unc"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"dns_resolve.h\"\n#include <linux/dns_resolver.h>\n#include <linux/slab.h>\n\nint\ndns_resolve_server_name_to_ip(const char *unc, char **ip_addr)\n{\n\tstruct sockaddr_storage ss;\n\tconst char *hostname, *sep;\n\tchar *name;\n\tint len, rc;\n\n\tif (!ip_addr || !unc)\n\t\treturn -EINVAL;\n\n\tlen = strlen(unc);\n\tif (len < 3) {\n\t\tcifs_dbg(FYI, \"%s: unc is too short: %s\\n\", __func__, unc);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Discount leading slashes for cifs */\n\tlen -= 2;\n\thostname = unc + 2;\n\n\t/* Search for server name delimiter */\n\tsep = memchr(hostname, '/', len);\n\tif (sep)\n\t\tlen = sep - hostname;\n\telse\n\t\tcifs_dbg(FYI, \"%s: probably server name is whole unc: %s\\n\",\n\t\t\t __func__, unc);\n\n\t/* Try to interpret hostname as an IPv4 or IPv6 address */\n\trc = cifs_convert_address((struct sockaddr *)&ss, hostname, len);\n\tif (rc > 0)\n\t\tgoto name_is_IP_address;\n\n\t/* Perform the upcall */\n\trc = dns_query(NULL, hostname, len, NULL, ip_addr, NULL);\n\tif (rc < 0)\n\t\tcifs_dbg(FYI, \"%s: unable to resolve: %*.*s\\n\",\n\t\t\t __func__, len, len, hostname);\n\telse\n\t\tcifs_dbg(FYI, \"%s: resolved: %*.*s to %s\\n\",\n\t\t\t __func__, len, len, hostname, *ip_addr);\n\treturn rc;\n\nname_is_IP_address:\n\tname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tmemcpy(name, hostname, len);\n\tname[len] = 0;\n\tcifs_dbg(FYI, \"%s: unc is IP, skipping dns upcall: %s\\n\",\n\t\t __func__, name);\n\t*ip_addr = name;\n\treturn 0;\n}"
  }
]